Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    CAP
    COMMENT
    INTERFACE
    JOIN
    MAP
    MULTI_COMMENT
    PACKAGE

Grammar

Rule 0     S' -> codigo
Rule 1     codigo -> rule
Rule 2     codigo -> more_rules
Rule 3     more_rules -> rule codigo
Rule 4     rule -> impresion COLON
Rule 5     rule -> impresion
Rule 6     rule -> scan_func COLON
Rule 7     rule -> scan_func
Rule 8     rule -> expression COLON
Rule 9     rule -> expression
Rule 10    rule -> cicloFor
Rule 11    rule -> comparison
Rule 12    rule -> logic_operation
Rule 13    rule -> decVar COLON
Rule 14    rule -> decVar
Rule 15    rule -> decConst COLON
Rule 16    rule -> decConst
Rule 17    rule -> var_asignation
Rule 18    rule -> var_asignation COLON
Rule 19    rule -> funciones
Rule 20    rule -> funciones COLON
Rule 21    rule -> SenIF
Rule 22    rule -> SenElseIF
Rule 23    rule -> SenElse
Rule 24    rule -> SenStruct
Rule 25    rule -> cStruct
Rule 26    rule -> switch_statement
Rule 27    rule -> array_declaration COLON
Rule 28    rule -> array_declaration
Rule 29    rule -> array_var COLON
Rule 30    rule -> array_var
Rule 31    rule -> array_assignment COLON
Rule 32    rule -> array_assignment
Rule 33    rule -> slice_declaration COLON
Rule 34    rule -> slice_declaration
Rule 35    rule -> slice_var COLON
Rule 36    rule -> slice_var
Rule 37    rule -> slice_assignment COLON
Rule 38    rule -> slice_assignment
Rule 39    rule -> map_declaration COLON
Rule 40    rule -> map_declaration
Rule 41    rule -> map_assignment COLON
Rule 42    rule -> map_assignment
Rule 43    rule -> func_declaration
Rule 44    rule -> main_func
Rule 45    values -> STRING
Rule 46    values -> INTEGER
Rule 47    values -> FLOAT
Rule 48    values -> TRUE
Rule 49    values -> FALSE
Rule 50    data_types -> INT32
Rule 51    data_types -> INT64
Rule 52    data_types -> FLOAT32
Rule 53    data_types -> FLOAT64
Rule 54    data_types -> BYTE
Rule 55    data_types -> WINT
Rule 56    data_types -> WFLOAT
Rule 57    data_types -> WSTRING
Rule 58    data_types -> BOOL
Rule 59    operations -> expression
Rule 60    operations -> comparison
Rule 61    operations -> logic_operation
Rule 62    data_structure -> array_var
Rule 63    data_structure -> map_var
Rule 64    var_asignation -> ID EQUAL any
Rule 65    any -> values
Rule 66    any -> operations
Rule 67    any -> ID
Rule 68    any -> data_structure
Rule 69    any -> funciones
Rule 70    arr_content -> LLLAVE items COMA more_items RLLAVE
Rule 71    arr_content -> LLLAVE items RLLAVE
Rule 72    more_items -> items COMA more_items
Rule 73    more_items -> items
Rule 74    items -> values
Rule 75    items -> operations
Rule 76    something -> ID
Rule 77    something -> data_structure
Rule 78    something -> values
Rule 79    something -> operations
Rule 80    main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
Rule 81    scan_func -> SCAN LPAREN POINTER RPAREN
Rule 82    call_func -> ID LPAREN list_params RPAREN
Rule 83    call_func -> ID LPAREN RPAREN
Rule 84    list_params -> ID
Rule 85    list_params -> ID COMA more_p
Rule 86    more_p -> list_params
Rule 87    cicloFor -> FOR LLLAVE codigo RLLAVE
Rule 88    cicloFor -> FOR comparison LLLAVE codigo RLLAVE
Rule 89    cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE
Rule 90    cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
Rule 91    incre -> ID INCREASE
Rule 92    incre -> ID DECREASE
Rule 93    data_type_and_value -> WSTRING EQUAL STRING
Rule 94    data_type_and_value -> WINT EQUAL int_value
Rule 95    data_type_and_value -> INT32 EQUAL int_value
Rule 96    data_type_and_value -> INT64 EQUAL int_value
Rule 97    data_type_and_value -> WFLOAT EQUAL float_value
Rule 98    data_type_and_value -> FLOAT32 EQUAL float_value
Rule 99    data_type_and_value -> FLOAT64 EQUAL float_value
Rule 100   data_type_and_value -> BOOL EQUAL bool_value
Rule 101   int_value -> INTEGER
Rule 102   int_value -> expression
Rule 103   bool_value -> TRUE
Rule 104   bool_value -> FALSE
Rule 105   bool_value -> comparison
Rule 106   bool_value -> logic_operation
Rule 107   float_value -> FLOAT
Rule 108   float_value -> expression
Rule 109   decConst -> CONST ID data_type_and_value
Rule 110   decConst -> CONST ID EQUAL ID
Rule 111   decConst -> CONST ID EQUAL data_structure
Rule 112   decVar -> static
Rule 113   decVar -> dynamic
Rule 114   static -> single
Rule 115   static -> multiple
Rule 116   multiple -> list_var data_types
Rule 117   list_var -> VAR ID COMA more
Rule 118   more -> ID
Rule 119   more -> ID COMA more
Rule 120   single -> VAR ID data_types
Rule 121   single -> VAR ID data_types EQUAL funciones
Rule 122   single -> VAR ID data_types EQUAL ID
Rule 123   single -> VAR ID data_types EQUAL data_structure
Rule 124   single -> VAR ID data_type_and_value
Rule 125   dynamic -> ID DEQUAL algo
Rule 126   algo -> values
Rule 127   algo -> operations
Rule 128   algo -> ID
Rule 129   algo -> data_structure
Rule 130   algo -> funciones
Rule 131   slice_declaration -> VAR ID LCORCHE RCORCHE data_types
Rule 132   slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
Rule 133   slice_declaration -> VAR ID EQUAL funM
Rule 134   slice_declaration -> ID DEQUAL funM
Rule 135   slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content
Rule 136   funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
Rule 137   funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
Rule 138   cap -> INTEGER
Rule 139   cap -> ID
Rule 140   cap -> expression
Rule 141   slice_var -> ID LCORCHE index_s RCORCHE
Rule 142   index_s -> ID
Rule 143   index_s -> INTEGER
Rule 144   index_s -> expression
Rule 145   slice_assignment -> slice_var EQUAL something_s
Rule 146   something_s -> ID
Rule 147   something_s -> array_var
Rule 148   something_s -> values
Rule 149   something_s -> operations
Rule 150   funciones -> APPEND LPAREN ID COMA values RPAREN
Rule 151   funciones -> APPEND LPAREN ID COMA ID RPAREN
Rule 152   funciones -> LEN LPAREN ID RPAREN
Rule 153   funciones -> COPY LPAREN ID COMA ID RPAREN
Rule 154   funciones -> DELETE LPAREN ID COMA ID RPAREN
Rule 155   funciones -> call_func
Rule 156   decVarOne -> ID DEQUAL ID
Rule 157   decVarOne -> ID DEQUAL INTEGER
Rule 158   SenIF -> IF comparison LLLAVE codigo RLLAVE
Rule 159   SenIF -> IF TRUE LLLAVE codigo RLLAVE
Rule 160   SenIF -> IF FALSE LLLAVE codigo RLLAVE
Rule 161   SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE
Rule 162   SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE
Rule 163   SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE
Rule 164   SenElse -> ELSE LLLAVE codigo RLLAVE
Rule 165   SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE
Rule 166   declaration -> variable data_types
Rule 167   declaration -> declaration variable data_types
Rule 168   variable -> ID
Rule 169   cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE
Rule 170   asignaciones -> ID POINTS valor
Rule 171   asignaciones -> ID POINTS valor COMA asignaciones
Rule 172   valor -> ID
Rule 173   valor -> INTEGER
Rule 174   valor -> TRUE
Rule 175   valor -> FALSE
Rule 176   comparison -> value op value
Rule 177   value -> ID
Rule 178   value -> expression
Rule 179   op -> GREATER
Rule 180   op -> SMALLER
Rule 181   op -> GREATER_OR_EQUAL
Rule 182   op -> SMALLER_OR_EQUAL
Rule 183   op -> EQUAL_COMPARE
Rule 184   op -> NOT_EQUAL
Rule 185   logic_operation -> logic_value logic_recu
Rule 186   logic_operation -> negation
Rule 187   logic_recu -> logic_op logic_value
Rule 188   logic_recu -> logic_op logic_value logic_recu
Rule 189   logic_value -> negation
Rule 190   logic_value -> comparison
Rule 191   logic_value -> ID
Rule 192   negation -> NOT comparison
Rule 193   negation -> NOT ID
Rule 194   logic_op -> AND
Rule 195   logic_op -> OR
Rule 196   switch_statement -> SWITCH ID LLLAVE cases RLLAVE
Rule 197   cases -> CASE values POINTS codigo
Rule 198   cases -> CASE values POINTS codigo more
Rule 199   more -> cases
Rule 200   more -> DEFAULT POINTS codigo
Rule 201   array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types
Rule 202   array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
Rule 203   capacity -> INTEGER
Rule 204   capacity -> ID
Rule 205   capacity -> expression
Rule 206   array_var -> ID LCORCHE index RCORCHE
Rule 207   index -> ID
Rule 208   index -> INTEGER
Rule 209   index -> expression
Rule 210   array_assignment -> array_var EQUAL something
Rule 211   map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types
Rule 212   map_var -> ID LCORCHE key RCORCHE
Rule 213   key -> ID
Rule 214   key -> values
Rule 215   key -> operations
Rule 216   map_assignment -> map_var EQUAL something
Rule 217   func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
Rule 218   func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
Rule 219   return_value -> retorno COLON
Rule 220   return_value -> retorno
Rule 221   retorno -> ID
Rule 222   retorno -> values
Rule 223   retorno -> operations
Rule 224   retorno -> data_structure
Rule 225   params -> ID data_types
Rule 226   params -> more_params
Rule 227   more_params -> ID data_types COMA params
Rule 228   impresion -> PRINT LPAREN content RPAREN
Rule 229   content -> values
Rule 230   content -> operations
Rule 231   content -> funciones
Rule 232   content -> data_structure
Rule 233   content -> ID
Rule 234   expression -> something_ex
Rule 235   expression -> something_ex adicionaEx
Rule 236   adicionaEx -> op something_ex
Rule 237   adicionaEx -> op something_ex adicionaEx
Rule 238   something_ex -> ID
Rule 239   something_ex -> INTEGER
Rule 240   something_ex -> FLOAT
Rule 241   something_ex -> data_structure
Rule 242   something_ex -> funciones
Rule 243   op -> PLUS
Rule 244   op -> TIMES
Rule 245   op -> DIVIDE
Rule 246   op -> MINUS
Rule 247   op -> MOD

Terminals, with rules where they appear

AND                  : 194
APPEND               : 150 151
ARRAY                : 
BOOL                 : 58 100
BYTE                 : 54
CAP                  : 
CASE                 : 197 198
COLON                : 4 6 8 13 15 18 20 27 29 31 33 35 37 39 41 90 90 219
COMA                 : 70 72 85 117 119 136 137 137 150 151 153 154 171 227
COMMENT              : 
CONST                : 109 110 111
COPY                 : 153
DECREASE             : 92
DEFAULT              : 200
DELETE               : 154
DEQUAL               : 125 134 135 156 157 169
DIVIDE               : 245
ELSE                 : 161 162 163 164
EQUAL                : 64 93 94 95 96 97 98 99 100 110 111 121 122 123 132 133 145 202 210 216
EQUAL_COMPARE        : 183
FALSE                : 49 104 160 163 175
FLOAT                : 47 107 240
FLOAT32              : 52 98
FLOAT64              : 53 99
FOR                  : 87 88 89 90
FUNC                 : 80 217 218
GREATER              : 179
GREATER_OR_EQUAL     : 181
ID                   : 64 67 76 82 83 84 85 91 92 109 110 110 111 117 118 119 120 121 122 122 123 124 125 128 131 132 133 134 135 139 141 142 146 150 151 151 152 153 153 154 154 156 156 157 165 168 169 169 170 171 172 177 191 193 196 201 202 204 206 207 211 212 213 217 218 221 225 227 233 238
IF                   : 158 159 160 161 162 163
INCREASE             : 91
INT32                : 50 95
INT64                : 51 96
INTEGER              : 46 101 138 143 157 173 203 208 239
INTERFACE            : 
JOIN                 : 
LCORCHE              : 131 132 135 136 137 141 201 202 206 211 212
LEN                  : 152
LLLAVE               : 70 71 80 87 88 89 90 158 159 160 161 162 163 164 165 169 196 217 218
LPAREN               : 80 81 82 83 136 137 150 151 152 153 154 217 218 228
MAIN                 : 80
MAKE                 : 136 137
MAP                  : 
MINUS                : 246
MOD                  : 247
MULTI_COMMENT        : 
NOT                  : 192 193
NOT_EQUAL            : 184
OR                   : 195
PACKAGE              : 
PLUS                 : 243
POINTER              : 81
POINTS               : 170 171 197 198 200
PRINT                : 228
RCORCHE              : 131 132 135 136 137 141 201 202 206 211 212
RETURN               : 217 218
RLLAVE               : 70 71 80 87 88 89 90 158 159 160 161 162 163 164 165 169 196 217 218
RPAREN               : 80 81 82 83 136 137 150 151 152 153 154 217 218 228
SCAN                 : 81
SMALLER              : 180
SMALLER_OR_EQUAL     : 182
STRING               : 45 93
STRUCT               : 165
SWITCH               : 196
TIMES                : 244
TRUE                 : 48 103 159 162 174
TYPE                 : 165
VAR                  : 117 120 121 122 123 124 131 132 133 201 202 211
WFLOAT               : 56 97
WINT                 : 55 94
WSTRING              : 57 93
error                : 

Nonterminals, with rules where they appear

SenElse              : 23
SenElseIF            : 22
SenIF                : 21
SenStruct            : 24
adicionaEx           : 235 237
algo                 : 125
any                  : 64
arr_content          : 132 135 202
array_assignment     : 31 32
array_declaration    : 27 28
array_var            : 29 30 62 147 210
asignaciones         : 169 171
bool_value           : 100
cStruct              : 25
call_func            : 155
cap                  : 136 137 137
capacity             : 201 202
cases                : 196 199
cicloFor             : 10
codigo               : 3 80 87 88 89 90 158 159 160 161 162 163 164 197 198 200 217 0
comparison           : 11 60 88 90 105 158 161 190 192
content              : 228
data_structure       : 68 77 111 123 129 224 232 241
data_type_and_value  : 109 124
data_types           : 116 120 121 122 123 131 132 135 136 137 166 167 201 202 211 211 217 218 225 227
decConst             : 15 16
decVar               : 13 14
decVarOne            : 90
declaration          : 165 167
dynamic              : 113
expression           : 8 9 59 102 108 140 144 178 205 209
float_value          : 97 98 99
funM                 : 133 134
func_declaration     : 43
funciones            : 19 20 69 121 130 231 242
impresion            : 4 5
incre                : 90
index                : 206
index_s              : 141
int_value            : 94 95 96
items                : 70 71 72 73
key                  : 212
list_params          : 82 86
list_var             : 116
logic_op             : 187 188
logic_operation      : 12 61 89 106
logic_recu           : 185 188
logic_value          : 185 187 188
main_func            : 44
map_assignment       : 41 42
map_declaration      : 39 40
map_var              : 63 216
more                 : 117 119 198
more_items           : 70 72
more_p               : 85
more_params          : 226
more_rules           : 2
multiple             : 115
negation             : 186 189
op                   : 176 236 237
operations           : 66 75 79 127 149 215 223 230
params               : 217 218 227
retorno              : 217 219 220
return_value         : 218
rule                 : 1 3
scan_func            : 6 7
single               : 114
slice_assignment     : 37 38
slice_declaration    : 33 34
slice_var            : 35 36 145
something            : 210 216
something_ex         : 234 235 236 237
something_s          : 145
static               : 112
switch_statement     : 26
valor                : 170 171
value                : 176 176
values               : 65 74 78 126 148 150 197 198 214 222 229
var_asignation       : 17 18
variable             : 166 167

Parsing method: LALR

state 0

    (0) S' -> . codigo
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 1
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 1

    (0) S' -> codigo .



state 2

    (1) codigo -> rule .
    (3) more_rules -> rule . codigo
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

  ! shift/reduce conflict for ID resolved as shift
    $end            reduce using rule 1 (codigo -> rule .)
    RLLAVE          reduce using rule 1 (codigo -> rule .)
    INT32           reduce using rule 1 (codigo -> rule .)
    INT64           reduce using rule 1 (codigo -> rule .)
    FLOAT32         reduce using rule 1 (codigo -> rule .)
    FLOAT64         reduce using rule 1 (codigo -> rule .)
    BYTE            reduce using rule 1 (codigo -> rule .)
    WINT            reduce using rule 1 (codigo -> rule .)
    WFLOAT          reduce using rule 1 (codigo -> rule .)
    WSTRING         reduce using rule 1 (codigo -> rule .)
    BOOL            reduce using rule 1 (codigo -> rule .)
    DEFAULT         reduce using rule 1 (codigo -> rule .)
    CASE            reduce using rule 1 (codigo -> rule .)
    RETURN          reduce using rule 1 (codigo -> rule .)
    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

  ! ID              [ reduce using rule 1 (codigo -> rule .) ]

    rule                           shift and go to state 2
    codigo                         shift and go to state 60
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 3

    (2) codigo -> more_rules .

    $end            reduce using rule 2 (codigo -> more_rules .)
    RLLAVE          reduce using rule 2 (codigo -> more_rules .)
    INT32           reduce using rule 2 (codigo -> more_rules .)
    INT64           reduce using rule 2 (codigo -> more_rules .)
    FLOAT32         reduce using rule 2 (codigo -> more_rules .)
    FLOAT64         reduce using rule 2 (codigo -> more_rules .)
    BYTE            reduce using rule 2 (codigo -> more_rules .)
    WINT            reduce using rule 2 (codigo -> more_rules .)
    WFLOAT          reduce using rule 2 (codigo -> more_rules .)
    WSTRING         reduce using rule 2 (codigo -> more_rules .)
    BOOL            reduce using rule 2 (codigo -> more_rules .)
    ID              reduce using rule 2 (codigo -> more_rules .)
    DEFAULT         reduce using rule 2 (codigo -> more_rules .)
    CASE            reduce using rule 2 (codigo -> more_rules .)
    RETURN          reduce using rule 2 (codigo -> more_rules .)


state 4

    (4) rule -> impresion . COLON
    (5) rule -> impresion .

    COLON           shift and go to state 61
    PRINT           reduce using rule 5 (rule -> impresion .)
    SCAN            reduce using rule 5 (rule -> impresion .)
    FOR             reduce using rule 5 (rule -> impresion .)
    CONST           reduce using rule 5 (rule -> impresion .)
    ID              reduce using rule 5 (rule -> impresion .)
    APPEND          reduce using rule 5 (rule -> impresion .)
    LEN             reduce using rule 5 (rule -> impresion .)
    COPY            reduce using rule 5 (rule -> impresion .)
    DELETE          reduce using rule 5 (rule -> impresion .)
    IF              reduce using rule 5 (rule -> impresion .)
    ELSE            reduce using rule 5 (rule -> impresion .)
    TYPE            reduce using rule 5 (rule -> impresion .)
    SWITCH          reduce using rule 5 (rule -> impresion .)
    VAR             reduce using rule 5 (rule -> impresion .)
    FUNC            reduce using rule 5 (rule -> impresion .)
    INTEGER         reduce using rule 5 (rule -> impresion .)
    FLOAT           reduce using rule 5 (rule -> impresion .)
    NOT             reduce using rule 5 (rule -> impresion .)
    $end            reduce using rule 5 (rule -> impresion .)
    RLLAVE          reduce using rule 5 (rule -> impresion .)
    INT32           reduce using rule 5 (rule -> impresion .)
    INT64           reduce using rule 5 (rule -> impresion .)
    FLOAT32         reduce using rule 5 (rule -> impresion .)
    FLOAT64         reduce using rule 5 (rule -> impresion .)
    BYTE            reduce using rule 5 (rule -> impresion .)
    WINT            reduce using rule 5 (rule -> impresion .)
    WFLOAT          reduce using rule 5 (rule -> impresion .)
    WSTRING         reduce using rule 5 (rule -> impresion .)
    BOOL            reduce using rule 5 (rule -> impresion .)
    DEFAULT         reduce using rule 5 (rule -> impresion .)
    CASE            reduce using rule 5 (rule -> impresion .)
    RETURN          reduce using rule 5 (rule -> impresion .)


state 5

    (6) rule -> scan_func . COLON
    (7) rule -> scan_func .

    COLON           shift and go to state 62
    PRINT           reduce using rule 7 (rule -> scan_func .)
    SCAN            reduce using rule 7 (rule -> scan_func .)
    FOR             reduce using rule 7 (rule -> scan_func .)
    CONST           reduce using rule 7 (rule -> scan_func .)
    ID              reduce using rule 7 (rule -> scan_func .)
    APPEND          reduce using rule 7 (rule -> scan_func .)
    LEN             reduce using rule 7 (rule -> scan_func .)
    COPY            reduce using rule 7 (rule -> scan_func .)
    DELETE          reduce using rule 7 (rule -> scan_func .)
    IF              reduce using rule 7 (rule -> scan_func .)
    ELSE            reduce using rule 7 (rule -> scan_func .)
    TYPE            reduce using rule 7 (rule -> scan_func .)
    SWITCH          reduce using rule 7 (rule -> scan_func .)
    VAR             reduce using rule 7 (rule -> scan_func .)
    FUNC            reduce using rule 7 (rule -> scan_func .)
    INTEGER         reduce using rule 7 (rule -> scan_func .)
    FLOAT           reduce using rule 7 (rule -> scan_func .)
    NOT             reduce using rule 7 (rule -> scan_func .)
    $end            reduce using rule 7 (rule -> scan_func .)
    RLLAVE          reduce using rule 7 (rule -> scan_func .)
    INT32           reduce using rule 7 (rule -> scan_func .)
    INT64           reduce using rule 7 (rule -> scan_func .)
    FLOAT32         reduce using rule 7 (rule -> scan_func .)
    FLOAT64         reduce using rule 7 (rule -> scan_func .)
    BYTE            reduce using rule 7 (rule -> scan_func .)
    WINT            reduce using rule 7 (rule -> scan_func .)
    WFLOAT          reduce using rule 7 (rule -> scan_func .)
    WSTRING         reduce using rule 7 (rule -> scan_func .)
    BOOL            reduce using rule 7 (rule -> scan_func .)
    DEFAULT         reduce using rule 7 (rule -> scan_func .)
    CASE            reduce using rule 7 (rule -> scan_func .)
    RETURN          reduce using rule 7 (rule -> scan_func .)


state 6

    (8) rule -> expression . COLON
    (9) rule -> expression .
    (178) value -> expression .

    COLON           shift and go to state 63
    PRINT           reduce using rule 9 (rule -> expression .)
    SCAN            reduce using rule 9 (rule -> expression .)
    FOR             reduce using rule 9 (rule -> expression .)
    CONST           reduce using rule 9 (rule -> expression .)
    ID              reduce using rule 9 (rule -> expression .)
    APPEND          reduce using rule 9 (rule -> expression .)
    LEN             reduce using rule 9 (rule -> expression .)
    COPY            reduce using rule 9 (rule -> expression .)
    DELETE          reduce using rule 9 (rule -> expression .)
    IF              reduce using rule 9 (rule -> expression .)
    ELSE            reduce using rule 9 (rule -> expression .)
    TYPE            reduce using rule 9 (rule -> expression .)
    SWITCH          reduce using rule 9 (rule -> expression .)
    VAR             reduce using rule 9 (rule -> expression .)
    FUNC            reduce using rule 9 (rule -> expression .)
    INTEGER         reduce using rule 9 (rule -> expression .)
    FLOAT           reduce using rule 9 (rule -> expression .)
    NOT             reduce using rule 9 (rule -> expression .)
    $end            reduce using rule 9 (rule -> expression .)
    RLLAVE          reduce using rule 9 (rule -> expression .)
    INT32           reduce using rule 9 (rule -> expression .)
    INT64           reduce using rule 9 (rule -> expression .)
    FLOAT32         reduce using rule 9 (rule -> expression .)
    FLOAT64         reduce using rule 9 (rule -> expression .)
    BYTE            reduce using rule 9 (rule -> expression .)
    WINT            reduce using rule 9 (rule -> expression .)
    WFLOAT          reduce using rule 9 (rule -> expression .)
    WSTRING         reduce using rule 9 (rule -> expression .)
    BOOL            reduce using rule 9 (rule -> expression .)
    DEFAULT         reduce using rule 9 (rule -> expression .)
    CASE            reduce using rule 9 (rule -> expression .)
    RETURN          reduce using rule 9 (rule -> expression .)
    GREATER         reduce using rule 178 (value -> expression .)
    SMALLER         reduce using rule 178 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 178 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 178 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 178 (value -> expression .)
    NOT_EQUAL       reduce using rule 178 (value -> expression .)
    PLUS            reduce using rule 178 (value -> expression .)
    TIMES           reduce using rule 178 (value -> expression .)
    DIVIDE          reduce using rule 178 (value -> expression .)
    MINUS           reduce using rule 178 (value -> expression .)
    MOD             reduce using rule 178 (value -> expression .)


state 7

    (10) rule -> cicloFor .

    PRINT           reduce using rule 10 (rule -> cicloFor .)
    SCAN            reduce using rule 10 (rule -> cicloFor .)
    FOR             reduce using rule 10 (rule -> cicloFor .)
    CONST           reduce using rule 10 (rule -> cicloFor .)
    ID              reduce using rule 10 (rule -> cicloFor .)
    APPEND          reduce using rule 10 (rule -> cicloFor .)
    LEN             reduce using rule 10 (rule -> cicloFor .)
    COPY            reduce using rule 10 (rule -> cicloFor .)
    DELETE          reduce using rule 10 (rule -> cicloFor .)
    IF              reduce using rule 10 (rule -> cicloFor .)
    ELSE            reduce using rule 10 (rule -> cicloFor .)
    TYPE            reduce using rule 10 (rule -> cicloFor .)
    SWITCH          reduce using rule 10 (rule -> cicloFor .)
    VAR             reduce using rule 10 (rule -> cicloFor .)
    FUNC            reduce using rule 10 (rule -> cicloFor .)
    INTEGER         reduce using rule 10 (rule -> cicloFor .)
    FLOAT           reduce using rule 10 (rule -> cicloFor .)
    NOT             reduce using rule 10 (rule -> cicloFor .)
    $end            reduce using rule 10 (rule -> cicloFor .)
    RLLAVE          reduce using rule 10 (rule -> cicloFor .)
    INT32           reduce using rule 10 (rule -> cicloFor .)
    INT64           reduce using rule 10 (rule -> cicloFor .)
    FLOAT32         reduce using rule 10 (rule -> cicloFor .)
    FLOAT64         reduce using rule 10 (rule -> cicloFor .)
    BYTE            reduce using rule 10 (rule -> cicloFor .)
    WINT            reduce using rule 10 (rule -> cicloFor .)
    WFLOAT          reduce using rule 10 (rule -> cicloFor .)
    WSTRING         reduce using rule 10 (rule -> cicloFor .)
    BOOL            reduce using rule 10 (rule -> cicloFor .)
    DEFAULT         reduce using rule 10 (rule -> cicloFor .)
    CASE            reduce using rule 10 (rule -> cicloFor .)
    RETURN          reduce using rule 10 (rule -> cicloFor .)


state 8

    (11) rule -> comparison .
    (190) logic_value -> comparison .

    PRINT           reduce using rule 11 (rule -> comparison .)
    SCAN            reduce using rule 11 (rule -> comparison .)
    FOR             reduce using rule 11 (rule -> comparison .)
    CONST           reduce using rule 11 (rule -> comparison .)
    ID              reduce using rule 11 (rule -> comparison .)
    APPEND          reduce using rule 11 (rule -> comparison .)
    LEN             reduce using rule 11 (rule -> comparison .)
    COPY            reduce using rule 11 (rule -> comparison .)
    DELETE          reduce using rule 11 (rule -> comparison .)
    IF              reduce using rule 11 (rule -> comparison .)
    ELSE            reduce using rule 11 (rule -> comparison .)
    TYPE            reduce using rule 11 (rule -> comparison .)
    SWITCH          reduce using rule 11 (rule -> comparison .)
    VAR             reduce using rule 11 (rule -> comparison .)
    FUNC            reduce using rule 11 (rule -> comparison .)
    INTEGER         reduce using rule 11 (rule -> comparison .)
    FLOAT           reduce using rule 11 (rule -> comparison .)
    NOT             reduce using rule 11 (rule -> comparison .)
    $end            reduce using rule 11 (rule -> comparison .)
    RLLAVE          reduce using rule 11 (rule -> comparison .)
    INT32           reduce using rule 11 (rule -> comparison .)
    INT64           reduce using rule 11 (rule -> comparison .)
    FLOAT32         reduce using rule 11 (rule -> comparison .)
    FLOAT64         reduce using rule 11 (rule -> comparison .)
    BYTE            reduce using rule 11 (rule -> comparison .)
    WINT            reduce using rule 11 (rule -> comparison .)
    WFLOAT          reduce using rule 11 (rule -> comparison .)
    WSTRING         reduce using rule 11 (rule -> comparison .)
    BOOL            reduce using rule 11 (rule -> comparison .)
    DEFAULT         reduce using rule 11 (rule -> comparison .)
    CASE            reduce using rule 11 (rule -> comparison .)
    RETURN          reduce using rule 11 (rule -> comparison .)
    AND             reduce using rule 190 (logic_value -> comparison .)
    OR              reduce using rule 190 (logic_value -> comparison .)


state 9

    (12) rule -> logic_operation .

    PRINT           reduce using rule 12 (rule -> logic_operation .)
    SCAN            reduce using rule 12 (rule -> logic_operation .)
    FOR             reduce using rule 12 (rule -> logic_operation .)
    CONST           reduce using rule 12 (rule -> logic_operation .)
    ID              reduce using rule 12 (rule -> logic_operation .)
    APPEND          reduce using rule 12 (rule -> logic_operation .)
    LEN             reduce using rule 12 (rule -> logic_operation .)
    COPY            reduce using rule 12 (rule -> logic_operation .)
    DELETE          reduce using rule 12 (rule -> logic_operation .)
    IF              reduce using rule 12 (rule -> logic_operation .)
    ELSE            reduce using rule 12 (rule -> logic_operation .)
    TYPE            reduce using rule 12 (rule -> logic_operation .)
    SWITCH          reduce using rule 12 (rule -> logic_operation .)
    VAR             reduce using rule 12 (rule -> logic_operation .)
    FUNC            reduce using rule 12 (rule -> logic_operation .)
    INTEGER         reduce using rule 12 (rule -> logic_operation .)
    FLOAT           reduce using rule 12 (rule -> logic_operation .)
    NOT             reduce using rule 12 (rule -> logic_operation .)
    $end            reduce using rule 12 (rule -> logic_operation .)
    RLLAVE          reduce using rule 12 (rule -> logic_operation .)
    INT32           reduce using rule 12 (rule -> logic_operation .)
    INT64           reduce using rule 12 (rule -> logic_operation .)
    FLOAT32         reduce using rule 12 (rule -> logic_operation .)
    FLOAT64         reduce using rule 12 (rule -> logic_operation .)
    BYTE            reduce using rule 12 (rule -> logic_operation .)
    WINT            reduce using rule 12 (rule -> logic_operation .)
    WFLOAT          reduce using rule 12 (rule -> logic_operation .)
    WSTRING         reduce using rule 12 (rule -> logic_operation .)
    BOOL            reduce using rule 12 (rule -> logic_operation .)
    DEFAULT         reduce using rule 12 (rule -> logic_operation .)
    CASE            reduce using rule 12 (rule -> logic_operation .)
    RETURN          reduce using rule 12 (rule -> logic_operation .)


state 10

    (13) rule -> decVar . COLON
    (14) rule -> decVar .

    COLON           shift and go to state 64
    PRINT           reduce using rule 14 (rule -> decVar .)
    SCAN            reduce using rule 14 (rule -> decVar .)
    FOR             reduce using rule 14 (rule -> decVar .)
    CONST           reduce using rule 14 (rule -> decVar .)
    ID              reduce using rule 14 (rule -> decVar .)
    APPEND          reduce using rule 14 (rule -> decVar .)
    LEN             reduce using rule 14 (rule -> decVar .)
    COPY            reduce using rule 14 (rule -> decVar .)
    DELETE          reduce using rule 14 (rule -> decVar .)
    IF              reduce using rule 14 (rule -> decVar .)
    ELSE            reduce using rule 14 (rule -> decVar .)
    TYPE            reduce using rule 14 (rule -> decVar .)
    SWITCH          reduce using rule 14 (rule -> decVar .)
    VAR             reduce using rule 14 (rule -> decVar .)
    FUNC            reduce using rule 14 (rule -> decVar .)
    INTEGER         reduce using rule 14 (rule -> decVar .)
    FLOAT           reduce using rule 14 (rule -> decVar .)
    NOT             reduce using rule 14 (rule -> decVar .)
    $end            reduce using rule 14 (rule -> decVar .)
    RLLAVE          reduce using rule 14 (rule -> decVar .)
    INT32           reduce using rule 14 (rule -> decVar .)
    INT64           reduce using rule 14 (rule -> decVar .)
    FLOAT32         reduce using rule 14 (rule -> decVar .)
    FLOAT64         reduce using rule 14 (rule -> decVar .)
    BYTE            reduce using rule 14 (rule -> decVar .)
    WINT            reduce using rule 14 (rule -> decVar .)
    WFLOAT          reduce using rule 14 (rule -> decVar .)
    WSTRING         reduce using rule 14 (rule -> decVar .)
    BOOL            reduce using rule 14 (rule -> decVar .)
    DEFAULT         reduce using rule 14 (rule -> decVar .)
    CASE            reduce using rule 14 (rule -> decVar .)
    RETURN          reduce using rule 14 (rule -> decVar .)


state 11

    (15) rule -> decConst . COLON
    (16) rule -> decConst .

    COLON           shift and go to state 65
    PRINT           reduce using rule 16 (rule -> decConst .)
    SCAN            reduce using rule 16 (rule -> decConst .)
    FOR             reduce using rule 16 (rule -> decConst .)
    CONST           reduce using rule 16 (rule -> decConst .)
    ID              reduce using rule 16 (rule -> decConst .)
    APPEND          reduce using rule 16 (rule -> decConst .)
    LEN             reduce using rule 16 (rule -> decConst .)
    COPY            reduce using rule 16 (rule -> decConst .)
    DELETE          reduce using rule 16 (rule -> decConst .)
    IF              reduce using rule 16 (rule -> decConst .)
    ELSE            reduce using rule 16 (rule -> decConst .)
    TYPE            reduce using rule 16 (rule -> decConst .)
    SWITCH          reduce using rule 16 (rule -> decConst .)
    VAR             reduce using rule 16 (rule -> decConst .)
    FUNC            reduce using rule 16 (rule -> decConst .)
    INTEGER         reduce using rule 16 (rule -> decConst .)
    FLOAT           reduce using rule 16 (rule -> decConst .)
    NOT             reduce using rule 16 (rule -> decConst .)
    $end            reduce using rule 16 (rule -> decConst .)
    RLLAVE          reduce using rule 16 (rule -> decConst .)
    INT32           reduce using rule 16 (rule -> decConst .)
    INT64           reduce using rule 16 (rule -> decConst .)
    FLOAT32         reduce using rule 16 (rule -> decConst .)
    FLOAT64         reduce using rule 16 (rule -> decConst .)
    BYTE            reduce using rule 16 (rule -> decConst .)
    WINT            reduce using rule 16 (rule -> decConst .)
    WFLOAT          reduce using rule 16 (rule -> decConst .)
    WSTRING         reduce using rule 16 (rule -> decConst .)
    BOOL            reduce using rule 16 (rule -> decConst .)
    DEFAULT         reduce using rule 16 (rule -> decConst .)
    CASE            reduce using rule 16 (rule -> decConst .)
    RETURN          reduce using rule 16 (rule -> decConst .)


state 12

    (17) rule -> var_asignation .
    (18) rule -> var_asignation . COLON

    PRINT           reduce using rule 17 (rule -> var_asignation .)
    SCAN            reduce using rule 17 (rule -> var_asignation .)
    FOR             reduce using rule 17 (rule -> var_asignation .)
    CONST           reduce using rule 17 (rule -> var_asignation .)
    ID              reduce using rule 17 (rule -> var_asignation .)
    APPEND          reduce using rule 17 (rule -> var_asignation .)
    LEN             reduce using rule 17 (rule -> var_asignation .)
    COPY            reduce using rule 17 (rule -> var_asignation .)
    DELETE          reduce using rule 17 (rule -> var_asignation .)
    IF              reduce using rule 17 (rule -> var_asignation .)
    ELSE            reduce using rule 17 (rule -> var_asignation .)
    TYPE            reduce using rule 17 (rule -> var_asignation .)
    SWITCH          reduce using rule 17 (rule -> var_asignation .)
    VAR             reduce using rule 17 (rule -> var_asignation .)
    FUNC            reduce using rule 17 (rule -> var_asignation .)
    INTEGER         reduce using rule 17 (rule -> var_asignation .)
    FLOAT           reduce using rule 17 (rule -> var_asignation .)
    NOT             reduce using rule 17 (rule -> var_asignation .)
    $end            reduce using rule 17 (rule -> var_asignation .)
    RLLAVE          reduce using rule 17 (rule -> var_asignation .)
    INT32           reduce using rule 17 (rule -> var_asignation .)
    INT64           reduce using rule 17 (rule -> var_asignation .)
    FLOAT32         reduce using rule 17 (rule -> var_asignation .)
    FLOAT64         reduce using rule 17 (rule -> var_asignation .)
    BYTE            reduce using rule 17 (rule -> var_asignation .)
    WINT            reduce using rule 17 (rule -> var_asignation .)
    WFLOAT          reduce using rule 17 (rule -> var_asignation .)
    WSTRING         reduce using rule 17 (rule -> var_asignation .)
    BOOL            reduce using rule 17 (rule -> var_asignation .)
    DEFAULT         reduce using rule 17 (rule -> var_asignation .)
    CASE            reduce using rule 17 (rule -> var_asignation .)
    RETURN          reduce using rule 17 (rule -> var_asignation .)
    COLON           shift and go to state 66


state 13

    (19) rule -> funciones .
    (20) rule -> funciones . COLON
    (242) something_ex -> funciones .

  ! shift/reduce conflict for COLON resolved as shift
  ! reduce/reduce conflict for PRINT resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for SCAN resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for FOR resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for CONST resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for ID resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for APPEND resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for LEN resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for COPY resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for DELETE resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for IF resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for ELSE resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for TYPE resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for SWITCH resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for VAR resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for FUNC resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for INTEGER resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for FLOAT resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for NOT resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for $end resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for INT32 resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for INT64 resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for BYTE resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for WINT resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for WSTRING resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for BOOL resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for CASE resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for RETURN resolved using rule 19 (rule -> funciones .)
    PRINT           reduce using rule 19 (rule -> funciones .)
    SCAN            reduce using rule 19 (rule -> funciones .)
    FOR             reduce using rule 19 (rule -> funciones .)
    CONST           reduce using rule 19 (rule -> funciones .)
    ID              reduce using rule 19 (rule -> funciones .)
    APPEND          reduce using rule 19 (rule -> funciones .)
    LEN             reduce using rule 19 (rule -> funciones .)
    COPY            reduce using rule 19 (rule -> funciones .)
    DELETE          reduce using rule 19 (rule -> funciones .)
    IF              reduce using rule 19 (rule -> funciones .)
    ELSE            reduce using rule 19 (rule -> funciones .)
    TYPE            reduce using rule 19 (rule -> funciones .)
    SWITCH          reduce using rule 19 (rule -> funciones .)
    VAR             reduce using rule 19 (rule -> funciones .)
    FUNC            reduce using rule 19 (rule -> funciones .)
    INTEGER         reduce using rule 19 (rule -> funciones .)
    FLOAT           reduce using rule 19 (rule -> funciones .)
    NOT             reduce using rule 19 (rule -> funciones .)
    $end            reduce using rule 19 (rule -> funciones .)
    RLLAVE          reduce using rule 19 (rule -> funciones .)
    INT32           reduce using rule 19 (rule -> funciones .)
    INT64           reduce using rule 19 (rule -> funciones .)
    FLOAT32         reduce using rule 19 (rule -> funciones .)
    FLOAT64         reduce using rule 19 (rule -> funciones .)
    BYTE            reduce using rule 19 (rule -> funciones .)
    WINT            reduce using rule 19 (rule -> funciones .)
    WFLOAT          reduce using rule 19 (rule -> funciones .)
    WSTRING         reduce using rule 19 (rule -> funciones .)
    BOOL            reduce using rule 19 (rule -> funciones .)
    DEFAULT         reduce using rule 19 (rule -> funciones .)
    CASE            reduce using rule 19 (rule -> funciones .)
    RETURN          reduce using rule 19 (rule -> funciones .)
    COLON           shift and go to state 67
    GREATER         reduce using rule 242 (something_ex -> funciones .)
    SMALLER         reduce using rule 242 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 242 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 242 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 242 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 242 (something_ex -> funciones .)
    PLUS            reduce using rule 242 (something_ex -> funciones .)
    TIMES           reduce using rule 242 (something_ex -> funciones .)
    DIVIDE          reduce using rule 242 (something_ex -> funciones .)
    MINUS           reduce using rule 242 (something_ex -> funciones .)
    MOD             reduce using rule 242 (something_ex -> funciones .)

  ! COLON           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! PRINT           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! SCAN            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! FOR             [ reduce using rule 242 (something_ex -> funciones .) ]
  ! CONST           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! ID              [ reduce using rule 242 (something_ex -> funciones .) ]
  ! APPEND          [ reduce using rule 242 (something_ex -> funciones .) ]
  ! LEN             [ reduce using rule 242 (something_ex -> funciones .) ]
  ! COPY            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! DELETE          [ reduce using rule 242 (something_ex -> funciones .) ]
  ! IF              [ reduce using rule 242 (something_ex -> funciones .) ]
  ! ELSE            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! TYPE            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! SWITCH          [ reduce using rule 242 (something_ex -> funciones .) ]
  ! VAR             [ reduce using rule 242 (something_ex -> funciones .) ]
  ! FUNC            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! INTEGER         [ reduce using rule 242 (something_ex -> funciones .) ]
  ! FLOAT           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! NOT             [ reduce using rule 242 (something_ex -> funciones .) ]
  ! $end            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! RLLAVE          [ reduce using rule 242 (something_ex -> funciones .) ]
  ! INT32           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! INT64           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! FLOAT32         [ reduce using rule 242 (something_ex -> funciones .) ]
  ! FLOAT64         [ reduce using rule 242 (something_ex -> funciones .) ]
  ! BYTE            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! WINT            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! WFLOAT          [ reduce using rule 242 (something_ex -> funciones .) ]
  ! WSTRING         [ reduce using rule 242 (something_ex -> funciones .) ]
  ! BOOL            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! DEFAULT         [ reduce using rule 242 (something_ex -> funciones .) ]
  ! CASE            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! RETURN          [ reduce using rule 242 (something_ex -> funciones .) ]


state 14

    (21) rule -> SenIF .

    PRINT           reduce using rule 21 (rule -> SenIF .)
    SCAN            reduce using rule 21 (rule -> SenIF .)
    FOR             reduce using rule 21 (rule -> SenIF .)
    CONST           reduce using rule 21 (rule -> SenIF .)
    ID              reduce using rule 21 (rule -> SenIF .)
    APPEND          reduce using rule 21 (rule -> SenIF .)
    LEN             reduce using rule 21 (rule -> SenIF .)
    COPY            reduce using rule 21 (rule -> SenIF .)
    DELETE          reduce using rule 21 (rule -> SenIF .)
    IF              reduce using rule 21 (rule -> SenIF .)
    ELSE            reduce using rule 21 (rule -> SenIF .)
    TYPE            reduce using rule 21 (rule -> SenIF .)
    SWITCH          reduce using rule 21 (rule -> SenIF .)
    VAR             reduce using rule 21 (rule -> SenIF .)
    FUNC            reduce using rule 21 (rule -> SenIF .)
    INTEGER         reduce using rule 21 (rule -> SenIF .)
    FLOAT           reduce using rule 21 (rule -> SenIF .)
    NOT             reduce using rule 21 (rule -> SenIF .)
    $end            reduce using rule 21 (rule -> SenIF .)
    RLLAVE          reduce using rule 21 (rule -> SenIF .)
    INT32           reduce using rule 21 (rule -> SenIF .)
    INT64           reduce using rule 21 (rule -> SenIF .)
    FLOAT32         reduce using rule 21 (rule -> SenIF .)
    FLOAT64         reduce using rule 21 (rule -> SenIF .)
    BYTE            reduce using rule 21 (rule -> SenIF .)
    WINT            reduce using rule 21 (rule -> SenIF .)
    WFLOAT          reduce using rule 21 (rule -> SenIF .)
    WSTRING         reduce using rule 21 (rule -> SenIF .)
    BOOL            reduce using rule 21 (rule -> SenIF .)
    DEFAULT         reduce using rule 21 (rule -> SenIF .)
    CASE            reduce using rule 21 (rule -> SenIF .)
    RETURN          reduce using rule 21 (rule -> SenIF .)


state 15

    (22) rule -> SenElseIF .

    PRINT           reduce using rule 22 (rule -> SenElseIF .)
    SCAN            reduce using rule 22 (rule -> SenElseIF .)
    FOR             reduce using rule 22 (rule -> SenElseIF .)
    CONST           reduce using rule 22 (rule -> SenElseIF .)
    ID              reduce using rule 22 (rule -> SenElseIF .)
    APPEND          reduce using rule 22 (rule -> SenElseIF .)
    LEN             reduce using rule 22 (rule -> SenElseIF .)
    COPY            reduce using rule 22 (rule -> SenElseIF .)
    DELETE          reduce using rule 22 (rule -> SenElseIF .)
    IF              reduce using rule 22 (rule -> SenElseIF .)
    ELSE            reduce using rule 22 (rule -> SenElseIF .)
    TYPE            reduce using rule 22 (rule -> SenElseIF .)
    SWITCH          reduce using rule 22 (rule -> SenElseIF .)
    VAR             reduce using rule 22 (rule -> SenElseIF .)
    FUNC            reduce using rule 22 (rule -> SenElseIF .)
    INTEGER         reduce using rule 22 (rule -> SenElseIF .)
    FLOAT           reduce using rule 22 (rule -> SenElseIF .)
    NOT             reduce using rule 22 (rule -> SenElseIF .)
    $end            reduce using rule 22 (rule -> SenElseIF .)
    RLLAVE          reduce using rule 22 (rule -> SenElseIF .)
    INT32           reduce using rule 22 (rule -> SenElseIF .)
    INT64           reduce using rule 22 (rule -> SenElseIF .)
    FLOAT32         reduce using rule 22 (rule -> SenElseIF .)
    FLOAT64         reduce using rule 22 (rule -> SenElseIF .)
    BYTE            reduce using rule 22 (rule -> SenElseIF .)
    WINT            reduce using rule 22 (rule -> SenElseIF .)
    WFLOAT          reduce using rule 22 (rule -> SenElseIF .)
    WSTRING         reduce using rule 22 (rule -> SenElseIF .)
    BOOL            reduce using rule 22 (rule -> SenElseIF .)
    DEFAULT         reduce using rule 22 (rule -> SenElseIF .)
    CASE            reduce using rule 22 (rule -> SenElseIF .)
    RETURN          reduce using rule 22 (rule -> SenElseIF .)


state 16

    (23) rule -> SenElse .

    PRINT           reduce using rule 23 (rule -> SenElse .)
    SCAN            reduce using rule 23 (rule -> SenElse .)
    FOR             reduce using rule 23 (rule -> SenElse .)
    CONST           reduce using rule 23 (rule -> SenElse .)
    ID              reduce using rule 23 (rule -> SenElse .)
    APPEND          reduce using rule 23 (rule -> SenElse .)
    LEN             reduce using rule 23 (rule -> SenElse .)
    COPY            reduce using rule 23 (rule -> SenElse .)
    DELETE          reduce using rule 23 (rule -> SenElse .)
    IF              reduce using rule 23 (rule -> SenElse .)
    ELSE            reduce using rule 23 (rule -> SenElse .)
    TYPE            reduce using rule 23 (rule -> SenElse .)
    SWITCH          reduce using rule 23 (rule -> SenElse .)
    VAR             reduce using rule 23 (rule -> SenElse .)
    FUNC            reduce using rule 23 (rule -> SenElse .)
    INTEGER         reduce using rule 23 (rule -> SenElse .)
    FLOAT           reduce using rule 23 (rule -> SenElse .)
    NOT             reduce using rule 23 (rule -> SenElse .)
    $end            reduce using rule 23 (rule -> SenElse .)
    RLLAVE          reduce using rule 23 (rule -> SenElse .)
    INT32           reduce using rule 23 (rule -> SenElse .)
    INT64           reduce using rule 23 (rule -> SenElse .)
    FLOAT32         reduce using rule 23 (rule -> SenElse .)
    FLOAT64         reduce using rule 23 (rule -> SenElse .)
    BYTE            reduce using rule 23 (rule -> SenElse .)
    WINT            reduce using rule 23 (rule -> SenElse .)
    WFLOAT          reduce using rule 23 (rule -> SenElse .)
    WSTRING         reduce using rule 23 (rule -> SenElse .)
    BOOL            reduce using rule 23 (rule -> SenElse .)
    DEFAULT         reduce using rule 23 (rule -> SenElse .)
    CASE            reduce using rule 23 (rule -> SenElse .)
    RETURN          reduce using rule 23 (rule -> SenElse .)


state 17

    (24) rule -> SenStruct .

    PRINT           reduce using rule 24 (rule -> SenStruct .)
    SCAN            reduce using rule 24 (rule -> SenStruct .)
    FOR             reduce using rule 24 (rule -> SenStruct .)
    CONST           reduce using rule 24 (rule -> SenStruct .)
    ID              reduce using rule 24 (rule -> SenStruct .)
    APPEND          reduce using rule 24 (rule -> SenStruct .)
    LEN             reduce using rule 24 (rule -> SenStruct .)
    COPY            reduce using rule 24 (rule -> SenStruct .)
    DELETE          reduce using rule 24 (rule -> SenStruct .)
    IF              reduce using rule 24 (rule -> SenStruct .)
    ELSE            reduce using rule 24 (rule -> SenStruct .)
    TYPE            reduce using rule 24 (rule -> SenStruct .)
    SWITCH          reduce using rule 24 (rule -> SenStruct .)
    VAR             reduce using rule 24 (rule -> SenStruct .)
    FUNC            reduce using rule 24 (rule -> SenStruct .)
    INTEGER         reduce using rule 24 (rule -> SenStruct .)
    FLOAT           reduce using rule 24 (rule -> SenStruct .)
    NOT             reduce using rule 24 (rule -> SenStruct .)
    $end            reduce using rule 24 (rule -> SenStruct .)
    RLLAVE          reduce using rule 24 (rule -> SenStruct .)
    INT32           reduce using rule 24 (rule -> SenStruct .)
    INT64           reduce using rule 24 (rule -> SenStruct .)
    FLOAT32         reduce using rule 24 (rule -> SenStruct .)
    FLOAT64         reduce using rule 24 (rule -> SenStruct .)
    BYTE            reduce using rule 24 (rule -> SenStruct .)
    WINT            reduce using rule 24 (rule -> SenStruct .)
    WFLOAT          reduce using rule 24 (rule -> SenStruct .)
    WSTRING         reduce using rule 24 (rule -> SenStruct .)
    BOOL            reduce using rule 24 (rule -> SenStruct .)
    DEFAULT         reduce using rule 24 (rule -> SenStruct .)
    CASE            reduce using rule 24 (rule -> SenStruct .)
    RETURN          reduce using rule 24 (rule -> SenStruct .)


state 18

    (25) rule -> cStruct .

    PRINT           reduce using rule 25 (rule -> cStruct .)
    SCAN            reduce using rule 25 (rule -> cStruct .)
    FOR             reduce using rule 25 (rule -> cStruct .)
    CONST           reduce using rule 25 (rule -> cStruct .)
    ID              reduce using rule 25 (rule -> cStruct .)
    APPEND          reduce using rule 25 (rule -> cStruct .)
    LEN             reduce using rule 25 (rule -> cStruct .)
    COPY            reduce using rule 25 (rule -> cStruct .)
    DELETE          reduce using rule 25 (rule -> cStruct .)
    IF              reduce using rule 25 (rule -> cStruct .)
    ELSE            reduce using rule 25 (rule -> cStruct .)
    TYPE            reduce using rule 25 (rule -> cStruct .)
    SWITCH          reduce using rule 25 (rule -> cStruct .)
    VAR             reduce using rule 25 (rule -> cStruct .)
    FUNC            reduce using rule 25 (rule -> cStruct .)
    INTEGER         reduce using rule 25 (rule -> cStruct .)
    FLOAT           reduce using rule 25 (rule -> cStruct .)
    NOT             reduce using rule 25 (rule -> cStruct .)
    $end            reduce using rule 25 (rule -> cStruct .)
    RLLAVE          reduce using rule 25 (rule -> cStruct .)
    INT32           reduce using rule 25 (rule -> cStruct .)
    INT64           reduce using rule 25 (rule -> cStruct .)
    FLOAT32         reduce using rule 25 (rule -> cStruct .)
    FLOAT64         reduce using rule 25 (rule -> cStruct .)
    BYTE            reduce using rule 25 (rule -> cStruct .)
    WINT            reduce using rule 25 (rule -> cStruct .)
    WFLOAT          reduce using rule 25 (rule -> cStruct .)
    WSTRING         reduce using rule 25 (rule -> cStruct .)
    BOOL            reduce using rule 25 (rule -> cStruct .)
    DEFAULT         reduce using rule 25 (rule -> cStruct .)
    CASE            reduce using rule 25 (rule -> cStruct .)
    RETURN          reduce using rule 25 (rule -> cStruct .)


state 19

    (26) rule -> switch_statement .

    PRINT           reduce using rule 26 (rule -> switch_statement .)
    SCAN            reduce using rule 26 (rule -> switch_statement .)
    FOR             reduce using rule 26 (rule -> switch_statement .)
    CONST           reduce using rule 26 (rule -> switch_statement .)
    ID              reduce using rule 26 (rule -> switch_statement .)
    APPEND          reduce using rule 26 (rule -> switch_statement .)
    LEN             reduce using rule 26 (rule -> switch_statement .)
    COPY            reduce using rule 26 (rule -> switch_statement .)
    DELETE          reduce using rule 26 (rule -> switch_statement .)
    IF              reduce using rule 26 (rule -> switch_statement .)
    ELSE            reduce using rule 26 (rule -> switch_statement .)
    TYPE            reduce using rule 26 (rule -> switch_statement .)
    SWITCH          reduce using rule 26 (rule -> switch_statement .)
    VAR             reduce using rule 26 (rule -> switch_statement .)
    FUNC            reduce using rule 26 (rule -> switch_statement .)
    INTEGER         reduce using rule 26 (rule -> switch_statement .)
    FLOAT           reduce using rule 26 (rule -> switch_statement .)
    NOT             reduce using rule 26 (rule -> switch_statement .)
    $end            reduce using rule 26 (rule -> switch_statement .)
    RLLAVE          reduce using rule 26 (rule -> switch_statement .)
    INT32           reduce using rule 26 (rule -> switch_statement .)
    INT64           reduce using rule 26 (rule -> switch_statement .)
    FLOAT32         reduce using rule 26 (rule -> switch_statement .)
    FLOAT64         reduce using rule 26 (rule -> switch_statement .)
    BYTE            reduce using rule 26 (rule -> switch_statement .)
    WINT            reduce using rule 26 (rule -> switch_statement .)
    WFLOAT          reduce using rule 26 (rule -> switch_statement .)
    WSTRING         reduce using rule 26 (rule -> switch_statement .)
    BOOL            reduce using rule 26 (rule -> switch_statement .)
    DEFAULT         reduce using rule 26 (rule -> switch_statement .)
    CASE            reduce using rule 26 (rule -> switch_statement .)
    RETURN          reduce using rule 26 (rule -> switch_statement .)


state 20

    (27) rule -> array_declaration . COLON
    (28) rule -> array_declaration .

    COLON           shift and go to state 68
    PRINT           reduce using rule 28 (rule -> array_declaration .)
    SCAN            reduce using rule 28 (rule -> array_declaration .)
    FOR             reduce using rule 28 (rule -> array_declaration .)
    CONST           reduce using rule 28 (rule -> array_declaration .)
    ID              reduce using rule 28 (rule -> array_declaration .)
    APPEND          reduce using rule 28 (rule -> array_declaration .)
    LEN             reduce using rule 28 (rule -> array_declaration .)
    COPY            reduce using rule 28 (rule -> array_declaration .)
    DELETE          reduce using rule 28 (rule -> array_declaration .)
    IF              reduce using rule 28 (rule -> array_declaration .)
    ELSE            reduce using rule 28 (rule -> array_declaration .)
    TYPE            reduce using rule 28 (rule -> array_declaration .)
    SWITCH          reduce using rule 28 (rule -> array_declaration .)
    VAR             reduce using rule 28 (rule -> array_declaration .)
    FUNC            reduce using rule 28 (rule -> array_declaration .)
    INTEGER         reduce using rule 28 (rule -> array_declaration .)
    FLOAT           reduce using rule 28 (rule -> array_declaration .)
    NOT             reduce using rule 28 (rule -> array_declaration .)
    $end            reduce using rule 28 (rule -> array_declaration .)
    RLLAVE          reduce using rule 28 (rule -> array_declaration .)
    INT32           reduce using rule 28 (rule -> array_declaration .)
    INT64           reduce using rule 28 (rule -> array_declaration .)
    FLOAT32         reduce using rule 28 (rule -> array_declaration .)
    FLOAT64         reduce using rule 28 (rule -> array_declaration .)
    BYTE            reduce using rule 28 (rule -> array_declaration .)
    WINT            reduce using rule 28 (rule -> array_declaration .)
    WFLOAT          reduce using rule 28 (rule -> array_declaration .)
    WSTRING         reduce using rule 28 (rule -> array_declaration .)
    BOOL            reduce using rule 28 (rule -> array_declaration .)
    DEFAULT         reduce using rule 28 (rule -> array_declaration .)
    CASE            reduce using rule 28 (rule -> array_declaration .)
    RETURN          reduce using rule 28 (rule -> array_declaration .)


state 21

    (29) rule -> array_var . COLON
    (30) rule -> array_var .
    (210) array_assignment -> array_var . EQUAL something
    (62) data_structure -> array_var .

  ! shift/reduce conflict for COLON resolved as shift
  ! reduce/reduce conflict for PRINT resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for SCAN resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for FOR resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for CONST resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for ID resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for APPEND resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for LEN resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for COPY resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for DELETE resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for IF resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for ELSE resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for TYPE resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for SWITCH resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for VAR resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for FUNC resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for INTEGER resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for FLOAT resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for NOT resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for $end resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for INT32 resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for INT64 resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for BYTE resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for WINT resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for WSTRING resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for BOOL resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for CASE resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for RETURN resolved using rule 30 (rule -> array_var .)
    COLON           shift and go to state 69
    PRINT           reduce using rule 30 (rule -> array_var .)
    SCAN            reduce using rule 30 (rule -> array_var .)
    FOR             reduce using rule 30 (rule -> array_var .)
    CONST           reduce using rule 30 (rule -> array_var .)
    ID              reduce using rule 30 (rule -> array_var .)
    APPEND          reduce using rule 30 (rule -> array_var .)
    LEN             reduce using rule 30 (rule -> array_var .)
    COPY            reduce using rule 30 (rule -> array_var .)
    DELETE          reduce using rule 30 (rule -> array_var .)
    IF              reduce using rule 30 (rule -> array_var .)
    ELSE            reduce using rule 30 (rule -> array_var .)
    TYPE            reduce using rule 30 (rule -> array_var .)
    SWITCH          reduce using rule 30 (rule -> array_var .)
    VAR             reduce using rule 30 (rule -> array_var .)
    FUNC            reduce using rule 30 (rule -> array_var .)
    INTEGER         reduce using rule 30 (rule -> array_var .)
    FLOAT           reduce using rule 30 (rule -> array_var .)
    NOT             reduce using rule 30 (rule -> array_var .)
    $end            reduce using rule 30 (rule -> array_var .)
    RLLAVE          reduce using rule 30 (rule -> array_var .)
    INT32           reduce using rule 30 (rule -> array_var .)
    INT64           reduce using rule 30 (rule -> array_var .)
    FLOAT32         reduce using rule 30 (rule -> array_var .)
    FLOAT64         reduce using rule 30 (rule -> array_var .)
    BYTE            reduce using rule 30 (rule -> array_var .)
    WINT            reduce using rule 30 (rule -> array_var .)
    WFLOAT          reduce using rule 30 (rule -> array_var .)
    WSTRING         reduce using rule 30 (rule -> array_var .)
    BOOL            reduce using rule 30 (rule -> array_var .)
    DEFAULT         reduce using rule 30 (rule -> array_var .)
    CASE            reduce using rule 30 (rule -> array_var .)
    RETURN          reduce using rule 30 (rule -> array_var .)
    EQUAL           shift and go to state 70
    GREATER         reduce using rule 62 (data_structure -> array_var .)
    SMALLER         reduce using rule 62 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 62 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 62 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 62 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 62 (data_structure -> array_var .)
    PLUS            reduce using rule 62 (data_structure -> array_var .)
    TIMES           reduce using rule 62 (data_structure -> array_var .)
    DIVIDE          reduce using rule 62 (data_structure -> array_var .)
    MINUS           reduce using rule 62 (data_structure -> array_var .)
    MOD             reduce using rule 62 (data_structure -> array_var .)

  ! COLON           [ reduce using rule 62 (data_structure -> array_var .) ]
  ! PRINT           [ reduce using rule 62 (data_structure -> array_var .) ]
  ! SCAN            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! FOR             [ reduce using rule 62 (data_structure -> array_var .) ]
  ! CONST           [ reduce using rule 62 (data_structure -> array_var .) ]
  ! ID              [ reduce using rule 62 (data_structure -> array_var .) ]
  ! APPEND          [ reduce using rule 62 (data_structure -> array_var .) ]
  ! LEN             [ reduce using rule 62 (data_structure -> array_var .) ]
  ! COPY            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! DELETE          [ reduce using rule 62 (data_structure -> array_var .) ]
  ! IF              [ reduce using rule 62 (data_structure -> array_var .) ]
  ! ELSE            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! TYPE            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! SWITCH          [ reduce using rule 62 (data_structure -> array_var .) ]
  ! VAR             [ reduce using rule 62 (data_structure -> array_var .) ]
  ! FUNC            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! INTEGER         [ reduce using rule 62 (data_structure -> array_var .) ]
  ! FLOAT           [ reduce using rule 62 (data_structure -> array_var .) ]
  ! NOT             [ reduce using rule 62 (data_structure -> array_var .) ]
  ! $end            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! RLLAVE          [ reduce using rule 62 (data_structure -> array_var .) ]
  ! INT32           [ reduce using rule 62 (data_structure -> array_var .) ]
  ! INT64           [ reduce using rule 62 (data_structure -> array_var .) ]
  ! FLOAT32         [ reduce using rule 62 (data_structure -> array_var .) ]
  ! FLOAT64         [ reduce using rule 62 (data_structure -> array_var .) ]
  ! BYTE            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! WINT            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! WFLOAT          [ reduce using rule 62 (data_structure -> array_var .) ]
  ! WSTRING         [ reduce using rule 62 (data_structure -> array_var .) ]
  ! BOOL            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! DEFAULT         [ reduce using rule 62 (data_structure -> array_var .) ]
  ! CASE            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! RETURN          [ reduce using rule 62 (data_structure -> array_var .) ]


state 22

    (31) rule -> array_assignment . COLON
    (32) rule -> array_assignment .

    COLON           shift and go to state 71
    PRINT           reduce using rule 32 (rule -> array_assignment .)
    SCAN            reduce using rule 32 (rule -> array_assignment .)
    FOR             reduce using rule 32 (rule -> array_assignment .)
    CONST           reduce using rule 32 (rule -> array_assignment .)
    ID              reduce using rule 32 (rule -> array_assignment .)
    APPEND          reduce using rule 32 (rule -> array_assignment .)
    LEN             reduce using rule 32 (rule -> array_assignment .)
    COPY            reduce using rule 32 (rule -> array_assignment .)
    DELETE          reduce using rule 32 (rule -> array_assignment .)
    IF              reduce using rule 32 (rule -> array_assignment .)
    ELSE            reduce using rule 32 (rule -> array_assignment .)
    TYPE            reduce using rule 32 (rule -> array_assignment .)
    SWITCH          reduce using rule 32 (rule -> array_assignment .)
    VAR             reduce using rule 32 (rule -> array_assignment .)
    FUNC            reduce using rule 32 (rule -> array_assignment .)
    INTEGER         reduce using rule 32 (rule -> array_assignment .)
    FLOAT           reduce using rule 32 (rule -> array_assignment .)
    NOT             reduce using rule 32 (rule -> array_assignment .)
    $end            reduce using rule 32 (rule -> array_assignment .)
    RLLAVE          reduce using rule 32 (rule -> array_assignment .)
    INT32           reduce using rule 32 (rule -> array_assignment .)
    INT64           reduce using rule 32 (rule -> array_assignment .)
    FLOAT32         reduce using rule 32 (rule -> array_assignment .)
    FLOAT64         reduce using rule 32 (rule -> array_assignment .)
    BYTE            reduce using rule 32 (rule -> array_assignment .)
    WINT            reduce using rule 32 (rule -> array_assignment .)
    WFLOAT          reduce using rule 32 (rule -> array_assignment .)
    WSTRING         reduce using rule 32 (rule -> array_assignment .)
    BOOL            reduce using rule 32 (rule -> array_assignment .)
    DEFAULT         reduce using rule 32 (rule -> array_assignment .)
    CASE            reduce using rule 32 (rule -> array_assignment .)
    RETURN          reduce using rule 32 (rule -> array_assignment .)


state 23

    (33) rule -> slice_declaration . COLON
    (34) rule -> slice_declaration .

    COLON           shift and go to state 72
    PRINT           reduce using rule 34 (rule -> slice_declaration .)
    SCAN            reduce using rule 34 (rule -> slice_declaration .)
    FOR             reduce using rule 34 (rule -> slice_declaration .)
    CONST           reduce using rule 34 (rule -> slice_declaration .)
    ID              reduce using rule 34 (rule -> slice_declaration .)
    APPEND          reduce using rule 34 (rule -> slice_declaration .)
    LEN             reduce using rule 34 (rule -> slice_declaration .)
    COPY            reduce using rule 34 (rule -> slice_declaration .)
    DELETE          reduce using rule 34 (rule -> slice_declaration .)
    IF              reduce using rule 34 (rule -> slice_declaration .)
    ELSE            reduce using rule 34 (rule -> slice_declaration .)
    TYPE            reduce using rule 34 (rule -> slice_declaration .)
    SWITCH          reduce using rule 34 (rule -> slice_declaration .)
    VAR             reduce using rule 34 (rule -> slice_declaration .)
    FUNC            reduce using rule 34 (rule -> slice_declaration .)
    INTEGER         reduce using rule 34 (rule -> slice_declaration .)
    FLOAT           reduce using rule 34 (rule -> slice_declaration .)
    NOT             reduce using rule 34 (rule -> slice_declaration .)
    $end            reduce using rule 34 (rule -> slice_declaration .)
    RLLAVE          reduce using rule 34 (rule -> slice_declaration .)
    INT32           reduce using rule 34 (rule -> slice_declaration .)
    INT64           reduce using rule 34 (rule -> slice_declaration .)
    FLOAT32         reduce using rule 34 (rule -> slice_declaration .)
    FLOAT64         reduce using rule 34 (rule -> slice_declaration .)
    BYTE            reduce using rule 34 (rule -> slice_declaration .)
    WINT            reduce using rule 34 (rule -> slice_declaration .)
    WFLOAT          reduce using rule 34 (rule -> slice_declaration .)
    WSTRING         reduce using rule 34 (rule -> slice_declaration .)
    BOOL            reduce using rule 34 (rule -> slice_declaration .)
    DEFAULT         reduce using rule 34 (rule -> slice_declaration .)
    CASE            reduce using rule 34 (rule -> slice_declaration .)
    RETURN          reduce using rule 34 (rule -> slice_declaration .)


state 24

    (35) rule -> slice_var . COLON
    (36) rule -> slice_var .
    (145) slice_assignment -> slice_var . EQUAL something_s

    COLON           shift and go to state 73
    PRINT           reduce using rule 36 (rule -> slice_var .)
    SCAN            reduce using rule 36 (rule -> slice_var .)
    FOR             reduce using rule 36 (rule -> slice_var .)
    CONST           reduce using rule 36 (rule -> slice_var .)
    ID              reduce using rule 36 (rule -> slice_var .)
    APPEND          reduce using rule 36 (rule -> slice_var .)
    LEN             reduce using rule 36 (rule -> slice_var .)
    COPY            reduce using rule 36 (rule -> slice_var .)
    DELETE          reduce using rule 36 (rule -> slice_var .)
    IF              reduce using rule 36 (rule -> slice_var .)
    ELSE            reduce using rule 36 (rule -> slice_var .)
    TYPE            reduce using rule 36 (rule -> slice_var .)
    SWITCH          reduce using rule 36 (rule -> slice_var .)
    VAR             reduce using rule 36 (rule -> slice_var .)
    FUNC            reduce using rule 36 (rule -> slice_var .)
    INTEGER         reduce using rule 36 (rule -> slice_var .)
    FLOAT           reduce using rule 36 (rule -> slice_var .)
    NOT             reduce using rule 36 (rule -> slice_var .)
    $end            reduce using rule 36 (rule -> slice_var .)
    RLLAVE          reduce using rule 36 (rule -> slice_var .)
    INT32           reduce using rule 36 (rule -> slice_var .)
    INT64           reduce using rule 36 (rule -> slice_var .)
    FLOAT32         reduce using rule 36 (rule -> slice_var .)
    FLOAT64         reduce using rule 36 (rule -> slice_var .)
    BYTE            reduce using rule 36 (rule -> slice_var .)
    WINT            reduce using rule 36 (rule -> slice_var .)
    WFLOAT          reduce using rule 36 (rule -> slice_var .)
    WSTRING         reduce using rule 36 (rule -> slice_var .)
    BOOL            reduce using rule 36 (rule -> slice_var .)
    DEFAULT         reduce using rule 36 (rule -> slice_var .)
    CASE            reduce using rule 36 (rule -> slice_var .)
    RETURN          reduce using rule 36 (rule -> slice_var .)
    EQUAL           shift and go to state 74


state 25

    (37) rule -> slice_assignment . COLON
    (38) rule -> slice_assignment .

    COLON           shift and go to state 75
    PRINT           reduce using rule 38 (rule -> slice_assignment .)
    SCAN            reduce using rule 38 (rule -> slice_assignment .)
    FOR             reduce using rule 38 (rule -> slice_assignment .)
    CONST           reduce using rule 38 (rule -> slice_assignment .)
    ID              reduce using rule 38 (rule -> slice_assignment .)
    APPEND          reduce using rule 38 (rule -> slice_assignment .)
    LEN             reduce using rule 38 (rule -> slice_assignment .)
    COPY            reduce using rule 38 (rule -> slice_assignment .)
    DELETE          reduce using rule 38 (rule -> slice_assignment .)
    IF              reduce using rule 38 (rule -> slice_assignment .)
    ELSE            reduce using rule 38 (rule -> slice_assignment .)
    TYPE            reduce using rule 38 (rule -> slice_assignment .)
    SWITCH          reduce using rule 38 (rule -> slice_assignment .)
    VAR             reduce using rule 38 (rule -> slice_assignment .)
    FUNC            reduce using rule 38 (rule -> slice_assignment .)
    INTEGER         reduce using rule 38 (rule -> slice_assignment .)
    FLOAT           reduce using rule 38 (rule -> slice_assignment .)
    NOT             reduce using rule 38 (rule -> slice_assignment .)
    $end            reduce using rule 38 (rule -> slice_assignment .)
    RLLAVE          reduce using rule 38 (rule -> slice_assignment .)
    INT32           reduce using rule 38 (rule -> slice_assignment .)
    INT64           reduce using rule 38 (rule -> slice_assignment .)
    FLOAT32         reduce using rule 38 (rule -> slice_assignment .)
    FLOAT64         reduce using rule 38 (rule -> slice_assignment .)
    BYTE            reduce using rule 38 (rule -> slice_assignment .)
    WINT            reduce using rule 38 (rule -> slice_assignment .)
    WFLOAT          reduce using rule 38 (rule -> slice_assignment .)
    WSTRING         reduce using rule 38 (rule -> slice_assignment .)
    BOOL            reduce using rule 38 (rule -> slice_assignment .)
    DEFAULT         reduce using rule 38 (rule -> slice_assignment .)
    CASE            reduce using rule 38 (rule -> slice_assignment .)
    RETURN          reduce using rule 38 (rule -> slice_assignment .)


state 26

    (39) rule -> map_declaration . COLON
    (40) rule -> map_declaration .

    COLON           shift and go to state 76
    PRINT           reduce using rule 40 (rule -> map_declaration .)
    SCAN            reduce using rule 40 (rule -> map_declaration .)
    FOR             reduce using rule 40 (rule -> map_declaration .)
    CONST           reduce using rule 40 (rule -> map_declaration .)
    ID              reduce using rule 40 (rule -> map_declaration .)
    APPEND          reduce using rule 40 (rule -> map_declaration .)
    LEN             reduce using rule 40 (rule -> map_declaration .)
    COPY            reduce using rule 40 (rule -> map_declaration .)
    DELETE          reduce using rule 40 (rule -> map_declaration .)
    IF              reduce using rule 40 (rule -> map_declaration .)
    ELSE            reduce using rule 40 (rule -> map_declaration .)
    TYPE            reduce using rule 40 (rule -> map_declaration .)
    SWITCH          reduce using rule 40 (rule -> map_declaration .)
    VAR             reduce using rule 40 (rule -> map_declaration .)
    FUNC            reduce using rule 40 (rule -> map_declaration .)
    INTEGER         reduce using rule 40 (rule -> map_declaration .)
    FLOAT           reduce using rule 40 (rule -> map_declaration .)
    NOT             reduce using rule 40 (rule -> map_declaration .)
    $end            reduce using rule 40 (rule -> map_declaration .)
    RLLAVE          reduce using rule 40 (rule -> map_declaration .)
    INT32           reduce using rule 40 (rule -> map_declaration .)
    INT64           reduce using rule 40 (rule -> map_declaration .)
    FLOAT32         reduce using rule 40 (rule -> map_declaration .)
    FLOAT64         reduce using rule 40 (rule -> map_declaration .)
    BYTE            reduce using rule 40 (rule -> map_declaration .)
    WINT            reduce using rule 40 (rule -> map_declaration .)
    WFLOAT          reduce using rule 40 (rule -> map_declaration .)
    WSTRING         reduce using rule 40 (rule -> map_declaration .)
    BOOL            reduce using rule 40 (rule -> map_declaration .)
    DEFAULT         reduce using rule 40 (rule -> map_declaration .)
    CASE            reduce using rule 40 (rule -> map_declaration .)
    RETURN          reduce using rule 40 (rule -> map_declaration .)


state 27

    (41) rule -> map_assignment . COLON
    (42) rule -> map_assignment .

    COLON           shift and go to state 77
    PRINT           reduce using rule 42 (rule -> map_assignment .)
    SCAN            reduce using rule 42 (rule -> map_assignment .)
    FOR             reduce using rule 42 (rule -> map_assignment .)
    CONST           reduce using rule 42 (rule -> map_assignment .)
    ID              reduce using rule 42 (rule -> map_assignment .)
    APPEND          reduce using rule 42 (rule -> map_assignment .)
    LEN             reduce using rule 42 (rule -> map_assignment .)
    COPY            reduce using rule 42 (rule -> map_assignment .)
    DELETE          reduce using rule 42 (rule -> map_assignment .)
    IF              reduce using rule 42 (rule -> map_assignment .)
    ELSE            reduce using rule 42 (rule -> map_assignment .)
    TYPE            reduce using rule 42 (rule -> map_assignment .)
    SWITCH          reduce using rule 42 (rule -> map_assignment .)
    VAR             reduce using rule 42 (rule -> map_assignment .)
    FUNC            reduce using rule 42 (rule -> map_assignment .)
    INTEGER         reduce using rule 42 (rule -> map_assignment .)
    FLOAT           reduce using rule 42 (rule -> map_assignment .)
    NOT             reduce using rule 42 (rule -> map_assignment .)
    $end            reduce using rule 42 (rule -> map_assignment .)
    RLLAVE          reduce using rule 42 (rule -> map_assignment .)
    INT32           reduce using rule 42 (rule -> map_assignment .)
    INT64           reduce using rule 42 (rule -> map_assignment .)
    FLOAT32         reduce using rule 42 (rule -> map_assignment .)
    FLOAT64         reduce using rule 42 (rule -> map_assignment .)
    BYTE            reduce using rule 42 (rule -> map_assignment .)
    WINT            reduce using rule 42 (rule -> map_assignment .)
    WFLOAT          reduce using rule 42 (rule -> map_assignment .)
    WSTRING         reduce using rule 42 (rule -> map_assignment .)
    BOOL            reduce using rule 42 (rule -> map_assignment .)
    DEFAULT         reduce using rule 42 (rule -> map_assignment .)
    CASE            reduce using rule 42 (rule -> map_assignment .)
    RETURN          reduce using rule 42 (rule -> map_assignment .)


state 28

    (43) rule -> func_declaration .

    PRINT           reduce using rule 43 (rule -> func_declaration .)
    SCAN            reduce using rule 43 (rule -> func_declaration .)
    FOR             reduce using rule 43 (rule -> func_declaration .)
    CONST           reduce using rule 43 (rule -> func_declaration .)
    ID              reduce using rule 43 (rule -> func_declaration .)
    APPEND          reduce using rule 43 (rule -> func_declaration .)
    LEN             reduce using rule 43 (rule -> func_declaration .)
    COPY            reduce using rule 43 (rule -> func_declaration .)
    DELETE          reduce using rule 43 (rule -> func_declaration .)
    IF              reduce using rule 43 (rule -> func_declaration .)
    ELSE            reduce using rule 43 (rule -> func_declaration .)
    TYPE            reduce using rule 43 (rule -> func_declaration .)
    SWITCH          reduce using rule 43 (rule -> func_declaration .)
    VAR             reduce using rule 43 (rule -> func_declaration .)
    FUNC            reduce using rule 43 (rule -> func_declaration .)
    INTEGER         reduce using rule 43 (rule -> func_declaration .)
    FLOAT           reduce using rule 43 (rule -> func_declaration .)
    NOT             reduce using rule 43 (rule -> func_declaration .)
    $end            reduce using rule 43 (rule -> func_declaration .)
    RLLAVE          reduce using rule 43 (rule -> func_declaration .)
    INT32           reduce using rule 43 (rule -> func_declaration .)
    INT64           reduce using rule 43 (rule -> func_declaration .)
    FLOAT32         reduce using rule 43 (rule -> func_declaration .)
    FLOAT64         reduce using rule 43 (rule -> func_declaration .)
    BYTE            reduce using rule 43 (rule -> func_declaration .)
    WINT            reduce using rule 43 (rule -> func_declaration .)
    WFLOAT          reduce using rule 43 (rule -> func_declaration .)
    WSTRING         reduce using rule 43 (rule -> func_declaration .)
    BOOL            reduce using rule 43 (rule -> func_declaration .)
    DEFAULT         reduce using rule 43 (rule -> func_declaration .)
    CASE            reduce using rule 43 (rule -> func_declaration .)
    RETURN          reduce using rule 43 (rule -> func_declaration .)


state 29

    (44) rule -> main_func .

    PRINT           reduce using rule 44 (rule -> main_func .)
    SCAN            reduce using rule 44 (rule -> main_func .)
    FOR             reduce using rule 44 (rule -> main_func .)
    CONST           reduce using rule 44 (rule -> main_func .)
    ID              reduce using rule 44 (rule -> main_func .)
    APPEND          reduce using rule 44 (rule -> main_func .)
    LEN             reduce using rule 44 (rule -> main_func .)
    COPY            reduce using rule 44 (rule -> main_func .)
    DELETE          reduce using rule 44 (rule -> main_func .)
    IF              reduce using rule 44 (rule -> main_func .)
    ELSE            reduce using rule 44 (rule -> main_func .)
    TYPE            reduce using rule 44 (rule -> main_func .)
    SWITCH          reduce using rule 44 (rule -> main_func .)
    VAR             reduce using rule 44 (rule -> main_func .)
    FUNC            reduce using rule 44 (rule -> main_func .)
    INTEGER         reduce using rule 44 (rule -> main_func .)
    FLOAT           reduce using rule 44 (rule -> main_func .)
    NOT             reduce using rule 44 (rule -> main_func .)
    $end            reduce using rule 44 (rule -> main_func .)
    RLLAVE          reduce using rule 44 (rule -> main_func .)
    INT32           reduce using rule 44 (rule -> main_func .)
    INT64           reduce using rule 44 (rule -> main_func .)
    FLOAT32         reduce using rule 44 (rule -> main_func .)
    FLOAT64         reduce using rule 44 (rule -> main_func .)
    BYTE            reduce using rule 44 (rule -> main_func .)
    WINT            reduce using rule 44 (rule -> main_func .)
    WFLOAT          reduce using rule 44 (rule -> main_func .)
    WSTRING         reduce using rule 44 (rule -> main_func .)
    BOOL            reduce using rule 44 (rule -> main_func .)
    DEFAULT         reduce using rule 44 (rule -> main_func .)
    CASE            reduce using rule 44 (rule -> main_func .)
    RETURN          reduce using rule 44 (rule -> main_func .)


state 30

    (228) impresion -> PRINT . LPAREN content RPAREN

    LPAREN          shift and go to state 78


state 31

    (81) scan_func -> SCAN . LPAREN POINTER RPAREN

    LPAREN          shift and go to state 79


state 32

    (234) expression -> something_ex .
    (235) expression -> something_ex . adicionaEx
    (236) adicionaEx -> . op something_ex
    (237) adicionaEx -> . op something_ex adicionaEx
    (179) op -> . GREATER
    (180) op -> . SMALLER
    (181) op -> . GREATER_OR_EQUAL
    (182) op -> . SMALLER_OR_EQUAL
    (183) op -> . EQUAL_COMPARE
    (184) op -> . NOT_EQUAL
    (243) op -> . PLUS
    (244) op -> . TIMES
    (245) op -> . DIVIDE
    (246) op -> . MINUS
    (247) op -> . MOD

  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL_COMPARE resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
    COLON           reduce using rule 234 (expression -> something_ex .)
    PRINT           reduce using rule 234 (expression -> something_ex .)
    SCAN            reduce using rule 234 (expression -> something_ex .)
    FOR             reduce using rule 234 (expression -> something_ex .)
    CONST           reduce using rule 234 (expression -> something_ex .)
    ID              reduce using rule 234 (expression -> something_ex .)
    APPEND          reduce using rule 234 (expression -> something_ex .)
    LEN             reduce using rule 234 (expression -> something_ex .)
    COPY            reduce using rule 234 (expression -> something_ex .)
    DELETE          reduce using rule 234 (expression -> something_ex .)
    IF              reduce using rule 234 (expression -> something_ex .)
    ELSE            reduce using rule 234 (expression -> something_ex .)
    TYPE            reduce using rule 234 (expression -> something_ex .)
    SWITCH          reduce using rule 234 (expression -> something_ex .)
    VAR             reduce using rule 234 (expression -> something_ex .)
    FUNC            reduce using rule 234 (expression -> something_ex .)
    INTEGER         reduce using rule 234 (expression -> something_ex .)
    FLOAT           reduce using rule 234 (expression -> something_ex .)
    NOT             reduce using rule 234 (expression -> something_ex .)
    $end            reduce using rule 234 (expression -> something_ex .)
    RLLAVE          reduce using rule 234 (expression -> something_ex .)
    INT32           reduce using rule 234 (expression -> something_ex .)
    INT64           reduce using rule 234 (expression -> something_ex .)
    FLOAT32         reduce using rule 234 (expression -> something_ex .)
    FLOAT64         reduce using rule 234 (expression -> something_ex .)
    BYTE            reduce using rule 234 (expression -> something_ex .)
    WINT            reduce using rule 234 (expression -> something_ex .)
    WFLOAT          reduce using rule 234 (expression -> something_ex .)
    WSTRING         reduce using rule 234 (expression -> something_ex .)
    BOOL            reduce using rule 234 (expression -> something_ex .)
    DEFAULT         reduce using rule 234 (expression -> something_ex .)
    CASE            reduce using rule 234 (expression -> something_ex .)
    RETURN          reduce using rule 234 (expression -> something_ex .)
    RPAREN          reduce using rule 234 (expression -> something_ex .)
    AND             reduce using rule 234 (expression -> something_ex .)
    OR              reduce using rule 234 (expression -> something_ex .)
    LLLAVE          reduce using rule 234 (expression -> something_ex .)
    RCORCHE         reduce using rule 234 (expression -> something_ex .)
    COMA            reduce using rule 234 (expression -> something_ex .)
    GREATER         shift and go to state 82
    SMALLER         shift and go to state 83
    GREATER_OR_EQUAL shift and go to state 84
    SMALLER_OR_EQUAL shift and go to state 85
    EQUAL_COMPARE   shift and go to state 86
    NOT_EQUAL       shift and go to state 87
    PLUS            shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MINUS           shift and go to state 91
    MOD             shift and go to state 92

  ! GREATER         [ reduce using rule 234 (expression -> something_ex .) ]
  ! SMALLER         [ reduce using rule 234 (expression -> something_ex .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 234 (expression -> something_ex .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 234 (expression -> something_ex .) ]
  ! EQUAL_COMPARE   [ reduce using rule 234 (expression -> something_ex .) ]
  ! NOT_EQUAL       [ reduce using rule 234 (expression -> something_ex .) ]
  ! PLUS            [ reduce using rule 234 (expression -> something_ex .) ]
  ! TIMES           [ reduce using rule 234 (expression -> something_ex .) ]
  ! DIVIDE          [ reduce using rule 234 (expression -> something_ex .) ]
  ! MINUS           [ reduce using rule 234 (expression -> something_ex .) ]
  ! MOD             [ reduce using rule 234 (expression -> something_ex .) ]

    adicionaEx                     shift and go to state 80
    op                             shift and go to state 81

state 33

    (87) cicloFor -> FOR . LLLAVE codigo RLLAVE
    (88) cicloFor -> FOR . comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> FOR . logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> FOR . decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (156) decVarOne -> . ID DEQUAL ID
    (157) decVarOne -> . ID DEQUAL INTEGER
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    LLLAVE          shift and go to state 93
    ID              shift and go to state 97
    NOT             shift and go to state 56
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    comparison                     shift and go to state 94
    logic_operation                shift and go to state 95
    decVarOne                      shift and go to state 96
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    expression                     shift and go to state 98
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 34

    (176) comparison -> value . op value
    (179) op -> . GREATER
    (180) op -> . SMALLER
    (181) op -> . GREATER_OR_EQUAL
    (182) op -> . SMALLER_OR_EQUAL
    (183) op -> . EQUAL_COMPARE
    (184) op -> . NOT_EQUAL
    (243) op -> . PLUS
    (244) op -> . TIMES
    (245) op -> . DIVIDE
    (246) op -> . MINUS
    (247) op -> . MOD

    GREATER         shift and go to state 82
    SMALLER         shift and go to state 83
    GREATER_OR_EQUAL shift and go to state 84
    SMALLER_OR_EQUAL shift and go to state 85
    EQUAL_COMPARE   shift and go to state 86
    NOT_EQUAL       shift and go to state 87
    PLUS            shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MINUS           shift and go to state 91
    MOD             shift and go to state 92

    op                             shift and go to state 102

state 35

    (185) logic_operation -> logic_value . logic_recu
    (187) logic_recu -> . logic_op logic_value
    (188) logic_recu -> . logic_op logic_value logic_recu
    (194) logic_op -> . AND
    (195) logic_op -> . OR

    AND             shift and go to state 105
    OR              shift and go to state 106

    logic_recu                     shift and go to state 103
    logic_op                       shift and go to state 104

state 36

    (186) logic_operation -> negation .
    (189) logic_value -> negation .

    PRINT           reduce using rule 186 (logic_operation -> negation .)
    SCAN            reduce using rule 186 (logic_operation -> negation .)
    FOR             reduce using rule 186 (logic_operation -> negation .)
    CONST           reduce using rule 186 (logic_operation -> negation .)
    ID              reduce using rule 186 (logic_operation -> negation .)
    APPEND          reduce using rule 186 (logic_operation -> negation .)
    LEN             reduce using rule 186 (logic_operation -> negation .)
    COPY            reduce using rule 186 (logic_operation -> negation .)
    DELETE          reduce using rule 186 (logic_operation -> negation .)
    IF              reduce using rule 186 (logic_operation -> negation .)
    ELSE            reduce using rule 186 (logic_operation -> negation .)
    TYPE            reduce using rule 186 (logic_operation -> negation .)
    SWITCH          reduce using rule 186 (logic_operation -> negation .)
    VAR             reduce using rule 186 (logic_operation -> negation .)
    FUNC            reduce using rule 186 (logic_operation -> negation .)
    INTEGER         reduce using rule 186 (logic_operation -> negation .)
    FLOAT           reduce using rule 186 (logic_operation -> negation .)
    NOT             reduce using rule 186 (logic_operation -> negation .)
    $end            reduce using rule 186 (logic_operation -> negation .)
    RLLAVE          reduce using rule 186 (logic_operation -> negation .)
    INT32           reduce using rule 186 (logic_operation -> negation .)
    INT64           reduce using rule 186 (logic_operation -> negation .)
    FLOAT32         reduce using rule 186 (logic_operation -> negation .)
    FLOAT64         reduce using rule 186 (logic_operation -> negation .)
    BYTE            reduce using rule 186 (logic_operation -> negation .)
    WINT            reduce using rule 186 (logic_operation -> negation .)
    WFLOAT          reduce using rule 186 (logic_operation -> negation .)
    WSTRING         reduce using rule 186 (logic_operation -> negation .)
    BOOL            reduce using rule 186 (logic_operation -> negation .)
    DEFAULT         reduce using rule 186 (logic_operation -> negation .)
    CASE            reduce using rule 186 (logic_operation -> negation .)
    RETURN          reduce using rule 186 (logic_operation -> negation .)
    LLLAVE          reduce using rule 186 (logic_operation -> negation .)
    COLON           reduce using rule 186 (logic_operation -> negation .)
    RPAREN          reduce using rule 186 (logic_operation -> negation .)
    RCORCHE         reduce using rule 186 (logic_operation -> negation .)
    COMA            reduce using rule 186 (logic_operation -> negation .)
    AND             reduce using rule 189 (logic_value -> negation .)
    OR              reduce using rule 189 (logic_value -> negation .)


state 37

    (112) decVar -> static .

    COLON           reduce using rule 112 (decVar -> static .)
    PRINT           reduce using rule 112 (decVar -> static .)
    SCAN            reduce using rule 112 (decVar -> static .)
    FOR             reduce using rule 112 (decVar -> static .)
    CONST           reduce using rule 112 (decVar -> static .)
    ID              reduce using rule 112 (decVar -> static .)
    APPEND          reduce using rule 112 (decVar -> static .)
    LEN             reduce using rule 112 (decVar -> static .)
    COPY            reduce using rule 112 (decVar -> static .)
    DELETE          reduce using rule 112 (decVar -> static .)
    IF              reduce using rule 112 (decVar -> static .)
    ELSE            reduce using rule 112 (decVar -> static .)
    TYPE            reduce using rule 112 (decVar -> static .)
    SWITCH          reduce using rule 112 (decVar -> static .)
    VAR             reduce using rule 112 (decVar -> static .)
    FUNC            reduce using rule 112 (decVar -> static .)
    INTEGER         reduce using rule 112 (decVar -> static .)
    FLOAT           reduce using rule 112 (decVar -> static .)
    NOT             reduce using rule 112 (decVar -> static .)
    $end            reduce using rule 112 (decVar -> static .)
    RLLAVE          reduce using rule 112 (decVar -> static .)
    INT32           reduce using rule 112 (decVar -> static .)
    INT64           reduce using rule 112 (decVar -> static .)
    FLOAT32         reduce using rule 112 (decVar -> static .)
    FLOAT64         reduce using rule 112 (decVar -> static .)
    BYTE            reduce using rule 112 (decVar -> static .)
    WINT            reduce using rule 112 (decVar -> static .)
    WFLOAT          reduce using rule 112 (decVar -> static .)
    WSTRING         reduce using rule 112 (decVar -> static .)
    BOOL            reduce using rule 112 (decVar -> static .)
    DEFAULT         reduce using rule 112 (decVar -> static .)
    CASE            reduce using rule 112 (decVar -> static .)
    RETURN          reduce using rule 112 (decVar -> static .)


state 38

    (113) decVar -> dynamic .

    COLON           reduce using rule 113 (decVar -> dynamic .)
    PRINT           reduce using rule 113 (decVar -> dynamic .)
    SCAN            reduce using rule 113 (decVar -> dynamic .)
    FOR             reduce using rule 113 (decVar -> dynamic .)
    CONST           reduce using rule 113 (decVar -> dynamic .)
    ID              reduce using rule 113 (decVar -> dynamic .)
    APPEND          reduce using rule 113 (decVar -> dynamic .)
    LEN             reduce using rule 113 (decVar -> dynamic .)
    COPY            reduce using rule 113 (decVar -> dynamic .)
    DELETE          reduce using rule 113 (decVar -> dynamic .)
    IF              reduce using rule 113 (decVar -> dynamic .)
    ELSE            reduce using rule 113 (decVar -> dynamic .)
    TYPE            reduce using rule 113 (decVar -> dynamic .)
    SWITCH          reduce using rule 113 (decVar -> dynamic .)
    VAR             reduce using rule 113 (decVar -> dynamic .)
    FUNC            reduce using rule 113 (decVar -> dynamic .)
    INTEGER         reduce using rule 113 (decVar -> dynamic .)
    FLOAT           reduce using rule 113 (decVar -> dynamic .)
    NOT             reduce using rule 113 (decVar -> dynamic .)
    $end            reduce using rule 113 (decVar -> dynamic .)
    RLLAVE          reduce using rule 113 (decVar -> dynamic .)
    INT32           reduce using rule 113 (decVar -> dynamic .)
    INT64           reduce using rule 113 (decVar -> dynamic .)
    FLOAT32         reduce using rule 113 (decVar -> dynamic .)
    FLOAT64         reduce using rule 113 (decVar -> dynamic .)
    BYTE            reduce using rule 113 (decVar -> dynamic .)
    WINT            reduce using rule 113 (decVar -> dynamic .)
    WFLOAT          reduce using rule 113 (decVar -> dynamic .)
    WSTRING         reduce using rule 113 (decVar -> dynamic .)
    BOOL            reduce using rule 113 (decVar -> dynamic .)
    DEFAULT         reduce using rule 113 (decVar -> dynamic .)
    CASE            reduce using rule 113 (decVar -> dynamic .)
    RETURN          reduce using rule 113 (decVar -> dynamic .)


state 39

    (109) decConst -> CONST . ID data_type_and_value
    (110) decConst -> CONST . ID EQUAL ID
    (111) decConst -> CONST . ID EQUAL data_structure

    ID              shift and go to state 107


state 40

    (64) var_asignation -> ID . EQUAL any
    (169) cStruct -> ID . DEQUAL ID LLLAVE asignaciones RLLAVE
    (206) array_var -> ID . LCORCHE index RCORCHE
    (134) slice_declaration -> ID . DEQUAL funM
    (135) slice_declaration -> ID . DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> ID . LCORCHE index_s RCORCHE
    (238) something_ex -> ID .
    (177) value -> ID .
    (191) logic_value -> ID .
    (125) dynamic -> ID . DEQUAL algo
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN
    (212) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 177 (value -> ID .)
    EQUAL           shift and go to state 108
    DEQUAL          shift and go to state 109
    LCORCHE         shift and go to state 110
    COLON           reduce using rule 238 (something_ex -> ID .)
    PRINT           reduce using rule 238 (something_ex -> ID .)
    SCAN            reduce using rule 238 (something_ex -> ID .)
    FOR             reduce using rule 238 (something_ex -> ID .)
    CONST           reduce using rule 238 (something_ex -> ID .)
    ID              reduce using rule 238 (something_ex -> ID .)
    APPEND          reduce using rule 238 (something_ex -> ID .)
    LEN             reduce using rule 238 (something_ex -> ID .)
    COPY            reduce using rule 238 (something_ex -> ID .)
    DELETE          reduce using rule 238 (something_ex -> ID .)
    IF              reduce using rule 238 (something_ex -> ID .)
    ELSE            reduce using rule 238 (something_ex -> ID .)
    TYPE            reduce using rule 238 (something_ex -> ID .)
    SWITCH          reduce using rule 238 (something_ex -> ID .)
    VAR             reduce using rule 238 (something_ex -> ID .)
    FUNC            reduce using rule 238 (something_ex -> ID .)
    INTEGER         reduce using rule 238 (something_ex -> ID .)
    FLOAT           reduce using rule 238 (something_ex -> ID .)
    NOT             reduce using rule 238 (something_ex -> ID .)
    $end            reduce using rule 238 (something_ex -> ID .)
    RLLAVE          reduce using rule 238 (something_ex -> ID .)
    INT32           reduce using rule 238 (something_ex -> ID .)
    INT64           reduce using rule 238 (something_ex -> ID .)
    FLOAT32         reduce using rule 238 (something_ex -> ID .)
    FLOAT64         reduce using rule 238 (something_ex -> ID .)
    BYTE            reduce using rule 238 (something_ex -> ID .)
    WINT            reduce using rule 238 (something_ex -> ID .)
    WFLOAT          reduce using rule 238 (something_ex -> ID .)
    WSTRING         reduce using rule 238 (something_ex -> ID .)
    BOOL            reduce using rule 238 (something_ex -> ID .)
    DEFAULT         reduce using rule 238 (something_ex -> ID .)
    CASE            reduce using rule 238 (something_ex -> ID .)
    RETURN          reduce using rule 238 (something_ex -> ID .)
    GREATER         reduce using rule 177 (value -> ID .)
    SMALLER         reduce using rule 177 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 177 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 177 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 177 (value -> ID .)
    NOT_EQUAL       reduce using rule 177 (value -> ID .)
    PLUS            reduce using rule 177 (value -> ID .)
    TIMES           reduce using rule 177 (value -> ID .)
    DIVIDE          reduce using rule 177 (value -> ID .)
    MINUS           reduce using rule 177 (value -> ID .)
    MOD             reduce using rule 177 (value -> ID .)
    AND             reduce using rule 191 (logic_value -> ID .)
    OR              reduce using rule 191 (logic_value -> ID .)
    LPAREN          shift and go to state 111

  ! GREATER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 238 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 238 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 238 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 238 (something_ex -> ID .) ]


state 41

    (241) something_ex -> data_structure .

    GREATER         reduce using rule 241 (something_ex -> data_structure .)
    SMALLER         reduce using rule 241 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 241 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 241 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 241 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 241 (something_ex -> data_structure .)
    PLUS            reduce using rule 241 (something_ex -> data_structure .)
    TIMES           reduce using rule 241 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 241 (something_ex -> data_structure .)
    MINUS           reduce using rule 241 (something_ex -> data_structure .)
    MOD             reduce using rule 241 (something_ex -> data_structure .)
    COLON           reduce using rule 241 (something_ex -> data_structure .)
    PRINT           reduce using rule 241 (something_ex -> data_structure .)
    SCAN            reduce using rule 241 (something_ex -> data_structure .)
    FOR             reduce using rule 241 (something_ex -> data_structure .)
    CONST           reduce using rule 241 (something_ex -> data_structure .)
    ID              reduce using rule 241 (something_ex -> data_structure .)
    APPEND          reduce using rule 241 (something_ex -> data_structure .)
    LEN             reduce using rule 241 (something_ex -> data_structure .)
    COPY            reduce using rule 241 (something_ex -> data_structure .)
    DELETE          reduce using rule 241 (something_ex -> data_structure .)
    IF              reduce using rule 241 (something_ex -> data_structure .)
    ELSE            reduce using rule 241 (something_ex -> data_structure .)
    TYPE            reduce using rule 241 (something_ex -> data_structure .)
    SWITCH          reduce using rule 241 (something_ex -> data_structure .)
    VAR             reduce using rule 241 (something_ex -> data_structure .)
    FUNC            reduce using rule 241 (something_ex -> data_structure .)
    INTEGER         reduce using rule 241 (something_ex -> data_structure .)
    FLOAT           reduce using rule 241 (something_ex -> data_structure .)
    NOT             reduce using rule 241 (something_ex -> data_structure .)
    $end            reduce using rule 241 (something_ex -> data_structure .)
    RLLAVE          reduce using rule 241 (something_ex -> data_structure .)
    INT32           reduce using rule 241 (something_ex -> data_structure .)
    INT64           reduce using rule 241 (something_ex -> data_structure .)
    FLOAT32         reduce using rule 241 (something_ex -> data_structure .)
    FLOAT64         reduce using rule 241 (something_ex -> data_structure .)
    BYTE            reduce using rule 241 (something_ex -> data_structure .)
    WINT            reduce using rule 241 (something_ex -> data_structure .)
    WFLOAT          reduce using rule 241 (something_ex -> data_structure .)
    WSTRING         reduce using rule 241 (something_ex -> data_structure .)
    BOOL            reduce using rule 241 (something_ex -> data_structure .)
    DEFAULT         reduce using rule 241 (something_ex -> data_structure .)
    CASE            reduce using rule 241 (something_ex -> data_structure .)
    RETURN          reduce using rule 241 (something_ex -> data_structure .)
    RPAREN          reduce using rule 241 (something_ex -> data_structure .)
    AND             reduce using rule 241 (something_ex -> data_structure .)
    OR              reduce using rule 241 (something_ex -> data_structure .)
    LLLAVE          reduce using rule 241 (something_ex -> data_structure .)
    RCORCHE         reduce using rule 241 (something_ex -> data_structure .)
    COMA            reduce using rule 241 (something_ex -> data_structure .)


state 42

    (150) funciones -> APPEND . LPAREN ID COMA values RPAREN
    (151) funciones -> APPEND . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 112


state 43

    (152) funciones -> LEN . LPAREN ID RPAREN

    LPAREN          shift and go to state 113


state 44

    (153) funciones -> COPY . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 114


state 45

    (154) funciones -> DELETE . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 115


state 46

    (155) funciones -> call_func .

    COLON           reduce using rule 155 (funciones -> call_func .)
    PRINT           reduce using rule 155 (funciones -> call_func .)
    SCAN            reduce using rule 155 (funciones -> call_func .)
    FOR             reduce using rule 155 (funciones -> call_func .)
    CONST           reduce using rule 155 (funciones -> call_func .)
    ID              reduce using rule 155 (funciones -> call_func .)
    APPEND          reduce using rule 155 (funciones -> call_func .)
    LEN             reduce using rule 155 (funciones -> call_func .)
    COPY            reduce using rule 155 (funciones -> call_func .)
    DELETE          reduce using rule 155 (funciones -> call_func .)
    IF              reduce using rule 155 (funciones -> call_func .)
    ELSE            reduce using rule 155 (funciones -> call_func .)
    TYPE            reduce using rule 155 (funciones -> call_func .)
    SWITCH          reduce using rule 155 (funciones -> call_func .)
    VAR             reduce using rule 155 (funciones -> call_func .)
    FUNC            reduce using rule 155 (funciones -> call_func .)
    INTEGER         reduce using rule 155 (funciones -> call_func .)
    FLOAT           reduce using rule 155 (funciones -> call_func .)
    NOT             reduce using rule 155 (funciones -> call_func .)
    $end            reduce using rule 155 (funciones -> call_func .)
    GREATER         reduce using rule 155 (funciones -> call_func .)
    SMALLER         reduce using rule 155 (funciones -> call_func .)
    GREATER_OR_EQUAL reduce using rule 155 (funciones -> call_func .)
    SMALLER_OR_EQUAL reduce using rule 155 (funciones -> call_func .)
    EQUAL_COMPARE   reduce using rule 155 (funciones -> call_func .)
    NOT_EQUAL       reduce using rule 155 (funciones -> call_func .)
    PLUS            reduce using rule 155 (funciones -> call_func .)
    TIMES           reduce using rule 155 (funciones -> call_func .)
    DIVIDE          reduce using rule 155 (funciones -> call_func .)
    MINUS           reduce using rule 155 (funciones -> call_func .)
    MOD             reduce using rule 155 (funciones -> call_func .)
    RLLAVE          reduce using rule 155 (funciones -> call_func .)
    INT32           reduce using rule 155 (funciones -> call_func .)
    INT64           reduce using rule 155 (funciones -> call_func .)
    FLOAT32         reduce using rule 155 (funciones -> call_func .)
    FLOAT64         reduce using rule 155 (funciones -> call_func .)
    BYTE            reduce using rule 155 (funciones -> call_func .)
    WINT            reduce using rule 155 (funciones -> call_func .)
    WFLOAT          reduce using rule 155 (funciones -> call_func .)
    WSTRING         reduce using rule 155 (funciones -> call_func .)
    BOOL            reduce using rule 155 (funciones -> call_func .)
    DEFAULT         reduce using rule 155 (funciones -> call_func .)
    CASE            reduce using rule 155 (funciones -> call_func .)
    RETURN          reduce using rule 155 (funciones -> call_func .)
    RPAREN          reduce using rule 155 (funciones -> call_func .)
    AND             reduce using rule 155 (funciones -> call_func .)
    OR              reduce using rule 155 (funciones -> call_func .)
    LLLAVE          reduce using rule 155 (funciones -> call_func .)
    RCORCHE         reduce using rule 155 (funciones -> call_func .)
    COMA            reduce using rule 155 (funciones -> call_func .)


state 47

    (158) SenIF -> IF . comparison LLLAVE codigo RLLAVE
    (159) SenIF -> IF . TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> IF . FALSE LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (177) value -> . ID
    (178) value -> . expression
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    TRUE            shift and go to state 117
    FALSE           shift and go to state 118
    ID              shift and go to state 119
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    comparison                     shift and go to state 116
    value                          shift and go to state 34
    expression                     shift and go to state 98
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 48

    (161) SenElseIF -> ELSE . IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> ELSE . IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> ELSE . IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> ELSE . LLLAVE codigo RLLAVE

    IF              shift and go to state 120
    LLLAVE          shift and go to state 121


state 49

    (165) SenStruct -> TYPE . ID STRUCT LLLAVE declaration RLLAVE

    ID              shift and go to state 122


state 50

    (196) switch_statement -> SWITCH . ID LLLAVE cases RLLAVE

    ID              shift and go to state 123


state 51

    (201) array_declaration -> VAR . ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> VAR . ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (131) slice_declaration -> VAR . ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> VAR . ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> VAR . ID EQUAL funM
    (211) map_declaration -> VAR . ID LCORCHE data_types RCORCHE data_types
    (120) single -> VAR . ID data_types
    (121) single -> VAR . ID data_types EQUAL funciones
    (122) single -> VAR . ID data_types EQUAL ID
    (123) single -> VAR . ID data_types EQUAL data_structure
    (124) single -> VAR . ID data_type_and_value
    (117) list_var -> VAR . ID COMA more

    ID              shift and go to state 124


state 52

    (216) map_assignment -> map_var . EQUAL something
    (63) data_structure -> map_var .

    EQUAL           shift and go to state 125
    GREATER         reduce using rule 63 (data_structure -> map_var .)
    SMALLER         reduce using rule 63 (data_structure -> map_var .)
    GREATER_OR_EQUAL reduce using rule 63 (data_structure -> map_var .)
    SMALLER_OR_EQUAL reduce using rule 63 (data_structure -> map_var .)
    EQUAL_COMPARE   reduce using rule 63 (data_structure -> map_var .)
    NOT_EQUAL       reduce using rule 63 (data_structure -> map_var .)
    PLUS            reduce using rule 63 (data_structure -> map_var .)
    TIMES           reduce using rule 63 (data_structure -> map_var .)
    DIVIDE          reduce using rule 63 (data_structure -> map_var .)
    MINUS           reduce using rule 63 (data_structure -> map_var .)
    MOD             reduce using rule 63 (data_structure -> map_var .)
    COLON           reduce using rule 63 (data_structure -> map_var .)
    PRINT           reduce using rule 63 (data_structure -> map_var .)
    SCAN            reduce using rule 63 (data_structure -> map_var .)
    FOR             reduce using rule 63 (data_structure -> map_var .)
    CONST           reduce using rule 63 (data_structure -> map_var .)
    ID              reduce using rule 63 (data_structure -> map_var .)
    APPEND          reduce using rule 63 (data_structure -> map_var .)
    LEN             reduce using rule 63 (data_structure -> map_var .)
    COPY            reduce using rule 63 (data_structure -> map_var .)
    DELETE          reduce using rule 63 (data_structure -> map_var .)
    IF              reduce using rule 63 (data_structure -> map_var .)
    ELSE            reduce using rule 63 (data_structure -> map_var .)
    TYPE            reduce using rule 63 (data_structure -> map_var .)
    SWITCH          reduce using rule 63 (data_structure -> map_var .)
    VAR             reduce using rule 63 (data_structure -> map_var .)
    FUNC            reduce using rule 63 (data_structure -> map_var .)
    INTEGER         reduce using rule 63 (data_structure -> map_var .)
    FLOAT           reduce using rule 63 (data_structure -> map_var .)
    NOT             reduce using rule 63 (data_structure -> map_var .)
    $end            reduce using rule 63 (data_structure -> map_var .)
    RLLAVE          reduce using rule 63 (data_structure -> map_var .)
    INT32           reduce using rule 63 (data_structure -> map_var .)
    INT64           reduce using rule 63 (data_structure -> map_var .)
    FLOAT32         reduce using rule 63 (data_structure -> map_var .)
    FLOAT64         reduce using rule 63 (data_structure -> map_var .)
    BYTE            reduce using rule 63 (data_structure -> map_var .)
    WINT            reduce using rule 63 (data_structure -> map_var .)
    WFLOAT          reduce using rule 63 (data_structure -> map_var .)
    WSTRING         reduce using rule 63 (data_structure -> map_var .)
    BOOL            reduce using rule 63 (data_structure -> map_var .)
    DEFAULT         reduce using rule 63 (data_structure -> map_var .)
    CASE            reduce using rule 63 (data_structure -> map_var .)
    RETURN          reduce using rule 63 (data_structure -> map_var .)


state 53

    (217) func_declaration -> FUNC . ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> FUNC . ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> FUNC . MAIN LPAREN RPAREN LLLAVE codigo RLLAVE

    ID              shift and go to state 126
    MAIN            shift and go to state 127


state 54

    (239) something_ex -> INTEGER .

    GREATER         reduce using rule 239 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 239 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 239 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 239 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 239 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 239 (something_ex -> INTEGER .)
    PLUS            reduce using rule 239 (something_ex -> INTEGER .)
    TIMES           reduce using rule 239 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 239 (something_ex -> INTEGER .)
    MINUS           reduce using rule 239 (something_ex -> INTEGER .)
    MOD             reduce using rule 239 (something_ex -> INTEGER .)
    COLON           reduce using rule 239 (something_ex -> INTEGER .)
    PRINT           reduce using rule 239 (something_ex -> INTEGER .)
    SCAN            reduce using rule 239 (something_ex -> INTEGER .)
    FOR             reduce using rule 239 (something_ex -> INTEGER .)
    CONST           reduce using rule 239 (something_ex -> INTEGER .)
    ID              reduce using rule 239 (something_ex -> INTEGER .)
    APPEND          reduce using rule 239 (something_ex -> INTEGER .)
    LEN             reduce using rule 239 (something_ex -> INTEGER .)
    COPY            reduce using rule 239 (something_ex -> INTEGER .)
    DELETE          reduce using rule 239 (something_ex -> INTEGER .)
    IF              reduce using rule 239 (something_ex -> INTEGER .)
    ELSE            reduce using rule 239 (something_ex -> INTEGER .)
    TYPE            reduce using rule 239 (something_ex -> INTEGER .)
    SWITCH          reduce using rule 239 (something_ex -> INTEGER .)
    VAR             reduce using rule 239 (something_ex -> INTEGER .)
    FUNC            reduce using rule 239 (something_ex -> INTEGER .)
    INTEGER         reduce using rule 239 (something_ex -> INTEGER .)
    FLOAT           reduce using rule 239 (something_ex -> INTEGER .)
    NOT             reduce using rule 239 (something_ex -> INTEGER .)
    $end            reduce using rule 239 (something_ex -> INTEGER .)
    RLLAVE          reduce using rule 239 (something_ex -> INTEGER .)
    INT32           reduce using rule 239 (something_ex -> INTEGER .)
    INT64           reduce using rule 239 (something_ex -> INTEGER .)
    FLOAT32         reduce using rule 239 (something_ex -> INTEGER .)
    FLOAT64         reduce using rule 239 (something_ex -> INTEGER .)
    BYTE            reduce using rule 239 (something_ex -> INTEGER .)
    WINT            reduce using rule 239 (something_ex -> INTEGER .)
    WFLOAT          reduce using rule 239 (something_ex -> INTEGER .)
    WSTRING         reduce using rule 239 (something_ex -> INTEGER .)
    BOOL            reduce using rule 239 (something_ex -> INTEGER .)
    DEFAULT         reduce using rule 239 (something_ex -> INTEGER .)
    CASE            reduce using rule 239 (something_ex -> INTEGER .)
    RETURN          reduce using rule 239 (something_ex -> INTEGER .)
    RPAREN          reduce using rule 239 (something_ex -> INTEGER .)
    AND             reduce using rule 239 (something_ex -> INTEGER .)
    OR              reduce using rule 239 (something_ex -> INTEGER .)
    LLLAVE          reduce using rule 239 (something_ex -> INTEGER .)
    RCORCHE         reduce using rule 239 (something_ex -> INTEGER .)
    COMA            reduce using rule 239 (something_ex -> INTEGER .)


state 55

    (240) something_ex -> FLOAT .

    GREATER         reduce using rule 240 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 240 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 240 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 240 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 240 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 240 (something_ex -> FLOAT .)
    PLUS            reduce using rule 240 (something_ex -> FLOAT .)
    TIMES           reduce using rule 240 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 240 (something_ex -> FLOAT .)
    MINUS           reduce using rule 240 (something_ex -> FLOAT .)
    MOD             reduce using rule 240 (something_ex -> FLOAT .)
    COLON           reduce using rule 240 (something_ex -> FLOAT .)
    PRINT           reduce using rule 240 (something_ex -> FLOAT .)
    SCAN            reduce using rule 240 (something_ex -> FLOAT .)
    FOR             reduce using rule 240 (something_ex -> FLOAT .)
    CONST           reduce using rule 240 (something_ex -> FLOAT .)
    ID              reduce using rule 240 (something_ex -> FLOAT .)
    APPEND          reduce using rule 240 (something_ex -> FLOAT .)
    LEN             reduce using rule 240 (something_ex -> FLOAT .)
    COPY            reduce using rule 240 (something_ex -> FLOAT .)
    DELETE          reduce using rule 240 (something_ex -> FLOAT .)
    IF              reduce using rule 240 (something_ex -> FLOAT .)
    ELSE            reduce using rule 240 (something_ex -> FLOAT .)
    TYPE            reduce using rule 240 (something_ex -> FLOAT .)
    SWITCH          reduce using rule 240 (something_ex -> FLOAT .)
    VAR             reduce using rule 240 (something_ex -> FLOAT .)
    FUNC            reduce using rule 240 (something_ex -> FLOAT .)
    INTEGER         reduce using rule 240 (something_ex -> FLOAT .)
    FLOAT           reduce using rule 240 (something_ex -> FLOAT .)
    NOT             reduce using rule 240 (something_ex -> FLOAT .)
    $end            reduce using rule 240 (something_ex -> FLOAT .)
    RLLAVE          reduce using rule 240 (something_ex -> FLOAT .)
    INT32           reduce using rule 240 (something_ex -> FLOAT .)
    INT64           reduce using rule 240 (something_ex -> FLOAT .)
    FLOAT32         reduce using rule 240 (something_ex -> FLOAT .)
    FLOAT64         reduce using rule 240 (something_ex -> FLOAT .)
    BYTE            reduce using rule 240 (something_ex -> FLOAT .)
    WINT            reduce using rule 240 (something_ex -> FLOAT .)
    WFLOAT          reduce using rule 240 (something_ex -> FLOAT .)
    WSTRING         reduce using rule 240 (something_ex -> FLOAT .)
    BOOL            reduce using rule 240 (something_ex -> FLOAT .)
    DEFAULT         reduce using rule 240 (something_ex -> FLOAT .)
    CASE            reduce using rule 240 (something_ex -> FLOAT .)
    RETURN          reduce using rule 240 (something_ex -> FLOAT .)
    RPAREN          reduce using rule 240 (something_ex -> FLOAT .)
    AND             reduce using rule 240 (something_ex -> FLOAT .)
    OR              reduce using rule 240 (something_ex -> FLOAT .)
    LLLAVE          reduce using rule 240 (something_ex -> FLOAT .)
    RCORCHE         reduce using rule 240 (something_ex -> FLOAT .)
    COMA            reduce using rule 240 (something_ex -> FLOAT .)


state 56

    (192) negation -> NOT . comparison
    (193) negation -> NOT . ID
    (176) comparison -> . value op value
    (177) value -> . ID
    (178) value -> . expression
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 129
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    comparison                     shift and go to state 128
    value                          shift and go to state 34
    expression                     shift and go to state 98
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 57

    (114) static -> single .

    COLON           reduce using rule 114 (static -> single .)
    PRINT           reduce using rule 114 (static -> single .)
    SCAN            reduce using rule 114 (static -> single .)
    FOR             reduce using rule 114 (static -> single .)
    CONST           reduce using rule 114 (static -> single .)
    ID              reduce using rule 114 (static -> single .)
    APPEND          reduce using rule 114 (static -> single .)
    LEN             reduce using rule 114 (static -> single .)
    COPY            reduce using rule 114 (static -> single .)
    DELETE          reduce using rule 114 (static -> single .)
    IF              reduce using rule 114 (static -> single .)
    ELSE            reduce using rule 114 (static -> single .)
    TYPE            reduce using rule 114 (static -> single .)
    SWITCH          reduce using rule 114 (static -> single .)
    VAR             reduce using rule 114 (static -> single .)
    FUNC            reduce using rule 114 (static -> single .)
    INTEGER         reduce using rule 114 (static -> single .)
    FLOAT           reduce using rule 114 (static -> single .)
    NOT             reduce using rule 114 (static -> single .)
    $end            reduce using rule 114 (static -> single .)
    RLLAVE          reduce using rule 114 (static -> single .)
    INT32           reduce using rule 114 (static -> single .)
    INT64           reduce using rule 114 (static -> single .)
    FLOAT32         reduce using rule 114 (static -> single .)
    FLOAT64         reduce using rule 114 (static -> single .)
    BYTE            reduce using rule 114 (static -> single .)
    WINT            reduce using rule 114 (static -> single .)
    WFLOAT          reduce using rule 114 (static -> single .)
    WSTRING         reduce using rule 114 (static -> single .)
    BOOL            reduce using rule 114 (static -> single .)
    DEFAULT         reduce using rule 114 (static -> single .)
    CASE            reduce using rule 114 (static -> single .)
    RETURN          reduce using rule 114 (static -> single .)


state 58

    (115) static -> multiple .

    COLON           reduce using rule 115 (static -> multiple .)
    PRINT           reduce using rule 115 (static -> multiple .)
    SCAN            reduce using rule 115 (static -> multiple .)
    FOR             reduce using rule 115 (static -> multiple .)
    CONST           reduce using rule 115 (static -> multiple .)
    ID              reduce using rule 115 (static -> multiple .)
    APPEND          reduce using rule 115 (static -> multiple .)
    LEN             reduce using rule 115 (static -> multiple .)
    COPY            reduce using rule 115 (static -> multiple .)
    DELETE          reduce using rule 115 (static -> multiple .)
    IF              reduce using rule 115 (static -> multiple .)
    ELSE            reduce using rule 115 (static -> multiple .)
    TYPE            reduce using rule 115 (static -> multiple .)
    SWITCH          reduce using rule 115 (static -> multiple .)
    VAR             reduce using rule 115 (static -> multiple .)
    FUNC            reduce using rule 115 (static -> multiple .)
    INTEGER         reduce using rule 115 (static -> multiple .)
    FLOAT           reduce using rule 115 (static -> multiple .)
    NOT             reduce using rule 115 (static -> multiple .)
    $end            reduce using rule 115 (static -> multiple .)
    RLLAVE          reduce using rule 115 (static -> multiple .)
    INT32           reduce using rule 115 (static -> multiple .)
    INT64           reduce using rule 115 (static -> multiple .)
    FLOAT32         reduce using rule 115 (static -> multiple .)
    FLOAT64         reduce using rule 115 (static -> multiple .)
    BYTE            reduce using rule 115 (static -> multiple .)
    WINT            reduce using rule 115 (static -> multiple .)
    WFLOAT          reduce using rule 115 (static -> multiple .)
    WSTRING         reduce using rule 115 (static -> multiple .)
    BOOL            reduce using rule 115 (static -> multiple .)
    DEFAULT         reduce using rule 115 (static -> multiple .)
    CASE            reduce using rule 115 (static -> multiple .)
    RETURN          reduce using rule 115 (static -> multiple .)


state 59

    (116) multiple -> list_var . data_types
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WINT
    (56) data_types -> . WFLOAT
    (57) data_types -> . WSTRING
    (58) data_types -> . BOOL

    INT32           shift and go to state 131
    INT64           shift and go to state 132
    FLOAT32         shift and go to state 133
    FLOAT64         shift and go to state 134
    BYTE            shift and go to state 135
    WINT            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    BOOL            shift and go to state 139

    data_types                     shift and go to state 130

state 60

    (3) more_rules -> rule codigo .

    $end            reduce using rule 3 (more_rules -> rule codigo .)
    RLLAVE          reduce using rule 3 (more_rules -> rule codigo .)
    INT32           reduce using rule 3 (more_rules -> rule codigo .)
    INT64           reduce using rule 3 (more_rules -> rule codigo .)
    FLOAT32         reduce using rule 3 (more_rules -> rule codigo .)
    FLOAT64         reduce using rule 3 (more_rules -> rule codigo .)
    BYTE            reduce using rule 3 (more_rules -> rule codigo .)
    WINT            reduce using rule 3 (more_rules -> rule codigo .)
    WFLOAT          reduce using rule 3 (more_rules -> rule codigo .)
    WSTRING         reduce using rule 3 (more_rules -> rule codigo .)
    BOOL            reduce using rule 3 (more_rules -> rule codigo .)
    ID              reduce using rule 3 (more_rules -> rule codigo .)
    DEFAULT         reduce using rule 3 (more_rules -> rule codigo .)
    CASE            reduce using rule 3 (more_rules -> rule codigo .)
    RETURN          reduce using rule 3 (more_rules -> rule codigo .)


state 61

    (4) rule -> impresion COLON .

    PRINT           reduce using rule 4 (rule -> impresion COLON .)
    SCAN            reduce using rule 4 (rule -> impresion COLON .)
    FOR             reduce using rule 4 (rule -> impresion COLON .)
    CONST           reduce using rule 4 (rule -> impresion COLON .)
    ID              reduce using rule 4 (rule -> impresion COLON .)
    APPEND          reduce using rule 4 (rule -> impresion COLON .)
    LEN             reduce using rule 4 (rule -> impresion COLON .)
    COPY            reduce using rule 4 (rule -> impresion COLON .)
    DELETE          reduce using rule 4 (rule -> impresion COLON .)
    IF              reduce using rule 4 (rule -> impresion COLON .)
    ELSE            reduce using rule 4 (rule -> impresion COLON .)
    TYPE            reduce using rule 4 (rule -> impresion COLON .)
    SWITCH          reduce using rule 4 (rule -> impresion COLON .)
    VAR             reduce using rule 4 (rule -> impresion COLON .)
    FUNC            reduce using rule 4 (rule -> impresion COLON .)
    INTEGER         reduce using rule 4 (rule -> impresion COLON .)
    FLOAT           reduce using rule 4 (rule -> impresion COLON .)
    NOT             reduce using rule 4 (rule -> impresion COLON .)
    $end            reduce using rule 4 (rule -> impresion COLON .)
    RLLAVE          reduce using rule 4 (rule -> impresion COLON .)
    INT32           reduce using rule 4 (rule -> impresion COLON .)
    INT64           reduce using rule 4 (rule -> impresion COLON .)
    FLOAT32         reduce using rule 4 (rule -> impresion COLON .)
    FLOAT64         reduce using rule 4 (rule -> impresion COLON .)
    BYTE            reduce using rule 4 (rule -> impresion COLON .)
    WINT            reduce using rule 4 (rule -> impresion COLON .)
    WFLOAT          reduce using rule 4 (rule -> impresion COLON .)
    WSTRING         reduce using rule 4 (rule -> impresion COLON .)
    BOOL            reduce using rule 4 (rule -> impresion COLON .)
    DEFAULT         reduce using rule 4 (rule -> impresion COLON .)
    CASE            reduce using rule 4 (rule -> impresion COLON .)
    RETURN          reduce using rule 4 (rule -> impresion COLON .)


state 62

    (6) rule -> scan_func COLON .

    PRINT           reduce using rule 6 (rule -> scan_func COLON .)
    SCAN            reduce using rule 6 (rule -> scan_func COLON .)
    FOR             reduce using rule 6 (rule -> scan_func COLON .)
    CONST           reduce using rule 6 (rule -> scan_func COLON .)
    ID              reduce using rule 6 (rule -> scan_func COLON .)
    APPEND          reduce using rule 6 (rule -> scan_func COLON .)
    LEN             reduce using rule 6 (rule -> scan_func COLON .)
    COPY            reduce using rule 6 (rule -> scan_func COLON .)
    DELETE          reduce using rule 6 (rule -> scan_func COLON .)
    IF              reduce using rule 6 (rule -> scan_func COLON .)
    ELSE            reduce using rule 6 (rule -> scan_func COLON .)
    TYPE            reduce using rule 6 (rule -> scan_func COLON .)
    SWITCH          reduce using rule 6 (rule -> scan_func COLON .)
    VAR             reduce using rule 6 (rule -> scan_func COLON .)
    FUNC            reduce using rule 6 (rule -> scan_func COLON .)
    INTEGER         reduce using rule 6 (rule -> scan_func COLON .)
    FLOAT           reduce using rule 6 (rule -> scan_func COLON .)
    NOT             reduce using rule 6 (rule -> scan_func COLON .)
    $end            reduce using rule 6 (rule -> scan_func COLON .)
    RLLAVE          reduce using rule 6 (rule -> scan_func COLON .)
    INT32           reduce using rule 6 (rule -> scan_func COLON .)
    INT64           reduce using rule 6 (rule -> scan_func COLON .)
    FLOAT32         reduce using rule 6 (rule -> scan_func COLON .)
    FLOAT64         reduce using rule 6 (rule -> scan_func COLON .)
    BYTE            reduce using rule 6 (rule -> scan_func COLON .)
    WINT            reduce using rule 6 (rule -> scan_func COLON .)
    WFLOAT          reduce using rule 6 (rule -> scan_func COLON .)
    WSTRING         reduce using rule 6 (rule -> scan_func COLON .)
    BOOL            reduce using rule 6 (rule -> scan_func COLON .)
    DEFAULT         reduce using rule 6 (rule -> scan_func COLON .)
    CASE            reduce using rule 6 (rule -> scan_func COLON .)
    RETURN          reduce using rule 6 (rule -> scan_func COLON .)


state 63

    (8) rule -> expression COLON .

    PRINT           reduce using rule 8 (rule -> expression COLON .)
    SCAN            reduce using rule 8 (rule -> expression COLON .)
    FOR             reduce using rule 8 (rule -> expression COLON .)
    CONST           reduce using rule 8 (rule -> expression COLON .)
    ID              reduce using rule 8 (rule -> expression COLON .)
    APPEND          reduce using rule 8 (rule -> expression COLON .)
    LEN             reduce using rule 8 (rule -> expression COLON .)
    COPY            reduce using rule 8 (rule -> expression COLON .)
    DELETE          reduce using rule 8 (rule -> expression COLON .)
    IF              reduce using rule 8 (rule -> expression COLON .)
    ELSE            reduce using rule 8 (rule -> expression COLON .)
    TYPE            reduce using rule 8 (rule -> expression COLON .)
    SWITCH          reduce using rule 8 (rule -> expression COLON .)
    VAR             reduce using rule 8 (rule -> expression COLON .)
    FUNC            reduce using rule 8 (rule -> expression COLON .)
    INTEGER         reduce using rule 8 (rule -> expression COLON .)
    FLOAT           reduce using rule 8 (rule -> expression COLON .)
    NOT             reduce using rule 8 (rule -> expression COLON .)
    $end            reduce using rule 8 (rule -> expression COLON .)
    RLLAVE          reduce using rule 8 (rule -> expression COLON .)
    INT32           reduce using rule 8 (rule -> expression COLON .)
    INT64           reduce using rule 8 (rule -> expression COLON .)
    FLOAT32         reduce using rule 8 (rule -> expression COLON .)
    FLOAT64         reduce using rule 8 (rule -> expression COLON .)
    BYTE            reduce using rule 8 (rule -> expression COLON .)
    WINT            reduce using rule 8 (rule -> expression COLON .)
    WFLOAT          reduce using rule 8 (rule -> expression COLON .)
    WSTRING         reduce using rule 8 (rule -> expression COLON .)
    BOOL            reduce using rule 8 (rule -> expression COLON .)
    DEFAULT         reduce using rule 8 (rule -> expression COLON .)
    CASE            reduce using rule 8 (rule -> expression COLON .)
    RETURN          reduce using rule 8 (rule -> expression COLON .)


state 64

    (13) rule -> decVar COLON .

    PRINT           reduce using rule 13 (rule -> decVar COLON .)
    SCAN            reduce using rule 13 (rule -> decVar COLON .)
    FOR             reduce using rule 13 (rule -> decVar COLON .)
    CONST           reduce using rule 13 (rule -> decVar COLON .)
    ID              reduce using rule 13 (rule -> decVar COLON .)
    APPEND          reduce using rule 13 (rule -> decVar COLON .)
    LEN             reduce using rule 13 (rule -> decVar COLON .)
    COPY            reduce using rule 13 (rule -> decVar COLON .)
    DELETE          reduce using rule 13 (rule -> decVar COLON .)
    IF              reduce using rule 13 (rule -> decVar COLON .)
    ELSE            reduce using rule 13 (rule -> decVar COLON .)
    TYPE            reduce using rule 13 (rule -> decVar COLON .)
    SWITCH          reduce using rule 13 (rule -> decVar COLON .)
    VAR             reduce using rule 13 (rule -> decVar COLON .)
    FUNC            reduce using rule 13 (rule -> decVar COLON .)
    INTEGER         reduce using rule 13 (rule -> decVar COLON .)
    FLOAT           reduce using rule 13 (rule -> decVar COLON .)
    NOT             reduce using rule 13 (rule -> decVar COLON .)
    $end            reduce using rule 13 (rule -> decVar COLON .)
    RLLAVE          reduce using rule 13 (rule -> decVar COLON .)
    INT32           reduce using rule 13 (rule -> decVar COLON .)
    INT64           reduce using rule 13 (rule -> decVar COLON .)
    FLOAT32         reduce using rule 13 (rule -> decVar COLON .)
    FLOAT64         reduce using rule 13 (rule -> decVar COLON .)
    BYTE            reduce using rule 13 (rule -> decVar COLON .)
    WINT            reduce using rule 13 (rule -> decVar COLON .)
    WFLOAT          reduce using rule 13 (rule -> decVar COLON .)
    WSTRING         reduce using rule 13 (rule -> decVar COLON .)
    BOOL            reduce using rule 13 (rule -> decVar COLON .)
    DEFAULT         reduce using rule 13 (rule -> decVar COLON .)
    CASE            reduce using rule 13 (rule -> decVar COLON .)
    RETURN          reduce using rule 13 (rule -> decVar COLON .)


state 65

    (15) rule -> decConst COLON .

    PRINT           reduce using rule 15 (rule -> decConst COLON .)
    SCAN            reduce using rule 15 (rule -> decConst COLON .)
    FOR             reduce using rule 15 (rule -> decConst COLON .)
    CONST           reduce using rule 15 (rule -> decConst COLON .)
    ID              reduce using rule 15 (rule -> decConst COLON .)
    APPEND          reduce using rule 15 (rule -> decConst COLON .)
    LEN             reduce using rule 15 (rule -> decConst COLON .)
    COPY            reduce using rule 15 (rule -> decConst COLON .)
    DELETE          reduce using rule 15 (rule -> decConst COLON .)
    IF              reduce using rule 15 (rule -> decConst COLON .)
    ELSE            reduce using rule 15 (rule -> decConst COLON .)
    TYPE            reduce using rule 15 (rule -> decConst COLON .)
    SWITCH          reduce using rule 15 (rule -> decConst COLON .)
    VAR             reduce using rule 15 (rule -> decConst COLON .)
    FUNC            reduce using rule 15 (rule -> decConst COLON .)
    INTEGER         reduce using rule 15 (rule -> decConst COLON .)
    FLOAT           reduce using rule 15 (rule -> decConst COLON .)
    NOT             reduce using rule 15 (rule -> decConst COLON .)
    $end            reduce using rule 15 (rule -> decConst COLON .)
    RLLAVE          reduce using rule 15 (rule -> decConst COLON .)
    INT32           reduce using rule 15 (rule -> decConst COLON .)
    INT64           reduce using rule 15 (rule -> decConst COLON .)
    FLOAT32         reduce using rule 15 (rule -> decConst COLON .)
    FLOAT64         reduce using rule 15 (rule -> decConst COLON .)
    BYTE            reduce using rule 15 (rule -> decConst COLON .)
    WINT            reduce using rule 15 (rule -> decConst COLON .)
    WFLOAT          reduce using rule 15 (rule -> decConst COLON .)
    WSTRING         reduce using rule 15 (rule -> decConst COLON .)
    BOOL            reduce using rule 15 (rule -> decConst COLON .)
    DEFAULT         reduce using rule 15 (rule -> decConst COLON .)
    CASE            reduce using rule 15 (rule -> decConst COLON .)
    RETURN          reduce using rule 15 (rule -> decConst COLON .)


state 66

    (18) rule -> var_asignation COLON .

    PRINT           reduce using rule 18 (rule -> var_asignation COLON .)
    SCAN            reduce using rule 18 (rule -> var_asignation COLON .)
    FOR             reduce using rule 18 (rule -> var_asignation COLON .)
    CONST           reduce using rule 18 (rule -> var_asignation COLON .)
    ID              reduce using rule 18 (rule -> var_asignation COLON .)
    APPEND          reduce using rule 18 (rule -> var_asignation COLON .)
    LEN             reduce using rule 18 (rule -> var_asignation COLON .)
    COPY            reduce using rule 18 (rule -> var_asignation COLON .)
    DELETE          reduce using rule 18 (rule -> var_asignation COLON .)
    IF              reduce using rule 18 (rule -> var_asignation COLON .)
    ELSE            reduce using rule 18 (rule -> var_asignation COLON .)
    TYPE            reduce using rule 18 (rule -> var_asignation COLON .)
    SWITCH          reduce using rule 18 (rule -> var_asignation COLON .)
    VAR             reduce using rule 18 (rule -> var_asignation COLON .)
    FUNC            reduce using rule 18 (rule -> var_asignation COLON .)
    INTEGER         reduce using rule 18 (rule -> var_asignation COLON .)
    FLOAT           reduce using rule 18 (rule -> var_asignation COLON .)
    NOT             reduce using rule 18 (rule -> var_asignation COLON .)
    $end            reduce using rule 18 (rule -> var_asignation COLON .)
    RLLAVE          reduce using rule 18 (rule -> var_asignation COLON .)
    INT32           reduce using rule 18 (rule -> var_asignation COLON .)
    INT64           reduce using rule 18 (rule -> var_asignation COLON .)
    FLOAT32         reduce using rule 18 (rule -> var_asignation COLON .)
    FLOAT64         reduce using rule 18 (rule -> var_asignation COLON .)
    BYTE            reduce using rule 18 (rule -> var_asignation COLON .)
    WINT            reduce using rule 18 (rule -> var_asignation COLON .)
    WFLOAT          reduce using rule 18 (rule -> var_asignation COLON .)
    WSTRING         reduce using rule 18 (rule -> var_asignation COLON .)
    BOOL            reduce using rule 18 (rule -> var_asignation COLON .)
    DEFAULT         reduce using rule 18 (rule -> var_asignation COLON .)
    CASE            reduce using rule 18 (rule -> var_asignation COLON .)
    RETURN          reduce using rule 18 (rule -> var_asignation COLON .)


state 67

    (20) rule -> funciones COLON .

    PRINT           reduce using rule 20 (rule -> funciones COLON .)
    SCAN            reduce using rule 20 (rule -> funciones COLON .)
    FOR             reduce using rule 20 (rule -> funciones COLON .)
    CONST           reduce using rule 20 (rule -> funciones COLON .)
    ID              reduce using rule 20 (rule -> funciones COLON .)
    APPEND          reduce using rule 20 (rule -> funciones COLON .)
    LEN             reduce using rule 20 (rule -> funciones COLON .)
    COPY            reduce using rule 20 (rule -> funciones COLON .)
    DELETE          reduce using rule 20 (rule -> funciones COLON .)
    IF              reduce using rule 20 (rule -> funciones COLON .)
    ELSE            reduce using rule 20 (rule -> funciones COLON .)
    TYPE            reduce using rule 20 (rule -> funciones COLON .)
    SWITCH          reduce using rule 20 (rule -> funciones COLON .)
    VAR             reduce using rule 20 (rule -> funciones COLON .)
    FUNC            reduce using rule 20 (rule -> funciones COLON .)
    INTEGER         reduce using rule 20 (rule -> funciones COLON .)
    FLOAT           reduce using rule 20 (rule -> funciones COLON .)
    NOT             reduce using rule 20 (rule -> funciones COLON .)
    $end            reduce using rule 20 (rule -> funciones COLON .)
    RLLAVE          reduce using rule 20 (rule -> funciones COLON .)
    INT32           reduce using rule 20 (rule -> funciones COLON .)
    INT64           reduce using rule 20 (rule -> funciones COLON .)
    FLOAT32         reduce using rule 20 (rule -> funciones COLON .)
    FLOAT64         reduce using rule 20 (rule -> funciones COLON .)
    BYTE            reduce using rule 20 (rule -> funciones COLON .)
    WINT            reduce using rule 20 (rule -> funciones COLON .)
    WFLOAT          reduce using rule 20 (rule -> funciones COLON .)
    WSTRING         reduce using rule 20 (rule -> funciones COLON .)
    BOOL            reduce using rule 20 (rule -> funciones COLON .)
    DEFAULT         reduce using rule 20 (rule -> funciones COLON .)
    CASE            reduce using rule 20 (rule -> funciones COLON .)
    RETURN          reduce using rule 20 (rule -> funciones COLON .)


state 68

    (27) rule -> array_declaration COLON .

    PRINT           reduce using rule 27 (rule -> array_declaration COLON .)
    SCAN            reduce using rule 27 (rule -> array_declaration COLON .)
    FOR             reduce using rule 27 (rule -> array_declaration COLON .)
    CONST           reduce using rule 27 (rule -> array_declaration COLON .)
    ID              reduce using rule 27 (rule -> array_declaration COLON .)
    APPEND          reduce using rule 27 (rule -> array_declaration COLON .)
    LEN             reduce using rule 27 (rule -> array_declaration COLON .)
    COPY            reduce using rule 27 (rule -> array_declaration COLON .)
    DELETE          reduce using rule 27 (rule -> array_declaration COLON .)
    IF              reduce using rule 27 (rule -> array_declaration COLON .)
    ELSE            reduce using rule 27 (rule -> array_declaration COLON .)
    TYPE            reduce using rule 27 (rule -> array_declaration COLON .)
    SWITCH          reduce using rule 27 (rule -> array_declaration COLON .)
    VAR             reduce using rule 27 (rule -> array_declaration COLON .)
    FUNC            reduce using rule 27 (rule -> array_declaration COLON .)
    INTEGER         reduce using rule 27 (rule -> array_declaration COLON .)
    FLOAT           reduce using rule 27 (rule -> array_declaration COLON .)
    NOT             reduce using rule 27 (rule -> array_declaration COLON .)
    $end            reduce using rule 27 (rule -> array_declaration COLON .)
    RLLAVE          reduce using rule 27 (rule -> array_declaration COLON .)
    INT32           reduce using rule 27 (rule -> array_declaration COLON .)
    INT64           reduce using rule 27 (rule -> array_declaration COLON .)
    FLOAT32         reduce using rule 27 (rule -> array_declaration COLON .)
    FLOAT64         reduce using rule 27 (rule -> array_declaration COLON .)
    BYTE            reduce using rule 27 (rule -> array_declaration COLON .)
    WINT            reduce using rule 27 (rule -> array_declaration COLON .)
    WFLOAT          reduce using rule 27 (rule -> array_declaration COLON .)
    WSTRING         reduce using rule 27 (rule -> array_declaration COLON .)
    BOOL            reduce using rule 27 (rule -> array_declaration COLON .)
    DEFAULT         reduce using rule 27 (rule -> array_declaration COLON .)
    CASE            reduce using rule 27 (rule -> array_declaration COLON .)
    RETURN          reduce using rule 27 (rule -> array_declaration COLON .)


state 69

    (29) rule -> array_var COLON .

    PRINT           reduce using rule 29 (rule -> array_var COLON .)
    SCAN            reduce using rule 29 (rule -> array_var COLON .)
    FOR             reduce using rule 29 (rule -> array_var COLON .)
    CONST           reduce using rule 29 (rule -> array_var COLON .)
    ID              reduce using rule 29 (rule -> array_var COLON .)
    APPEND          reduce using rule 29 (rule -> array_var COLON .)
    LEN             reduce using rule 29 (rule -> array_var COLON .)
    COPY            reduce using rule 29 (rule -> array_var COLON .)
    DELETE          reduce using rule 29 (rule -> array_var COLON .)
    IF              reduce using rule 29 (rule -> array_var COLON .)
    ELSE            reduce using rule 29 (rule -> array_var COLON .)
    TYPE            reduce using rule 29 (rule -> array_var COLON .)
    SWITCH          reduce using rule 29 (rule -> array_var COLON .)
    VAR             reduce using rule 29 (rule -> array_var COLON .)
    FUNC            reduce using rule 29 (rule -> array_var COLON .)
    INTEGER         reduce using rule 29 (rule -> array_var COLON .)
    FLOAT           reduce using rule 29 (rule -> array_var COLON .)
    NOT             reduce using rule 29 (rule -> array_var COLON .)
    $end            reduce using rule 29 (rule -> array_var COLON .)
    RLLAVE          reduce using rule 29 (rule -> array_var COLON .)
    INT32           reduce using rule 29 (rule -> array_var COLON .)
    INT64           reduce using rule 29 (rule -> array_var COLON .)
    FLOAT32         reduce using rule 29 (rule -> array_var COLON .)
    FLOAT64         reduce using rule 29 (rule -> array_var COLON .)
    BYTE            reduce using rule 29 (rule -> array_var COLON .)
    WINT            reduce using rule 29 (rule -> array_var COLON .)
    WFLOAT          reduce using rule 29 (rule -> array_var COLON .)
    WSTRING         reduce using rule 29 (rule -> array_var COLON .)
    BOOL            reduce using rule 29 (rule -> array_var COLON .)
    DEFAULT         reduce using rule 29 (rule -> array_var COLON .)
    CASE            reduce using rule 29 (rule -> array_var COLON .)
    RETURN          reduce using rule 29 (rule -> array_var COLON .)


state 70

    (210) array_assignment -> array_var EQUAL . something
    (76) something -> . ID
    (77) something -> . data_structure
    (78) something -> . values
    (79) something -> . operations
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 141
    STRING          shift and go to state 145
    INTEGER         shift and go to state 146
    FLOAT           shift and go to state 147
    TRUE            shift and go to state 148
    FALSE           shift and go to state 149
    NOT             shift and go to state 56
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    array_var                      shift and go to state 100
    something                      shift and go to state 140
    data_structure                 shift and go to state 142
    values                         shift and go to state 143
    operations                     shift and go to state 144
    map_var                        shift and go to state 101
    expression                     shift and go to state 150
    comparison                     shift and go to state 151
    logic_operation                shift and go to state 152
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    funciones                      shift and go to state 99
    call_func                      shift and go to state 46

state 71

    (31) rule -> array_assignment COLON .

    PRINT           reduce using rule 31 (rule -> array_assignment COLON .)
    SCAN            reduce using rule 31 (rule -> array_assignment COLON .)
    FOR             reduce using rule 31 (rule -> array_assignment COLON .)
    CONST           reduce using rule 31 (rule -> array_assignment COLON .)
    ID              reduce using rule 31 (rule -> array_assignment COLON .)
    APPEND          reduce using rule 31 (rule -> array_assignment COLON .)
    LEN             reduce using rule 31 (rule -> array_assignment COLON .)
    COPY            reduce using rule 31 (rule -> array_assignment COLON .)
    DELETE          reduce using rule 31 (rule -> array_assignment COLON .)
    IF              reduce using rule 31 (rule -> array_assignment COLON .)
    ELSE            reduce using rule 31 (rule -> array_assignment COLON .)
    TYPE            reduce using rule 31 (rule -> array_assignment COLON .)
    SWITCH          reduce using rule 31 (rule -> array_assignment COLON .)
    VAR             reduce using rule 31 (rule -> array_assignment COLON .)
    FUNC            reduce using rule 31 (rule -> array_assignment COLON .)
    INTEGER         reduce using rule 31 (rule -> array_assignment COLON .)
    FLOAT           reduce using rule 31 (rule -> array_assignment COLON .)
    NOT             reduce using rule 31 (rule -> array_assignment COLON .)
    $end            reduce using rule 31 (rule -> array_assignment COLON .)
    RLLAVE          reduce using rule 31 (rule -> array_assignment COLON .)
    INT32           reduce using rule 31 (rule -> array_assignment COLON .)
    INT64           reduce using rule 31 (rule -> array_assignment COLON .)
    FLOAT32         reduce using rule 31 (rule -> array_assignment COLON .)
    FLOAT64         reduce using rule 31 (rule -> array_assignment COLON .)
    BYTE            reduce using rule 31 (rule -> array_assignment COLON .)
    WINT            reduce using rule 31 (rule -> array_assignment COLON .)
    WFLOAT          reduce using rule 31 (rule -> array_assignment COLON .)
    WSTRING         reduce using rule 31 (rule -> array_assignment COLON .)
    BOOL            reduce using rule 31 (rule -> array_assignment COLON .)
    DEFAULT         reduce using rule 31 (rule -> array_assignment COLON .)
    CASE            reduce using rule 31 (rule -> array_assignment COLON .)
    RETURN          reduce using rule 31 (rule -> array_assignment COLON .)


state 72

    (33) rule -> slice_declaration COLON .

    PRINT           reduce using rule 33 (rule -> slice_declaration COLON .)
    SCAN            reduce using rule 33 (rule -> slice_declaration COLON .)
    FOR             reduce using rule 33 (rule -> slice_declaration COLON .)
    CONST           reduce using rule 33 (rule -> slice_declaration COLON .)
    ID              reduce using rule 33 (rule -> slice_declaration COLON .)
    APPEND          reduce using rule 33 (rule -> slice_declaration COLON .)
    LEN             reduce using rule 33 (rule -> slice_declaration COLON .)
    COPY            reduce using rule 33 (rule -> slice_declaration COLON .)
    DELETE          reduce using rule 33 (rule -> slice_declaration COLON .)
    IF              reduce using rule 33 (rule -> slice_declaration COLON .)
    ELSE            reduce using rule 33 (rule -> slice_declaration COLON .)
    TYPE            reduce using rule 33 (rule -> slice_declaration COLON .)
    SWITCH          reduce using rule 33 (rule -> slice_declaration COLON .)
    VAR             reduce using rule 33 (rule -> slice_declaration COLON .)
    FUNC            reduce using rule 33 (rule -> slice_declaration COLON .)
    INTEGER         reduce using rule 33 (rule -> slice_declaration COLON .)
    FLOAT           reduce using rule 33 (rule -> slice_declaration COLON .)
    NOT             reduce using rule 33 (rule -> slice_declaration COLON .)
    $end            reduce using rule 33 (rule -> slice_declaration COLON .)
    RLLAVE          reduce using rule 33 (rule -> slice_declaration COLON .)
    INT32           reduce using rule 33 (rule -> slice_declaration COLON .)
    INT64           reduce using rule 33 (rule -> slice_declaration COLON .)
    FLOAT32         reduce using rule 33 (rule -> slice_declaration COLON .)
    FLOAT64         reduce using rule 33 (rule -> slice_declaration COLON .)
    BYTE            reduce using rule 33 (rule -> slice_declaration COLON .)
    WINT            reduce using rule 33 (rule -> slice_declaration COLON .)
    WFLOAT          reduce using rule 33 (rule -> slice_declaration COLON .)
    WSTRING         reduce using rule 33 (rule -> slice_declaration COLON .)
    BOOL            reduce using rule 33 (rule -> slice_declaration COLON .)
    DEFAULT         reduce using rule 33 (rule -> slice_declaration COLON .)
    CASE            reduce using rule 33 (rule -> slice_declaration COLON .)
    RETURN          reduce using rule 33 (rule -> slice_declaration COLON .)


state 73

    (35) rule -> slice_var COLON .

    PRINT           reduce using rule 35 (rule -> slice_var COLON .)
    SCAN            reduce using rule 35 (rule -> slice_var COLON .)
    FOR             reduce using rule 35 (rule -> slice_var COLON .)
    CONST           reduce using rule 35 (rule -> slice_var COLON .)
    ID              reduce using rule 35 (rule -> slice_var COLON .)
    APPEND          reduce using rule 35 (rule -> slice_var COLON .)
    LEN             reduce using rule 35 (rule -> slice_var COLON .)
    COPY            reduce using rule 35 (rule -> slice_var COLON .)
    DELETE          reduce using rule 35 (rule -> slice_var COLON .)
    IF              reduce using rule 35 (rule -> slice_var COLON .)
    ELSE            reduce using rule 35 (rule -> slice_var COLON .)
    TYPE            reduce using rule 35 (rule -> slice_var COLON .)
    SWITCH          reduce using rule 35 (rule -> slice_var COLON .)
    VAR             reduce using rule 35 (rule -> slice_var COLON .)
    FUNC            reduce using rule 35 (rule -> slice_var COLON .)
    INTEGER         reduce using rule 35 (rule -> slice_var COLON .)
    FLOAT           reduce using rule 35 (rule -> slice_var COLON .)
    NOT             reduce using rule 35 (rule -> slice_var COLON .)
    $end            reduce using rule 35 (rule -> slice_var COLON .)
    RLLAVE          reduce using rule 35 (rule -> slice_var COLON .)
    INT32           reduce using rule 35 (rule -> slice_var COLON .)
    INT64           reduce using rule 35 (rule -> slice_var COLON .)
    FLOAT32         reduce using rule 35 (rule -> slice_var COLON .)
    FLOAT64         reduce using rule 35 (rule -> slice_var COLON .)
    BYTE            reduce using rule 35 (rule -> slice_var COLON .)
    WINT            reduce using rule 35 (rule -> slice_var COLON .)
    WFLOAT          reduce using rule 35 (rule -> slice_var COLON .)
    WSTRING         reduce using rule 35 (rule -> slice_var COLON .)
    BOOL            reduce using rule 35 (rule -> slice_var COLON .)
    DEFAULT         reduce using rule 35 (rule -> slice_var COLON .)
    CASE            reduce using rule 35 (rule -> slice_var COLON .)
    RETURN          reduce using rule 35 (rule -> slice_var COLON .)


state 74

    (145) slice_assignment -> slice_var EQUAL . something_s
    (146) something_s -> . ID
    (147) something_s -> . array_var
    (148) something_s -> . values
    (149) something_s -> . operations
    (206) array_var -> . ID LCORCHE index RCORCHE
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 154
    STRING          shift and go to state 145
    INTEGER         shift and go to state 146
    FLOAT           shift and go to state 147
    TRUE            shift and go to state 148
    FALSE           shift and go to state 149
    NOT             shift and go to state 56
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    something_s                    shift and go to state 153
    array_var                      shift and go to state 155
    values                         shift and go to state 156
    operations                     shift and go to state 157
    expression                     shift and go to state 150
    comparison                     shift and go to state 151
    logic_operation                shift and go to state 152
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 75

    (37) rule -> slice_assignment COLON .

    PRINT           reduce using rule 37 (rule -> slice_assignment COLON .)
    SCAN            reduce using rule 37 (rule -> slice_assignment COLON .)
    FOR             reduce using rule 37 (rule -> slice_assignment COLON .)
    CONST           reduce using rule 37 (rule -> slice_assignment COLON .)
    ID              reduce using rule 37 (rule -> slice_assignment COLON .)
    APPEND          reduce using rule 37 (rule -> slice_assignment COLON .)
    LEN             reduce using rule 37 (rule -> slice_assignment COLON .)
    COPY            reduce using rule 37 (rule -> slice_assignment COLON .)
    DELETE          reduce using rule 37 (rule -> slice_assignment COLON .)
    IF              reduce using rule 37 (rule -> slice_assignment COLON .)
    ELSE            reduce using rule 37 (rule -> slice_assignment COLON .)
    TYPE            reduce using rule 37 (rule -> slice_assignment COLON .)
    SWITCH          reduce using rule 37 (rule -> slice_assignment COLON .)
    VAR             reduce using rule 37 (rule -> slice_assignment COLON .)
    FUNC            reduce using rule 37 (rule -> slice_assignment COLON .)
    INTEGER         reduce using rule 37 (rule -> slice_assignment COLON .)
    FLOAT           reduce using rule 37 (rule -> slice_assignment COLON .)
    NOT             reduce using rule 37 (rule -> slice_assignment COLON .)
    $end            reduce using rule 37 (rule -> slice_assignment COLON .)
    RLLAVE          reduce using rule 37 (rule -> slice_assignment COLON .)
    INT32           reduce using rule 37 (rule -> slice_assignment COLON .)
    INT64           reduce using rule 37 (rule -> slice_assignment COLON .)
    FLOAT32         reduce using rule 37 (rule -> slice_assignment COLON .)
    FLOAT64         reduce using rule 37 (rule -> slice_assignment COLON .)
    BYTE            reduce using rule 37 (rule -> slice_assignment COLON .)
    WINT            reduce using rule 37 (rule -> slice_assignment COLON .)
    WFLOAT          reduce using rule 37 (rule -> slice_assignment COLON .)
    WSTRING         reduce using rule 37 (rule -> slice_assignment COLON .)
    BOOL            reduce using rule 37 (rule -> slice_assignment COLON .)
    DEFAULT         reduce using rule 37 (rule -> slice_assignment COLON .)
    CASE            reduce using rule 37 (rule -> slice_assignment COLON .)
    RETURN          reduce using rule 37 (rule -> slice_assignment COLON .)


state 76

    (39) rule -> map_declaration COLON .

    PRINT           reduce using rule 39 (rule -> map_declaration COLON .)
    SCAN            reduce using rule 39 (rule -> map_declaration COLON .)
    FOR             reduce using rule 39 (rule -> map_declaration COLON .)
    CONST           reduce using rule 39 (rule -> map_declaration COLON .)
    ID              reduce using rule 39 (rule -> map_declaration COLON .)
    APPEND          reduce using rule 39 (rule -> map_declaration COLON .)
    LEN             reduce using rule 39 (rule -> map_declaration COLON .)
    COPY            reduce using rule 39 (rule -> map_declaration COLON .)
    DELETE          reduce using rule 39 (rule -> map_declaration COLON .)
    IF              reduce using rule 39 (rule -> map_declaration COLON .)
    ELSE            reduce using rule 39 (rule -> map_declaration COLON .)
    TYPE            reduce using rule 39 (rule -> map_declaration COLON .)
    SWITCH          reduce using rule 39 (rule -> map_declaration COLON .)
    VAR             reduce using rule 39 (rule -> map_declaration COLON .)
    FUNC            reduce using rule 39 (rule -> map_declaration COLON .)
    INTEGER         reduce using rule 39 (rule -> map_declaration COLON .)
    FLOAT           reduce using rule 39 (rule -> map_declaration COLON .)
    NOT             reduce using rule 39 (rule -> map_declaration COLON .)
    $end            reduce using rule 39 (rule -> map_declaration COLON .)
    RLLAVE          reduce using rule 39 (rule -> map_declaration COLON .)
    INT32           reduce using rule 39 (rule -> map_declaration COLON .)
    INT64           reduce using rule 39 (rule -> map_declaration COLON .)
    FLOAT32         reduce using rule 39 (rule -> map_declaration COLON .)
    FLOAT64         reduce using rule 39 (rule -> map_declaration COLON .)
    BYTE            reduce using rule 39 (rule -> map_declaration COLON .)
    WINT            reduce using rule 39 (rule -> map_declaration COLON .)
    WFLOAT          reduce using rule 39 (rule -> map_declaration COLON .)
    WSTRING         reduce using rule 39 (rule -> map_declaration COLON .)
    BOOL            reduce using rule 39 (rule -> map_declaration COLON .)
    DEFAULT         reduce using rule 39 (rule -> map_declaration COLON .)
    CASE            reduce using rule 39 (rule -> map_declaration COLON .)
    RETURN          reduce using rule 39 (rule -> map_declaration COLON .)


state 77

    (41) rule -> map_assignment COLON .

    PRINT           reduce using rule 41 (rule -> map_assignment COLON .)
    SCAN            reduce using rule 41 (rule -> map_assignment COLON .)
    FOR             reduce using rule 41 (rule -> map_assignment COLON .)
    CONST           reduce using rule 41 (rule -> map_assignment COLON .)
    ID              reduce using rule 41 (rule -> map_assignment COLON .)
    APPEND          reduce using rule 41 (rule -> map_assignment COLON .)
    LEN             reduce using rule 41 (rule -> map_assignment COLON .)
    COPY            reduce using rule 41 (rule -> map_assignment COLON .)
    DELETE          reduce using rule 41 (rule -> map_assignment COLON .)
    IF              reduce using rule 41 (rule -> map_assignment COLON .)
    ELSE            reduce using rule 41 (rule -> map_assignment COLON .)
    TYPE            reduce using rule 41 (rule -> map_assignment COLON .)
    SWITCH          reduce using rule 41 (rule -> map_assignment COLON .)
    VAR             reduce using rule 41 (rule -> map_assignment COLON .)
    FUNC            reduce using rule 41 (rule -> map_assignment COLON .)
    INTEGER         reduce using rule 41 (rule -> map_assignment COLON .)
    FLOAT           reduce using rule 41 (rule -> map_assignment COLON .)
    NOT             reduce using rule 41 (rule -> map_assignment COLON .)
    $end            reduce using rule 41 (rule -> map_assignment COLON .)
    RLLAVE          reduce using rule 41 (rule -> map_assignment COLON .)
    INT32           reduce using rule 41 (rule -> map_assignment COLON .)
    INT64           reduce using rule 41 (rule -> map_assignment COLON .)
    FLOAT32         reduce using rule 41 (rule -> map_assignment COLON .)
    FLOAT64         reduce using rule 41 (rule -> map_assignment COLON .)
    BYTE            reduce using rule 41 (rule -> map_assignment COLON .)
    WINT            reduce using rule 41 (rule -> map_assignment COLON .)
    WFLOAT          reduce using rule 41 (rule -> map_assignment COLON .)
    WSTRING         reduce using rule 41 (rule -> map_assignment COLON .)
    BOOL            reduce using rule 41 (rule -> map_assignment COLON .)
    DEFAULT         reduce using rule 41 (rule -> map_assignment COLON .)
    CASE            reduce using rule 41 (rule -> map_assignment COLON .)
    RETURN          reduce using rule 41 (rule -> map_assignment COLON .)


state 78

    (228) impresion -> PRINT LPAREN . content RPAREN
    (229) content -> . values
    (230) content -> . operations
    (231) content -> . funciones
    (232) content -> . data_structure
    (233) content -> . ID
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID

    ID              shift and go to state 163
    STRING          shift and go to state 145
    INTEGER         shift and go to state 146
    FLOAT           shift and go to state 147
    TRUE            shift and go to state 148
    FALSE           shift and go to state 149
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    NOT             shift and go to state 56

    content                        shift and go to state 158
    values                         shift and go to state 159
    operations                     shift and go to state 160
    funciones                      shift and go to state 161
    data_structure                 shift and go to state 162
    expression                     shift and go to state 150
    comparison                     shift and go to state 151
    logic_operation                shift and go to state 152
    call_func                      shift and go to state 46
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36

state 79

    (81) scan_func -> SCAN LPAREN . POINTER RPAREN

    POINTER         shift and go to state 164


state 80

    (235) expression -> something_ex adicionaEx .

    COLON           reduce using rule 235 (expression -> something_ex adicionaEx .)
    PRINT           reduce using rule 235 (expression -> something_ex adicionaEx .)
    SCAN            reduce using rule 235 (expression -> something_ex adicionaEx .)
    FOR             reduce using rule 235 (expression -> something_ex adicionaEx .)
    CONST           reduce using rule 235 (expression -> something_ex adicionaEx .)
    ID              reduce using rule 235 (expression -> something_ex adicionaEx .)
    APPEND          reduce using rule 235 (expression -> something_ex adicionaEx .)
    LEN             reduce using rule 235 (expression -> something_ex adicionaEx .)
    COPY            reduce using rule 235 (expression -> something_ex adicionaEx .)
    DELETE          reduce using rule 235 (expression -> something_ex adicionaEx .)
    IF              reduce using rule 235 (expression -> something_ex adicionaEx .)
    ELSE            reduce using rule 235 (expression -> something_ex adicionaEx .)
    TYPE            reduce using rule 235 (expression -> something_ex adicionaEx .)
    SWITCH          reduce using rule 235 (expression -> something_ex adicionaEx .)
    VAR             reduce using rule 235 (expression -> something_ex adicionaEx .)
    FUNC            reduce using rule 235 (expression -> something_ex adicionaEx .)
    INTEGER         reduce using rule 235 (expression -> something_ex adicionaEx .)
    FLOAT           reduce using rule 235 (expression -> something_ex adicionaEx .)
    NOT             reduce using rule 235 (expression -> something_ex adicionaEx .)
    $end            reduce using rule 235 (expression -> something_ex adicionaEx .)
    GREATER         reduce using rule 235 (expression -> something_ex adicionaEx .)
    SMALLER         reduce using rule 235 (expression -> something_ex adicionaEx .)
    GREATER_OR_EQUAL reduce using rule 235 (expression -> something_ex adicionaEx .)
    SMALLER_OR_EQUAL reduce using rule 235 (expression -> something_ex adicionaEx .)
    EQUAL_COMPARE   reduce using rule 235 (expression -> something_ex adicionaEx .)
    NOT_EQUAL       reduce using rule 235 (expression -> something_ex adicionaEx .)
    PLUS            reduce using rule 235 (expression -> something_ex adicionaEx .)
    TIMES           reduce using rule 235 (expression -> something_ex adicionaEx .)
    DIVIDE          reduce using rule 235 (expression -> something_ex adicionaEx .)
    MINUS           reduce using rule 235 (expression -> something_ex adicionaEx .)
    MOD             reduce using rule 235 (expression -> something_ex adicionaEx .)
    RLLAVE          reduce using rule 235 (expression -> something_ex adicionaEx .)
    INT32           reduce using rule 235 (expression -> something_ex adicionaEx .)
    INT64           reduce using rule 235 (expression -> something_ex adicionaEx .)
    FLOAT32         reduce using rule 235 (expression -> something_ex adicionaEx .)
    FLOAT64         reduce using rule 235 (expression -> something_ex adicionaEx .)
    BYTE            reduce using rule 235 (expression -> something_ex adicionaEx .)
    WINT            reduce using rule 235 (expression -> something_ex adicionaEx .)
    WFLOAT          reduce using rule 235 (expression -> something_ex adicionaEx .)
    WSTRING         reduce using rule 235 (expression -> something_ex adicionaEx .)
    BOOL            reduce using rule 235 (expression -> something_ex adicionaEx .)
    DEFAULT         reduce using rule 235 (expression -> something_ex adicionaEx .)
    CASE            reduce using rule 235 (expression -> something_ex adicionaEx .)
    RETURN          reduce using rule 235 (expression -> something_ex adicionaEx .)
    RPAREN          reduce using rule 235 (expression -> something_ex adicionaEx .)
    AND             reduce using rule 235 (expression -> something_ex adicionaEx .)
    OR              reduce using rule 235 (expression -> something_ex adicionaEx .)
    LLLAVE          reduce using rule 235 (expression -> something_ex adicionaEx .)
    RCORCHE         reduce using rule 235 (expression -> something_ex adicionaEx .)
    COMA            reduce using rule 235 (expression -> something_ex adicionaEx .)


state 81

    (236) adicionaEx -> op . something_ex
    (237) adicionaEx -> op . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 166
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    something_ex                   shift and go to state 165
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 82

    (179) op -> GREATER .

    ID              reduce using rule 179 (op -> GREATER .)
    INTEGER         reduce using rule 179 (op -> GREATER .)
    FLOAT           reduce using rule 179 (op -> GREATER .)
    APPEND          reduce using rule 179 (op -> GREATER .)
    LEN             reduce using rule 179 (op -> GREATER .)
    COPY            reduce using rule 179 (op -> GREATER .)
    DELETE          reduce using rule 179 (op -> GREATER .)


state 83

    (180) op -> SMALLER .

    ID              reduce using rule 180 (op -> SMALLER .)
    INTEGER         reduce using rule 180 (op -> SMALLER .)
    FLOAT           reduce using rule 180 (op -> SMALLER .)
    APPEND          reduce using rule 180 (op -> SMALLER .)
    LEN             reduce using rule 180 (op -> SMALLER .)
    COPY            reduce using rule 180 (op -> SMALLER .)
    DELETE          reduce using rule 180 (op -> SMALLER .)


state 84

    (181) op -> GREATER_OR_EQUAL .

    ID              reduce using rule 181 (op -> GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 181 (op -> GREATER_OR_EQUAL .)
    FLOAT           reduce using rule 181 (op -> GREATER_OR_EQUAL .)
    APPEND          reduce using rule 181 (op -> GREATER_OR_EQUAL .)
    LEN             reduce using rule 181 (op -> GREATER_OR_EQUAL .)
    COPY            reduce using rule 181 (op -> GREATER_OR_EQUAL .)
    DELETE          reduce using rule 181 (op -> GREATER_OR_EQUAL .)


state 85

    (182) op -> SMALLER_OR_EQUAL .

    ID              reduce using rule 182 (op -> SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 182 (op -> SMALLER_OR_EQUAL .)
    FLOAT           reduce using rule 182 (op -> SMALLER_OR_EQUAL .)
    APPEND          reduce using rule 182 (op -> SMALLER_OR_EQUAL .)
    LEN             reduce using rule 182 (op -> SMALLER_OR_EQUAL .)
    COPY            reduce using rule 182 (op -> SMALLER_OR_EQUAL .)
    DELETE          reduce using rule 182 (op -> SMALLER_OR_EQUAL .)


state 86

    (183) op -> EQUAL_COMPARE .

    ID              reduce using rule 183 (op -> EQUAL_COMPARE .)
    INTEGER         reduce using rule 183 (op -> EQUAL_COMPARE .)
    FLOAT           reduce using rule 183 (op -> EQUAL_COMPARE .)
    APPEND          reduce using rule 183 (op -> EQUAL_COMPARE .)
    LEN             reduce using rule 183 (op -> EQUAL_COMPARE .)
    COPY            reduce using rule 183 (op -> EQUAL_COMPARE .)
    DELETE          reduce using rule 183 (op -> EQUAL_COMPARE .)


state 87

    (184) op -> NOT_EQUAL .

    ID              reduce using rule 184 (op -> NOT_EQUAL .)
    INTEGER         reduce using rule 184 (op -> NOT_EQUAL .)
    FLOAT           reduce using rule 184 (op -> NOT_EQUAL .)
    APPEND          reduce using rule 184 (op -> NOT_EQUAL .)
    LEN             reduce using rule 184 (op -> NOT_EQUAL .)
    COPY            reduce using rule 184 (op -> NOT_EQUAL .)
    DELETE          reduce using rule 184 (op -> NOT_EQUAL .)


state 88

    (243) op -> PLUS .

    ID              reduce using rule 243 (op -> PLUS .)
    INTEGER         reduce using rule 243 (op -> PLUS .)
    FLOAT           reduce using rule 243 (op -> PLUS .)
    APPEND          reduce using rule 243 (op -> PLUS .)
    LEN             reduce using rule 243 (op -> PLUS .)
    COPY            reduce using rule 243 (op -> PLUS .)
    DELETE          reduce using rule 243 (op -> PLUS .)


state 89

    (244) op -> TIMES .

    ID              reduce using rule 244 (op -> TIMES .)
    INTEGER         reduce using rule 244 (op -> TIMES .)
    FLOAT           reduce using rule 244 (op -> TIMES .)
    APPEND          reduce using rule 244 (op -> TIMES .)
    LEN             reduce using rule 244 (op -> TIMES .)
    COPY            reduce using rule 244 (op -> TIMES .)
    DELETE          reduce using rule 244 (op -> TIMES .)


state 90

    (245) op -> DIVIDE .

    ID              reduce using rule 245 (op -> DIVIDE .)
    INTEGER         reduce using rule 245 (op -> DIVIDE .)
    FLOAT           reduce using rule 245 (op -> DIVIDE .)
    APPEND          reduce using rule 245 (op -> DIVIDE .)
    LEN             reduce using rule 245 (op -> DIVIDE .)
    COPY            reduce using rule 245 (op -> DIVIDE .)
    DELETE          reduce using rule 245 (op -> DIVIDE .)


state 91

    (246) op -> MINUS .

    ID              reduce using rule 246 (op -> MINUS .)
    INTEGER         reduce using rule 246 (op -> MINUS .)
    FLOAT           reduce using rule 246 (op -> MINUS .)
    APPEND          reduce using rule 246 (op -> MINUS .)
    LEN             reduce using rule 246 (op -> MINUS .)
    COPY            reduce using rule 246 (op -> MINUS .)
    DELETE          reduce using rule 246 (op -> MINUS .)


state 92

    (247) op -> MOD .

    ID              reduce using rule 247 (op -> MOD .)
    INTEGER         reduce using rule 247 (op -> MOD .)
    FLOAT           reduce using rule 247 (op -> MOD .)
    APPEND          reduce using rule 247 (op -> MOD .)
    LEN             reduce using rule 247 (op -> MOD .)
    COPY            reduce using rule 247 (op -> MOD .)
    DELETE          reduce using rule 247 (op -> MOD .)


state 93

    (87) cicloFor -> FOR LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 167
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 94

    (88) cicloFor -> FOR comparison . LLLAVE codigo RLLAVE
    (190) logic_value -> comparison .

    LLLAVE          shift and go to state 168
    AND             reduce using rule 190 (logic_value -> comparison .)
    OR              reduce using rule 190 (logic_value -> comparison .)


state 95

    (89) cicloFor -> FOR logic_operation . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 169


state 96

    (90) cicloFor -> FOR decVarOne . COLON comparison COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 170


state 97

    (156) decVarOne -> ID . DEQUAL ID
    (157) decVarOne -> ID . DEQUAL INTEGER
    (177) value -> ID .
    (191) logic_value -> ID .
    (238) something_ex -> ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 177 (value -> ID .)
    DEQUAL          shift and go to state 171
    GREATER         reduce using rule 177 (value -> ID .)
    SMALLER         reduce using rule 177 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 177 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 177 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 177 (value -> ID .)
    NOT_EQUAL       reduce using rule 177 (value -> ID .)
    PLUS            reduce using rule 177 (value -> ID .)
    TIMES           reduce using rule 177 (value -> ID .)
    DIVIDE          reduce using rule 177 (value -> ID .)
    MINUS           reduce using rule 177 (value -> ID .)
    MOD             reduce using rule 177 (value -> ID .)
    AND             reduce using rule 191 (logic_value -> ID .)
    OR              reduce using rule 191 (logic_value -> ID .)
    LCORCHE         shift and go to state 172
    LPAREN          shift and go to state 111

  ! GREATER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 238 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 238 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 238 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 238 (something_ex -> ID .) ]


state 98

    (178) value -> expression .

    GREATER         reduce using rule 178 (value -> expression .)
    SMALLER         reduce using rule 178 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 178 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 178 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 178 (value -> expression .)
    NOT_EQUAL       reduce using rule 178 (value -> expression .)
    PLUS            reduce using rule 178 (value -> expression .)
    TIMES           reduce using rule 178 (value -> expression .)
    DIVIDE          reduce using rule 178 (value -> expression .)
    MINUS           reduce using rule 178 (value -> expression .)
    MOD             reduce using rule 178 (value -> expression .)
    PRINT           reduce using rule 178 (value -> expression .)
    SCAN            reduce using rule 178 (value -> expression .)
    FOR             reduce using rule 178 (value -> expression .)
    CONST           reduce using rule 178 (value -> expression .)
    ID              reduce using rule 178 (value -> expression .)
    APPEND          reduce using rule 178 (value -> expression .)
    LEN             reduce using rule 178 (value -> expression .)
    COPY            reduce using rule 178 (value -> expression .)
    DELETE          reduce using rule 178 (value -> expression .)
    IF              reduce using rule 178 (value -> expression .)
    ELSE            reduce using rule 178 (value -> expression .)
    TYPE            reduce using rule 178 (value -> expression .)
    SWITCH          reduce using rule 178 (value -> expression .)
    VAR             reduce using rule 178 (value -> expression .)
    FUNC            reduce using rule 178 (value -> expression .)
    INTEGER         reduce using rule 178 (value -> expression .)
    FLOAT           reduce using rule 178 (value -> expression .)
    NOT             reduce using rule 178 (value -> expression .)
    $end            reduce using rule 178 (value -> expression .)
    AND             reduce using rule 178 (value -> expression .)
    OR              reduce using rule 178 (value -> expression .)
    RLLAVE          reduce using rule 178 (value -> expression .)
    INT32           reduce using rule 178 (value -> expression .)
    INT64           reduce using rule 178 (value -> expression .)
    FLOAT32         reduce using rule 178 (value -> expression .)
    FLOAT64         reduce using rule 178 (value -> expression .)
    BYTE            reduce using rule 178 (value -> expression .)
    WINT            reduce using rule 178 (value -> expression .)
    WFLOAT          reduce using rule 178 (value -> expression .)
    WSTRING         reduce using rule 178 (value -> expression .)
    BOOL            reduce using rule 178 (value -> expression .)
    DEFAULT         reduce using rule 178 (value -> expression .)
    CASE            reduce using rule 178 (value -> expression .)
    RETURN          reduce using rule 178 (value -> expression .)
    LLLAVE          reduce using rule 178 (value -> expression .)
    COLON           reduce using rule 178 (value -> expression .)
    RPAREN          reduce using rule 178 (value -> expression .)
    RCORCHE         reduce using rule 178 (value -> expression .)
    COMA            reduce using rule 178 (value -> expression .)


state 99

    (242) something_ex -> funciones .

    GREATER         reduce using rule 242 (something_ex -> funciones .)
    SMALLER         reduce using rule 242 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 242 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 242 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 242 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 242 (something_ex -> funciones .)
    PLUS            reduce using rule 242 (something_ex -> funciones .)
    TIMES           reduce using rule 242 (something_ex -> funciones .)
    DIVIDE          reduce using rule 242 (something_ex -> funciones .)
    MINUS           reduce using rule 242 (something_ex -> funciones .)
    MOD             reduce using rule 242 (something_ex -> funciones .)
    COLON           reduce using rule 242 (something_ex -> funciones .)
    PRINT           reduce using rule 242 (something_ex -> funciones .)
    SCAN            reduce using rule 242 (something_ex -> funciones .)
    FOR             reduce using rule 242 (something_ex -> funciones .)
    CONST           reduce using rule 242 (something_ex -> funciones .)
    ID              reduce using rule 242 (something_ex -> funciones .)
    APPEND          reduce using rule 242 (something_ex -> funciones .)
    LEN             reduce using rule 242 (something_ex -> funciones .)
    COPY            reduce using rule 242 (something_ex -> funciones .)
    DELETE          reduce using rule 242 (something_ex -> funciones .)
    IF              reduce using rule 242 (something_ex -> funciones .)
    ELSE            reduce using rule 242 (something_ex -> funciones .)
    TYPE            reduce using rule 242 (something_ex -> funciones .)
    SWITCH          reduce using rule 242 (something_ex -> funciones .)
    VAR             reduce using rule 242 (something_ex -> funciones .)
    FUNC            reduce using rule 242 (something_ex -> funciones .)
    INTEGER         reduce using rule 242 (something_ex -> funciones .)
    FLOAT           reduce using rule 242 (something_ex -> funciones .)
    NOT             reduce using rule 242 (something_ex -> funciones .)
    $end            reduce using rule 242 (something_ex -> funciones .)
    RLLAVE          reduce using rule 242 (something_ex -> funciones .)
    INT32           reduce using rule 242 (something_ex -> funciones .)
    INT64           reduce using rule 242 (something_ex -> funciones .)
    FLOAT32         reduce using rule 242 (something_ex -> funciones .)
    FLOAT64         reduce using rule 242 (something_ex -> funciones .)
    BYTE            reduce using rule 242 (something_ex -> funciones .)
    WINT            reduce using rule 242 (something_ex -> funciones .)
    WFLOAT          reduce using rule 242 (something_ex -> funciones .)
    WSTRING         reduce using rule 242 (something_ex -> funciones .)
    BOOL            reduce using rule 242 (something_ex -> funciones .)
    DEFAULT         reduce using rule 242 (something_ex -> funciones .)
    CASE            reduce using rule 242 (something_ex -> funciones .)
    RETURN          reduce using rule 242 (something_ex -> funciones .)
    RPAREN          reduce using rule 242 (something_ex -> funciones .)
    AND             reduce using rule 242 (something_ex -> funciones .)
    OR              reduce using rule 242 (something_ex -> funciones .)
    LLLAVE          reduce using rule 242 (something_ex -> funciones .)
    RCORCHE         reduce using rule 242 (something_ex -> funciones .)
    COMA            reduce using rule 242 (something_ex -> funciones .)


state 100

    (62) data_structure -> array_var .

    GREATER         reduce using rule 62 (data_structure -> array_var .)
    SMALLER         reduce using rule 62 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 62 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 62 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 62 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 62 (data_structure -> array_var .)
    PLUS            reduce using rule 62 (data_structure -> array_var .)
    TIMES           reduce using rule 62 (data_structure -> array_var .)
    DIVIDE          reduce using rule 62 (data_structure -> array_var .)
    MINUS           reduce using rule 62 (data_structure -> array_var .)
    MOD             reduce using rule 62 (data_structure -> array_var .)
    COLON           reduce using rule 62 (data_structure -> array_var .)
    PRINT           reduce using rule 62 (data_structure -> array_var .)
    SCAN            reduce using rule 62 (data_structure -> array_var .)
    FOR             reduce using rule 62 (data_structure -> array_var .)
    CONST           reduce using rule 62 (data_structure -> array_var .)
    ID              reduce using rule 62 (data_structure -> array_var .)
    APPEND          reduce using rule 62 (data_structure -> array_var .)
    LEN             reduce using rule 62 (data_structure -> array_var .)
    COPY            reduce using rule 62 (data_structure -> array_var .)
    DELETE          reduce using rule 62 (data_structure -> array_var .)
    IF              reduce using rule 62 (data_structure -> array_var .)
    ELSE            reduce using rule 62 (data_structure -> array_var .)
    TYPE            reduce using rule 62 (data_structure -> array_var .)
    SWITCH          reduce using rule 62 (data_structure -> array_var .)
    VAR             reduce using rule 62 (data_structure -> array_var .)
    FUNC            reduce using rule 62 (data_structure -> array_var .)
    INTEGER         reduce using rule 62 (data_structure -> array_var .)
    FLOAT           reduce using rule 62 (data_structure -> array_var .)
    NOT             reduce using rule 62 (data_structure -> array_var .)
    $end            reduce using rule 62 (data_structure -> array_var .)
    RLLAVE          reduce using rule 62 (data_structure -> array_var .)
    INT32           reduce using rule 62 (data_structure -> array_var .)
    INT64           reduce using rule 62 (data_structure -> array_var .)
    FLOAT32         reduce using rule 62 (data_structure -> array_var .)
    FLOAT64         reduce using rule 62 (data_structure -> array_var .)
    BYTE            reduce using rule 62 (data_structure -> array_var .)
    WINT            reduce using rule 62 (data_structure -> array_var .)
    WFLOAT          reduce using rule 62 (data_structure -> array_var .)
    WSTRING         reduce using rule 62 (data_structure -> array_var .)
    BOOL            reduce using rule 62 (data_structure -> array_var .)
    DEFAULT         reduce using rule 62 (data_structure -> array_var .)
    CASE            reduce using rule 62 (data_structure -> array_var .)
    RETURN          reduce using rule 62 (data_structure -> array_var .)
    RPAREN          reduce using rule 62 (data_structure -> array_var .)
    AND             reduce using rule 62 (data_structure -> array_var .)
    OR              reduce using rule 62 (data_structure -> array_var .)
    LLLAVE          reduce using rule 62 (data_structure -> array_var .)
    RCORCHE         reduce using rule 62 (data_structure -> array_var .)
    COMA            reduce using rule 62 (data_structure -> array_var .)


state 101

    (63) data_structure -> map_var .

    GREATER         reduce using rule 63 (data_structure -> map_var .)
    SMALLER         reduce using rule 63 (data_structure -> map_var .)
    GREATER_OR_EQUAL reduce using rule 63 (data_structure -> map_var .)
    SMALLER_OR_EQUAL reduce using rule 63 (data_structure -> map_var .)
    EQUAL_COMPARE   reduce using rule 63 (data_structure -> map_var .)
    NOT_EQUAL       reduce using rule 63 (data_structure -> map_var .)
    PLUS            reduce using rule 63 (data_structure -> map_var .)
    TIMES           reduce using rule 63 (data_structure -> map_var .)
    DIVIDE          reduce using rule 63 (data_structure -> map_var .)
    MINUS           reduce using rule 63 (data_structure -> map_var .)
    MOD             reduce using rule 63 (data_structure -> map_var .)
    COLON           reduce using rule 63 (data_structure -> map_var .)
    PRINT           reduce using rule 63 (data_structure -> map_var .)
    SCAN            reduce using rule 63 (data_structure -> map_var .)
    FOR             reduce using rule 63 (data_structure -> map_var .)
    CONST           reduce using rule 63 (data_structure -> map_var .)
    ID              reduce using rule 63 (data_structure -> map_var .)
    APPEND          reduce using rule 63 (data_structure -> map_var .)
    LEN             reduce using rule 63 (data_structure -> map_var .)
    COPY            reduce using rule 63 (data_structure -> map_var .)
    DELETE          reduce using rule 63 (data_structure -> map_var .)
    IF              reduce using rule 63 (data_structure -> map_var .)
    ELSE            reduce using rule 63 (data_structure -> map_var .)
    TYPE            reduce using rule 63 (data_structure -> map_var .)
    SWITCH          reduce using rule 63 (data_structure -> map_var .)
    VAR             reduce using rule 63 (data_structure -> map_var .)
    FUNC            reduce using rule 63 (data_structure -> map_var .)
    INTEGER         reduce using rule 63 (data_structure -> map_var .)
    FLOAT           reduce using rule 63 (data_structure -> map_var .)
    NOT             reduce using rule 63 (data_structure -> map_var .)
    $end            reduce using rule 63 (data_structure -> map_var .)
    RLLAVE          reduce using rule 63 (data_structure -> map_var .)
    INT32           reduce using rule 63 (data_structure -> map_var .)
    INT64           reduce using rule 63 (data_structure -> map_var .)
    FLOAT32         reduce using rule 63 (data_structure -> map_var .)
    FLOAT64         reduce using rule 63 (data_structure -> map_var .)
    BYTE            reduce using rule 63 (data_structure -> map_var .)
    WINT            reduce using rule 63 (data_structure -> map_var .)
    WFLOAT          reduce using rule 63 (data_structure -> map_var .)
    WSTRING         reduce using rule 63 (data_structure -> map_var .)
    BOOL            reduce using rule 63 (data_structure -> map_var .)
    DEFAULT         reduce using rule 63 (data_structure -> map_var .)
    CASE            reduce using rule 63 (data_structure -> map_var .)
    RETURN          reduce using rule 63 (data_structure -> map_var .)
    RPAREN          reduce using rule 63 (data_structure -> map_var .)
    AND             reduce using rule 63 (data_structure -> map_var .)
    OR              reduce using rule 63 (data_structure -> map_var .)
    LLLAVE          reduce using rule 63 (data_structure -> map_var .)
    RCORCHE         reduce using rule 63 (data_structure -> map_var .)
    COMA            reduce using rule 63 (data_structure -> map_var .)


state 102

    (176) comparison -> value op . value
    (177) value -> . ID
    (178) value -> . expression
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 119
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    value                          shift and go to state 173
    expression                     shift and go to state 98
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 103

    (185) logic_operation -> logic_value logic_recu .

    PRINT           reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    SCAN            reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    FOR             reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    CONST           reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    ID              reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    APPEND          reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    LEN             reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    COPY            reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    DELETE          reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    IF              reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    ELSE            reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    TYPE            reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    SWITCH          reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    VAR             reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    FUNC            reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    INTEGER         reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    FLOAT           reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    NOT             reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    $end            reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    RLLAVE          reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    INT32           reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    INT64           reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    FLOAT32         reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    FLOAT64         reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    BYTE            reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    WINT            reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    WFLOAT          reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    WSTRING         reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    BOOL            reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    DEFAULT         reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    CASE            reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    RETURN          reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    LLLAVE          reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    COLON           reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    RPAREN          reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    RCORCHE         reduce using rule 185 (logic_operation -> logic_value logic_recu .)
    COMA            reduce using rule 185 (logic_operation -> logic_value logic_recu .)


state 104

    (187) logic_recu -> logic_op . logic_value
    (188) logic_recu -> logic_op . logic_value logic_recu
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (176) comparison -> . value op value
    (177) value -> . ID
    (178) value -> . expression
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 177
    NOT             shift and go to state 56
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    logic_value                    shift and go to state 174
    negation                       shift and go to state 175
    comparison                     shift and go to state 176
    value                          shift and go to state 34
    expression                     shift and go to state 98
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 105

    (194) logic_op -> AND .

    ID              reduce using rule 194 (logic_op -> AND .)
    NOT             reduce using rule 194 (logic_op -> AND .)
    INTEGER         reduce using rule 194 (logic_op -> AND .)
    FLOAT           reduce using rule 194 (logic_op -> AND .)
    APPEND          reduce using rule 194 (logic_op -> AND .)
    LEN             reduce using rule 194 (logic_op -> AND .)
    COPY            reduce using rule 194 (logic_op -> AND .)
    DELETE          reduce using rule 194 (logic_op -> AND .)


state 106

    (195) logic_op -> OR .

    ID              reduce using rule 195 (logic_op -> OR .)
    NOT             reduce using rule 195 (logic_op -> OR .)
    INTEGER         reduce using rule 195 (logic_op -> OR .)
    FLOAT           reduce using rule 195 (logic_op -> OR .)
    APPEND          reduce using rule 195 (logic_op -> OR .)
    LEN             reduce using rule 195 (logic_op -> OR .)
    COPY            reduce using rule 195 (logic_op -> OR .)
    DELETE          reduce using rule 195 (logic_op -> OR .)


state 107

    (109) decConst -> CONST ID . data_type_and_value
    (110) decConst -> CONST ID . EQUAL ID
    (111) decConst -> CONST ID . EQUAL data_structure
    (93) data_type_and_value -> . WSTRING EQUAL STRING
    (94) data_type_and_value -> . WINT EQUAL int_value
    (95) data_type_and_value -> . INT32 EQUAL int_value
    (96) data_type_and_value -> . INT64 EQUAL int_value
    (97) data_type_and_value -> . WFLOAT EQUAL float_value
    (98) data_type_and_value -> . FLOAT32 EQUAL float_value
    (99) data_type_and_value -> . FLOAT64 EQUAL float_value
    (100) data_type_and_value -> . BOOL EQUAL bool_value

    EQUAL           shift and go to state 179
    WSTRING         shift and go to state 180
    WINT            shift and go to state 181
    INT32           shift and go to state 182
    INT64           shift and go to state 183
    WFLOAT          shift and go to state 184
    FLOAT32         shift and go to state 185
    FLOAT64         shift and go to state 186
    BOOL            shift and go to state 187

    data_type_and_value            shift and go to state 178

state 108

    (64) var_asignation -> ID EQUAL . any
    (65) any -> . values
    (66) any -> . operations
    (67) any -> . ID
    (68) any -> . data_structure
    (69) any -> . funciones
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID

    ID              shift and go to state 188
    STRING          shift and go to state 145
    INTEGER         shift and go to state 146
    FLOAT           shift and go to state 147
    TRUE            shift and go to state 148
    FALSE           shift and go to state 149
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    NOT             shift and go to state 56

    any                            shift and go to state 189
    values                         shift and go to state 190
    operations                     shift and go to state 191
    data_structure                 shift and go to state 192
    funciones                      shift and go to state 193
    expression                     shift and go to state 150
    comparison                     shift and go to state 151
    logic_operation                shift and go to state 152
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36

state 109

    (169) cStruct -> ID DEQUAL . ID LLLAVE asignaciones RLLAVE
    (134) slice_declaration -> ID DEQUAL . funM
    (135) slice_declaration -> ID DEQUAL . LCORCHE RCORCHE data_types arr_content
    (125) dynamic -> ID DEQUAL . algo
    (136) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (137) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
    (126) algo -> . values
    (127) algo -> . operations
    (128) algo -> . ID
    (129) algo -> . data_structure
    (130) algo -> . funciones
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID

    ID              shift and go to state 194
    LCORCHE         shift and go to state 196
    MAKE            shift and go to state 198
    STRING          shift and go to state 145
    INTEGER         shift and go to state 146
    FLOAT           shift and go to state 147
    TRUE            shift and go to state 148
    FALSE           shift and go to state 149
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    NOT             shift and go to state 56

    funM                           shift and go to state 195
    algo                           shift and go to state 197
    values                         shift and go to state 199
    operations                     shift and go to state 200
    data_structure                 shift and go to state 201
    funciones                      shift and go to state 202
    expression                     shift and go to state 150
    comparison                     shift and go to state 151
    logic_operation                shift and go to state 152
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36

state 110

    (206) array_var -> ID LCORCHE . index RCORCHE
    (141) slice_var -> ID LCORCHE . index_s RCORCHE
    (212) map_var -> ID LCORCHE . key RCORCHE
    (207) index -> . ID
    (208) index -> . INTEGER
    (209) index -> . expression
    (142) index_s -> . ID
    (143) index_s -> . INTEGER
    (144) index_s -> . expression
    (213) key -> . ID
    (214) key -> . values
    (215) key -> . operations
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 203
    INTEGER         shift and go to state 207
    STRING          shift and go to state 145
    FLOAT           shift and go to state 147
    TRUE            shift and go to state 148
    FALSE           shift and go to state 149
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    NOT             shift and go to state 56

    index                          shift and go to state 204
    index_s                        shift and go to state 205
    key                            shift and go to state 206
    expression                     shift and go to state 208
    values                         shift and go to state 209
    operations                     shift and go to state 210
    something_ex                   shift and go to state 32
    comparison                     shift and go to state 151
    logic_operation                shift and go to state 152
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 111

    (82) call_func -> ID LPAREN . list_params RPAREN
    (83) call_func -> ID LPAREN . RPAREN
    (84) list_params -> . ID
    (85) list_params -> . ID COMA more_p

    RPAREN          shift and go to state 213
    ID              shift and go to state 211

    list_params                    shift and go to state 212

state 112

    (150) funciones -> APPEND LPAREN . ID COMA values RPAREN
    (151) funciones -> APPEND LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 214


state 113

    (152) funciones -> LEN LPAREN . ID RPAREN

    ID              shift and go to state 215


state 114

    (153) funciones -> COPY LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 216


state 115

    (154) funciones -> DELETE LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 217


state 116

    (158) SenIF -> IF comparison . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 218


state 117

    (159) SenIF -> IF TRUE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 219


state 118

    (160) SenIF -> IF FALSE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 220


state 119

    (177) value -> ID .
    (238) something_ex -> ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for CONST resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for INT32 resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for INT64 resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for BYTE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for WINT resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for WSTRING resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for LLLAVE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 177 (value -> ID .)
    GREATER         reduce using rule 177 (value -> ID .)
    SMALLER         reduce using rule 177 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 177 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 177 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 177 (value -> ID .)
    NOT_EQUAL       reduce using rule 177 (value -> ID .)
    PLUS            reduce using rule 177 (value -> ID .)
    TIMES           reduce using rule 177 (value -> ID .)
    DIVIDE          reduce using rule 177 (value -> ID .)
    MINUS           reduce using rule 177 (value -> ID .)
    MOD             reduce using rule 177 (value -> ID .)
    PRINT           reduce using rule 177 (value -> ID .)
    SCAN            reduce using rule 177 (value -> ID .)
    FOR             reduce using rule 177 (value -> ID .)
    CONST           reduce using rule 177 (value -> ID .)
    ID              reduce using rule 177 (value -> ID .)
    APPEND          reduce using rule 177 (value -> ID .)
    LEN             reduce using rule 177 (value -> ID .)
    COPY            reduce using rule 177 (value -> ID .)
    DELETE          reduce using rule 177 (value -> ID .)
    IF              reduce using rule 177 (value -> ID .)
    ELSE            reduce using rule 177 (value -> ID .)
    TYPE            reduce using rule 177 (value -> ID .)
    SWITCH          reduce using rule 177 (value -> ID .)
    VAR             reduce using rule 177 (value -> ID .)
    FUNC            reduce using rule 177 (value -> ID .)
    INTEGER         reduce using rule 177 (value -> ID .)
    FLOAT           reduce using rule 177 (value -> ID .)
    NOT             reduce using rule 177 (value -> ID .)
    $end            reduce using rule 177 (value -> ID .)
    AND             reduce using rule 177 (value -> ID .)
    OR              reduce using rule 177 (value -> ID .)
    RLLAVE          reduce using rule 177 (value -> ID .)
    INT32           reduce using rule 177 (value -> ID .)
    INT64           reduce using rule 177 (value -> ID .)
    FLOAT32         reduce using rule 177 (value -> ID .)
    FLOAT64         reduce using rule 177 (value -> ID .)
    BYTE            reduce using rule 177 (value -> ID .)
    WINT            reduce using rule 177 (value -> ID .)
    WFLOAT          reduce using rule 177 (value -> ID .)
    WSTRING         reduce using rule 177 (value -> ID .)
    BOOL            reduce using rule 177 (value -> ID .)
    DEFAULT         reduce using rule 177 (value -> ID .)
    CASE            reduce using rule 177 (value -> ID .)
    RETURN          reduce using rule 177 (value -> ID .)
    LLLAVE          reduce using rule 177 (value -> ID .)
    COLON           reduce using rule 177 (value -> ID .)
    RPAREN          reduce using rule 177 (value -> ID .)
    RCORCHE         reduce using rule 177 (value -> ID .)
    COMA            reduce using rule 177 (value -> ID .)
    LCORCHE         shift and go to state 172
    LPAREN          shift and go to state 111

  ! GREATER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 238 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 238 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 238 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 238 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 238 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 238 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 238 (something_ex -> ID .) ]
  ! CONST           [ reduce using rule 238 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 238 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 238 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 238 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 238 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 238 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 238 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 238 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 238 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 238 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 238 (something_ex -> ID .) ]
  ! AND             [ reduce using rule 238 (something_ex -> ID .) ]
  ! OR              [ reduce using rule 238 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! INT32           [ reduce using rule 238 (something_ex -> ID .) ]
  ! INT64           [ reduce using rule 238 (something_ex -> ID .) ]
  ! FLOAT32         [ reduce using rule 238 (something_ex -> ID .) ]
  ! FLOAT64         [ reduce using rule 238 (something_ex -> ID .) ]
  ! BYTE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! WINT            [ reduce using rule 238 (something_ex -> ID .) ]
  ! WFLOAT          [ reduce using rule 238 (something_ex -> ID .) ]
  ! WSTRING         [ reduce using rule 238 (something_ex -> ID .) ]
  ! BOOL            [ reduce using rule 238 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 238 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 238 (something_ex -> ID .) ]
  ! LLLAVE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 238 (something_ex -> ID .) ]
  ! RPAREN          [ reduce using rule 238 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 238 (something_ex -> ID .) ]
  ! COMA            [ reduce using rule 238 (something_ex -> ID .) ]


state 120

    (161) SenElseIF -> ELSE IF . comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> ELSE IF . TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> ELSE IF . FALSE LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (177) value -> . ID
    (178) value -> . expression
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    TRUE            shift and go to state 222
    FALSE           shift and go to state 223
    ID              shift and go to state 119
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    comparison                     shift and go to state 221
    value                          shift and go to state 34
    expression                     shift and go to state 98
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 121

    (164) SenElse -> ELSE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 224
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 122

    (165) SenStruct -> TYPE ID . STRUCT LLLAVE declaration RLLAVE

    STRUCT          shift and go to state 225


state 123

    (196) switch_statement -> SWITCH ID . LLLAVE cases RLLAVE

    LLLAVE          shift and go to state 226


state 124

    (201) array_declaration -> VAR ID . LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> VAR ID . EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (131) slice_declaration -> VAR ID . LCORCHE RCORCHE data_types
    (132) slice_declaration -> VAR ID . EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> VAR ID . EQUAL funM
    (211) map_declaration -> VAR ID . LCORCHE data_types RCORCHE data_types
    (120) single -> VAR ID . data_types
    (121) single -> VAR ID . data_types EQUAL funciones
    (122) single -> VAR ID . data_types EQUAL ID
    (123) single -> VAR ID . data_types EQUAL data_structure
    (124) single -> VAR ID . data_type_and_value
    (117) list_var -> VAR ID . COMA more
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WINT
    (56) data_types -> . WFLOAT
    (57) data_types -> . WSTRING
    (58) data_types -> . BOOL
    (93) data_type_and_value -> . WSTRING EQUAL STRING
    (94) data_type_and_value -> . WINT EQUAL int_value
    (95) data_type_and_value -> . INT32 EQUAL int_value
    (96) data_type_and_value -> . INT64 EQUAL int_value
    (97) data_type_and_value -> . WFLOAT EQUAL float_value
    (98) data_type_and_value -> . FLOAT32 EQUAL float_value
    (99) data_type_and_value -> . FLOAT64 EQUAL float_value
    (100) data_type_and_value -> . BOOL EQUAL bool_value

    LCORCHE         shift and go to state 227
    EQUAL           shift and go to state 229
    COMA            shift and go to state 231
    INT32           shift and go to state 232
    INT64           shift and go to state 233
    FLOAT32         shift and go to state 234
    FLOAT64         shift and go to state 235
    BYTE            shift and go to state 135
    WINT            shift and go to state 236
    WFLOAT          shift and go to state 237
    WSTRING         shift and go to state 238
    BOOL            shift and go to state 239

    data_types                     shift and go to state 228
    data_type_and_value            shift and go to state 230

state 125

    (216) map_assignment -> map_var EQUAL . something
    (76) something -> . ID
    (77) something -> . data_structure
    (78) something -> . values
    (79) something -> . operations
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 141
    STRING          shift and go to state 145
    INTEGER         shift and go to state 146
    FLOAT           shift and go to state 147
    TRUE            shift and go to state 148
    FALSE           shift and go to state 149
    NOT             shift and go to state 56
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    map_var                        shift and go to state 101
    something                      shift and go to state 240
    data_structure                 shift and go to state 142
    values                         shift and go to state 143
    operations                     shift and go to state 144
    array_var                      shift and go to state 100
    expression                     shift and go to state 150
    comparison                     shift and go to state 151
    logic_operation                shift and go to state 152
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    funciones                      shift and go to state 99
    call_func                      shift and go to state 46

state 126

    (217) func_declaration -> FUNC ID . LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> FUNC ID . LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE

    LPAREN          shift and go to state 241


state 127

    (80) main_func -> FUNC MAIN . LPAREN RPAREN LLLAVE codigo RLLAVE

    LPAREN          shift and go to state 242


state 128

    (192) negation -> NOT comparison .

    PRINT           reduce using rule 192 (negation -> NOT comparison .)
    SCAN            reduce using rule 192 (negation -> NOT comparison .)
    FOR             reduce using rule 192 (negation -> NOT comparison .)
    CONST           reduce using rule 192 (negation -> NOT comparison .)
    ID              reduce using rule 192 (negation -> NOT comparison .)
    APPEND          reduce using rule 192 (negation -> NOT comparison .)
    LEN             reduce using rule 192 (negation -> NOT comparison .)
    COPY            reduce using rule 192 (negation -> NOT comparison .)
    DELETE          reduce using rule 192 (negation -> NOT comparison .)
    IF              reduce using rule 192 (negation -> NOT comparison .)
    ELSE            reduce using rule 192 (negation -> NOT comparison .)
    TYPE            reduce using rule 192 (negation -> NOT comparison .)
    SWITCH          reduce using rule 192 (negation -> NOT comparison .)
    VAR             reduce using rule 192 (negation -> NOT comparison .)
    FUNC            reduce using rule 192 (negation -> NOT comparison .)
    INTEGER         reduce using rule 192 (negation -> NOT comparison .)
    FLOAT           reduce using rule 192 (negation -> NOT comparison .)
    NOT             reduce using rule 192 (negation -> NOT comparison .)
    $end            reduce using rule 192 (negation -> NOT comparison .)
    AND             reduce using rule 192 (negation -> NOT comparison .)
    OR              reduce using rule 192 (negation -> NOT comparison .)
    RLLAVE          reduce using rule 192 (negation -> NOT comparison .)
    INT32           reduce using rule 192 (negation -> NOT comparison .)
    INT64           reduce using rule 192 (negation -> NOT comparison .)
    FLOAT32         reduce using rule 192 (negation -> NOT comparison .)
    FLOAT64         reduce using rule 192 (negation -> NOT comparison .)
    BYTE            reduce using rule 192 (negation -> NOT comparison .)
    WINT            reduce using rule 192 (negation -> NOT comparison .)
    WFLOAT          reduce using rule 192 (negation -> NOT comparison .)
    WSTRING         reduce using rule 192 (negation -> NOT comparison .)
    BOOL            reduce using rule 192 (negation -> NOT comparison .)
    DEFAULT         reduce using rule 192 (negation -> NOT comparison .)
    CASE            reduce using rule 192 (negation -> NOT comparison .)
    RETURN          reduce using rule 192 (negation -> NOT comparison .)
    LLLAVE          reduce using rule 192 (negation -> NOT comparison .)
    COLON           reduce using rule 192 (negation -> NOT comparison .)
    RPAREN          reduce using rule 192 (negation -> NOT comparison .)
    RCORCHE         reduce using rule 192 (negation -> NOT comparison .)
    COMA            reduce using rule 192 (negation -> NOT comparison .)


state 129

    (193) negation -> NOT ID .
    (177) value -> ID .
    (238) something_ex -> ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 177 (value -> ID .)
    PRINT           reduce using rule 193 (negation -> NOT ID .)
    SCAN            reduce using rule 193 (negation -> NOT ID .)
    FOR             reduce using rule 193 (negation -> NOT ID .)
    CONST           reduce using rule 193 (negation -> NOT ID .)
    ID              reduce using rule 193 (negation -> NOT ID .)
    APPEND          reduce using rule 193 (negation -> NOT ID .)
    LEN             reduce using rule 193 (negation -> NOT ID .)
    COPY            reduce using rule 193 (negation -> NOT ID .)
    DELETE          reduce using rule 193 (negation -> NOT ID .)
    IF              reduce using rule 193 (negation -> NOT ID .)
    ELSE            reduce using rule 193 (negation -> NOT ID .)
    TYPE            reduce using rule 193 (negation -> NOT ID .)
    SWITCH          reduce using rule 193 (negation -> NOT ID .)
    VAR             reduce using rule 193 (negation -> NOT ID .)
    FUNC            reduce using rule 193 (negation -> NOT ID .)
    INTEGER         reduce using rule 193 (negation -> NOT ID .)
    FLOAT           reduce using rule 193 (negation -> NOT ID .)
    NOT             reduce using rule 193 (negation -> NOT ID .)
    $end            reduce using rule 193 (negation -> NOT ID .)
    AND             reduce using rule 193 (negation -> NOT ID .)
    OR              reduce using rule 193 (negation -> NOT ID .)
    RLLAVE          reduce using rule 193 (negation -> NOT ID .)
    INT32           reduce using rule 193 (negation -> NOT ID .)
    INT64           reduce using rule 193 (negation -> NOT ID .)
    FLOAT32         reduce using rule 193 (negation -> NOT ID .)
    FLOAT64         reduce using rule 193 (negation -> NOT ID .)
    BYTE            reduce using rule 193 (negation -> NOT ID .)
    WINT            reduce using rule 193 (negation -> NOT ID .)
    WFLOAT          reduce using rule 193 (negation -> NOT ID .)
    WSTRING         reduce using rule 193 (negation -> NOT ID .)
    BOOL            reduce using rule 193 (negation -> NOT ID .)
    DEFAULT         reduce using rule 193 (negation -> NOT ID .)
    CASE            reduce using rule 193 (negation -> NOT ID .)
    RETURN          reduce using rule 193 (negation -> NOT ID .)
    LLLAVE          reduce using rule 193 (negation -> NOT ID .)
    COLON           reduce using rule 193 (negation -> NOT ID .)
    RPAREN          reduce using rule 193 (negation -> NOT ID .)
    RCORCHE         reduce using rule 193 (negation -> NOT ID .)
    COMA            reduce using rule 193 (negation -> NOT ID .)
    GREATER         reduce using rule 177 (value -> ID .)
    SMALLER         reduce using rule 177 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 177 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 177 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 177 (value -> ID .)
    NOT_EQUAL       reduce using rule 177 (value -> ID .)
    PLUS            reduce using rule 177 (value -> ID .)
    TIMES           reduce using rule 177 (value -> ID .)
    DIVIDE          reduce using rule 177 (value -> ID .)
    MINUS           reduce using rule 177 (value -> ID .)
    MOD             reduce using rule 177 (value -> ID .)
    LCORCHE         shift and go to state 172
    LPAREN          shift and go to state 111

  ! GREATER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 238 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 238 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 238 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 238 (something_ex -> ID .) ]


state 130

    (116) multiple -> list_var data_types .

    COLON           reduce using rule 116 (multiple -> list_var data_types .)
    PRINT           reduce using rule 116 (multiple -> list_var data_types .)
    SCAN            reduce using rule 116 (multiple -> list_var data_types .)
    FOR             reduce using rule 116 (multiple -> list_var data_types .)
    CONST           reduce using rule 116 (multiple -> list_var data_types .)
    ID              reduce using rule 116 (multiple -> list_var data_types .)
    APPEND          reduce using rule 116 (multiple -> list_var data_types .)
    LEN             reduce using rule 116 (multiple -> list_var data_types .)
    COPY            reduce using rule 116 (multiple -> list_var data_types .)
    DELETE          reduce using rule 116 (multiple -> list_var data_types .)
    IF              reduce using rule 116 (multiple -> list_var data_types .)
    ELSE            reduce using rule 116 (multiple -> list_var data_types .)
    TYPE            reduce using rule 116 (multiple -> list_var data_types .)
    SWITCH          reduce using rule 116 (multiple -> list_var data_types .)
    VAR             reduce using rule 116 (multiple -> list_var data_types .)
    FUNC            reduce using rule 116 (multiple -> list_var data_types .)
    INTEGER         reduce using rule 116 (multiple -> list_var data_types .)
    FLOAT           reduce using rule 116 (multiple -> list_var data_types .)
    NOT             reduce using rule 116 (multiple -> list_var data_types .)
    $end            reduce using rule 116 (multiple -> list_var data_types .)
    RLLAVE          reduce using rule 116 (multiple -> list_var data_types .)
    INT32           reduce using rule 116 (multiple -> list_var data_types .)
    INT64           reduce using rule 116 (multiple -> list_var data_types .)
    FLOAT32         reduce using rule 116 (multiple -> list_var data_types .)
    FLOAT64         reduce using rule 116 (multiple -> list_var data_types .)
    BYTE            reduce using rule 116 (multiple -> list_var data_types .)
    WINT            reduce using rule 116 (multiple -> list_var data_types .)
    WFLOAT          reduce using rule 116 (multiple -> list_var data_types .)
    WSTRING         reduce using rule 116 (multiple -> list_var data_types .)
    BOOL            reduce using rule 116 (multiple -> list_var data_types .)
    DEFAULT         reduce using rule 116 (multiple -> list_var data_types .)
    CASE            reduce using rule 116 (multiple -> list_var data_types .)
    RETURN          reduce using rule 116 (multiple -> list_var data_types .)


state 131

    (50) data_types -> INT32 .

    COLON           reduce using rule 50 (data_types -> INT32 .)
    PRINT           reduce using rule 50 (data_types -> INT32 .)
    SCAN            reduce using rule 50 (data_types -> INT32 .)
    FOR             reduce using rule 50 (data_types -> INT32 .)
    CONST           reduce using rule 50 (data_types -> INT32 .)
    ID              reduce using rule 50 (data_types -> INT32 .)
    APPEND          reduce using rule 50 (data_types -> INT32 .)
    LEN             reduce using rule 50 (data_types -> INT32 .)
    COPY            reduce using rule 50 (data_types -> INT32 .)
    DELETE          reduce using rule 50 (data_types -> INT32 .)
    IF              reduce using rule 50 (data_types -> INT32 .)
    ELSE            reduce using rule 50 (data_types -> INT32 .)
    TYPE            reduce using rule 50 (data_types -> INT32 .)
    SWITCH          reduce using rule 50 (data_types -> INT32 .)
    VAR             reduce using rule 50 (data_types -> INT32 .)
    FUNC            reduce using rule 50 (data_types -> INT32 .)
    INTEGER         reduce using rule 50 (data_types -> INT32 .)
    FLOAT           reduce using rule 50 (data_types -> INT32 .)
    NOT             reduce using rule 50 (data_types -> INT32 .)
    $end            reduce using rule 50 (data_types -> INT32 .)
    RLLAVE          reduce using rule 50 (data_types -> INT32 .)
    INT32           reduce using rule 50 (data_types -> INT32 .)
    INT64           reduce using rule 50 (data_types -> INT32 .)
    FLOAT32         reduce using rule 50 (data_types -> INT32 .)
    FLOAT64         reduce using rule 50 (data_types -> INT32 .)
    BYTE            reduce using rule 50 (data_types -> INT32 .)
    WINT            reduce using rule 50 (data_types -> INT32 .)
    WFLOAT          reduce using rule 50 (data_types -> INT32 .)
    WSTRING         reduce using rule 50 (data_types -> INT32 .)
    BOOL            reduce using rule 50 (data_types -> INT32 .)
    DEFAULT         reduce using rule 50 (data_types -> INT32 .)
    CASE            reduce using rule 50 (data_types -> INT32 .)
    RETURN          reduce using rule 50 (data_types -> INT32 .)
    RCORCHE         reduce using rule 50 (data_types -> INT32 .)
    LLLAVE          reduce using rule 50 (data_types -> INT32 .)
    COMA            reduce using rule 50 (data_types -> INT32 .)
    RPAREN          reduce using rule 50 (data_types -> INT32 .)


state 132

    (51) data_types -> INT64 .

    COLON           reduce using rule 51 (data_types -> INT64 .)
    PRINT           reduce using rule 51 (data_types -> INT64 .)
    SCAN            reduce using rule 51 (data_types -> INT64 .)
    FOR             reduce using rule 51 (data_types -> INT64 .)
    CONST           reduce using rule 51 (data_types -> INT64 .)
    ID              reduce using rule 51 (data_types -> INT64 .)
    APPEND          reduce using rule 51 (data_types -> INT64 .)
    LEN             reduce using rule 51 (data_types -> INT64 .)
    COPY            reduce using rule 51 (data_types -> INT64 .)
    DELETE          reduce using rule 51 (data_types -> INT64 .)
    IF              reduce using rule 51 (data_types -> INT64 .)
    ELSE            reduce using rule 51 (data_types -> INT64 .)
    TYPE            reduce using rule 51 (data_types -> INT64 .)
    SWITCH          reduce using rule 51 (data_types -> INT64 .)
    VAR             reduce using rule 51 (data_types -> INT64 .)
    FUNC            reduce using rule 51 (data_types -> INT64 .)
    INTEGER         reduce using rule 51 (data_types -> INT64 .)
    FLOAT           reduce using rule 51 (data_types -> INT64 .)
    NOT             reduce using rule 51 (data_types -> INT64 .)
    $end            reduce using rule 51 (data_types -> INT64 .)
    RLLAVE          reduce using rule 51 (data_types -> INT64 .)
    INT32           reduce using rule 51 (data_types -> INT64 .)
    INT64           reduce using rule 51 (data_types -> INT64 .)
    FLOAT32         reduce using rule 51 (data_types -> INT64 .)
    FLOAT64         reduce using rule 51 (data_types -> INT64 .)
    BYTE            reduce using rule 51 (data_types -> INT64 .)
    WINT            reduce using rule 51 (data_types -> INT64 .)
    WFLOAT          reduce using rule 51 (data_types -> INT64 .)
    WSTRING         reduce using rule 51 (data_types -> INT64 .)
    BOOL            reduce using rule 51 (data_types -> INT64 .)
    DEFAULT         reduce using rule 51 (data_types -> INT64 .)
    CASE            reduce using rule 51 (data_types -> INT64 .)
    RETURN          reduce using rule 51 (data_types -> INT64 .)
    RCORCHE         reduce using rule 51 (data_types -> INT64 .)
    LLLAVE          reduce using rule 51 (data_types -> INT64 .)
    COMA            reduce using rule 51 (data_types -> INT64 .)
    RPAREN          reduce using rule 51 (data_types -> INT64 .)


state 133

    (52) data_types -> FLOAT32 .

    COLON           reduce using rule 52 (data_types -> FLOAT32 .)
    PRINT           reduce using rule 52 (data_types -> FLOAT32 .)
    SCAN            reduce using rule 52 (data_types -> FLOAT32 .)
    FOR             reduce using rule 52 (data_types -> FLOAT32 .)
    CONST           reduce using rule 52 (data_types -> FLOAT32 .)
    ID              reduce using rule 52 (data_types -> FLOAT32 .)
    APPEND          reduce using rule 52 (data_types -> FLOAT32 .)
    LEN             reduce using rule 52 (data_types -> FLOAT32 .)
    COPY            reduce using rule 52 (data_types -> FLOAT32 .)
    DELETE          reduce using rule 52 (data_types -> FLOAT32 .)
    IF              reduce using rule 52 (data_types -> FLOAT32 .)
    ELSE            reduce using rule 52 (data_types -> FLOAT32 .)
    TYPE            reduce using rule 52 (data_types -> FLOAT32 .)
    SWITCH          reduce using rule 52 (data_types -> FLOAT32 .)
    VAR             reduce using rule 52 (data_types -> FLOAT32 .)
    FUNC            reduce using rule 52 (data_types -> FLOAT32 .)
    INTEGER         reduce using rule 52 (data_types -> FLOAT32 .)
    FLOAT           reduce using rule 52 (data_types -> FLOAT32 .)
    NOT             reduce using rule 52 (data_types -> FLOAT32 .)
    $end            reduce using rule 52 (data_types -> FLOAT32 .)
    RLLAVE          reduce using rule 52 (data_types -> FLOAT32 .)
    INT32           reduce using rule 52 (data_types -> FLOAT32 .)
    INT64           reduce using rule 52 (data_types -> FLOAT32 .)
    FLOAT32         reduce using rule 52 (data_types -> FLOAT32 .)
    FLOAT64         reduce using rule 52 (data_types -> FLOAT32 .)
    BYTE            reduce using rule 52 (data_types -> FLOAT32 .)
    WINT            reduce using rule 52 (data_types -> FLOAT32 .)
    WFLOAT          reduce using rule 52 (data_types -> FLOAT32 .)
    WSTRING         reduce using rule 52 (data_types -> FLOAT32 .)
    BOOL            reduce using rule 52 (data_types -> FLOAT32 .)
    DEFAULT         reduce using rule 52 (data_types -> FLOAT32 .)
    CASE            reduce using rule 52 (data_types -> FLOAT32 .)
    RETURN          reduce using rule 52 (data_types -> FLOAT32 .)
    RCORCHE         reduce using rule 52 (data_types -> FLOAT32 .)
    LLLAVE          reduce using rule 52 (data_types -> FLOAT32 .)
    COMA            reduce using rule 52 (data_types -> FLOAT32 .)
    RPAREN          reduce using rule 52 (data_types -> FLOAT32 .)


state 134

    (53) data_types -> FLOAT64 .

    COLON           reduce using rule 53 (data_types -> FLOAT64 .)
    PRINT           reduce using rule 53 (data_types -> FLOAT64 .)
    SCAN            reduce using rule 53 (data_types -> FLOAT64 .)
    FOR             reduce using rule 53 (data_types -> FLOAT64 .)
    CONST           reduce using rule 53 (data_types -> FLOAT64 .)
    ID              reduce using rule 53 (data_types -> FLOAT64 .)
    APPEND          reduce using rule 53 (data_types -> FLOAT64 .)
    LEN             reduce using rule 53 (data_types -> FLOAT64 .)
    COPY            reduce using rule 53 (data_types -> FLOAT64 .)
    DELETE          reduce using rule 53 (data_types -> FLOAT64 .)
    IF              reduce using rule 53 (data_types -> FLOAT64 .)
    ELSE            reduce using rule 53 (data_types -> FLOAT64 .)
    TYPE            reduce using rule 53 (data_types -> FLOAT64 .)
    SWITCH          reduce using rule 53 (data_types -> FLOAT64 .)
    VAR             reduce using rule 53 (data_types -> FLOAT64 .)
    FUNC            reduce using rule 53 (data_types -> FLOAT64 .)
    INTEGER         reduce using rule 53 (data_types -> FLOAT64 .)
    FLOAT           reduce using rule 53 (data_types -> FLOAT64 .)
    NOT             reduce using rule 53 (data_types -> FLOAT64 .)
    $end            reduce using rule 53 (data_types -> FLOAT64 .)
    RLLAVE          reduce using rule 53 (data_types -> FLOAT64 .)
    INT32           reduce using rule 53 (data_types -> FLOAT64 .)
    INT64           reduce using rule 53 (data_types -> FLOAT64 .)
    FLOAT32         reduce using rule 53 (data_types -> FLOAT64 .)
    FLOAT64         reduce using rule 53 (data_types -> FLOAT64 .)
    BYTE            reduce using rule 53 (data_types -> FLOAT64 .)
    WINT            reduce using rule 53 (data_types -> FLOAT64 .)
    WFLOAT          reduce using rule 53 (data_types -> FLOAT64 .)
    WSTRING         reduce using rule 53 (data_types -> FLOAT64 .)
    BOOL            reduce using rule 53 (data_types -> FLOAT64 .)
    DEFAULT         reduce using rule 53 (data_types -> FLOAT64 .)
    CASE            reduce using rule 53 (data_types -> FLOAT64 .)
    RETURN          reduce using rule 53 (data_types -> FLOAT64 .)
    RCORCHE         reduce using rule 53 (data_types -> FLOAT64 .)
    LLLAVE          reduce using rule 53 (data_types -> FLOAT64 .)
    COMA            reduce using rule 53 (data_types -> FLOAT64 .)
    RPAREN          reduce using rule 53 (data_types -> FLOAT64 .)


state 135

    (54) data_types -> BYTE .

    COLON           reduce using rule 54 (data_types -> BYTE .)
    PRINT           reduce using rule 54 (data_types -> BYTE .)
    SCAN            reduce using rule 54 (data_types -> BYTE .)
    FOR             reduce using rule 54 (data_types -> BYTE .)
    CONST           reduce using rule 54 (data_types -> BYTE .)
    ID              reduce using rule 54 (data_types -> BYTE .)
    APPEND          reduce using rule 54 (data_types -> BYTE .)
    LEN             reduce using rule 54 (data_types -> BYTE .)
    COPY            reduce using rule 54 (data_types -> BYTE .)
    DELETE          reduce using rule 54 (data_types -> BYTE .)
    IF              reduce using rule 54 (data_types -> BYTE .)
    ELSE            reduce using rule 54 (data_types -> BYTE .)
    TYPE            reduce using rule 54 (data_types -> BYTE .)
    SWITCH          reduce using rule 54 (data_types -> BYTE .)
    VAR             reduce using rule 54 (data_types -> BYTE .)
    FUNC            reduce using rule 54 (data_types -> BYTE .)
    INTEGER         reduce using rule 54 (data_types -> BYTE .)
    FLOAT           reduce using rule 54 (data_types -> BYTE .)
    NOT             reduce using rule 54 (data_types -> BYTE .)
    $end            reduce using rule 54 (data_types -> BYTE .)
    RLLAVE          reduce using rule 54 (data_types -> BYTE .)
    INT32           reduce using rule 54 (data_types -> BYTE .)
    INT64           reduce using rule 54 (data_types -> BYTE .)
    FLOAT32         reduce using rule 54 (data_types -> BYTE .)
    FLOAT64         reduce using rule 54 (data_types -> BYTE .)
    BYTE            reduce using rule 54 (data_types -> BYTE .)
    WINT            reduce using rule 54 (data_types -> BYTE .)
    WFLOAT          reduce using rule 54 (data_types -> BYTE .)
    WSTRING         reduce using rule 54 (data_types -> BYTE .)
    BOOL            reduce using rule 54 (data_types -> BYTE .)
    DEFAULT         reduce using rule 54 (data_types -> BYTE .)
    CASE            reduce using rule 54 (data_types -> BYTE .)
    RETURN          reduce using rule 54 (data_types -> BYTE .)
    EQUAL           reduce using rule 54 (data_types -> BYTE .)
    RCORCHE         reduce using rule 54 (data_types -> BYTE .)
    LLLAVE          reduce using rule 54 (data_types -> BYTE .)
    COMA            reduce using rule 54 (data_types -> BYTE .)
    RPAREN          reduce using rule 54 (data_types -> BYTE .)


state 136

    (55) data_types -> WINT .

    COLON           reduce using rule 55 (data_types -> WINT .)
    PRINT           reduce using rule 55 (data_types -> WINT .)
    SCAN            reduce using rule 55 (data_types -> WINT .)
    FOR             reduce using rule 55 (data_types -> WINT .)
    CONST           reduce using rule 55 (data_types -> WINT .)
    ID              reduce using rule 55 (data_types -> WINT .)
    APPEND          reduce using rule 55 (data_types -> WINT .)
    LEN             reduce using rule 55 (data_types -> WINT .)
    COPY            reduce using rule 55 (data_types -> WINT .)
    DELETE          reduce using rule 55 (data_types -> WINT .)
    IF              reduce using rule 55 (data_types -> WINT .)
    ELSE            reduce using rule 55 (data_types -> WINT .)
    TYPE            reduce using rule 55 (data_types -> WINT .)
    SWITCH          reduce using rule 55 (data_types -> WINT .)
    VAR             reduce using rule 55 (data_types -> WINT .)
    FUNC            reduce using rule 55 (data_types -> WINT .)
    INTEGER         reduce using rule 55 (data_types -> WINT .)
    FLOAT           reduce using rule 55 (data_types -> WINT .)
    NOT             reduce using rule 55 (data_types -> WINT .)
    $end            reduce using rule 55 (data_types -> WINT .)
    RLLAVE          reduce using rule 55 (data_types -> WINT .)
    INT32           reduce using rule 55 (data_types -> WINT .)
    INT64           reduce using rule 55 (data_types -> WINT .)
    FLOAT32         reduce using rule 55 (data_types -> WINT .)
    FLOAT64         reduce using rule 55 (data_types -> WINT .)
    BYTE            reduce using rule 55 (data_types -> WINT .)
    WINT            reduce using rule 55 (data_types -> WINT .)
    WFLOAT          reduce using rule 55 (data_types -> WINT .)
    WSTRING         reduce using rule 55 (data_types -> WINT .)
    BOOL            reduce using rule 55 (data_types -> WINT .)
    DEFAULT         reduce using rule 55 (data_types -> WINT .)
    CASE            reduce using rule 55 (data_types -> WINT .)
    RETURN          reduce using rule 55 (data_types -> WINT .)
    RCORCHE         reduce using rule 55 (data_types -> WINT .)
    LLLAVE          reduce using rule 55 (data_types -> WINT .)
    COMA            reduce using rule 55 (data_types -> WINT .)
    RPAREN          reduce using rule 55 (data_types -> WINT .)


state 137

    (56) data_types -> WFLOAT .

    COLON           reduce using rule 56 (data_types -> WFLOAT .)
    PRINT           reduce using rule 56 (data_types -> WFLOAT .)
    SCAN            reduce using rule 56 (data_types -> WFLOAT .)
    FOR             reduce using rule 56 (data_types -> WFLOAT .)
    CONST           reduce using rule 56 (data_types -> WFLOAT .)
    ID              reduce using rule 56 (data_types -> WFLOAT .)
    APPEND          reduce using rule 56 (data_types -> WFLOAT .)
    LEN             reduce using rule 56 (data_types -> WFLOAT .)
    COPY            reduce using rule 56 (data_types -> WFLOAT .)
    DELETE          reduce using rule 56 (data_types -> WFLOAT .)
    IF              reduce using rule 56 (data_types -> WFLOAT .)
    ELSE            reduce using rule 56 (data_types -> WFLOAT .)
    TYPE            reduce using rule 56 (data_types -> WFLOAT .)
    SWITCH          reduce using rule 56 (data_types -> WFLOAT .)
    VAR             reduce using rule 56 (data_types -> WFLOAT .)
    FUNC            reduce using rule 56 (data_types -> WFLOAT .)
    INTEGER         reduce using rule 56 (data_types -> WFLOAT .)
    FLOAT           reduce using rule 56 (data_types -> WFLOAT .)
    NOT             reduce using rule 56 (data_types -> WFLOAT .)
    $end            reduce using rule 56 (data_types -> WFLOAT .)
    RLLAVE          reduce using rule 56 (data_types -> WFLOAT .)
    INT32           reduce using rule 56 (data_types -> WFLOAT .)
    INT64           reduce using rule 56 (data_types -> WFLOAT .)
    FLOAT32         reduce using rule 56 (data_types -> WFLOAT .)
    FLOAT64         reduce using rule 56 (data_types -> WFLOAT .)
    BYTE            reduce using rule 56 (data_types -> WFLOAT .)
    WINT            reduce using rule 56 (data_types -> WFLOAT .)
    WFLOAT          reduce using rule 56 (data_types -> WFLOAT .)
    WSTRING         reduce using rule 56 (data_types -> WFLOAT .)
    BOOL            reduce using rule 56 (data_types -> WFLOAT .)
    DEFAULT         reduce using rule 56 (data_types -> WFLOAT .)
    CASE            reduce using rule 56 (data_types -> WFLOAT .)
    RETURN          reduce using rule 56 (data_types -> WFLOAT .)
    RCORCHE         reduce using rule 56 (data_types -> WFLOAT .)
    LLLAVE          reduce using rule 56 (data_types -> WFLOAT .)
    COMA            reduce using rule 56 (data_types -> WFLOAT .)
    RPAREN          reduce using rule 56 (data_types -> WFLOAT .)


state 138

    (57) data_types -> WSTRING .

    COLON           reduce using rule 57 (data_types -> WSTRING .)
    PRINT           reduce using rule 57 (data_types -> WSTRING .)
    SCAN            reduce using rule 57 (data_types -> WSTRING .)
    FOR             reduce using rule 57 (data_types -> WSTRING .)
    CONST           reduce using rule 57 (data_types -> WSTRING .)
    ID              reduce using rule 57 (data_types -> WSTRING .)
    APPEND          reduce using rule 57 (data_types -> WSTRING .)
    LEN             reduce using rule 57 (data_types -> WSTRING .)
    COPY            reduce using rule 57 (data_types -> WSTRING .)
    DELETE          reduce using rule 57 (data_types -> WSTRING .)
    IF              reduce using rule 57 (data_types -> WSTRING .)
    ELSE            reduce using rule 57 (data_types -> WSTRING .)
    TYPE            reduce using rule 57 (data_types -> WSTRING .)
    SWITCH          reduce using rule 57 (data_types -> WSTRING .)
    VAR             reduce using rule 57 (data_types -> WSTRING .)
    FUNC            reduce using rule 57 (data_types -> WSTRING .)
    INTEGER         reduce using rule 57 (data_types -> WSTRING .)
    FLOAT           reduce using rule 57 (data_types -> WSTRING .)
    NOT             reduce using rule 57 (data_types -> WSTRING .)
    $end            reduce using rule 57 (data_types -> WSTRING .)
    RLLAVE          reduce using rule 57 (data_types -> WSTRING .)
    INT32           reduce using rule 57 (data_types -> WSTRING .)
    INT64           reduce using rule 57 (data_types -> WSTRING .)
    FLOAT32         reduce using rule 57 (data_types -> WSTRING .)
    FLOAT64         reduce using rule 57 (data_types -> WSTRING .)
    BYTE            reduce using rule 57 (data_types -> WSTRING .)
    WINT            reduce using rule 57 (data_types -> WSTRING .)
    WFLOAT          reduce using rule 57 (data_types -> WSTRING .)
    WSTRING         reduce using rule 57 (data_types -> WSTRING .)
    BOOL            reduce using rule 57 (data_types -> WSTRING .)
    DEFAULT         reduce using rule 57 (data_types -> WSTRING .)
    CASE            reduce using rule 57 (data_types -> WSTRING .)
    RETURN          reduce using rule 57 (data_types -> WSTRING .)
    RCORCHE         reduce using rule 57 (data_types -> WSTRING .)
    LLLAVE          reduce using rule 57 (data_types -> WSTRING .)
    COMA            reduce using rule 57 (data_types -> WSTRING .)
    RPAREN          reduce using rule 57 (data_types -> WSTRING .)


state 139

    (58) data_types -> BOOL .

    COLON           reduce using rule 58 (data_types -> BOOL .)
    PRINT           reduce using rule 58 (data_types -> BOOL .)
    SCAN            reduce using rule 58 (data_types -> BOOL .)
    FOR             reduce using rule 58 (data_types -> BOOL .)
    CONST           reduce using rule 58 (data_types -> BOOL .)
    ID              reduce using rule 58 (data_types -> BOOL .)
    APPEND          reduce using rule 58 (data_types -> BOOL .)
    LEN             reduce using rule 58 (data_types -> BOOL .)
    COPY            reduce using rule 58 (data_types -> BOOL .)
    DELETE          reduce using rule 58 (data_types -> BOOL .)
    IF              reduce using rule 58 (data_types -> BOOL .)
    ELSE            reduce using rule 58 (data_types -> BOOL .)
    TYPE            reduce using rule 58 (data_types -> BOOL .)
    SWITCH          reduce using rule 58 (data_types -> BOOL .)
    VAR             reduce using rule 58 (data_types -> BOOL .)
    FUNC            reduce using rule 58 (data_types -> BOOL .)
    INTEGER         reduce using rule 58 (data_types -> BOOL .)
    FLOAT           reduce using rule 58 (data_types -> BOOL .)
    NOT             reduce using rule 58 (data_types -> BOOL .)
    $end            reduce using rule 58 (data_types -> BOOL .)
    RLLAVE          reduce using rule 58 (data_types -> BOOL .)
    INT32           reduce using rule 58 (data_types -> BOOL .)
    INT64           reduce using rule 58 (data_types -> BOOL .)
    FLOAT32         reduce using rule 58 (data_types -> BOOL .)
    FLOAT64         reduce using rule 58 (data_types -> BOOL .)
    BYTE            reduce using rule 58 (data_types -> BOOL .)
    WINT            reduce using rule 58 (data_types -> BOOL .)
    WFLOAT          reduce using rule 58 (data_types -> BOOL .)
    WSTRING         reduce using rule 58 (data_types -> BOOL .)
    BOOL            reduce using rule 58 (data_types -> BOOL .)
    DEFAULT         reduce using rule 58 (data_types -> BOOL .)
    CASE            reduce using rule 58 (data_types -> BOOL .)
    RETURN          reduce using rule 58 (data_types -> BOOL .)
    RCORCHE         reduce using rule 58 (data_types -> BOOL .)
    LLLAVE          reduce using rule 58 (data_types -> BOOL .)
    COMA            reduce using rule 58 (data_types -> BOOL .)
    RPAREN          reduce using rule 58 (data_types -> BOOL .)


state 140

    (210) array_assignment -> array_var EQUAL something .

    COLON           reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    PRINT           reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    SCAN            reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    FOR             reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    CONST           reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    ID              reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    APPEND          reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    LEN             reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    COPY            reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    DELETE          reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    IF              reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    ELSE            reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    TYPE            reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    SWITCH          reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    VAR             reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    FUNC            reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    INTEGER         reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    FLOAT           reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    NOT             reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    $end            reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    RLLAVE          reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    INT32           reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    INT64           reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    FLOAT32         reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    FLOAT64         reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    BYTE            reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    WINT            reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    WFLOAT          reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    WSTRING         reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    BOOL            reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    DEFAULT         reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    CASE            reduce using rule 210 (array_assignment -> array_var EQUAL something .)
    RETURN          reduce using rule 210 (array_assignment -> array_var EQUAL something .)


state 141

    (76) something -> ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE
    (238) something_ex -> ID .
    (177) value -> ID .
    (191) logic_value -> ID .
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for COLON resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for CONST resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for INT32 resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for INT64 resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for BYTE resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for WINT resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for WSTRING resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 76 (something -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 177 (value -> ID .)
    COLON           reduce using rule 76 (something -> ID .)
    PRINT           reduce using rule 76 (something -> ID .)
    SCAN            reduce using rule 76 (something -> ID .)
    FOR             reduce using rule 76 (something -> ID .)
    CONST           reduce using rule 76 (something -> ID .)
    ID              reduce using rule 76 (something -> ID .)
    APPEND          reduce using rule 76 (something -> ID .)
    LEN             reduce using rule 76 (something -> ID .)
    COPY            reduce using rule 76 (something -> ID .)
    DELETE          reduce using rule 76 (something -> ID .)
    IF              reduce using rule 76 (something -> ID .)
    ELSE            reduce using rule 76 (something -> ID .)
    TYPE            reduce using rule 76 (something -> ID .)
    SWITCH          reduce using rule 76 (something -> ID .)
    VAR             reduce using rule 76 (something -> ID .)
    FUNC            reduce using rule 76 (something -> ID .)
    INTEGER         reduce using rule 76 (something -> ID .)
    FLOAT           reduce using rule 76 (something -> ID .)
    NOT             reduce using rule 76 (something -> ID .)
    $end            reduce using rule 76 (something -> ID .)
    RLLAVE          reduce using rule 76 (something -> ID .)
    INT32           reduce using rule 76 (something -> ID .)
    INT64           reduce using rule 76 (something -> ID .)
    FLOAT32         reduce using rule 76 (something -> ID .)
    FLOAT64         reduce using rule 76 (something -> ID .)
    BYTE            reduce using rule 76 (something -> ID .)
    WINT            reduce using rule 76 (something -> ID .)
    WFLOAT          reduce using rule 76 (something -> ID .)
    WSTRING         reduce using rule 76 (something -> ID .)
    BOOL            reduce using rule 76 (something -> ID .)
    DEFAULT         reduce using rule 76 (something -> ID .)
    CASE            reduce using rule 76 (something -> ID .)
    RETURN          reduce using rule 76 (something -> ID .)
    LCORCHE         shift and go to state 172
    GREATER         reduce using rule 177 (value -> ID .)
    SMALLER         reduce using rule 177 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 177 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 177 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 177 (value -> ID .)
    NOT_EQUAL       reduce using rule 177 (value -> ID .)
    PLUS            reduce using rule 177 (value -> ID .)
    TIMES           reduce using rule 177 (value -> ID .)
    DIVIDE          reduce using rule 177 (value -> ID .)
    MINUS           reduce using rule 177 (value -> ID .)
    MOD             reduce using rule 177 (value -> ID .)
    AND             reduce using rule 191 (logic_value -> ID .)
    OR              reduce using rule 191 (logic_value -> ID .)
    LPAREN          shift and go to state 111

  ! GREATER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 238 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 238 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 238 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 238 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 238 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 238 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 238 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 238 (something_ex -> ID .) ]
  ! CONST           [ reduce using rule 238 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 238 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 238 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 238 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 238 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 238 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 238 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 238 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 238 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 238 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 238 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! INT32           [ reduce using rule 238 (something_ex -> ID .) ]
  ! INT64           [ reduce using rule 238 (something_ex -> ID .) ]
  ! FLOAT32         [ reduce using rule 238 (something_ex -> ID .) ]
  ! FLOAT64         [ reduce using rule 238 (something_ex -> ID .) ]
  ! BYTE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! WINT            [ reduce using rule 238 (something_ex -> ID .) ]
  ! WFLOAT          [ reduce using rule 238 (something_ex -> ID .) ]
  ! WSTRING         [ reduce using rule 238 (something_ex -> ID .) ]
  ! BOOL            [ reduce using rule 238 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 238 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 238 (something_ex -> ID .) ]


state 142

    (77) something -> data_structure .
    (241) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for PRINT resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for SCAN resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for FOR resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for CONST resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for ID resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for APPEND resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for LEN resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for COPY resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for DELETE resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for IF resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for ELSE resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for TYPE resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for SWITCH resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for VAR resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for FUNC resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for INTEGER resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for FLOAT resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for NOT resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for $end resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for INT32 resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for INT64 resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for BYTE resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for WINT resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for WSTRING resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for BOOL resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for CASE resolved using rule 77 (something -> data_structure .)
  ! reduce/reduce conflict for RETURN resolved using rule 77 (something -> data_structure .)
    COLON           reduce using rule 77 (something -> data_structure .)
    PRINT           reduce using rule 77 (something -> data_structure .)
    SCAN            reduce using rule 77 (something -> data_structure .)
    FOR             reduce using rule 77 (something -> data_structure .)
    CONST           reduce using rule 77 (something -> data_structure .)
    ID              reduce using rule 77 (something -> data_structure .)
    APPEND          reduce using rule 77 (something -> data_structure .)
    LEN             reduce using rule 77 (something -> data_structure .)
    COPY            reduce using rule 77 (something -> data_structure .)
    DELETE          reduce using rule 77 (something -> data_structure .)
    IF              reduce using rule 77 (something -> data_structure .)
    ELSE            reduce using rule 77 (something -> data_structure .)
    TYPE            reduce using rule 77 (something -> data_structure .)
    SWITCH          reduce using rule 77 (something -> data_structure .)
    VAR             reduce using rule 77 (something -> data_structure .)
    FUNC            reduce using rule 77 (something -> data_structure .)
    INTEGER         reduce using rule 77 (something -> data_structure .)
    FLOAT           reduce using rule 77 (something -> data_structure .)
    NOT             reduce using rule 77 (something -> data_structure .)
    $end            reduce using rule 77 (something -> data_structure .)
    RLLAVE          reduce using rule 77 (something -> data_structure .)
    INT32           reduce using rule 77 (something -> data_structure .)
    INT64           reduce using rule 77 (something -> data_structure .)
    FLOAT32         reduce using rule 77 (something -> data_structure .)
    FLOAT64         reduce using rule 77 (something -> data_structure .)
    BYTE            reduce using rule 77 (something -> data_structure .)
    WINT            reduce using rule 77 (something -> data_structure .)
    WFLOAT          reduce using rule 77 (something -> data_structure .)
    WSTRING         reduce using rule 77 (something -> data_structure .)
    BOOL            reduce using rule 77 (something -> data_structure .)
    DEFAULT         reduce using rule 77 (something -> data_structure .)
    CASE            reduce using rule 77 (something -> data_structure .)
    RETURN          reduce using rule 77 (something -> data_structure .)
    GREATER         reduce using rule 241 (something_ex -> data_structure .)
    SMALLER         reduce using rule 241 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 241 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 241 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 241 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 241 (something_ex -> data_structure .)
    PLUS            reduce using rule 241 (something_ex -> data_structure .)
    TIMES           reduce using rule 241 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 241 (something_ex -> data_structure .)
    MINUS           reduce using rule 241 (something_ex -> data_structure .)
    MOD             reduce using rule 241 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! PRINT           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! SCAN            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! FOR             [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! CONST           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! ID              [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! APPEND          [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! LEN             [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! COPY            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! DELETE          [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! IF              [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! ELSE            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! TYPE            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! SWITCH          [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! VAR             [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! FUNC            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! INTEGER         [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! FLOAT           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! NOT             [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! $end            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! INT32           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! INT64           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! FLOAT32         [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! FLOAT64         [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! BYTE            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! WINT            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! WFLOAT          [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! WSTRING         [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! BOOL            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! DEFAULT         [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! CASE            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! RETURN          [ reduce using rule 241 (something_ex -> data_structure .) ]


state 143

    (78) something -> values .

    COLON           reduce using rule 78 (something -> values .)
    PRINT           reduce using rule 78 (something -> values .)
    SCAN            reduce using rule 78 (something -> values .)
    FOR             reduce using rule 78 (something -> values .)
    CONST           reduce using rule 78 (something -> values .)
    ID              reduce using rule 78 (something -> values .)
    APPEND          reduce using rule 78 (something -> values .)
    LEN             reduce using rule 78 (something -> values .)
    COPY            reduce using rule 78 (something -> values .)
    DELETE          reduce using rule 78 (something -> values .)
    IF              reduce using rule 78 (something -> values .)
    ELSE            reduce using rule 78 (something -> values .)
    TYPE            reduce using rule 78 (something -> values .)
    SWITCH          reduce using rule 78 (something -> values .)
    VAR             reduce using rule 78 (something -> values .)
    FUNC            reduce using rule 78 (something -> values .)
    INTEGER         reduce using rule 78 (something -> values .)
    FLOAT           reduce using rule 78 (something -> values .)
    NOT             reduce using rule 78 (something -> values .)
    $end            reduce using rule 78 (something -> values .)
    RLLAVE          reduce using rule 78 (something -> values .)
    INT32           reduce using rule 78 (something -> values .)
    INT64           reduce using rule 78 (something -> values .)
    FLOAT32         reduce using rule 78 (something -> values .)
    FLOAT64         reduce using rule 78 (something -> values .)
    BYTE            reduce using rule 78 (something -> values .)
    WINT            reduce using rule 78 (something -> values .)
    WFLOAT          reduce using rule 78 (something -> values .)
    WSTRING         reduce using rule 78 (something -> values .)
    BOOL            reduce using rule 78 (something -> values .)
    DEFAULT         reduce using rule 78 (something -> values .)
    CASE            reduce using rule 78 (something -> values .)
    RETURN          reduce using rule 78 (something -> values .)


state 144

    (79) something -> operations .

    COLON           reduce using rule 79 (something -> operations .)
    PRINT           reduce using rule 79 (something -> operations .)
    SCAN            reduce using rule 79 (something -> operations .)
    FOR             reduce using rule 79 (something -> operations .)
    CONST           reduce using rule 79 (something -> operations .)
    ID              reduce using rule 79 (something -> operations .)
    APPEND          reduce using rule 79 (something -> operations .)
    LEN             reduce using rule 79 (something -> operations .)
    COPY            reduce using rule 79 (something -> operations .)
    DELETE          reduce using rule 79 (something -> operations .)
    IF              reduce using rule 79 (something -> operations .)
    ELSE            reduce using rule 79 (something -> operations .)
    TYPE            reduce using rule 79 (something -> operations .)
    SWITCH          reduce using rule 79 (something -> operations .)
    VAR             reduce using rule 79 (something -> operations .)
    FUNC            reduce using rule 79 (something -> operations .)
    INTEGER         reduce using rule 79 (something -> operations .)
    FLOAT           reduce using rule 79 (something -> operations .)
    NOT             reduce using rule 79 (something -> operations .)
    $end            reduce using rule 79 (something -> operations .)
    RLLAVE          reduce using rule 79 (something -> operations .)
    INT32           reduce using rule 79 (something -> operations .)
    INT64           reduce using rule 79 (something -> operations .)
    FLOAT32         reduce using rule 79 (something -> operations .)
    FLOAT64         reduce using rule 79 (something -> operations .)
    BYTE            reduce using rule 79 (something -> operations .)
    WINT            reduce using rule 79 (something -> operations .)
    WFLOAT          reduce using rule 79 (something -> operations .)
    WSTRING         reduce using rule 79 (something -> operations .)
    BOOL            reduce using rule 79 (something -> operations .)
    DEFAULT         reduce using rule 79 (something -> operations .)
    CASE            reduce using rule 79 (something -> operations .)
    RETURN          reduce using rule 79 (something -> operations .)


state 145

    (45) values -> STRING .

    COLON           reduce using rule 45 (values -> STRING .)
    PRINT           reduce using rule 45 (values -> STRING .)
    SCAN            reduce using rule 45 (values -> STRING .)
    FOR             reduce using rule 45 (values -> STRING .)
    CONST           reduce using rule 45 (values -> STRING .)
    ID              reduce using rule 45 (values -> STRING .)
    APPEND          reduce using rule 45 (values -> STRING .)
    LEN             reduce using rule 45 (values -> STRING .)
    COPY            reduce using rule 45 (values -> STRING .)
    DELETE          reduce using rule 45 (values -> STRING .)
    IF              reduce using rule 45 (values -> STRING .)
    ELSE            reduce using rule 45 (values -> STRING .)
    TYPE            reduce using rule 45 (values -> STRING .)
    SWITCH          reduce using rule 45 (values -> STRING .)
    VAR             reduce using rule 45 (values -> STRING .)
    FUNC            reduce using rule 45 (values -> STRING .)
    INTEGER         reduce using rule 45 (values -> STRING .)
    FLOAT           reduce using rule 45 (values -> STRING .)
    NOT             reduce using rule 45 (values -> STRING .)
    $end            reduce using rule 45 (values -> STRING .)
    RLLAVE          reduce using rule 45 (values -> STRING .)
    INT32           reduce using rule 45 (values -> STRING .)
    INT64           reduce using rule 45 (values -> STRING .)
    FLOAT32         reduce using rule 45 (values -> STRING .)
    FLOAT64         reduce using rule 45 (values -> STRING .)
    BYTE            reduce using rule 45 (values -> STRING .)
    WINT            reduce using rule 45 (values -> STRING .)
    WFLOAT          reduce using rule 45 (values -> STRING .)
    WSTRING         reduce using rule 45 (values -> STRING .)
    BOOL            reduce using rule 45 (values -> STRING .)
    DEFAULT         reduce using rule 45 (values -> STRING .)
    CASE            reduce using rule 45 (values -> STRING .)
    RETURN          reduce using rule 45 (values -> STRING .)
    RPAREN          reduce using rule 45 (values -> STRING .)
    RCORCHE         reduce using rule 45 (values -> STRING .)
    POINTS          reduce using rule 45 (values -> STRING .)
    COMA            reduce using rule 45 (values -> STRING .)


state 146

    (46) values -> INTEGER .
    (239) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for PRINT resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for SCAN resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for FOR resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for CONST resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for ID resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for APPEND resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for LEN resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for COPY resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for DELETE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for IF resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for ELSE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for TYPE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for SWITCH resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for VAR resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for FUNC resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for INTEGER resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for FLOAT resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for NOT resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for INT32 resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for INT64 resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for BYTE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for WINT resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for WSTRING resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for BOOL resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 46 (values -> INTEGER .)
    COLON           reduce using rule 46 (values -> INTEGER .)
    PRINT           reduce using rule 46 (values -> INTEGER .)
    SCAN            reduce using rule 46 (values -> INTEGER .)
    FOR             reduce using rule 46 (values -> INTEGER .)
    CONST           reduce using rule 46 (values -> INTEGER .)
    ID              reduce using rule 46 (values -> INTEGER .)
    APPEND          reduce using rule 46 (values -> INTEGER .)
    LEN             reduce using rule 46 (values -> INTEGER .)
    COPY            reduce using rule 46 (values -> INTEGER .)
    DELETE          reduce using rule 46 (values -> INTEGER .)
    IF              reduce using rule 46 (values -> INTEGER .)
    ELSE            reduce using rule 46 (values -> INTEGER .)
    TYPE            reduce using rule 46 (values -> INTEGER .)
    SWITCH          reduce using rule 46 (values -> INTEGER .)
    VAR             reduce using rule 46 (values -> INTEGER .)
    FUNC            reduce using rule 46 (values -> INTEGER .)
    INTEGER         reduce using rule 46 (values -> INTEGER .)
    FLOAT           reduce using rule 46 (values -> INTEGER .)
    NOT             reduce using rule 46 (values -> INTEGER .)
    $end            reduce using rule 46 (values -> INTEGER .)
    RLLAVE          reduce using rule 46 (values -> INTEGER .)
    INT32           reduce using rule 46 (values -> INTEGER .)
    INT64           reduce using rule 46 (values -> INTEGER .)
    FLOAT32         reduce using rule 46 (values -> INTEGER .)
    FLOAT64         reduce using rule 46 (values -> INTEGER .)
    BYTE            reduce using rule 46 (values -> INTEGER .)
    WINT            reduce using rule 46 (values -> INTEGER .)
    WFLOAT          reduce using rule 46 (values -> INTEGER .)
    WSTRING         reduce using rule 46 (values -> INTEGER .)
    BOOL            reduce using rule 46 (values -> INTEGER .)
    DEFAULT         reduce using rule 46 (values -> INTEGER .)
    CASE            reduce using rule 46 (values -> INTEGER .)
    RETURN          reduce using rule 46 (values -> INTEGER .)
    RPAREN          reduce using rule 46 (values -> INTEGER .)
    COMA            reduce using rule 46 (values -> INTEGER .)
    GREATER         reduce using rule 239 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 239 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 239 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 239 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 239 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 239 (something_ex -> INTEGER .)
    PLUS            reduce using rule 239 (something_ex -> INTEGER .)
    TIMES           reduce using rule 239 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 239 (something_ex -> INTEGER .)
    MINUS           reduce using rule 239 (something_ex -> INTEGER .)
    MOD             reduce using rule 239 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! PRINT           [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! SCAN            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! FOR             [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! CONST           [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! ID              [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! APPEND          [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! LEN             [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! COPY            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! DELETE          [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! IF              [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! ELSE            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! TYPE            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! SWITCH          [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! VAR             [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! FUNC            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! INTEGER         [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! FLOAT           [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! NOT             [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! INT32           [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! INT64           [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! FLOAT32         [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! FLOAT64         [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! BYTE            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! WINT            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! WFLOAT          [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! WSTRING         [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! BOOL            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! RPAREN          [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! COMA            [ reduce using rule 239 (something_ex -> INTEGER .) ]


state 147

    (47) values -> FLOAT .
    (240) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for PRINT resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for SCAN resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for FOR resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for CONST resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for ID resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for APPEND resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for LEN resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for COPY resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for DELETE resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for IF resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for ELSE resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for TYPE resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for SWITCH resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for VAR resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for FUNC resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for INTEGER resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for FLOAT resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for NOT resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for INT32 resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for INT64 resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for BYTE resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for WINT resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for WSTRING resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for BOOL resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for RPAREN resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for COMA resolved using rule 47 (values -> FLOAT .)
    COLON           reduce using rule 47 (values -> FLOAT .)
    PRINT           reduce using rule 47 (values -> FLOAT .)
    SCAN            reduce using rule 47 (values -> FLOAT .)
    FOR             reduce using rule 47 (values -> FLOAT .)
    CONST           reduce using rule 47 (values -> FLOAT .)
    ID              reduce using rule 47 (values -> FLOAT .)
    APPEND          reduce using rule 47 (values -> FLOAT .)
    LEN             reduce using rule 47 (values -> FLOAT .)
    COPY            reduce using rule 47 (values -> FLOAT .)
    DELETE          reduce using rule 47 (values -> FLOAT .)
    IF              reduce using rule 47 (values -> FLOAT .)
    ELSE            reduce using rule 47 (values -> FLOAT .)
    TYPE            reduce using rule 47 (values -> FLOAT .)
    SWITCH          reduce using rule 47 (values -> FLOAT .)
    VAR             reduce using rule 47 (values -> FLOAT .)
    FUNC            reduce using rule 47 (values -> FLOAT .)
    INTEGER         reduce using rule 47 (values -> FLOAT .)
    FLOAT           reduce using rule 47 (values -> FLOAT .)
    NOT             reduce using rule 47 (values -> FLOAT .)
    $end            reduce using rule 47 (values -> FLOAT .)
    RLLAVE          reduce using rule 47 (values -> FLOAT .)
    INT32           reduce using rule 47 (values -> FLOAT .)
    INT64           reduce using rule 47 (values -> FLOAT .)
    FLOAT32         reduce using rule 47 (values -> FLOAT .)
    FLOAT64         reduce using rule 47 (values -> FLOAT .)
    BYTE            reduce using rule 47 (values -> FLOAT .)
    WINT            reduce using rule 47 (values -> FLOAT .)
    WFLOAT          reduce using rule 47 (values -> FLOAT .)
    WSTRING         reduce using rule 47 (values -> FLOAT .)
    BOOL            reduce using rule 47 (values -> FLOAT .)
    DEFAULT         reduce using rule 47 (values -> FLOAT .)
    CASE            reduce using rule 47 (values -> FLOAT .)
    RETURN          reduce using rule 47 (values -> FLOAT .)
    RPAREN          reduce using rule 47 (values -> FLOAT .)
    RCORCHE         reduce using rule 47 (values -> FLOAT .)
    COMA            reduce using rule 47 (values -> FLOAT .)
    GREATER         reduce using rule 240 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 240 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 240 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 240 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 240 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 240 (something_ex -> FLOAT .)
    PLUS            reduce using rule 240 (something_ex -> FLOAT .)
    TIMES           reduce using rule 240 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 240 (something_ex -> FLOAT .)
    MINUS           reduce using rule 240 (something_ex -> FLOAT .)
    MOD             reduce using rule 240 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! PRINT           [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! SCAN            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! FOR             [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! CONST           [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! ID              [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! APPEND          [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! LEN             [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! COPY            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! DELETE          [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! IF              [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! ELSE            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! TYPE            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! SWITCH          [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! VAR             [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! FUNC            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! INTEGER         [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! FLOAT           [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! NOT             [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! INT32           [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! INT64           [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! FLOAT32         [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! FLOAT64         [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! BYTE            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! WINT            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! WFLOAT          [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! WSTRING         [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! BOOL            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! RPAREN          [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! RCORCHE         [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! COMA            [ reduce using rule 240 (something_ex -> FLOAT .) ]


state 148

    (48) values -> TRUE .

    COLON           reduce using rule 48 (values -> TRUE .)
    PRINT           reduce using rule 48 (values -> TRUE .)
    SCAN            reduce using rule 48 (values -> TRUE .)
    FOR             reduce using rule 48 (values -> TRUE .)
    CONST           reduce using rule 48 (values -> TRUE .)
    ID              reduce using rule 48 (values -> TRUE .)
    APPEND          reduce using rule 48 (values -> TRUE .)
    LEN             reduce using rule 48 (values -> TRUE .)
    COPY            reduce using rule 48 (values -> TRUE .)
    DELETE          reduce using rule 48 (values -> TRUE .)
    IF              reduce using rule 48 (values -> TRUE .)
    ELSE            reduce using rule 48 (values -> TRUE .)
    TYPE            reduce using rule 48 (values -> TRUE .)
    SWITCH          reduce using rule 48 (values -> TRUE .)
    VAR             reduce using rule 48 (values -> TRUE .)
    FUNC            reduce using rule 48 (values -> TRUE .)
    INTEGER         reduce using rule 48 (values -> TRUE .)
    FLOAT           reduce using rule 48 (values -> TRUE .)
    NOT             reduce using rule 48 (values -> TRUE .)
    $end            reduce using rule 48 (values -> TRUE .)
    RLLAVE          reduce using rule 48 (values -> TRUE .)
    INT32           reduce using rule 48 (values -> TRUE .)
    INT64           reduce using rule 48 (values -> TRUE .)
    FLOAT32         reduce using rule 48 (values -> TRUE .)
    FLOAT64         reduce using rule 48 (values -> TRUE .)
    BYTE            reduce using rule 48 (values -> TRUE .)
    WINT            reduce using rule 48 (values -> TRUE .)
    WFLOAT          reduce using rule 48 (values -> TRUE .)
    WSTRING         reduce using rule 48 (values -> TRUE .)
    BOOL            reduce using rule 48 (values -> TRUE .)
    DEFAULT         reduce using rule 48 (values -> TRUE .)
    CASE            reduce using rule 48 (values -> TRUE .)
    RETURN          reduce using rule 48 (values -> TRUE .)
    RPAREN          reduce using rule 48 (values -> TRUE .)
    RCORCHE         reduce using rule 48 (values -> TRUE .)
    POINTS          reduce using rule 48 (values -> TRUE .)
    COMA            reduce using rule 48 (values -> TRUE .)


state 149

    (49) values -> FALSE .

    COLON           reduce using rule 49 (values -> FALSE .)
    PRINT           reduce using rule 49 (values -> FALSE .)
    SCAN            reduce using rule 49 (values -> FALSE .)
    FOR             reduce using rule 49 (values -> FALSE .)
    CONST           reduce using rule 49 (values -> FALSE .)
    ID              reduce using rule 49 (values -> FALSE .)
    APPEND          reduce using rule 49 (values -> FALSE .)
    LEN             reduce using rule 49 (values -> FALSE .)
    COPY            reduce using rule 49 (values -> FALSE .)
    DELETE          reduce using rule 49 (values -> FALSE .)
    IF              reduce using rule 49 (values -> FALSE .)
    ELSE            reduce using rule 49 (values -> FALSE .)
    TYPE            reduce using rule 49 (values -> FALSE .)
    SWITCH          reduce using rule 49 (values -> FALSE .)
    VAR             reduce using rule 49 (values -> FALSE .)
    FUNC            reduce using rule 49 (values -> FALSE .)
    INTEGER         reduce using rule 49 (values -> FALSE .)
    FLOAT           reduce using rule 49 (values -> FALSE .)
    NOT             reduce using rule 49 (values -> FALSE .)
    $end            reduce using rule 49 (values -> FALSE .)
    RLLAVE          reduce using rule 49 (values -> FALSE .)
    INT32           reduce using rule 49 (values -> FALSE .)
    INT64           reduce using rule 49 (values -> FALSE .)
    FLOAT32         reduce using rule 49 (values -> FALSE .)
    FLOAT64         reduce using rule 49 (values -> FALSE .)
    BYTE            reduce using rule 49 (values -> FALSE .)
    WINT            reduce using rule 49 (values -> FALSE .)
    WFLOAT          reduce using rule 49 (values -> FALSE .)
    WSTRING         reduce using rule 49 (values -> FALSE .)
    BOOL            reduce using rule 49 (values -> FALSE .)
    DEFAULT         reduce using rule 49 (values -> FALSE .)
    CASE            reduce using rule 49 (values -> FALSE .)
    RETURN          reduce using rule 49 (values -> FALSE .)
    RPAREN          reduce using rule 49 (values -> FALSE .)
    RCORCHE         reduce using rule 49 (values -> FALSE .)
    POINTS          reduce using rule 49 (values -> FALSE .)
    COMA            reduce using rule 49 (values -> FALSE .)


state 150

    (59) operations -> expression .
    (178) value -> expression .

    COLON           reduce using rule 59 (operations -> expression .)
    PRINT           reduce using rule 59 (operations -> expression .)
    SCAN            reduce using rule 59 (operations -> expression .)
    FOR             reduce using rule 59 (operations -> expression .)
    CONST           reduce using rule 59 (operations -> expression .)
    ID              reduce using rule 59 (operations -> expression .)
    APPEND          reduce using rule 59 (operations -> expression .)
    LEN             reduce using rule 59 (operations -> expression .)
    COPY            reduce using rule 59 (operations -> expression .)
    DELETE          reduce using rule 59 (operations -> expression .)
    IF              reduce using rule 59 (operations -> expression .)
    ELSE            reduce using rule 59 (operations -> expression .)
    TYPE            reduce using rule 59 (operations -> expression .)
    SWITCH          reduce using rule 59 (operations -> expression .)
    VAR             reduce using rule 59 (operations -> expression .)
    FUNC            reduce using rule 59 (operations -> expression .)
    INTEGER         reduce using rule 59 (operations -> expression .)
    FLOAT           reduce using rule 59 (operations -> expression .)
    NOT             reduce using rule 59 (operations -> expression .)
    $end            reduce using rule 59 (operations -> expression .)
    RLLAVE          reduce using rule 59 (operations -> expression .)
    INT32           reduce using rule 59 (operations -> expression .)
    INT64           reduce using rule 59 (operations -> expression .)
    FLOAT32         reduce using rule 59 (operations -> expression .)
    FLOAT64         reduce using rule 59 (operations -> expression .)
    BYTE            reduce using rule 59 (operations -> expression .)
    WINT            reduce using rule 59 (operations -> expression .)
    WFLOAT          reduce using rule 59 (operations -> expression .)
    WSTRING         reduce using rule 59 (operations -> expression .)
    BOOL            reduce using rule 59 (operations -> expression .)
    DEFAULT         reduce using rule 59 (operations -> expression .)
    CASE            reduce using rule 59 (operations -> expression .)
    RETURN          reduce using rule 59 (operations -> expression .)
    RPAREN          reduce using rule 59 (operations -> expression .)
    COMA            reduce using rule 59 (operations -> expression .)
    GREATER         reduce using rule 178 (value -> expression .)
    SMALLER         reduce using rule 178 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 178 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 178 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 178 (value -> expression .)
    NOT_EQUAL       reduce using rule 178 (value -> expression .)
    PLUS            reduce using rule 178 (value -> expression .)
    TIMES           reduce using rule 178 (value -> expression .)
    DIVIDE          reduce using rule 178 (value -> expression .)
    MINUS           reduce using rule 178 (value -> expression .)
    MOD             reduce using rule 178 (value -> expression .)


state 151

    (60) operations -> comparison .
    (190) logic_value -> comparison .

    COLON           reduce using rule 60 (operations -> comparison .)
    PRINT           reduce using rule 60 (operations -> comparison .)
    SCAN            reduce using rule 60 (operations -> comparison .)
    FOR             reduce using rule 60 (operations -> comparison .)
    CONST           reduce using rule 60 (operations -> comparison .)
    ID              reduce using rule 60 (operations -> comparison .)
    APPEND          reduce using rule 60 (operations -> comparison .)
    LEN             reduce using rule 60 (operations -> comparison .)
    COPY            reduce using rule 60 (operations -> comparison .)
    DELETE          reduce using rule 60 (operations -> comparison .)
    IF              reduce using rule 60 (operations -> comparison .)
    ELSE            reduce using rule 60 (operations -> comparison .)
    TYPE            reduce using rule 60 (operations -> comparison .)
    SWITCH          reduce using rule 60 (operations -> comparison .)
    VAR             reduce using rule 60 (operations -> comparison .)
    FUNC            reduce using rule 60 (operations -> comparison .)
    INTEGER         reduce using rule 60 (operations -> comparison .)
    FLOAT           reduce using rule 60 (operations -> comparison .)
    NOT             reduce using rule 60 (operations -> comparison .)
    $end            reduce using rule 60 (operations -> comparison .)
    RLLAVE          reduce using rule 60 (operations -> comparison .)
    INT32           reduce using rule 60 (operations -> comparison .)
    INT64           reduce using rule 60 (operations -> comparison .)
    FLOAT32         reduce using rule 60 (operations -> comparison .)
    FLOAT64         reduce using rule 60 (operations -> comparison .)
    BYTE            reduce using rule 60 (operations -> comparison .)
    WINT            reduce using rule 60 (operations -> comparison .)
    WFLOAT          reduce using rule 60 (operations -> comparison .)
    WSTRING         reduce using rule 60 (operations -> comparison .)
    BOOL            reduce using rule 60 (operations -> comparison .)
    DEFAULT         reduce using rule 60 (operations -> comparison .)
    CASE            reduce using rule 60 (operations -> comparison .)
    RETURN          reduce using rule 60 (operations -> comparison .)
    RPAREN          reduce using rule 60 (operations -> comparison .)
    RCORCHE         reduce using rule 60 (operations -> comparison .)
    COMA            reduce using rule 60 (operations -> comparison .)
    AND             reduce using rule 190 (logic_value -> comparison .)
    OR              reduce using rule 190 (logic_value -> comparison .)


state 152

    (61) operations -> logic_operation .

    COLON           reduce using rule 61 (operations -> logic_operation .)
    PRINT           reduce using rule 61 (operations -> logic_operation .)
    SCAN            reduce using rule 61 (operations -> logic_operation .)
    FOR             reduce using rule 61 (operations -> logic_operation .)
    CONST           reduce using rule 61 (operations -> logic_operation .)
    ID              reduce using rule 61 (operations -> logic_operation .)
    APPEND          reduce using rule 61 (operations -> logic_operation .)
    LEN             reduce using rule 61 (operations -> logic_operation .)
    COPY            reduce using rule 61 (operations -> logic_operation .)
    DELETE          reduce using rule 61 (operations -> logic_operation .)
    IF              reduce using rule 61 (operations -> logic_operation .)
    ELSE            reduce using rule 61 (operations -> logic_operation .)
    TYPE            reduce using rule 61 (operations -> logic_operation .)
    SWITCH          reduce using rule 61 (operations -> logic_operation .)
    VAR             reduce using rule 61 (operations -> logic_operation .)
    FUNC            reduce using rule 61 (operations -> logic_operation .)
    INTEGER         reduce using rule 61 (operations -> logic_operation .)
    FLOAT           reduce using rule 61 (operations -> logic_operation .)
    NOT             reduce using rule 61 (operations -> logic_operation .)
    $end            reduce using rule 61 (operations -> logic_operation .)
    RLLAVE          reduce using rule 61 (operations -> logic_operation .)
    INT32           reduce using rule 61 (operations -> logic_operation .)
    INT64           reduce using rule 61 (operations -> logic_operation .)
    FLOAT32         reduce using rule 61 (operations -> logic_operation .)
    FLOAT64         reduce using rule 61 (operations -> logic_operation .)
    BYTE            reduce using rule 61 (operations -> logic_operation .)
    WINT            reduce using rule 61 (operations -> logic_operation .)
    WFLOAT          reduce using rule 61 (operations -> logic_operation .)
    WSTRING         reduce using rule 61 (operations -> logic_operation .)
    BOOL            reduce using rule 61 (operations -> logic_operation .)
    DEFAULT         reduce using rule 61 (operations -> logic_operation .)
    CASE            reduce using rule 61 (operations -> logic_operation .)
    RETURN          reduce using rule 61 (operations -> logic_operation .)
    RPAREN          reduce using rule 61 (operations -> logic_operation .)
    RCORCHE         reduce using rule 61 (operations -> logic_operation .)
    COMA            reduce using rule 61 (operations -> logic_operation .)


state 153

    (145) slice_assignment -> slice_var EQUAL something_s .

    COLON           reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    PRINT           reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    SCAN            reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    FOR             reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    CONST           reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    ID              reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    APPEND          reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    LEN             reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    COPY            reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    DELETE          reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    IF              reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    ELSE            reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    TYPE            reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    SWITCH          reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    VAR             reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    FUNC            reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    INTEGER         reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    FLOAT           reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    NOT             reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    $end            reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    RLLAVE          reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    INT32           reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    INT64           reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    FLOAT32         reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    FLOAT64         reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    BYTE            reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    WINT            reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    WFLOAT          reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    WSTRING         reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    BOOL            reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    DEFAULT         reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    CASE            reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)
    RETURN          reduce using rule 145 (slice_assignment -> slice_var EQUAL something_s .)


state 154

    (146) something_s -> ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (238) something_ex -> ID .
    (177) value -> ID .
    (191) logic_value -> ID .
    (212) map_var -> ID . LCORCHE key RCORCHE
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for COLON resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for CONST resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for INT32 resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for INT64 resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for BYTE resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for WINT resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for WSTRING resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 146 (something_s -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 177 (value -> ID .)
    COLON           reduce using rule 146 (something_s -> ID .)
    PRINT           reduce using rule 146 (something_s -> ID .)
    SCAN            reduce using rule 146 (something_s -> ID .)
    FOR             reduce using rule 146 (something_s -> ID .)
    CONST           reduce using rule 146 (something_s -> ID .)
    ID              reduce using rule 146 (something_s -> ID .)
    APPEND          reduce using rule 146 (something_s -> ID .)
    LEN             reduce using rule 146 (something_s -> ID .)
    COPY            reduce using rule 146 (something_s -> ID .)
    DELETE          reduce using rule 146 (something_s -> ID .)
    IF              reduce using rule 146 (something_s -> ID .)
    ELSE            reduce using rule 146 (something_s -> ID .)
    TYPE            reduce using rule 146 (something_s -> ID .)
    SWITCH          reduce using rule 146 (something_s -> ID .)
    VAR             reduce using rule 146 (something_s -> ID .)
    FUNC            reduce using rule 146 (something_s -> ID .)
    INTEGER         reduce using rule 146 (something_s -> ID .)
    FLOAT           reduce using rule 146 (something_s -> ID .)
    NOT             reduce using rule 146 (something_s -> ID .)
    $end            reduce using rule 146 (something_s -> ID .)
    RLLAVE          reduce using rule 146 (something_s -> ID .)
    INT32           reduce using rule 146 (something_s -> ID .)
    INT64           reduce using rule 146 (something_s -> ID .)
    FLOAT32         reduce using rule 146 (something_s -> ID .)
    FLOAT64         reduce using rule 146 (something_s -> ID .)
    BYTE            reduce using rule 146 (something_s -> ID .)
    WINT            reduce using rule 146 (something_s -> ID .)
    WFLOAT          reduce using rule 146 (something_s -> ID .)
    WSTRING         reduce using rule 146 (something_s -> ID .)
    BOOL            reduce using rule 146 (something_s -> ID .)
    DEFAULT         reduce using rule 146 (something_s -> ID .)
    CASE            reduce using rule 146 (something_s -> ID .)
    RETURN          reduce using rule 146 (something_s -> ID .)
    LCORCHE         shift and go to state 172
    GREATER         reduce using rule 177 (value -> ID .)
    SMALLER         reduce using rule 177 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 177 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 177 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 177 (value -> ID .)
    NOT_EQUAL       reduce using rule 177 (value -> ID .)
    PLUS            reduce using rule 177 (value -> ID .)
    TIMES           reduce using rule 177 (value -> ID .)
    DIVIDE          reduce using rule 177 (value -> ID .)
    MINUS           reduce using rule 177 (value -> ID .)
    MOD             reduce using rule 177 (value -> ID .)
    AND             reduce using rule 191 (logic_value -> ID .)
    OR              reduce using rule 191 (logic_value -> ID .)
    LPAREN          shift and go to state 111

  ! GREATER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 238 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 238 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 238 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 238 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 238 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 238 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 238 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 238 (something_ex -> ID .) ]
  ! CONST           [ reduce using rule 238 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 238 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 238 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 238 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 238 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 238 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 238 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 238 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 238 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 238 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 238 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! INT32           [ reduce using rule 238 (something_ex -> ID .) ]
  ! INT64           [ reduce using rule 238 (something_ex -> ID .) ]
  ! FLOAT32         [ reduce using rule 238 (something_ex -> ID .) ]
  ! FLOAT64         [ reduce using rule 238 (something_ex -> ID .) ]
  ! BYTE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! WINT            [ reduce using rule 238 (something_ex -> ID .) ]
  ! WFLOAT          [ reduce using rule 238 (something_ex -> ID .) ]
  ! WSTRING         [ reduce using rule 238 (something_ex -> ID .) ]
  ! BOOL            [ reduce using rule 238 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 238 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 238 (something_ex -> ID .) ]


state 155

    (147) something_s -> array_var .
    (62) data_structure -> array_var .

  ! reduce/reduce conflict for COLON resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for PRINT resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for SCAN resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for FOR resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for CONST resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for ID resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for APPEND resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for LEN resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for COPY resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for DELETE resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for IF resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for ELSE resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for TYPE resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for SWITCH resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for VAR resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for FUNC resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for INTEGER resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for FLOAT resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for NOT resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for $end resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for INT32 resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for INT64 resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for BYTE resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for WINT resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for WSTRING resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for BOOL resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for CASE resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for RETURN resolved using rule 62 (data_structure -> array_var .)
    GREATER         reduce using rule 62 (data_structure -> array_var .)
    SMALLER         reduce using rule 62 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 62 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 62 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 62 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 62 (data_structure -> array_var .)
    PLUS            reduce using rule 62 (data_structure -> array_var .)
    TIMES           reduce using rule 62 (data_structure -> array_var .)
    DIVIDE          reduce using rule 62 (data_structure -> array_var .)
    MINUS           reduce using rule 62 (data_structure -> array_var .)
    MOD             reduce using rule 62 (data_structure -> array_var .)
    COLON           reduce using rule 62 (data_structure -> array_var .)
    PRINT           reduce using rule 62 (data_structure -> array_var .)
    SCAN            reduce using rule 62 (data_structure -> array_var .)
    FOR             reduce using rule 62 (data_structure -> array_var .)
    CONST           reduce using rule 62 (data_structure -> array_var .)
    ID              reduce using rule 62 (data_structure -> array_var .)
    APPEND          reduce using rule 62 (data_structure -> array_var .)
    LEN             reduce using rule 62 (data_structure -> array_var .)
    COPY            reduce using rule 62 (data_structure -> array_var .)
    DELETE          reduce using rule 62 (data_structure -> array_var .)
    IF              reduce using rule 62 (data_structure -> array_var .)
    ELSE            reduce using rule 62 (data_structure -> array_var .)
    TYPE            reduce using rule 62 (data_structure -> array_var .)
    SWITCH          reduce using rule 62 (data_structure -> array_var .)
    VAR             reduce using rule 62 (data_structure -> array_var .)
    FUNC            reduce using rule 62 (data_structure -> array_var .)
    INTEGER         reduce using rule 62 (data_structure -> array_var .)
    FLOAT           reduce using rule 62 (data_structure -> array_var .)
    NOT             reduce using rule 62 (data_structure -> array_var .)
    $end            reduce using rule 62 (data_structure -> array_var .)
    RLLAVE          reduce using rule 62 (data_structure -> array_var .)
    INT32           reduce using rule 62 (data_structure -> array_var .)
    INT64           reduce using rule 62 (data_structure -> array_var .)
    FLOAT32         reduce using rule 62 (data_structure -> array_var .)
    FLOAT64         reduce using rule 62 (data_structure -> array_var .)
    BYTE            reduce using rule 62 (data_structure -> array_var .)
    WINT            reduce using rule 62 (data_structure -> array_var .)
    WFLOAT          reduce using rule 62 (data_structure -> array_var .)
    WSTRING         reduce using rule 62 (data_structure -> array_var .)
    BOOL            reduce using rule 62 (data_structure -> array_var .)
    DEFAULT         reduce using rule 62 (data_structure -> array_var .)
    CASE            reduce using rule 62 (data_structure -> array_var .)
    RETURN          reduce using rule 62 (data_structure -> array_var .)

  ! COLON           [ reduce using rule 147 (something_s -> array_var .) ]
  ! PRINT           [ reduce using rule 147 (something_s -> array_var .) ]
  ! SCAN            [ reduce using rule 147 (something_s -> array_var .) ]
  ! FOR             [ reduce using rule 147 (something_s -> array_var .) ]
  ! CONST           [ reduce using rule 147 (something_s -> array_var .) ]
  ! ID              [ reduce using rule 147 (something_s -> array_var .) ]
  ! APPEND          [ reduce using rule 147 (something_s -> array_var .) ]
  ! LEN             [ reduce using rule 147 (something_s -> array_var .) ]
  ! COPY            [ reduce using rule 147 (something_s -> array_var .) ]
  ! DELETE          [ reduce using rule 147 (something_s -> array_var .) ]
  ! IF              [ reduce using rule 147 (something_s -> array_var .) ]
  ! ELSE            [ reduce using rule 147 (something_s -> array_var .) ]
  ! TYPE            [ reduce using rule 147 (something_s -> array_var .) ]
  ! SWITCH          [ reduce using rule 147 (something_s -> array_var .) ]
  ! VAR             [ reduce using rule 147 (something_s -> array_var .) ]
  ! FUNC            [ reduce using rule 147 (something_s -> array_var .) ]
  ! INTEGER         [ reduce using rule 147 (something_s -> array_var .) ]
  ! FLOAT           [ reduce using rule 147 (something_s -> array_var .) ]
  ! NOT             [ reduce using rule 147 (something_s -> array_var .) ]
  ! $end            [ reduce using rule 147 (something_s -> array_var .) ]
  ! RLLAVE          [ reduce using rule 147 (something_s -> array_var .) ]
  ! INT32           [ reduce using rule 147 (something_s -> array_var .) ]
  ! INT64           [ reduce using rule 147 (something_s -> array_var .) ]
  ! FLOAT32         [ reduce using rule 147 (something_s -> array_var .) ]
  ! FLOAT64         [ reduce using rule 147 (something_s -> array_var .) ]
  ! BYTE            [ reduce using rule 147 (something_s -> array_var .) ]
  ! WINT            [ reduce using rule 147 (something_s -> array_var .) ]
  ! WFLOAT          [ reduce using rule 147 (something_s -> array_var .) ]
  ! WSTRING         [ reduce using rule 147 (something_s -> array_var .) ]
  ! BOOL            [ reduce using rule 147 (something_s -> array_var .) ]
  ! DEFAULT         [ reduce using rule 147 (something_s -> array_var .) ]
  ! CASE            [ reduce using rule 147 (something_s -> array_var .) ]
  ! RETURN          [ reduce using rule 147 (something_s -> array_var .) ]


state 156

    (148) something_s -> values .

    COLON           reduce using rule 148 (something_s -> values .)
    PRINT           reduce using rule 148 (something_s -> values .)
    SCAN            reduce using rule 148 (something_s -> values .)
    FOR             reduce using rule 148 (something_s -> values .)
    CONST           reduce using rule 148 (something_s -> values .)
    ID              reduce using rule 148 (something_s -> values .)
    APPEND          reduce using rule 148 (something_s -> values .)
    LEN             reduce using rule 148 (something_s -> values .)
    COPY            reduce using rule 148 (something_s -> values .)
    DELETE          reduce using rule 148 (something_s -> values .)
    IF              reduce using rule 148 (something_s -> values .)
    ELSE            reduce using rule 148 (something_s -> values .)
    TYPE            reduce using rule 148 (something_s -> values .)
    SWITCH          reduce using rule 148 (something_s -> values .)
    VAR             reduce using rule 148 (something_s -> values .)
    FUNC            reduce using rule 148 (something_s -> values .)
    INTEGER         reduce using rule 148 (something_s -> values .)
    FLOAT           reduce using rule 148 (something_s -> values .)
    NOT             reduce using rule 148 (something_s -> values .)
    $end            reduce using rule 148 (something_s -> values .)
    RLLAVE          reduce using rule 148 (something_s -> values .)
    INT32           reduce using rule 148 (something_s -> values .)
    INT64           reduce using rule 148 (something_s -> values .)
    FLOAT32         reduce using rule 148 (something_s -> values .)
    FLOAT64         reduce using rule 148 (something_s -> values .)
    BYTE            reduce using rule 148 (something_s -> values .)
    WINT            reduce using rule 148 (something_s -> values .)
    WFLOAT          reduce using rule 148 (something_s -> values .)
    WSTRING         reduce using rule 148 (something_s -> values .)
    BOOL            reduce using rule 148 (something_s -> values .)
    DEFAULT         reduce using rule 148 (something_s -> values .)
    CASE            reduce using rule 148 (something_s -> values .)
    RETURN          reduce using rule 148 (something_s -> values .)


state 157

    (149) something_s -> operations .

    COLON           reduce using rule 149 (something_s -> operations .)
    PRINT           reduce using rule 149 (something_s -> operations .)
    SCAN            reduce using rule 149 (something_s -> operations .)
    FOR             reduce using rule 149 (something_s -> operations .)
    CONST           reduce using rule 149 (something_s -> operations .)
    ID              reduce using rule 149 (something_s -> operations .)
    APPEND          reduce using rule 149 (something_s -> operations .)
    LEN             reduce using rule 149 (something_s -> operations .)
    COPY            reduce using rule 149 (something_s -> operations .)
    DELETE          reduce using rule 149 (something_s -> operations .)
    IF              reduce using rule 149 (something_s -> operations .)
    ELSE            reduce using rule 149 (something_s -> operations .)
    TYPE            reduce using rule 149 (something_s -> operations .)
    SWITCH          reduce using rule 149 (something_s -> operations .)
    VAR             reduce using rule 149 (something_s -> operations .)
    FUNC            reduce using rule 149 (something_s -> operations .)
    INTEGER         reduce using rule 149 (something_s -> operations .)
    FLOAT           reduce using rule 149 (something_s -> operations .)
    NOT             reduce using rule 149 (something_s -> operations .)
    $end            reduce using rule 149 (something_s -> operations .)
    RLLAVE          reduce using rule 149 (something_s -> operations .)
    INT32           reduce using rule 149 (something_s -> operations .)
    INT64           reduce using rule 149 (something_s -> operations .)
    FLOAT32         reduce using rule 149 (something_s -> operations .)
    FLOAT64         reduce using rule 149 (something_s -> operations .)
    BYTE            reduce using rule 149 (something_s -> operations .)
    WINT            reduce using rule 149 (something_s -> operations .)
    WFLOAT          reduce using rule 149 (something_s -> operations .)
    WSTRING         reduce using rule 149 (something_s -> operations .)
    BOOL            reduce using rule 149 (something_s -> operations .)
    DEFAULT         reduce using rule 149 (something_s -> operations .)
    CASE            reduce using rule 149 (something_s -> operations .)
    RETURN          reduce using rule 149 (something_s -> operations .)


state 158

    (228) impresion -> PRINT LPAREN content . RPAREN

    RPAREN          shift and go to state 243


state 159

    (229) content -> values .

    RPAREN          reduce using rule 229 (content -> values .)


state 160

    (230) content -> operations .

    RPAREN          reduce using rule 230 (content -> operations .)


state 161

    (231) content -> funciones .
    (242) something_ex -> funciones .

  ! reduce/reduce conflict for RPAREN resolved using rule 231 (content -> funciones .)
    RPAREN          reduce using rule 231 (content -> funciones .)
    GREATER         reduce using rule 242 (something_ex -> funciones .)
    SMALLER         reduce using rule 242 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 242 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 242 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 242 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 242 (something_ex -> funciones .)
    PLUS            reduce using rule 242 (something_ex -> funciones .)
    TIMES           reduce using rule 242 (something_ex -> funciones .)
    DIVIDE          reduce using rule 242 (something_ex -> funciones .)
    MINUS           reduce using rule 242 (something_ex -> funciones .)
    MOD             reduce using rule 242 (something_ex -> funciones .)

  ! RPAREN          [ reduce using rule 242 (something_ex -> funciones .) ]


state 162

    (232) content -> data_structure .
    (241) something_ex -> data_structure .

  ! reduce/reduce conflict for RPAREN resolved using rule 232 (content -> data_structure .)
    RPAREN          reduce using rule 232 (content -> data_structure .)
    GREATER         reduce using rule 241 (something_ex -> data_structure .)
    SMALLER         reduce using rule 241 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 241 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 241 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 241 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 241 (something_ex -> data_structure .)
    PLUS            reduce using rule 241 (something_ex -> data_structure .)
    TIMES           reduce using rule 241 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 241 (something_ex -> data_structure .)
    MINUS           reduce using rule 241 (something_ex -> data_structure .)
    MOD             reduce using rule 241 (something_ex -> data_structure .)

  ! RPAREN          [ reduce using rule 241 (something_ex -> data_structure .) ]


state 163

    (233) content -> ID .
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE
    (238) something_ex -> ID .
    (177) value -> ID .
    (191) logic_value -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 233 (content -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 177 (value -> ID .)
    RPAREN          reduce using rule 233 (content -> ID .)
    LPAREN          shift and go to state 111
    LCORCHE         shift and go to state 172
    GREATER         reduce using rule 177 (value -> ID .)
    SMALLER         reduce using rule 177 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 177 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 177 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 177 (value -> ID .)
    NOT_EQUAL       reduce using rule 177 (value -> ID .)
    PLUS            reduce using rule 177 (value -> ID .)
    TIMES           reduce using rule 177 (value -> ID .)
    DIVIDE          reduce using rule 177 (value -> ID .)
    MINUS           reduce using rule 177 (value -> ID .)
    MOD             reduce using rule 177 (value -> ID .)
    AND             reduce using rule 191 (logic_value -> ID .)
    OR              reduce using rule 191 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 238 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 238 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 238 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 238 (something_ex -> ID .) ]
  ! RPAREN          [ reduce using rule 238 (something_ex -> ID .) ]


state 164

    (81) scan_func -> SCAN LPAREN POINTER . RPAREN

    RPAREN          shift and go to state 244


state 165

    (236) adicionaEx -> op something_ex .
    (237) adicionaEx -> op something_ex . adicionaEx
    (236) adicionaEx -> . op something_ex
    (237) adicionaEx -> . op something_ex adicionaEx
    (179) op -> . GREATER
    (180) op -> . SMALLER
    (181) op -> . GREATER_OR_EQUAL
    (182) op -> . SMALLER_OR_EQUAL
    (183) op -> . EQUAL_COMPARE
    (184) op -> . NOT_EQUAL
    (243) op -> . PLUS
    (244) op -> . TIMES
    (245) op -> . DIVIDE
    (246) op -> . MINUS
    (247) op -> . MOD

  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL_COMPARE resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
    COLON           reduce using rule 236 (adicionaEx -> op something_ex .)
    PRINT           reduce using rule 236 (adicionaEx -> op something_ex .)
    SCAN            reduce using rule 236 (adicionaEx -> op something_ex .)
    FOR             reduce using rule 236 (adicionaEx -> op something_ex .)
    CONST           reduce using rule 236 (adicionaEx -> op something_ex .)
    ID              reduce using rule 236 (adicionaEx -> op something_ex .)
    APPEND          reduce using rule 236 (adicionaEx -> op something_ex .)
    LEN             reduce using rule 236 (adicionaEx -> op something_ex .)
    COPY            reduce using rule 236 (adicionaEx -> op something_ex .)
    DELETE          reduce using rule 236 (adicionaEx -> op something_ex .)
    IF              reduce using rule 236 (adicionaEx -> op something_ex .)
    ELSE            reduce using rule 236 (adicionaEx -> op something_ex .)
    TYPE            reduce using rule 236 (adicionaEx -> op something_ex .)
    SWITCH          reduce using rule 236 (adicionaEx -> op something_ex .)
    VAR             reduce using rule 236 (adicionaEx -> op something_ex .)
    FUNC            reduce using rule 236 (adicionaEx -> op something_ex .)
    INTEGER         reduce using rule 236 (adicionaEx -> op something_ex .)
    FLOAT           reduce using rule 236 (adicionaEx -> op something_ex .)
    NOT             reduce using rule 236 (adicionaEx -> op something_ex .)
    $end            reduce using rule 236 (adicionaEx -> op something_ex .)
    RLLAVE          reduce using rule 236 (adicionaEx -> op something_ex .)
    INT32           reduce using rule 236 (adicionaEx -> op something_ex .)
    INT64           reduce using rule 236 (adicionaEx -> op something_ex .)
    FLOAT32         reduce using rule 236 (adicionaEx -> op something_ex .)
    FLOAT64         reduce using rule 236 (adicionaEx -> op something_ex .)
    BYTE            reduce using rule 236 (adicionaEx -> op something_ex .)
    WINT            reduce using rule 236 (adicionaEx -> op something_ex .)
    WFLOAT          reduce using rule 236 (adicionaEx -> op something_ex .)
    WSTRING         reduce using rule 236 (adicionaEx -> op something_ex .)
    BOOL            reduce using rule 236 (adicionaEx -> op something_ex .)
    DEFAULT         reduce using rule 236 (adicionaEx -> op something_ex .)
    CASE            reduce using rule 236 (adicionaEx -> op something_ex .)
    RETURN          reduce using rule 236 (adicionaEx -> op something_ex .)
    RPAREN          reduce using rule 236 (adicionaEx -> op something_ex .)
    AND             reduce using rule 236 (adicionaEx -> op something_ex .)
    OR              reduce using rule 236 (adicionaEx -> op something_ex .)
    LLLAVE          reduce using rule 236 (adicionaEx -> op something_ex .)
    RCORCHE         reduce using rule 236 (adicionaEx -> op something_ex .)
    COMA            reduce using rule 236 (adicionaEx -> op something_ex .)
    GREATER         shift and go to state 82
    SMALLER         shift and go to state 83
    GREATER_OR_EQUAL shift and go to state 84
    SMALLER_OR_EQUAL shift and go to state 85
    EQUAL_COMPARE   shift and go to state 86
    NOT_EQUAL       shift and go to state 87
    PLUS            shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MINUS           shift and go to state 91
    MOD             shift and go to state 92

  ! GREATER         [ reduce using rule 236 (adicionaEx -> op something_ex .) ]
  ! SMALLER         [ reduce using rule 236 (adicionaEx -> op something_ex .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 236 (adicionaEx -> op something_ex .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 236 (adicionaEx -> op something_ex .) ]
  ! EQUAL_COMPARE   [ reduce using rule 236 (adicionaEx -> op something_ex .) ]
  ! NOT_EQUAL       [ reduce using rule 236 (adicionaEx -> op something_ex .) ]
  ! PLUS            [ reduce using rule 236 (adicionaEx -> op something_ex .) ]
  ! TIMES           [ reduce using rule 236 (adicionaEx -> op something_ex .) ]
  ! DIVIDE          [ reduce using rule 236 (adicionaEx -> op something_ex .) ]
  ! MINUS           [ reduce using rule 236 (adicionaEx -> op something_ex .) ]
  ! MOD             [ reduce using rule 236 (adicionaEx -> op something_ex .) ]

    op                             shift and go to state 81
    adicionaEx                     shift and go to state 245

state 166

    (238) something_ex -> ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN

    GREATER         reduce using rule 238 (something_ex -> ID .)
    SMALLER         reduce using rule 238 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 238 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 238 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 238 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 238 (something_ex -> ID .)
    PLUS            reduce using rule 238 (something_ex -> ID .)
    TIMES           reduce using rule 238 (something_ex -> ID .)
    DIVIDE          reduce using rule 238 (something_ex -> ID .)
    MINUS           reduce using rule 238 (something_ex -> ID .)
    MOD             reduce using rule 238 (something_ex -> ID .)
    COLON           reduce using rule 238 (something_ex -> ID .)
    PRINT           reduce using rule 238 (something_ex -> ID .)
    SCAN            reduce using rule 238 (something_ex -> ID .)
    FOR             reduce using rule 238 (something_ex -> ID .)
    CONST           reduce using rule 238 (something_ex -> ID .)
    ID              reduce using rule 238 (something_ex -> ID .)
    APPEND          reduce using rule 238 (something_ex -> ID .)
    LEN             reduce using rule 238 (something_ex -> ID .)
    COPY            reduce using rule 238 (something_ex -> ID .)
    DELETE          reduce using rule 238 (something_ex -> ID .)
    IF              reduce using rule 238 (something_ex -> ID .)
    ELSE            reduce using rule 238 (something_ex -> ID .)
    TYPE            reduce using rule 238 (something_ex -> ID .)
    SWITCH          reduce using rule 238 (something_ex -> ID .)
    VAR             reduce using rule 238 (something_ex -> ID .)
    FUNC            reduce using rule 238 (something_ex -> ID .)
    INTEGER         reduce using rule 238 (something_ex -> ID .)
    FLOAT           reduce using rule 238 (something_ex -> ID .)
    NOT             reduce using rule 238 (something_ex -> ID .)
    $end            reduce using rule 238 (something_ex -> ID .)
    RLLAVE          reduce using rule 238 (something_ex -> ID .)
    INT32           reduce using rule 238 (something_ex -> ID .)
    INT64           reduce using rule 238 (something_ex -> ID .)
    FLOAT32         reduce using rule 238 (something_ex -> ID .)
    FLOAT64         reduce using rule 238 (something_ex -> ID .)
    BYTE            reduce using rule 238 (something_ex -> ID .)
    WINT            reduce using rule 238 (something_ex -> ID .)
    WFLOAT          reduce using rule 238 (something_ex -> ID .)
    WSTRING         reduce using rule 238 (something_ex -> ID .)
    BOOL            reduce using rule 238 (something_ex -> ID .)
    DEFAULT         reduce using rule 238 (something_ex -> ID .)
    CASE            reduce using rule 238 (something_ex -> ID .)
    RETURN          reduce using rule 238 (something_ex -> ID .)
    RPAREN          reduce using rule 238 (something_ex -> ID .)
    AND             reduce using rule 238 (something_ex -> ID .)
    OR              reduce using rule 238 (something_ex -> ID .)
    LLLAVE          reduce using rule 238 (something_ex -> ID .)
    RCORCHE         reduce using rule 238 (something_ex -> ID .)
    COMA            reduce using rule 238 (something_ex -> ID .)
    LCORCHE         shift and go to state 172
    LPAREN          shift and go to state 111


state 167

    (87) cicloFor -> FOR LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 246


state 168

    (88) cicloFor -> FOR comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    comparison                     shift and go to state 8
    codigo                         shift and go to state 247
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 169

    (89) cicloFor -> FOR logic_operation LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    logic_operation                shift and go to state 9
    codigo                         shift and go to state 248
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 170

    (90) cicloFor -> FOR decVarOne COLON . comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (177) value -> . ID
    (178) value -> . expression
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 119
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    comparison                     shift and go to state 249
    value                          shift and go to state 34
    expression                     shift and go to state 98
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 171

    (156) decVarOne -> ID DEQUAL . ID
    (157) decVarOne -> ID DEQUAL . INTEGER

    ID              shift and go to state 250
    INTEGER         shift and go to state 251


state 172

    (206) array_var -> ID LCORCHE . index RCORCHE
    (212) map_var -> ID LCORCHE . key RCORCHE
    (207) index -> . ID
    (208) index -> . INTEGER
    (209) index -> . expression
    (213) key -> . ID
    (214) key -> . values
    (215) key -> . operations
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 252
    INTEGER         shift and go to state 253
    STRING          shift and go to state 145
    FLOAT           shift and go to state 147
    TRUE            shift and go to state 148
    FALSE           shift and go to state 149
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    NOT             shift and go to state 56

    index                          shift and go to state 204
    key                            shift and go to state 206
    expression                     shift and go to state 254
    values                         shift and go to state 209
    operations                     shift and go to state 210
    something_ex                   shift and go to state 32
    comparison                     shift and go to state 151
    logic_operation                shift and go to state 152
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 173

    (176) comparison -> value op value .

    PRINT           reduce using rule 176 (comparison -> value op value .)
    SCAN            reduce using rule 176 (comparison -> value op value .)
    FOR             reduce using rule 176 (comparison -> value op value .)
    CONST           reduce using rule 176 (comparison -> value op value .)
    ID              reduce using rule 176 (comparison -> value op value .)
    APPEND          reduce using rule 176 (comparison -> value op value .)
    LEN             reduce using rule 176 (comparison -> value op value .)
    COPY            reduce using rule 176 (comparison -> value op value .)
    DELETE          reduce using rule 176 (comparison -> value op value .)
    IF              reduce using rule 176 (comparison -> value op value .)
    ELSE            reduce using rule 176 (comparison -> value op value .)
    TYPE            reduce using rule 176 (comparison -> value op value .)
    SWITCH          reduce using rule 176 (comparison -> value op value .)
    VAR             reduce using rule 176 (comparison -> value op value .)
    FUNC            reduce using rule 176 (comparison -> value op value .)
    INTEGER         reduce using rule 176 (comparison -> value op value .)
    FLOAT           reduce using rule 176 (comparison -> value op value .)
    NOT             reduce using rule 176 (comparison -> value op value .)
    $end            reduce using rule 176 (comparison -> value op value .)
    AND             reduce using rule 176 (comparison -> value op value .)
    OR              reduce using rule 176 (comparison -> value op value .)
    RLLAVE          reduce using rule 176 (comparison -> value op value .)
    INT32           reduce using rule 176 (comparison -> value op value .)
    INT64           reduce using rule 176 (comparison -> value op value .)
    FLOAT32         reduce using rule 176 (comparison -> value op value .)
    FLOAT64         reduce using rule 176 (comparison -> value op value .)
    BYTE            reduce using rule 176 (comparison -> value op value .)
    WINT            reduce using rule 176 (comparison -> value op value .)
    WFLOAT          reduce using rule 176 (comparison -> value op value .)
    WSTRING         reduce using rule 176 (comparison -> value op value .)
    BOOL            reduce using rule 176 (comparison -> value op value .)
    DEFAULT         reduce using rule 176 (comparison -> value op value .)
    CASE            reduce using rule 176 (comparison -> value op value .)
    RETURN          reduce using rule 176 (comparison -> value op value .)
    LLLAVE          reduce using rule 176 (comparison -> value op value .)
    COLON           reduce using rule 176 (comparison -> value op value .)
    RPAREN          reduce using rule 176 (comparison -> value op value .)
    RCORCHE         reduce using rule 176 (comparison -> value op value .)
    COMA            reduce using rule 176 (comparison -> value op value .)


state 174

    (187) logic_recu -> logic_op logic_value .
    (188) logic_recu -> logic_op logic_value . logic_recu
    (187) logic_recu -> . logic_op logic_value
    (188) logic_recu -> . logic_op logic_value logic_recu
    (194) logic_op -> . AND
    (195) logic_op -> . OR

    PRINT           reduce using rule 187 (logic_recu -> logic_op logic_value .)
    SCAN            reduce using rule 187 (logic_recu -> logic_op logic_value .)
    FOR             reduce using rule 187 (logic_recu -> logic_op logic_value .)
    CONST           reduce using rule 187 (logic_recu -> logic_op logic_value .)
    ID              reduce using rule 187 (logic_recu -> logic_op logic_value .)
    APPEND          reduce using rule 187 (logic_recu -> logic_op logic_value .)
    LEN             reduce using rule 187 (logic_recu -> logic_op logic_value .)
    COPY            reduce using rule 187 (logic_recu -> logic_op logic_value .)
    DELETE          reduce using rule 187 (logic_recu -> logic_op logic_value .)
    IF              reduce using rule 187 (logic_recu -> logic_op logic_value .)
    ELSE            reduce using rule 187 (logic_recu -> logic_op logic_value .)
    TYPE            reduce using rule 187 (logic_recu -> logic_op logic_value .)
    SWITCH          reduce using rule 187 (logic_recu -> logic_op logic_value .)
    VAR             reduce using rule 187 (logic_recu -> logic_op logic_value .)
    FUNC            reduce using rule 187 (logic_recu -> logic_op logic_value .)
    INTEGER         reduce using rule 187 (logic_recu -> logic_op logic_value .)
    FLOAT           reduce using rule 187 (logic_recu -> logic_op logic_value .)
    NOT             reduce using rule 187 (logic_recu -> logic_op logic_value .)
    $end            reduce using rule 187 (logic_recu -> logic_op logic_value .)
    RLLAVE          reduce using rule 187 (logic_recu -> logic_op logic_value .)
    INT32           reduce using rule 187 (logic_recu -> logic_op logic_value .)
    INT64           reduce using rule 187 (logic_recu -> logic_op logic_value .)
    FLOAT32         reduce using rule 187 (logic_recu -> logic_op logic_value .)
    FLOAT64         reduce using rule 187 (logic_recu -> logic_op logic_value .)
    BYTE            reduce using rule 187 (logic_recu -> logic_op logic_value .)
    WINT            reduce using rule 187 (logic_recu -> logic_op logic_value .)
    WFLOAT          reduce using rule 187 (logic_recu -> logic_op logic_value .)
    WSTRING         reduce using rule 187 (logic_recu -> logic_op logic_value .)
    BOOL            reduce using rule 187 (logic_recu -> logic_op logic_value .)
    DEFAULT         reduce using rule 187 (logic_recu -> logic_op logic_value .)
    CASE            reduce using rule 187 (logic_recu -> logic_op logic_value .)
    RETURN          reduce using rule 187 (logic_recu -> logic_op logic_value .)
    LLLAVE          reduce using rule 187 (logic_recu -> logic_op logic_value .)
    COLON           reduce using rule 187 (logic_recu -> logic_op logic_value .)
    RPAREN          reduce using rule 187 (logic_recu -> logic_op logic_value .)
    RCORCHE         reduce using rule 187 (logic_recu -> logic_op logic_value .)
    COMA            reduce using rule 187 (logic_recu -> logic_op logic_value .)
    AND             shift and go to state 105
    OR              shift and go to state 106

    logic_op                       shift and go to state 104
    logic_recu                     shift and go to state 255

state 175

    (189) logic_value -> negation .

    AND             reduce using rule 189 (logic_value -> negation .)
    OR              reduce using rule 189 (logic_value -> negation .)
    PRINT           reduce using rule 189 (logic_value -> negation .)
    SCAN            reduce using rule 189 (logic_value -> negation .)
    FOR             reduce using rule 189 (logic_value -> negation .)
    CONST           reduce using rule 189 (logic_value -> negation .)
    ID              reduce using rule 189 (logic_value -> negation .)
    APPEND          reduce using rule 189 (logic_value -> negation .)
    LEN             reduce using rule 189 (logic_value -> negation .)
    COPY            reduce using rule 189 (logic_value -> negation .)
    DELETE          reduce using rule 189 (logic_value -> negation .)
    IF              reduce using rule 189 (logic_value -> negation .)
    ELSE            reduce using rule 189 (logic_value -> negation .)
    TYPE            reduce using rule 189 (logic_value -> negation .)
    SWITCH          reduce using rule 189 (logic_value -> negation .)
    VAR             reduce using rule 189 (logic_value -> negation .)
    FUNC            reduce using rule 189 (logic_value -> negation .)
    INTEGER         reduce using rule 189 (logic_value -> negation .)
    FLOAT           reduce using rule 189 (logic_value -> negation .)
    NOT             reduce using rule 189 (logic_value -> negation .)
    $end            reduce using rule 189 (logic_value -> negation .)
    RLLAVE          reduce using rule 189 (logic_value -> negation .)
    INT32           reduce using rule 189 (logic_value -> negation .)
    INT64           reduce using rule 189 (logic_value -> negation .)
    FLOAT32         reduce using rule 189 (logic_value -> negation .)
    FLOAT64         reduce using rule 189 (logic_value -> negation .)
    BYTE            reduce using rule 189 (logic_value -> negation .)
    WINT            reduce using rule 189 (logic_value -> negation .)
    WFLOAT          reduce using rule 189 (logic_value -> negation .)
    WSTRING         reduce using rule 189 (logic_value -> negation .)
    BOOL            reduce using rule 189 (logic_value -> negation .)
    DEFAULT         reduce using rule 189 (logic_value -> negation .)
    CASE            reduce using rule 189 (logic_value -> negation .)
    RETURN          reduce using rule 189 (logic_value -> negation .)
    LLLAVE          reduce using rule 189 (logic_value -> negation .)
    COLON           reduce using rule 189 (logic_value -> negation .)
    RPAREN          reduce using rule 189 (logic_value -> negation .)
    RCORCHE         reduce using rule 189 (logic_value -> negation .)
    COMA            reduce using rule 189 (logic_value -> negation .)


state 176

    (190) logic_value -> comparison .

    AND             reduce using rule 190 (logic_value -> comparison .)
    OR              reduce using rule 190 (logic_value -> comparison .)
    PRINT           reduce using rule 190 (logic_value -> comparison .)
    SCAN            reduce using rule 190 (logic_value -> comparison .)
    FOR             reduce using rule 190 (logic_value -> comparison .)
    CONST           reduce using rule 190 (logic_value -> comparison .)
    ID              reduce using rule 190 (logic_value -> comparison .)
    APPEND          reduce using rule 190 (logic_value -> comparison .)
    LEN             reduce using rule 190 (logic_value -> comparison .)
    COPY            reduce using rule 190 (logic_value -> comparison .)
    DELETE          reduce using rule 190 (logic_value -> comparison .)
    IF              reduce using rule 190 (logic_value -> comparison .)
    ELSE            reduce using rule 190 (logic_value -> comparison .)
    TYPE            reduce using rule 190 (logic_value -> comparison .)
    SWITCH          reduce using rule 190 (logic_value -> comparison .)
    VAR             reduce using rule 190 (logic_value -> comparison .)
    FUNC            reduce using rule 190 (logic_value -> comparison .)
    INTEGER         reduce using rule 190 (logic_value -> comparison .)
    FLOAT           reduce using rule 190 (logic_value -> comparison .)
    NOT             reduce using rule 190 (logic_value -> comparison .)
    $end            reduce using rule 190 (logic_value -> comparison .)
    RLLAVE          reduce using rule 190 (logic_value -> comparison .)
    INT32           reduce using rule 190 (logic_value -> comparison .)
    INT64           reduce using rule 190 (logic_value -> comparison .)
    FLOAT32         reduce using rule 190 (logic_value -> comparison .)
    FLOAT64         reduce using rule 190 (logic_value -> comparison .)
    BYTE            reduce using rule 190 (logic_value -> comparison .)
    WINT            reduce using rule 190 (logic_value -> comparison .)
    WFLOAT          reduce using rule 190 (logic_value -> comparison .)
    WSTRING         reduce using rule 190 (logic_value -> comparison .)
    BOOL            reduce using rule 190 (logic_value -> comparison .)
    DEFAULT         reduce using rule 190 (logic_value -> comparison .)
    CASE            reduce using rule 190 (logic_value -> comparison .)
    RETURN          reduce using rule 190 (logic_value -> comparison .)
    LLLAVE          reduce using rule 190 (logic_value -> comparison .)
    COLON           reduce using rule 190 (logic_value -> comparison .)
    RPAREN          reduce using rule 190 (logic_value -> comparison .)
    RCORCHE         reduce using rule 190 (logic_value -> comparison .)
    COMA            reduce using rule 190 (logic_value -> comparison .)


state 177

    (191) logic_value -> ID .
    (177) value -> ID .
    (238) something_ex -> ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 177 (value -> ID .)
    AND             reduce using rule 191 (logic_value -> ID .)
    OR              reduce using rule 191 (logic_value -> ID .)
    PRINT           reduce using rule 191 (logic_value -> ID .)
    SCAN            reduce using rule 191 (logic_value -> ID .)
    FOR             reduce using rule 191 (logic_value -> ID .)
    CONST           reduce using rule 191 (logic_value -> ID .)
    ID              reduce using rule 191 (logic_value -> ID .)
    APPEND          reduce using rule 191 (logic_value -> ID .)
    LEN             reduce using rule 191 (logic_value -> ID .)
    COPY            reduce using rule 191 (logic_value -> ID .)
    DELETE          reduce using rule 191 (logic_value -> ID .)
    IF              reduce using rule 191 (logic_value -> ID .)
    ELSE            reduce using rule 191 (logic_value -> ID .)
    TYPE            reduce using rule 191 (logic_value -> ID .)
    SWITCH          reduce using rule 191 (logic_value -> ID .)
    VAR             reduce using rule 191 (logic_value -> ID .)
    FUNC            reduce using rule 191 (logic_value -> ID .)
    INTEGER         reduce using rule 191 (logic_value -> ID .)
    FLOAT           reduce using rule 191 (logic_value -> ID .)
    NOT             reduce using rule 191 (logic_value -> ID .)
    $end            reduce using rule 191 (logic_value -> ID .)
    RLLAVE          reduce using rule 191 (logic_value -> ID .)
    INT32           reduce using rule 191 (logic_value -> ID .)
    INT64           reduce using rule 191 (logic_value -> ID .)
    FLOAT32         reduce using rule 191 (logic_value -> ID .)
    FLOAT64         reduce using rule 191 (logic_value -> ID .)
    BYTE            reduce using rule 191 (logic_value -> ID .)
    WINT            reduce using rule 191 (logic_value -> ID .)
    WFLOAT          reduce using rule 191 (logic_value -> ID .)
    WSTRING         reduce using rule 191 (logic_value -> ID .)
    BOOL            reduce using rule 191 (logic_value -> ID .)
    DEFAULT         reduce using rule 191 (logic_value -> ID .)
    CASE            reduce using rule 191 (logic_value -> ID .)
    RETURN          reduce using rule 191 (logic_value -> ID .)
    LLLAVE          reduce using rule 191 (logic_value -> ID .)
    COLON           reduce using rule 191 (logic_value -> ID .)
    RPAREN          reduce using rule 191 (logic_value -> ID .)
    RCORCHE         reduce using rule 191 (logic_value -> ID .)
    COMA            reduce using rule 191 (logic_value -> ID .)
    GREATER         reduce using rule 177 (value -> ID .)
    SMALLER         reduce using rule 177 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 177 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 177 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 177 (value -> ID .)
    NOT_EQUAL       reduce using rule 177 (value -> ID .)
    PLUS            reduce using rule 177 (value -> ID .)
    TIMES           reduce using rule 177 (value -> ID .)
    DIVIDE          reduce using rule 177 (value -> ID .)
    MINUS           reduce using rule 177 (value -> ID .)
    MOD             reduce using rule 177 (value -> ID .)
    LCORCHE         shift and go to state 172
    LPAREN          shift and go to state 111

  ! GREATER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 238 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 238 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 238 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 238 (something_ex -> ID .) ]


state 178

    (109) decConst -> CONST ID data_type_and_value .

    COLON           reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    PRINT           reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    SCAN            reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    FOR             reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    CONST           reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    ID              reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    APPEND          reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    LEN             reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    COPY            reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    DELETE          reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    IF              reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    ELSE            reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    TYPE            reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    SWITCH          reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    VAR             reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    FUNC            reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    INTEGER         reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    FLOAT           reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    NOT             reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    $end            reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    RLLAVE          reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    INT32           reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    INT64           reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    FLOAT32         reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    FLOAT64         reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    BYTE            reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    WINT            reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    WFLOAT          reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    WSTRING         reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    BOOL            reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    DEFAULT         reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    CASE            reduce using rule 109 (decConst -> CONST ID data_type_and_value .)
    RETURN          reduce using rule 109 (decConst -> CONST ID data_type_and_value .)


state 179

    (110) decConst -> CONST ID EQUAL . ID
    (111) decConst -> CONST ID EQUAL . data_structure
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 256

    data_structure                 shift and go to state 257
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101

state 180

    (93) data_type_and_value -> WSTRING . EQUAL STRING

    EQUAL           shift and go to state 258


state 181

    (94) data_type_and_value -> WINT . EQUAL int_value

    EQUAL           shift and go to state 259


state 182

    (95) data_type_and_value -> INT32 . EQUAL int_value

    EQUAL           shift and go to state 260


state 183

    (96) data_type_and_value -> INT64 . EQUAL int_value

    EQUAL           shift and go to state 261


state 184

    (97) data_type_and_value -> WFLOAT . EQUAL float_value

    EQUAL           shift and go to state 262


state 185

    (98) data_type_and_value -> FLOAT32 . EQUAL float_value

    EQUAL           shift and go to state 263


state 186

    (99) data_type_and_value -> FLOAT64 . EQUAL float_value

    EQUAL           shift and go to state 264


state 187

    (100) data_type_and_value -> BOOL . EQUAL bool_value

    EQUAL           shift and go to state 265


state 188

    (67) any -> ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN
    (238) something_ex -> ID .
    (177) value -> ID .
    (191) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for CONST resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for INT32 resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for INT64 resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for BYTE resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for WINT resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for WSTRING resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 67 (any -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 177 (value -> ID .)
    COLON           reduce using rule 67 (any -> ID .)
    PRINT           reduce using rule 67 (any -> ID .)
    SCAN            reduce using rule 67 (any -> ID .)
    FOR             reduce using rule 67 (any -> ID .)
    CONST           reduce using rule 67 (any -> ID .)
    ID              reduce using rule 67 (any -> ID .)
    APPEND          reduce using rule 67 (any -> ID .)
    LEN             reduce using rule 67 (any -> ID .)
    COPY            reduce using rule 67 (any -> ID .)
    DELETE          reduce using rule 67 (any -> ID .)
    IF              reduce using rule 67 (any -> ID .)
    ELSE            reduce using rule 67 (any -> ID .)
    TYPE            reduce using rule 67 (any -> ID .)
    SWITCH          reduce using rule 67 (any -> ID .)
    VAR             reduce using rule 67 (any -> ID .)
    FUNC            reduce using rule 67 (any -> ID .)
    INTEGER         reduce using rule 67 (any -> ID .)
    FLOAT           reduce using rule 67 (any -> ID .)
    NOT             reduce using rule 67 (any -> ID .)
    $end            reduce using rule 67 (any -> ID .)
    RLLAVE          reduce using rule 67 (any -> ID .)
    INT32           reduce using rule 67 (any -> ID .)
    INT64           reduce using rule 67 (any -> ID .)
    FLOAT32         reduce using rule 67 (any -> ID .)
    FLOAT64         reduce using rule 67 (any -> ID .)
    BYTE            reduce using rule 67 (any -> ID .)
    WINT            reduce using rule 67 (any -> ID .)
    WFLOAT          reduce using rule 67 (any -> ID .)
    WSTRING         reduce using rule 67 (any -> ID .)
    BOOL            reduce using rule 67 (any -> ID .)
    DEFAULT         reduce using rule 67 (any -> ID .)
    CASE            reduce using rule 67 (any -> ID .)
    RETURN          reduce using rule 67 (any -> ID .)
    LCORCHE         shift and go to state 172
    LPAREN          shift and go to state 111
    GREATER         reduce using rule 177 (value -> ID .)
    SMALLER         reduce using rule 177 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 177 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 177 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 177 (value -> ID .)
    NOT_EQUAL       reduce using rule 177 (value -> ID .)
    PLUS            reduce using rule 177 (value -> ID .)
    TIMES           reduce using rule 177 (value -> ID .)
    DIVIDE          reduce using rule 177 (value -> ID .)
    MINUS           reduce using rule 177 (value -> ID .)
    MOD             reduce using rule 177 (value -> ID .)
    AND             reduce using rule 191 (logic_value -> ID .)
    OR              reduce using rule 191 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 238 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 238 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 238 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 238 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 238 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 238 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 238 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 238 (something_ex -> ID .) ]
  ! CONST           [ reduce using rule 238 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 238 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 238 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 238 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 238 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 238 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 238 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 238 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 238 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 238 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 238 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! INT32           [ reduce using rule 238 (something_ex -> ID .) ]
  ! INT64           [ reduce using rule 238 (something_ex -> ID .) ]
  ! FLOAT32         [ reduce using rule 238 (something_ex -> ID .) ]
  ! FLOAT64         [ reduce using rule 238 (something_ex -> ID .) ]
  ! BYTE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! WINT            [ reduce using rule 238 (something_ex -> ID .) ]
  ! WFLOAT          [ reduce using rule 238 (something_ex -> ID .) ]
  ! WSTRING         [ reduce using rule 238 (something_ex -> ID .) ]
  ! BOOL            [ reduce using rule 238 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 238 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 238 (something_ex -> ID .) ]


state 189

    (64) var_asignation -> ID EQUAL any .

    COLON           reduce using rule 64 (var_asignation -> ID EQUAL any .)
    PRINT           reduce using rule 64 (var_asignation -> ID EQUAL any .)
    SCAN            reduce using rule 64 (var_asignation -> ID EQUAL any .)
    FOR             reduce using rule 64 (var_asignation -> ID EQUAL any .)
    CONST           reduce using rule 64 (var_asignation -> ID EQUAL any .)
    ID              reduce using rule 64 (var_asignation -> ID EQUAL any .)
    APPEND          reduce using rule 64 (var_asignation -> ID EQUAL any .)
    LEN             reduce using rule 64 (var_asignation -> ID EQUAL any .)
    COPY            reduce using rule 64 (var_asignation -> ID EQUAL any .)
    DELETE          reduce using rule 64 (var_asignation -> ID EQUAL any .)
    IF              reduce using rule 64 (var_asignation -> ID EQUAL any .)
    ELSE            reduce using rule 64 (var_asignation -> ID EQUAL any .)
    TYPE            reduce using rule 64 (var_asignation -> ID EQUAL any .)
    SWITCH          reduce using rule 64 (var_asignation -> ID EQUAL any .)
    VAR             reduce using rule 64 (var_asignation -> ID EQUAL any .)
    FUNC            reduce using rule 64 (var_asignation -> ID EQUAL any .)
    INTEGER         reduce using rule 64 (var_asignation -> ID EQUAL any .)
    FLOAT           reduce using rule 64 (var_asignation -> ID EQUAL any .)
    NOT             reduce using rule 64 (var_asignation -> ID EQUAL any .)
    $end            reduce using rule 64 (var_asignation -> ID EQUAL any .)
    RLLAVE          reduce using rule 64 (var_asignation -> ID EQUAL any .)
    INT32           reduce using rule 64 (var_asignation -> ID EQUAL any .)
    INT64           reduce using rule 64 (var_asignation -> ID EQUAL any .)
    FLOAT32         reduce using rule 64 (var_asignation -> ID EQUAL any .)
    FLOAT64         reduce using rule 64 (var_asignation -> ID EQUAL any .)
    BYTE            reduce using rule 64 (var_asignation -> ID EQUAL any .)
    WINT            reduce using rule 64 (var_asignation -> ID EQUAL any .)
    WFLOAT          reduce using rule 64 (var_asignation -> ID EQUAL any .)
    WSTRING         reduce using rule 64 (var_asignation -> ID EQUAL any .)
    BOOL            reduce using rule 64 (var_asignation -> ID EQUAL any .)
    DEFAULT         reduce using rule 64 (var_asignation -> ID EQUAL any .)
    CASE            reduce using rule 64 (var_asignation -> ID EQUAL any .)
    RETURN          reduce using rule 64 (var_asignation -> ID EQUAL any .)


state 190

    (65) any -> values .

    COLON           reduce using rule 65 (any -> values .)
    PRINT           reduce using rule 65 (any -> values .)
    SCAN            reduce using rule 65 (any -> values .)
    FOR             reduce using rule 65 (any -> values .)
    CONST           reduce using rule 65 (any -> values .)
    ID              reduce using rule 65 (any -> values .)
    APPEND          reduce using rule 65 (any -> values .)
    LEN             reduce using rule 65 (any -> values .)
    COPY            reduce using rule 65 (any -> values .)
    DELETE          reduce using rule 65 (any -> values .)
    IF              reduce using rule 65 (any -> values .)
    ELSE            reduce using rule 65 (any -> values .)
    TYPE            reduce using rule 65 (any -> values .)
    SWITCH          reduce using rule 65 (any -> values .)
    VAR             reduce using rule 65 (any -> values .)
    FUNC            reduce using rule 65 (any -> values .)
    INTEGER         reduce using rule 65 (any -> values .)
    FLOAT           reduce using rule 65 (any -> values .)
    NOT             reduce using rule 65 (any -> values .)
    $end            reduce using rule 65 (any -> values .)
    RLLAVE          reduce using rule 65 (any -> values .)
    INT32           reduce using rule 65 (any -> values .)
    INT64           reduce using rule 65 (any -> values .)
    FLOAT32         reduce using rule 65 (any -> values .)
    FLOAT64         reduce using rule 65 (any -> values .)
    BYTE            reduce using rule 65 (any -> values .)
    WINT            reduce using rule 65 (any -> values .)
    WFLOAT          reduce using rule 65 (any -> values .)
    WSTRING         reduce using rule 65 (any -> values .)
    BOOL            reduce using rule 65 (any -> values .)
    DEFAULT         reduce using rule 65 (any -> values .)
    CASE            reduce using rule 65 (any -> values .)
    RETURN          reduce using rule 65 (any -> values .)


state 191

    (66) any -> operations .

    COLON           reduce using rule 66 (any -> operations .)
    PRINT           reduce using rule 66 (any -> operations .)
    SCAN            reduce using rule 66 (any -> operations .)
    FOR             reduce using rule 66 (any -> operations .)
    CONST           reduce using rule 66 (any -> operations .)
    ID              reduce using rule 66 (any -> operations .)
    APPEND          reduce using rule 66 (any -> operations .)
    LEN             reduce using rule 66 (any -> operations .)
    COPY            reduce using rule 66 (any -> operations .)
    DELETE          reduce using rule 66 (any -> operations .)
    IF              reduce using rule 66 (any -> operations .)
    ELSE            reduce using rule 66 (any -> operations .)
    TYPE            reduce using rule 66 (any -> operations .)
    SWITCH          reduce using rule 66 (any -> operations .)
    VAR             reduce using rule 66 (any -> operations .)
    FUNC            reduce using rule 66 (any -> operations .)
    INTEGER         reduce using rule 66 (any -> operations .)
    FLOAT           reduce using rule 66 (any -> operations .)
    NOT             reduce using rule 66 (any -> operations .)
    $end            reduce using rule 66 (any -> operations .)
    RLLAVE          reduce using rule 66 (any -> operations .)
    INT32           reduce using rule 66 (any -> operations .)
    INT64           reduce using rule 66 (any -> operations .)
    FLOAT32         reduce using rule 66 (any -> operations .)
    FLOAT64         reduce using rule 66 (any -> operations .)
    BYTE            reduce using rule 66 (any -> operations .)
    WINT            reduce using rule 66 (any -> operations .)
    WFLOAT          reduce using rule 66 (any -> operations .)
    WSTRING         reduce using rule 66 (any -> operations .)
    BOOL            reduce using rule 66 (any -> operations .)
    DEFAULT         reduce using rule 66 (any -> operations .)
    CASE            reduce using rule 66 (any -> operations .)
    RETURN          reduce using rule 66 (any -> operations .)


state 192

    (68) any -> data_structure .
    (241) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for PRINT resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for SCAN resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for FOR resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for CONST resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for ID resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for APPEND resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for LEN resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for COPY resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for DELETE resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for IF resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for ELSE resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for TYPE resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for SWITCH resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for VAR resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for FUNC resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for INTEGER resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for FLOAT resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for NOT resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for $end resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for INT32 resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for INT64 resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for BYTE resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for WINT resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for WSTRING resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for BOOL resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for CASE resolved using rule 68 (any -> data_structure .)
  ! reduce/reduce conflict for RETURN resolved using rule 68 (any -> data_structure .)
    COLON           reduce using rule 68 (any -> data_structure .)
    PRINT           reduce using rule 68 (any -> data_structure .)
    SCAN            reduce using rule 68 (any -> data_structure .)
    FOR             reduce using rule 68 (any -> data_structure .)
    CONST           reduce using rule 68 (any -> data_structure .)
    ID              reduce using rule 68 (any -> data_structure .)
    APPEND          reduce using rule 68 (any -> data_structure .)
    LEN             reduce using rule 68 (any -> data_structure .)
    COPY            reduce using rule 68 (any -> data_structure .)
    DELETE          reduce using rule 68 (any -> data_structure .)
    IF              reduce using rule 68 (any -> data_structure .)
    ELSE            reduce using rule 68 (any -> data_structure .)
    TYPE            reduce using rule 68 (any -> data_structure .)
    SWITCH          reduce using rule 68 (any -> data_structure .)
    VAR             reduce using rule 68 (any -> data_structure .)
    FUNC            reduce using rule 68 (any -> data_structure .)
    INTEGER         reduce using rule 68 (any -> data_structure .)
    FLOAT           reduce using rule 68 (any -> data_structure .)
    NOT             reduce using rule 68 (any -> data_structure .)
    $end            reduce using rule 68 (any -> data_structure .)
    RLLAVE          reduce using rule 68 (any -> data_structure .)
    INT32           reduce using rule 68 (any -> data_structure .)
    INT64           reduce using rule 68 (any -> data_structure .)
    FLOAT32         reduce using rule 68 (any -> data_structure .)
    FLOAT64         reduce using rule 68 (any -> data_structure .)
    BYTE            reduce using rule 68 (any -> data_structure .)
    WINT            reduce using rule 68 (any -> data_structure .)
    WFLOAT          reduce using rule 68 (any -> data_structure .)
    WSTRING         reduce using rule 68 (any -> data_structure .)
    BOOL            reduce using rule 68 (any -> data_structure .)
    DEFAULT         reduce using rule 68 (any -> data_structure .)
    CASE            reduce using rule 68 (any -> data_structure .)
    RETURN          reduce using rule 68 (any -> data_structure .)
    GREATER         reduce using rule 241 (something_ex -> data_structure .)
    SMALLER         reduce using rule 241 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 241 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 241 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 241 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 241 (something_ex -> data_structure .)
    PLUS            reduce using rule 241 (something_ex -> data_structure .)
    TIMES           reduce using rule 241 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 241 (something_ex -> data_structure .)
    MINUS           reduce using rule 241 (something_ex -> data_structure .)
    MOD             reduce using rule 241 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! PRINT           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! SCAN            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! FOR             [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! CONST           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! ID              [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! APPEND          [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! LEN             [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! COPY            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! DELETE          [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! IF              [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! ELSE            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! TYPE            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! SWITCH          [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! VAR             [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! FUNC            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! INTEGER         [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! FLOAT           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! NOT             [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! $end            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! INT32           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! INT64           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! FLOAT32         [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! FLOAT64         [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! BYTE            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! WINT            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! WFLOAT          [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! WSTRING         [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! BOOL            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! DEFAULT         [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! CASE            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! RETURN          [ reduce using rule 241 (something_ex -> data_structure .) ]


state 193

    (69) any -> funciones .
    (242) something_ex -> funciones .

  ! reduce/reduce conflict for COLON resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for PRINT resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for SCAN resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for FOR resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for CONST resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for ID resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for APPEND resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for LEN resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for COPY resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for DELETE resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for IF resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for ELSE resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for TYPE resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for SWITCH resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for VAR resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for FUNC resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for INTEGER resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for FLOAT resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for NOT resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for $end resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for INT32 resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for INT64 resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for BYTE resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for WINT resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for WSTRING resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for BOOL resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for CASE resolved using rule 69 (any -> funciones .)
  ! reduce/reduce conflict for RETURN resolved using rule 69 (any -> funciones .)
    COLON           reduce using rule 69 (any -> funciones .)
    PRINT           reduce using rule 69 (any -> funciones .)
    SCAN            reduce using rule 69 (any -> funciones .)
    FOR             reduce using rule 69 (any -> funciones .)
    CONST           reduce using rule 69 (any -> funciones .)
    ID              reduce using rule 69 (any -> funciones .)
    APPEND          reduce using rule 69 (any -> funciones .)
    LEN             reduce using rule 69 (any -> funciones .)
    COPY            reduce using rule 69 (any -> funciones .)
    DELETE          reduce using rule 69 (any -> funciones .)
    IF              reduce using rule 69 (any -> funciones .)
    ELSE            reduce using rule 69 (any -> funciones .)
    TYPE            reduce using rule 69 (any -> funciones .)
    SWITCH          reduce using rule 69 (any -> funciones .)
    VAR             reduce using rule 69 (any -> funciones .)
    FUNC            reduce using rule 69 (any -> funciones .)
    INTEGER         reduce using rule 69 (any -> funciones .)
    FLOAT           reduce using rule 69 (any -> funciones .)
    NOT             reduce using rule 69 (any -> funciones .)
    $end            reduce using rule 69 (any -> funciones .)
    RLLAVE          reduce using rule 69 (any -> funciones .)
    INT32           reduce using rule 69 (any -> funciones .)
    INT64           reduce using rule 69 (any -> funciones .)
    FLOAT32         reduce using rule 69 (any -> funciones .)
    FLOAT64         reduce using rule 69 (any -> funciones .)
    BYTE            reduce using rule 69 (any -> funciones .)
    WINT            reduce using rule 69 (any -> funciones .)
    WFLOAT          reduce using rule 69 (any -> funciones .)
    WSTRING         reduce using rule 69 (any -> funciones .)
    BOOL            reduce using rule 69 (any -> funciones .)
    DEFAULT         reduce using rule 69 (any -> funciones .)
    CASE            reduce using rule 69 (any -> funciones .)
    RETURN          reduce using rule 69 (any -> funciones .)
    GREATER         reduce using rule 242 (something_ex -> funciones .)
    SMALLER         reduce using rule 242 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 242 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 242 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 242 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 242 (something_ex -> funciones .)
    PLUS            reduce using rule 242 (something_ex -> funciones .)
    TIMES           reduce using rule 242 (something_ex -> funciones .)
    DIVIDE          reduce using rule 242 (something_ex -> funciones .)
    MINUS           reduce using rule 242 (something_ex -> funciones .)
    MOD             reduce using rule 242 (something_ex -> funciones .)

  ! COLON           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! PRINT           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! SCAN            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! FOR             [ reduce using rule 242 (something_ex -> funciones .) ]
  ! CONST           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! ID              [ reduce using rule 242 (something_ex -> funciones .) ]
  ! APPEND          [ reduce using rule 242 (something_ex -> funciones .) ]
  ! LEN             [ reduce using rule 242 (something_ex -> funciones .) ]
  ! COPY            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! DELETE          [ reduce using rule 242 (something_ex -> funciones .) ]
  ! IF              [ reduce using rule 242 (something_ex -> funciones .) ]
  ! ELSE            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! TYPE            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! SWITCH          [ reduce using rule 242 (something_ex -> funciones .) ]
  ! VAR             [ reduce using rule 242 (something_ex -> funciones .) ]
  ! FUNC            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! INTEGER         [ reduce using rule 242 (something_ex -> funciones .) ]
  ! FLOAT           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! NOT             [ reduce using rule 242 (something_ex -> funciones .) ]
  ! $end            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! RLLAVE          [ reduce using rule 242 (something_ex -> funciones .) ]
  ! INT32           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! INT64           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! FLOAT32         [ reduce using rule 242 (something_ex -> funciones .) ]
  ! FLOAT64         [ reduce using rule 242 (something_ex -> funciones .) ]
  ! BYTE            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! WINT            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! WFLOAT          [ reduce using rule 242 (something_ex -> funciones .) ]
  ! WSTRING         [ reduce using rule 242 (something_ex -> funciones .) ]
  ! BOOL            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! DEFAULT         [ reduce using rule 242 (something_ex -> funciones .) ]
  ! CASE            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! RETURN          [ reduce using rule 242 (something_ex -> funciones .) ]


state 194

    (169) cStruct -> ID DEQUAL ID . LLLAVE asignaciones RLLAVE
    (128) algo -> ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN
    (238) something_ex -> ID .
    (177) value -> ID .
    (191) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for CONST resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for INT32 resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for INT64 resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for BYTE resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for WINT resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for WSTRING resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 128 (algo -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 177 (value -> ID .)
    LLLAVE          shift and go to state 266
    COLON           reduce using rule 128 (algo -> ID .)
    PRINT           reduce using rule 128 (algo -> ID .)
    SCAN            reduce using rule 128 (algo -> ID .)
    FOR             reduce using rule 128 (algo -> ID .)
    CONST           reduce using rule 128 (algo -> ID .)
    ID              reduce using rule 128 (algo -> ID .)
    APPEND          reduce using rule 128 (algo -> ID .)
    LEN             reduce using rule 128 (algo -> ID .)
    COPY            reduce using rule 128 (algo -> ID .)
    DELETE          reduce using rule 128 (algo -> ID .)
    IF              reduce using rule 128 (algo -> ID .)
    ELSE            reduce using rule 128 (algo -> ID .)
    TYPE            reduce using rule 128 (algo -> ID .)
    SWITCH          reduce using rule 128 (algo -> ID .)
    VAR             reduce using rule 128 (algo -> ID .)
    FUNC            reduce using rule 128 (algo -> ID .)
    INTEGER         reduce using rule 128 (algo -> ID .)
    FLOAT           reduce using rule 128 (algo -> ID .)
    NOT             reduce using rule 128 (algo -> ID .)
    $end            reduce using rule 128 (algo -> ID .)
    RLLAVE          reduce using rule 128 (algo -> ID .)
    INT32           reduce using rule 128 (algo -> ID .)
    INT64           reduce using rule 128 (algo -> ID .)
    FLOAT32         reduce using rule 128 (algo -> ID .)
    FLOAT64         reduce using rule 128 (algo -> ID .)
    BYTE            reduce using rule 128 (algo -> ID .)
    WINT            reduce using rule 128 (algo -> ID .)
    WFLOAT          reduce using rule 128 (algo -> ID .)
    WSTRING         reduce using rule 128 (algo -> ID .)
    BOOL            reduce using rule 128 (algo -> ID .)
    DEFAULT         reduce using rule 128 (algo -> ID .)
    CASE            reduce using rule 128 (algo -> ID .)
    RETURN          reduce using rule 128 (algo -> ID .)
    LCORCHE         shift and go to state 172
    LPAREN          shift and go to state 111
    GREATER         reduce using rule 177 (value -> ID .)
    SMALLER         reduce using rule 177 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 177 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 177 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 177 (value -> ID .)
    NOT_EQUAL       reduce using rule 177 (value -> ID .)
    PLUS            reduce using rule 177 (value -> ID .)
    TIMES           reduce using rule 177 (value -> ID .)
    DIVIDE          reduce using rule 177 (value -> ID .)
    MINUS           reduce using rule 177 (value -> ID .)
    MOD             reduce using rule 177 (value -> ID .)
    AND             reduce using rule 191 (logic_value -> ID .)
    OR              reduce using rule 191 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 238 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 238 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 238 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 238 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 238 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 238 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 238 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 238 (something_ex -> ID .) ]
  ! CONST           [ reduce using rule 238 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 238 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 238 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 238 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 238 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 238 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 238 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 238 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 238 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 238 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 238 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! INT32           [ reduce using rule 238 (something_ex -> ID .) ]
  ! INT64           [ reduce using rule 238 (something_ex -> ID .) ]
  ! FLOAT32         [ reduce using rule 238 (something_ex -> ID .) ]
  ! FLOAT64         [ reduce using rule 238 (something_ex -> ID .) ]
  ! BYTE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! WINT            [ reduce using rule 238 (something_ex -> ID .) ]
  ! WFLOAT          [ reduce using rule 238 (something_ex -> ID .) ]
  ! WSTRING         [ reduce using rule 238 (something_ex -> ID .) ]
  ! BOOL            [ reduce using rule 238 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 238 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 238 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 238 (something_ex -> ID .) ]


state 195

    (134) slice_declaration -> ID DEQUAL funM .

    COLON           reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    PRINT           reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    SCAN            reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    FOR             reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    CONST           reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    ID              reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    APPEND          reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    LEN             reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    COPY            reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    DELETE          reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    IF              reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    ELSE            reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    TYPE            reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    SWITCH          reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    VAR             reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    FUNC            reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    INTEGER         reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    FLOAT           reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    NOT             reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    $end            reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    RLLAVE          reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    INT32           reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    INT64           reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    FLOAT32         reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    FLOAT64         reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    BYTE            reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    WINT            reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    WFLOAT          reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    WSTRING         reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    BOOL            reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    DEFAULT         reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    CASE            reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)
    RETURN          reduce using rule 134 (slice_declaration -> ID DEQUAL funM .)


state 196

    (135) slice_declaration -> ID DEQUAL LCORCHE . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 267


state 197

    (125) dynamic -> ID DEQUAL algo .

    COLON           reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    PRINT           reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    SCAN            reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    FOR             reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    CONST           reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    ID              reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    APPEND          reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    LEN             reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    COPY            reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    DELETE          reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    IF              reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    ELSE            reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    TYPE            reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    SWITCH          reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    VAR             reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    FUNC            reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    INTEGER         reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    FLOAT           reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    NOT             reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    $end            reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    RLLAVE          reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    INT32           reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    INT64           reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    FLOAT32         reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    FLOAT64         reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    BYTE            reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    WINT            reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    WFLOAT          reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    WSTRING         reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    BOOL            reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    DEFAULT         reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    CASE            reduce using rule 125 (dynamic -> ID DEQUAL algo .)
    RETURN          reduce using rule 125 (dynamic -> ID DEQUAL algo .)


state 198

    (136) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (137) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LPAREN          shift and go to state 268


state 199

    (126) algo -> values .

    COLON           reduce using rule 126 (algo -> values .)
    PRINT           reduce using rule 126 (algo -> values .)
    SCAN            reduce using rule 126 (algo -> values .)
    FOR             reduce using rule 126 (algo -> values .)
    CONST           reduce using rule 126 (algo -> values .)
    ID              reduce using rule 126 (algo -> values .)
    APPEND          reduce using rule 126 (algo -> values .)
    LEN             reduce using rule 126 (algo -> values .)
    COPY            reduce using rule 126 (algo -> values .)
    DELETE          reduce using rule 126 (algo -> values .)
    IF              reduce using rule 126 (algo -> values .)
    ELSE            reduce using rule 126 (algo -> values .)
    TYPE            reduce using rule 126 (algo -> values .)
    SWITCH          reduce using rule 126 (algo -> values .)
    VAR             reduce using rule 126 (algo -> values .)
    FUNC            reduce using rule 126 (algo -> values .)
    INTEGER         reduce using rule 126 (algo -> values .)
    FLOAT           reduce using rule 126 (algo -> values .)
    NOT             reduce using rule 126 (algo -> values .)
    $end            reduce using rule 126 (algo -> values .)
    RLLAVE          reduce using rule 126 (algo -> values .)
    INT32           reduce using rule 126 (algo -> values .)
    INT64           reduce using rule 126 (algo -> values .)
    FLOAT32         reduce using rule 126 (algo -> values .)
    FLOAT64         reduce using rule 126 (algo -> values .)
    BYTE            reduce using rule 126 (algo -> values .)
    WINT            reduce using rule 126 (algo -> values .)
    WFLOAT          reduce using rule 126 (algo -> values .)
    WSTRING         reduce using rule 126 (algo -> values .)
    BOOL            reduce using rule 126 (algo -> values .)
    DEFAULT         reduce using rule 126 (algo -> values .)
    CASE            reduce using rule 126 (algo -> values .)
    RETURN          reduce using rule 126 (algo -> values .)


state 200

    (127) algo -> operations .

    COLON           reduce using rule 127 (algo -> operations .)
    PRINT           reduce using rule 127 (algo -> operations .)
    SCAN            reduce using rule 127 (algo -> operations .)
    FOR             reduce using rule 127 (algo -> operations .)
    CONST           reduce using rule 127 (algo -> operations .)
    ID              reduce using rule 127 (algo -> operations .)
    APPEND          reduce using rule 127 (algo -> operations .)
    LEN             reduce using rule 127 (algo -> operations .)
    COPY            reduce using rule 127 (algo -> operations .)
    DELETE          reduce using rule 127 (algo -> operations .)
    IF              reduce using rule 127 (algo -> operations .)
    ELSE            reduce using rule 127 (algo -> operations .)
    TYPE            reduce using rule 127 (algo -> operations .)
    SWITCH          reduce using rule 127 (algo -> operations .)
    VAR             reduce using rule 127 (algo -> operations .)
    FUNC            reduce using rule 127 (algo -> operations .)
    INTEGER         reduce using rule 127 (algo -> operations .)
    FLOAT           reduce using rule 127 (algo -> operations .)
    NOT             reduce using rule 127 (algo -> operations .)
    $end            reduce using rule 127 (algo -> operations .)
    RLLAVE          reduce using rule 127 (algo -> operations .)
    INT32           reduce using rule 127 (algo -> operations .)
    INT64           reduce using rule 127 (algo -> operations .)
    FLOAT32         reduce using rule 127 (algo -> operations .)
    FLOAT64         reduce using rule 127 (algo -> operations .)
    BYTE            reduce using rule 127 (algo -> operations .)
    WINT            reduce using rule 127 (algo -> operations .)
    WFLOAT          reduce using rule 127 (algo -> operations .)
    WSTRING         reduce using rule 127 (algo -> operations .)
    BOOL            reduce using rule 127 (algo -> operations .)
    DEFAULT         reduce using rule 127 (algo -> operations .)
    CASE            reduce using rule 127 (algo -> operations .)
    RETURN          reduce using rule 127 (algo -> operations .)


state 201

    (129) algo -> data_structure .
    (241) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for PRINT resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for SCAN resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for FOR resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for CONST resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for ID resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for APPEND resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for LEN resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for COPY resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for DELETE resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for IF resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for ELSE resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for TYPE resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for SWITCH resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for VAR resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for FUNC resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for INTEGER resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for FLOAT resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for NOT resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for $end resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for INT32 resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for INT64 resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for BYTE resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for WINT resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for WSTRING resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for BOOL resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for CASE resolved using rule 129 (algo -> data_structure .)
  ! reduce/reduce conflict for RETURN resolved using rule 129 (algo -> data_structure .)
    COLON           reduce using rule 129 (algo -> data_structure .)
    PRINT           reduce using rule 129 (algo -> data_structure .)
    SCAN            reduce using rule 129 (algo -> data_structure .)
    FOR             reduce using rule 129 (algo -> data_structure .)
    CONST           reduce using rule 129 (algo -> data_structure .)
    ID              reduce using rule 129 (algo -> data_structure .)
    APPEND          reduce using rule 129 (algo -> data_structure .)
    LEN             reduce using rule 129 (algo -> data_structure .)
    COPY            reduce using rule 129 (algo -> data_structure .)
    DELETE          reduce using rule 129 (algo -> data_structure .)
    IF              reduce using rule 129 (algo -> data_structure .)
    ELSE            reduce using rule 129 (algo -> data_structure .)
    TYPE            reduce using rule 129 (algo -> data_structure .)
    SWITCH          reduce using rule 129 (algo -> data_structure .)
    VAR             reduce using rule 129 (algo -> data_structure .)
    FUNC            reduce using rule 129 (algo -> data_structure .)
    INTEGER         reduce using rule 129 (algo -> data_structure .)
    FLOAT           reduce using rule 129 (algo -> data_structure .)
    NOT             reduce using rule 129 (algo -> data_structure .)
    $end            reduce using rule 129 (algo -> data_structure .)
    RLLAVE          reduce using rule 129 (algo -> data_structure .)
    INT32           reduce using rule 129 (algo -> data_structure .)
    INT64           reduce using rule 129 (algo -> data_structure .)
    FLOAT32         reduce using rule 129 (algo -> data_structure .)
    FLOAT64         reduce using rule 129 (algo -> data_structure .)
    BYTE            reduce using rule 129 (algo -> data_structure .)
    WINT            reduce using rule 129 (algo -> data_structure .)
    WFLOAT          reduce using rule 129 (algo -> data_structure .)
    WSTRING         reduce using rule 129 (algo -> data_structure .)
    BOOL            reduce using rule 129 (algo -> data_structure .)
    DEFAULT         reduce using rule 129 (algo -> data_structure .)
    CASE            reduce using rule 129 (algo -> data_structure .)
    RETURN          reduce using rule 129 (algo -> data_structure .)
    GREATER         reduce using rule 241 (something_ex -> data_structure .)
    SMALLER         reduce using rule 241 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 241 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 241 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 241 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 241 (something_ex -> data_structure .)
    PLUS            reduce using rule 241 (something_ex -> data_structure .)
    TIMES           reduce using rule 241 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 241 (something_ex -> data_structure .)
    MINUS           reduce using rule 241 (something_ex -> data_structure .)
    MOD             reduce using rule 241 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! PRINT           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! SCAN            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! FOR             [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! CONST           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! ID              [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! APPEND          [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! LEN             [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! COPY            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! DELETE          [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! IF              [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! ELSE            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! TYPE            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! SWITCH          [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! VAR             [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! FUNC            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! INTEGER         [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! FLOAT           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! NOT             [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! $end            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! INT32           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! INT64           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! FLOAT32         [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! FLOAT64         [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! BYTE            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! WINT            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! WFLOAT          [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! WSTRING         [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! BOOL            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! DEFAULT         [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! CASE            [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! RETURN          [ reduce using rule 241 (something_ex -> data_structure .) ]


state 202

    (130) algo -> funciones .
    (242) something_ex -> funciones .

  ! reduce/reduce conflict for COLON resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for PRINT resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for SCAN resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for FOR resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for CONST resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for ID resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for APPEND resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for LEN resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for COPY resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for DELETE resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for IF resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for ELSE resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for TYPE resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for SWITCH resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for VAR resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for FUNC resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for INTEGER resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for FLOAT resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for NOT resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for $end resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for INT32 resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for INT64 resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for BYTE resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for WINT resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for WSTRING resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for BOOL resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for CASE resolved using rule 130 (algo -> funciones .)
  ! reduce/reduce conflict for RETURN resolved using rule 130 (algo -> funciones .)
    COLON           reduce using rule 130 (algo -> funciones .)
    PRINT           reduce using rule 130 (algo -> funciones .)
    SCAN            reduce using rule 130 (algo -> funciones .)
    FOR             reduce using rule 130 (algo -> funciones .)
    CONST           reduce using rule 130 (algo -> funciones .)
    ID              reduce using rule 130 (algo -> funciones .)
    APPEND          reduce using rule 130 (algo -> funciones .)
    LEN             reduce using rule 130 (algo -> funciones .)
    COPY            reduce using rule 130 (algo -> funciones .)
    DELETE          reduce using rule 130 (algo -> funciones .)
    IF              reduce using rule 130 (algo -> funciones .)
    ELSE            reduce using rule 130 (algo -> funciones .)
    TYPE            reduce using rule 130 (algo -> funciones .)
    SWITCH          reduce using rule 130 (algo -> funciones .)
    VAR             reduce using rule 130 (algo -> funciones .)
    FUNC            reduce using rule 130 (algo -> funciones .)
    INTEGER         reduce using rule 130 (algo -> funciones .)
    FLOAT           reduce using rule 130 (algo -> funciones .)
    NOT             reduce using rule 130 (algo -> funciones .)
    $end            reduce using rule 130 (algo -> funciones .)
    RLLAVE          reduce using rule 130 (algo -> funciones .)
    INT32           reduce using rule 130 (algo -> funciones .)
    INT64           reduce using rule 130 (algo -> funciones .)
    FLOAT32         reduce using rule 130 (algo -> funciones .)
    FLOAT64         reduce using rule 130 (algo -> funciones .)
    BYTE            reduce using rule 130 (algo -> funciones .)
    WINT            reduce using rule 130 (algo -> funciones .)
    WFLOAT          reduce using rule 130 (algo -> funciones .)
    WSTRING         reduce using rule 130 (algo -> funciones .)
    BOOL            reduce using rule 130 (algo -> funciones .)
    DEFAULT         reduce using rule 130 (algo -> funciones .)
    CASE            reduce using rule 130 (algo -> funciones .)
    RETURN          reduce using rule 130 (algo -> funciones .)
    GREATER         reduce using rule 242 (something_ex -> funciones .)
    SMALLER         reduce using rule 242 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 242 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 242 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 242 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 242 (something_ex -> funciones .)
    PLUS            reduce using rule 242 (something_ex -> funciones .)
    TIMES           reduce using rule 242 (something_ex -> funciones .)
    DIVIDE          reduce using rule 242 (something_ex -> funciones .)
    MINUS           reduce using rule 242 (something_ex -> funciones .)
    MOD             reduce using rule 242 (something_ex -> funciones .)

  ! COLON           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! PRINT           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! SCAN            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! FOR             [ reduce using rule 242 (something_ex -> funciones .) ]
  ! CONST           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! ID              [ reduce using rule 242 (something_ex -> funciones .) ]
  ! APPEND          [ reduce using rule 242 (something_ex -> funciones .) ]
  ! LEN             [ reduce using rule 242 (something_ex -> funciones .) ]
  ! COPY            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! DELETE          [ reduce using rule 242 (something_ex -> funciones .) ]
  ! IF              [ reduce using rule 242 (something_ex -> funciones .) ]
  ! ELSE            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! TYPE            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! SWITCH          [ reduce using rule 242 (something_ex -> funciones .) ]
  ! VAR             [ reduce using rule 242 (something_ex -> funciones .) ]
  ! FUNC            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! INTEGER         [ reduce using rule 242 (something_ex -> funciones .) ]
  ! FLOAT           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! NOT             [ reduce using rule 242 (something_ex -> funciones .) ]
  ! $end            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! RLLAVE          [ reduce using rule 242 (something_ex -> funciones .) ]
  ! INT32           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! INT64           [ reduce using rule 242 (something_ex -> funciones .) ]
  ! FLOAT32         [ reduce using rule 242 (something_ex -> funciones .) ]
  ! FLOAT64         [ reduce using rule 242 (something_ex -> funciones .) ]
  ! BYTE            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! WINT            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! WFLOAT          [ reduce using rule 242 (something_ex -> funciones .) ]
  ! WSTRING         [ reduce using rule 242 (something_ex -> funciones .) ]
  ! BOOL            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! DEFAULT         [ reduce using rule 242 (something_ex -> funciones .) ]
  ! CASE            [ reduce using rule 242 (something_ex -> funciones .) ]
  ! RETURN          [ reduce using rule 242 (something_ex -> funciones .) ]


state 203

    (207) index -> ID .
    (142) index_s -> ID .
    (213) key -> ID .
    (238) something_ex -> ID .
    (177) value -> ID .
    (191) logic_value -> ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for RCORCHE resolved using rule 142 (index_s -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 142 (index_s -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 142 (index_s -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 177 (value -> ID .)
    RCORCHE         reduce using rule 142 (index_s -> ID .)
    GREATER         reduce using rule 177 (value -> ID .)
    SMALLER         reduce using rule 177 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 177 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 177 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 177 (value -> ID .)
    NOT_EQUAL       reduce using rule 177 (value -> ID .)
    PLUS            reduce using rule 177 (value -> ID .)
    TIMES           reduce using rule 177 (value -> ID .)
    DIVIDE          reduce using rule 177 (value -> ID .)
    MINUS           reduce using rule 177 (value -> ID .)
    MOD             reduce using rule 177 (value -> ID .)
    AND             reduce using rule 191 (logic_value -> ID .)
    OR              reduce using rule 191 (logic_value -> ID .)
    LCORCHE         shift and go to state 172
    LPAREN          shift and go to state 111

  ! RCORCHE         [ reduce using rule 207 (index -> ID .) ]
  ! RCORCHE         [ reduce using rule 213 (key -> ID .) ]
  ! GREATER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 238 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 238 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 238 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 238 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 238 (something_ex -> ID .) ]


state 204

    (206) array_var -> ID LCORCHE index . RCORCHE

    RCORCHE         shift and go to state 269


state 205

    (141) slice_var -> ID LCORCHE index_s . RCORCHE

    RCORCHE         shift and go to state 270


state 206

    (212) map_var -> ID LCORCHE key . RCORCHE

    RCORCHE         shift and go to state 271


state 207

    (208) index -> INTEGER .
    (143) index_s -> INTEGER .
    (46) values -> INTEGER .
    (239) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 143 (index_s -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 46 (values -> INTEGER .)
    RCORCHE         reduce using rule 46 (values -> INTEGER .)
    GREATER         reduce using rule 239 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 239 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 239 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 239 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 239 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 239 (something_ex -> INTEGER .)
    PLUS            reduce using rule 239 (something_ex -> INTEGER .)
    TIMES           reduce using rule 239 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 239 (something_ex -> INTEGER .)
    MINUS           reduce using rule 239 (something_ex -> INTEGER .)
    MOD             reduce using rule 239 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 208 (index -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 143 (index_s -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 239 (something_ex -> INTEGER .) ]


state 208

    (209) index -> expression .
    (144) index_s -> expression .
    (59) operations -> expression .
    (178) value -> expression .

  ! reduce/reduce conflict for RCORCHE resolved using rule 144 (index_s -> expression .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 59 (operations -> expression .)
    RCORCHE         reduce using rule 59 (operations -> expression .)
    GREATER         reduce using rule 178 (value -> expression .)
    SMALLER         reduce using rule 178 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 178 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 178 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 178 (value -> expression .)
    NOT_EQUAL       reduce using rule 178 (value -> expression .)
    PLUS            reduce using rule 178 (value -> expression .)
    TIMES           reduce using rule 178 (value -> expression .)
    DIVIDE          reduce using rule 178 (value -> expression .)
    MINUS           reduce using rule 178 (value -> expression .)
    MOD             reduce using rule 178 (value -> expression .)

  ! RCORCHE         [ reduce using rule 209 (index -> expression .) ]
  ! RCORCHE         [ reduce using rule 144 (index_s -> expression .) ]


state 209

    (214) key -> values .

    RCORCHE         reduce using rule 214 (key -> values .)


state 210

    (215) key -> operations .

    RCORCHE         reduce using rule 215 (key -> operations .)


state 211

    (84) list_params -> ID .
    (85) list_params -> ID . COMA more_p

    RPAREN          reduce using rule 84 (list_params -> ID .)
    COMA            shift and go to state 272


state 212

    (82) call_func -> ID LPAREN list_params . RPAREN

    RPAREN          shift and go to state 273


state 213

    (83) call_func -> ID LPAREN RPAREN .

    COLON           reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    PRINT           reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    SCAN            reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    FOR             reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    CONST           reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    ID              reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    APPEND          reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    LEN             reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    COPY            reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    DELETE          reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    IF              reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    ELSE            reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    TYPE            reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    SWITCH          reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    VAR             reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    FUNC            reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    INTEGER         reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    FLOAT           reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    NOT             reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    $end            reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    GREATER         reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    SMALLER         reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    GREATER_OR_EQUAL reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    EQUAL_COMPARE   reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    NOT_EQUAL       reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    TIMES           reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    MOD             reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    RLLAVE          reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    INT32           reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    INT64           reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    FLOAT32         reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    FLOAT64         reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    BYTE            reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    WINT            reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    WFLOAT          reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    WSTRING         reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    BOOL            reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    DEFAULT         reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    CASE            reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    RETURN          reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    AND             reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    OR              reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    LLLAVE          reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    RCORCHE         reduce using rule 83 (call_func -> ID LPAREN RPAREN .)
    COMA            reduce using rule 83 (call_func -> ID LPAREN RPAREN .)


state 214

    (150) funciones -> APPEND LPAREN ID . COMA values RPAREN
    (151) funciones -> APPEND LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 274


state 215

    (152) funciones -> LEN LPAREN ID . RPAREN

    RPAREN          shift and go to state 275


state 216

    (153) funciones -> COPY LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 276


state 217

    (154) funciones -> DELETE LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 277


state 218

    (158) SenIF -> IF comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    comparison                     shift and go to state 8
    codigo                         shift and go to state 278
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 219

    (159) SenIF -> IF TRUE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 279
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 220

    (160) SenIF -> IF FALSE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 280
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 221

    (161) SenElseIF -> ELSE IF comparison . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 281


state 222

    (162) SenElseIF -> ELSE IF TRUE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 282


state 223

    (163) SenElseIF -> ELSE IF FALSE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 283


state 224

    (164) SenElse -> ELSE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 284


state 225

    (165) SenStruct -> TYPE ID STRUCT . LLLAVE declaration RLLAVE

    LLLAVE          shift and go to state 285


state 226

    (196) switch_statement -> SWITCH ID LLLAVE . cases RLLAVE
    (197) cases -> . CASE values POINTS codigo
    (198) cases -> . CASE values POINTS codigo more

    CASE            shift and go to state 287

    cases                          shift and go to state 286

state 227

    (201) array_declaration -> VAR ID LCORCHE . capacity RCORCHE data_types
    (131) slice_declaration -> VAR ID LCORCHE . RCORCHE data_types
    (211) map_declaration -> VAR ID LCORCHE . data_types RCORCHE data_types
    (203) capacity -> . INTEGER
    (204) capacity -> . ID
    (205) capacity -> . expression
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WINT
    (56) data_types -> . WFLOAT
    (57) data_types -> . WSTRING
    (58) data_types -> . BOOL
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    RCORCHE         shift and go to state 290
    INTEGER         shift and go to state 292
    ID              shift and go to state 288
    INT32           shift and go to state 131
    INT64           shift and go to state 132
    FLOAT32         shift and go to state 133
    FLOAT64         shift and go to state 134
    BYTE            shift and go to state 135
    WINT            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    BOOL            shift and go to state 139
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    capacity                       shift and go to state 289
    data_types                     shift and go to state 291
    expression                     shift and go to state 293
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 228

    (120) single -> VAR ID data_types .
    (121) single -> VAR ID data_types . EQUAL funciones
    (122) single -> VAR ID data_types . EQUAL ID
    (123) single -> VAR ID data_types . EQUAL data_structure

    COLON           reduce using rule 120 (single -> VAR ID data_types .)
    PRINT           reduce using rule 120 (single -> VAR ID data_types .)
    SCAN            reduce using rule 120 (single -> VAR ID data_types .)
    FOR             reduce using rule 120 (single -> VAR ID data_types .)
    CONST           reduce using rule 120 (single -> VAR ID data_types .)
    ID              reduce using rule 120 (single -> VAR ID data_types .)
    APPEND          reduce using rule 120 (single -> VAR ID data_types .)
    LEN             reduce using rule 120 (single -> VAR ID data_types .)
    COPY            reduce using rule 120 (single -> VAR ID data_types .)
    DELETE          reduce using rule 120 (single -> VAR ID data_types .)
    IF              reduce using rule 120 (single -> VAR ID data_types .)
    ELSE            reduce using rule 120 (single -> VAR ID data_types .)
    TYPE            reduce using rule 120 (single -> VAR ID data_types .)
    SWITCH          reduce using rule 120 (single -> VAR ID data_types .)
    VAR             reduce using rule 120 (single -> VAR ID data_types .)
    FUNC            reduce using rule 120 (single -> VAR ID data_types .)
    INTEGER         reduce using rule 120 (single -> VAR ID data_types .)
    FLOAT           reduce using rule 120 (single -> VAR ID data_types .)
    NOT             reduce using rule 120 (single -> VAR ID data_types .)
    $end            reduce using rule 120 (single -> VAR ID data_types .)
    RLLAVE          reduce using rule 120 (single -> VAR ID data_types .)
    INT32           reduce using rule 120 (single -> VAR ID data_types .)
    INT64           reduce using rule 120 (single -> VAR ID data_types .)
    FLOAT32         reduce using rule 120 (single -> VAR ID data_types .)
    FLOAT64         reduce using rule 120 (single -> VAR ID data_types .)
    BYTE            reduce using rule 120 (single -> VAR ID data_types .)
    WINT            reduce using rule 120 (single -> VAR ID data_types .)
    WFLOAT          reduce using rule 120 (single -> VAR ID data_types .)
    WSTRING         reduce using rule 120 (single -> VAR ID data_types .)
    BOOL            reduce using rule 120 (single -> VAR ID data_types .)
    DEFAULT         reduce using rule 120 (single -> VAR ID data_types .)
    CASE            reduce using rule 120 (single -> VAR ID data_types .)
    RETURN          reduce using rule 120 (single -> VAR ID data_types .)
    EQUAL           shift and go to state 294


state 229

    (202) array_declaration -> VAR ID EQUAL . LCORCHE capacity RCORCHE data_types arr_content
    (132) slice_declaration -> VAR ID EQUAL . LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> VAR ID EQUAL . funM
    (136) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (137) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LCORCHE         shift and go to state 295
    MAKE            shift and go to state 198

    funM                           shift and go to state 296

state 230

    (124) single -> VAR ID data_type_and_value .

    COLON           reduce using rule 124 (single -> VAR ID data_type_and_value .)
    PRINT           reduce using rule 124 (single -> VAR ID data_type_and_value .)
    SCAN            reduce using rule 124 (single -> VAR ID data_type_and_value .)
    FOR             reduce using rule 124 (single -> VAR ID data_type_and_value .)
    CONST           reduce using rule 124 (single -> VAR ID data_type_and_value .)
    ID              reduce using rule 124 (single -> VAR ID data_type_and_value .)
    APPEND          reduce using rule 124 (single -> VAR ID data_type_and_value .)
    LEN             reduce using rule 124 (single -> VAR ID data_type_and_value .)
    COPY            reduce using rule 124 (single -> VAR ID data_type_and_value .)
    DELETE          reduce using rule 124 (single -> VAR ID data_type_and_value .)
    IF              reduce using rule 124 (single -> VAR ID data_type_and_value .)
    ELSE            reduce using rule 124 (single -> VAR ID data_type_and_value .)
    TYPE            reduce using rule 124 (single -> VAR ID data_type_and_value .)
    SWITCH          reduce using rule 124 (single -> VAR ID data_type_and_value .)
    VAR             reduce using rule 124 (single -> VAR ID data_type_and_value .)
    FUNC            reduce using rule 124 (single -> VAR ID data_type_and_value .)
    INTEGER         reduce using rule 124 (single -> VAR ID data_type_and_value .)
    FLOAT           reduce using rule 124 (single -> VAR ID data_type_and_value .)
    NOT             reduce using rule 124 (single -> VAR ID data_type_and_value .)
    $end            reduce using rule 124 (single -> VAR ID data_type_and_value .)
    RLLAVE          reduce using rule 124 (single -> VAR ID data_type_and_value .)
    INT32           reduce using rule 124 (single -> VAR ID data_type_and_value .)
    INT64           reduce using rule 124 (single -> VAR ID data_type_and_value .)
    FLOAT32         reduce using rule 124 (single -> VAR ID data_type_and_value .)
    FLOAT64         reduce using rule 124 (single -> VAR ID data_type_and_value .)
    BYTE            reduce using rule 124 (single -> VAR ID data_type_and_value .)
    WINT            reduce using rule 124 (single -> VAR ID data_type_and_value .)
    WFLOAT          reduce using rule 124 (single -> VAR ID data_type_and_value .)
    WSTRING         reduce using rule 124 (single -> VAR ID data_type_and_value .)
    BOOL            reduce using rule 124 (single -> VAR ID data_type_and_value .)
    DEFAULT         reduce using rule 124 (single -> VAR ID data_type_and_value .)
    CASE            reduce using rule 124 (single -> VAR ID data_type_and_value .)
    RETURN          reduce using rule 124 (single -> VAR ID data_type_and_value .)


state 231

    (117) list_var -> VAR ID COMA . more
    (118) more -> . ID
    (119) more -> . ID COMA more
    (199) more -> . cases
    (200) more -> . DEFAULT POINTS codigo
    (197) cases -> . CASE values POINTS codigo
    (198) cases -> . CASE values POINTS codigo more

    ID              shift and go to state 297
    DEFAULT         shift and go to state 300
    CASE            shift and go to state 287

    more                           shift and go to state 298
    cases                          shift and go to state 299

state 232

    (50) data_types -> INT32 .
    (95) data_type_and_value -> INT32 . EQUAL int_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 50 (data_types -> INT32 .)
    PRINT           reduce using rule 50 (data_types -> INT32 .)
    SCAN            reduce using rule 50 (data_types -> INT32 .)
    FOR             reduce using rule 50 (data_types -> INT32 .)
    CONST           reduce using rule 50 (data_types -> INT32 .)
    ID              reduce using rule 50 (data_types -> INT32 .)
    APPEND          reduce using rule 50 (data_types -> INT32 .)
    LEN             reduce using rule 50 (data_types -> INT32 .)
    COPY            reduce using rule 50 (data_types -> INT32 .)
    DELETE          reduce using rule 50 (data_types -> INT32 .)
    IF              reduce using rule 50 (data_types -> INT32 .)
    ELSE            reduce using rule 50 (data_types -> INT32 .)
    TYPE            reduce using rule 50 (data_types -> INT32 .)
    SWITCH          reduce using rule 50 (data_types -> INT32 .)
    VAR             reduce using rule 50 (data_types -> INT32 .)
    FUNC            reduce using rule 50 (data_types -> INT32 .)
    INTEGER         reduce using rule 50 (data_types -> INT32 .)
    FLOAT           reduce using rule 50 (data_types -> INT32 .)
    NOT             reduce using rule 50 (data_types -> INT32 .)
    $end            reduce using rule 50 (data_types -> INT32 .)
    RLLAVE          reduce using rule 50 (data_types -> INT32 .)
    INT32           reduce using rule 50 (data_types -> INT32 .)
    INT64           reduce using rule 50 (data_types -> INT32 .)
    FLOAT32         reduce using rule 50 (data_types -> INT32 .)
    FLOAT64         reduce using rule 50 (data_types -> INT32 .)
    BYTE            reduce using rule 50 (data_types -> INT32 .)
    WINT            reduce using rule 50 (data_types -> INT32 .)
    WFLOAT          reduce using rule 50 (data_types -> INT32 .)
    WSTRING         reduce using rule 50 (data_types -> INT32 .)
    BOOL            reduce using rule 50 (data_types -> INT32 .)
    DEFAULT         reduce using rule 50 (data_types -> INT32 .)
    CASE            reduce using rule 50 (data_types -> INT32 .)
    RETURN          reduce using rule 50 (data_types -> INT32 .)
    EQUAL           shift and go to state 260

  ! EQUAL           [ reduce using rule 50 (data_types -> INT32 .) ]


state 233

    (51) data_types -> INT64 .
    (96) data_type_and_value -> INT64 . EQUAL int_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 51 (data_types -> INT64 .)
    PRINT           reduce using rule 51 (data_types -> INT64 .)
    SCAN            reduce using rule 51 (data_types -> INT64 .)
    FOR             reduce using rule 51 (data_types -> INT64 .)
    CONST           reduce using rule 51 (data_types -> INT64 .)
    ID              reduce using rule 51 (data_types -> INT64 .)
    APPEND          reduce using rule 51 (data_types -> INT64 .)
    LEN             reduce using rule 51 (data_types -> INT64 .)
    COPY            reduce using rule 51 (data_types -> INT64 .)
    DELETE          reduce using rule 51 (data_types -> INT64 .)
    IF              reduce using rule 51 (data_types -> INT64 .)
    ELSE            reduce using rule 51 (data_types -> INT64 .)
    TYPE            reduce using rule 51 (data_types -> INT64 .)
    SWITCH          reduce using rule 51 (data_types -> INT64 .)
    VAR             reduce using rule 51 (data_types -> INT64 .)
    FUNC            reduce using rule 51 (data_types -> INT64 .)
    INTEGER         reduce using rule 51 (data_types -> INT64 .)
    FLOAT           reduce using rule 51 (data_types -> INT64 .)
    NOT             reduce using rule 51 (data_types -> INT64 .)
    $end            reduce using rule 51 (data_types -> INT64 .)
    RLLAVE          reduce using rule 51 (data_types -> INT64 .)
    INT32           reduce using rule 51 (data_types -> INT64 .)
    INT64           reduce using rule 51 (data_types -> INT64 .)
    FLOAT32         reduce using rule 51 (data_types -> INT64 .)
    FLOAT64         reduce using rule 51 (data_types -> INT64 .)
    BYTE            reduce using rule 51 (data_types -> INT64 .)
    WINT            reduce using rule 51 (data_types -> INT64 .)
    WFLOAT          reduce using rule 51 (data_types -> INT64 .)
    WSTRING         reduce using rule 51 (data_types -> INT64 .)
    BOOL            reduce using rule 51 (data_types -> INT64 .)
    DEFAULT         reduce using rule 51 (data_types -> INT64 .)
    CASE            reduce using rule 51 (data_types -> INT64 .)
    RETURN          reduce using rule 51 (data_types -> INT64 .)
    EQUAL           shift and go to state 261

  ! EQUAL           [ reduce using rule 51 (data_types -> INT64 .) ]


state 234

    (52) data_types -> FLOAT32 .
    (98) data_type_and_value -> FLOAT32 . EQUAL float_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 52 (data_types -> FLOAT32 .)
    PRINT           reduce using rule 52 (data_types -> FLOAT32 .)
    SCAN            reduce using rule 52 (data_types -> FLOAT32 .)
    FOR             reduce using rule 52 (data_types -> FLOAT32 .)
    CONST           reduce using rule 52 (data_types -> FLOAT32 .)
    ID              reduce using rule 52 (data_types -> FLOAT32 .)
    APPEND          reduce using rule 52 (data_types -> FLOAT32 .)
    LEN             reduce using rule 52 (data_types -> FLOAT32 .)
    COPY            reduce using rule 52 (data_types -> FLOAT32 .)
    DELETE          reduce using rule 52 (data_types -> FLOAT32 .)
    IF              reduce using rule 52 (data_types -> FLOAT32 .)
    ELSE            reduce using rule 52 (data_types -> FLOAT32 .)
    TYPE            reduce using rule 52 (data_types -> FLOAT32 .)
    SWITCH          reduce using rule 52 (data_types -> FLOAT32 .)
    VAR             reduce using rule 52 (data_types -> FLOAT32 .)
    FUNC            reduce using rule 52 (data_types -> FLOAT32 .)
    INTEGER         reduce using rule 52 (data_types -> FLOAT32 .)
    FLOAT           reduce using rule 52 (data_types -> FLOAT32 .)
    NOT             reduce using rule 52 (data_types -> FLOAT32 .)
    $end            reduce using rule 52 (data_types -> FLOAT32 .)
    RLLAVE          reduce using rule 52 (data_types -> FLOAT32 .)
    INT32           reduce using rule 52 (data_types -> FLOAT32 .)
    INT64           reduce using rule 52 (data_types -> FLOAT32 .)
    FLOAT32         reduce using rule 52 (data_types -> FLOAT32 .)
    FLOAT64         reduce using rule 52 (data_types -> FLOAT32 .)
    BYTE            reduce using rule 52 (data_types -> FLOAT32 .)
    WINT            reduce using rule 52 (data_types -> FLOAT32 .)
    WFLOAT          reduce using rule 52 (data_types -> FLOAT32 .)
    WSTRING         reduce using rule 52 (data_types -> FLOAT32 .)
    BOOL            reduce using rule 52 (data_types -> FLOAT32 .)
    DEFAULT         reduce using rule 52 (data_types -> FLOAT32 .)
    CASE            reduce using rule 52 (data_types -> FLOAT32 .)
    RETURN          reduce using rule 52 (data_types -> FLOAT32 .)
    EQUAL           shift and go to state 263

  ! EQUAL           [ reduce using rule 52 (data_types -> FLOAT32 .) ]


state 235

    (53) data_types -> FLOAT64 .
    (99) data_type_and_value -> FLOAT64 . EQUAL float_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 53 (data_types -> FLOAT64 .)
    PRINT           reduce using rule 53 (data_types -> FLOAT64 .)
    SCAN            reduce using rule 53 (data_types -> FLOAT64 .)
    FOR             reduce using rule 53 (data_types -> FLOAT64 .)
    CONST           reduce using rule 53 (data_types -> FLOAT64 .)
    ID              reduce using rule 53 (data_types -> FLOAT64 .)
    APPEND          reduce using rule 53 (data_types -> FLOAT64 .)
    LEN             reduce using rule 53 (data_types -> FLOAT64 .)
    COPY            reduce using rule 53 (data_types -> FLOAT64 .)
    DELETE          reduce using rule 53 (data_types -> FLOAT64 .)
    IF              reduce using rule 53 (data_types -> FLOAT64 .)
    ELSE            reduce using rule 53 (data_types -> FLOAT64 .)
    TYPE            reduce using rule 53 (data_types -> FLOAT64 .)
    SWITCH          reduce using rule 53 (data_types -> FLOAT64 .)
    VAR             reduce using rule 53 (data_types -> FLOAT64 .)
    FUNC            reduce using rule 53 (data_types -> FLOAT64 .)
    INTEGER         reduce using rule 53 (data_types -> FLOAT64 .)
    FLOAT           reduce using rule 53 (data_types -> FLOAT64 .)
    NOT             reduce using rule 53 (data_types -> FLOAT64 .)
    $end            reduce using rule 53 (data_types -> FLOAT64 .)
    RLLAVE          reduce using rule 53 (data_types -> FLOAT64 .)
    INT32           reduce using rule 53 (data_types -> FLOAT64 .)
    INT64           reduce using rule 53 (data_types -> FLOAT64 .)
    FLOAT32         reduce using rule 53 (data_types -> FLOAT64 .)
    FLOAT64         reduce using rule 53 (data_types -> FLOAT64 .)
    BYTE            reduce using rule 53 (data_types -> FLOAT64 .)
    WINT            reduce using rule 53 (data_types -> FLOAT64 .)
    WFLOAT          reduce using rule 53 (data_types -> FLOAT64 .)
    WSTRING         reduce using rule 53 (data_types -> FLOAT64 .)
    BOOL            reduce using rule 53 (data_types -> FLOAT64 .)
    DEFAULT         reduce using rule 53 (data_types -> FLOAT64 .)
    CASE            reduce using rule 53 (data_types -> FLOAT64 .)
    RETURN          reduce using rule 53 (data_types -> FLOAT64 .)
    EQUAL           shift and go to state 264

  ! EQUAL           [ reduce using rule 53 (data_types -> FLOAT64 .) ]


state 236

    (55) data_types -> WINT .
    (94) data_type_and_value -> WINT . EQUAL int_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 55 (data_types -> WINT .)
    PRINT           reduce using rule 55 (data_types -> WINT .)
    SCAN            reduce using rule 55 (data_types -> WINT .)
    FOR             reduce using rule 55 (data_types -> WINT .)
    CONST           reduce using rule 55 (data_types -> WINT .)
    ID              reduce using rule 55 (data_types -> WINT .)
    APPEND          reduce using rule 55 (data_types -> WINT .)
    LEN             reduce using rule 55 (data_types -> WINT .)
    COPY            reduce using rule 55 (data_types -> WINT .)
    DELETE          reduce using rule 55 (data_types -> WINT .)
    IF              reduce using rule 55 (data_types -> WINT .)
    ELSE            reduce using rule 55 (data_types -> WINT .)
    TYPE            reduce using rule 55 (data_types -> WINT .)
    SWITCH          reduce using rule 55 (data_types -> WINT .)
    VAR             reduce using rule 55 (data_types -> WINT .)
    FUNC            reduce using rule 55 (data_types -> WINT .)
    INTEGER         reduce using rule 55 (data_types -> WINT .)
    FLOAT           reduce using rule 55 (data_types -> WINT .)
    NOT             reduce using rule 55 (data_types -> WINT .)
    $end            reduce using rule 55 (data_types -> WINT .)
    RLLAVE          reduce using rule 55 (data_types -> WINT .)
    INT32           reduce using rule 55 (data_types -> WINT .)
    INT64           reduce using rule 55 (data_types -> WINT .)
    FLOAT32         reduce using rule 55 (data_types -> WINT .)
    FLOAT64         reduce using rule 55 (data_types -> WINT .)
    BYTE            reduce using rule 55 (data_types -> WINT .)
    WINT            reduce using rule 55 (data_types -> WINT .)
    WFLOAT          reduce using rule 55 (data_types -> WINT .)
    WSTRING         reduce using rule 55 (data_types -> WINT .)
    BOOL            reduce using rule 55 (data_types -> WINT .)
    DEFAULT         reduce using rule 55 (data_types -> WINT .)
    CASE            reduce using rule 55 (data_types -> WINT .)
    RETURN          reduce using rule 55 (data_types -> WINT .)
    EQUAL           shift and go to state 259

  ! EQUAL           [ reduce using rule 55 (data_types -> WINT .) ]


state 237

    (56) data_types -> WFLOAT .
    (97) data_type_and_value -> WFLOAT . EQUAL float_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 56 (data_types -> WFLOAT .)
    PRINT           reduce using rule 56 (data_types -> WFLOAT .)
    SCAN            reduce using rule 56 (data_types -> WFLOAT .)
    FOR             reduce using rule 56 (data_types -> WFLOAT .)
    CONST           reduce using rule 56 (data_types -> WFLOAT .)
    ID              reduce using rule 56 (data_types -> WFLOAT .)
    APPEND          reduce using rule 56 (data_types -> WFLOAT .)
    LEN             reduce using rule 56 (data_types -> WFLOAT .)
    COPY            reduce using rule 56 (data_types -> WFLOAT .)
    DELETE          reduce using rule 56 (data_types -> WFLOAT .)
    IF              reduce using rule 56 (data_types -> WFLOAT .)
    ELSE            reduce using rule 56 (data_types -> WFLOAT .)
    TYPE            reduce using rule 56 (data_types -> WFLOAT .)
    SWITCH          reduce using rule 56 (data_types -> WFLOAT .)
    VAR             reduce using rule 56 (data_types -> WFLOAT .)
    FUNC            reduce using rule 56 (data_types -> WFLOAT .)
    INTEGER         reduce using rule 56 (data_types -> WFLOAT .)
    FLOAT           reduce using rule 56 (data_types -> WFLOAT .)
    NOT             reduce using rule 56 (data_types -> WFLOAT .)
    $end            reduce using rule 56 (data_types -> WFLOAT .)
    RLLAVE          reduce using rule 56 (data_types -> WFLOAT .)
    INT32           reduce using rule 56 (data_types -> WFLOAT .)
    INT64           reduce using rule 56 (data_types -> WFLOAT .)
    FLOAT32         reduce using rule 56 (data_types -> WFLOAT .)
    FLOAT64         reduce using rule 56 (data_types -> WFLOAT .)
    BYTE            reduce using rule 56 (data_types -> WFLOAT .)
    WINT            reduce using rule 56 (data_types -> WFLOAT .)
    WFLOAT          reduce using rule 56 (data_types -> WFLOAT .)
    WSTRING         reduce using rule 56 (data_types -> WFLOAT .)
    BOOL            reduce using rule 56 (data_types -> WFLOAT .)
    DEFAULT         reduce using rule 56 (data_types -> WFLOAT .)
    CASE            reduce using rule 56 (data_types -> WFLOAT .)
    RETURN          reduce using rule 56 (data_types -> WFLOAT .)
    EQUAL           shift and go to state 262

  ! EQUAL           [ reduce using rule 56 (data_types -> WFLOAT .) ]


state 238

    (57) data_types -> WSTRING .
    (93) data_type_and_value -> WSTRING . EQUAL STRING

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 57 (data_types -> WSTRING .)
    PRINT           reduce using rule 57 (data_types -> WSTRING .)
    SCAN            reduce using rule 57 (data_types -> WSTRING .)
    FOR             reduce using rule 57 (data_types -> WSTRING .)
    CONST           reduce using rule 57 (data_types -> WSTRING .)
    ID              reduce using rule 57 (data_types -> WSTRING .)
    APPEND          reduce using rule 57 (data_types -> WSTRING .)
    LEN             reduce using rule 57 (data_types -> WSTRING .)
    COPY            reduce using rule 57 (data_types -> WSTRING .)
    DELETE          reduce using rule 57 (data_types -> WSTRING .)
    IF              reduce using rule 57 (data_types -> WSTRING .)
    ELSE            reduce using rule 57 (data_types -> WSTRING .)
    TYPE            reduce using rule 57 (data_types -> WSTRING .)
    SWITCH          reduce using rule 57 (data_types -> WSTRING .)
    VAR             reduce using rule 57 (data_types -> WSTRING .)
    FUNC            reduce using rule 57 (data_types -> WSTRING .)
    INTEGER         reduce using rule 57 (data_types -> WSTRING .)
    FLOAT           reduce using rule 57 (data_types -> WSTRING .)
    NOT             reduce using rule 57 (data_types -> WSTRING .)
    $end            reduce using rule 57 (data_types -> WSTRING .)
    RLLAVE          reduce using rule 57 (data_types -> WSTRING .)
    INT32           reduce using rule 57 (data_types -> WSTRING .)
    INT64           reduce using rule 57 (data_types -> WSTRING .)
    FLOAT32         reduce using rule 57 (data_types -> WSTRING .)
    FLOAT64         reduce using rule 57 (data_types -> WSTRING .)
    BYTE            reduce using rule 57 (data_types -> WSTRING .)
    WINT            reduce using rule 57 (data_types -> WSTRING .)
    WFLOAT          reduce using rule 57 (data_types -> WSTRING .)
    WSTRING         reduce using rule 57 (data_types -> WSTRING .)
    BOOL            reduce using rule 57 (data_types -> WSTRING .)
    DEFAULT         reduce using rule 57 (data_types -> WSTRING .)
    CASE            reduce using rule 57 (data_types -> WSTRING .)
    RETURN          reduce using rule 57 (data_types -> WSTRING .)
    EQUAL           shift and go to state 258

  ! EQUAL           [ reduce using rule 57 (data_types -> WSTRING .) ]


state 239

    (58) data_types -> BOOL .
    (100) data_type_and_value -> BOOL . EQUAL bool_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 58 (data_types -> BOOL .)
    PRINT           reduce using rule 58 (data_types -> BOOL .)
    SCAN            reduce using rule 58 (data_types -> BOOL .)
    FOR             reduce using rule 58 (data_types -> BOOL .)
    CONST           reduce using rule 58 (data_types -> BOOL .)
    ID              reduce using rule 58 (data_types -> BOOL .)
    APPEND          reduce using rule 58 (data_types -> BOOL .)
    LEN             reduce using rule 58 (data_types -> BOOL .)
    COPY            reduce using rule 58 (data_types -> BOOL .)
    DELETE          reduce using rule 58 (data_types -> BOOL .)
    IF              reduce using rule 58 (data_types -> BOOL .)
    ELSE            reduce using rule 58 (data_types -> BOOL .)
    TYPE            reduce using rule 58 (data_types -> BOOL .)
    SWITCH          reduce using rule 58 (data_types -> BOOL .)
    VAR             reduce using rule 58 (data_types -> BOOL .)
    FUNC            reduce using rule 58 (data_types -> BOOL .)
    INTEGER         reduce using rule 58 (data_types -> BOOL .)
    FLOAT           reduce using rule 58 (data_types -> BOOL .)
    NOT             reduce using rule 58 (data_types -> BOOL .)
    $end            reduce using rule 58 (data_types -> BOOL .)
    RLLAVE          reduce using rule 58 (data_types -> BOOL .)
    INT32           reduce using rule 58 (data_types -> BOOL .)
    INT64           reduce using rule 58 (data_types -> BOOL .)
    FLOAT32         reduce using rule 58 (data_types -> BOOL .)
    FLOAT64         reduce using rule 58 (data_types -> BOOL .)
    BYTE            reduce using rule 58 (data_types -> BOOL .)
    WINT            reduce using rule 58 (data_types -> BOOL .)
    WFLOAT          reduce using rule 58 (data_types -> BOOL .)
    WSTRING         reduce using rule 58 (data_types -> BOOL .)
    BOOL            reduce using rule 58 (data_types -> BOOL .)
    DEFAULT         reduce using rule 58 (data_types -> BOOL .)
    CASE            reduce using rule 58 (data_types -> BOOL .)
    RETURN          reduce using rule 58 (data_types -> BOOL .)
    EQUAL           shift and go to state 265

  ! EQUAL           [ reduce using rule 58 (data_types -> BOOL .) ]


state 240

    (216) map_assignment -> map_var EQUAL something .

    COLON           reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    PRINT           reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    SCAN            reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    FOR             reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    CONST           reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    ID              reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    APPEND          reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    LEN             reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    COPY            reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    DELETE          reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    IF              reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    ELSE            reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    TYPE            reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    SWITCH          reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    VAR             reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    FUNC            reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    INTEGER         reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    FLOAT           reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    NOT             reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    $end            reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    RLLAVE          reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    INT32           reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    INT64           reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    FLOAT32         reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    FLOAT64         reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    BYTE            reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    WINT            reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    WFLOAT          reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    WSTRING         reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    BOOL            reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    DEFAULT         reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    CASE            reduce using rule 216 (map_assignment -> map_var EQUAL something .)
    RETURN          reduce using rule 216 (map_assignment -> map_var EQUAL something .)


state 241

    (217) func_declaration -> FUNC ID LPAREN . params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> FUNC ID LPAREN . params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (225) params -> . ID data_types
    (226) params -> . more_params
    (227) more_params -> . ID data_types COMA params

    ID              shift and go to state 301

    params                         shift and go to state 302
    more_params                    shift and go to state 303

state 242

    (80) main_func -> FUNC MAIN LPAREN . RPAREN LLLAVE codigo RLLAVE

    RPAREN          shift and go to state 304


state 243

    (228) impresion -> PRINT LPAREN content RPAREN .

    COLON           reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    PRINT           reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    SCAN            reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    FOR             reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    CONST           reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    ID              reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    APPEND          reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    LEN             reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    COPY            reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    DELETE          reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    IF              reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    ELSE            reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    TYPE            reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    SWITCH          reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    VAR             reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    FUNC            reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    INTEGER         reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    FLOAT           reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    NOT             reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    $end            reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    RLLAVE          reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    INT32           reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    INT64           reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    FLOAT32         reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    FLOAT64         reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    BYTE            reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    WINT            reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    WFLOAT          reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    WSTRING         reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    BOOL            reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    DEFAULT         reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    CASE            reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)
    RETURN          reduce using rule 228 (impresion -> PRINT LPAREN content RPAREN .)


state 244

    (81) scan_func -> SCAN LPAREN POINTER RPAREN .

    COLON           reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    PRINT           reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    SCAN            reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FOR             reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    CONST           reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    ID              reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    APPEND          reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    LEN             reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    COPY            reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    DELETE          reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    IF              reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    ELSE            reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    TYPE            reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    SWITCH          reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    VAR             reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FUNC            reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    INTEGER         reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FLOAT           reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    NOT             reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    $end            reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    RLLAVE          reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    INT32           reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    INT64           reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FLOAT32         reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FLOAT64         reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    BYTE            reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    WINT            reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    WFLOAT          reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    WSTRING         reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    BOOL            reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    DEFAULT         reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    CASE            reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    RETURN          reduce using rule 81 (scan_func -> SCAN LPAREN POINTER RPAREN .)


state 245

    (237) adicionaEx -> op something_ex adicionaEx .

    COLON           reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    PRINT           reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    SCAN            reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    FOR             reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    CONST           reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    ID              reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    APPEND          reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    LEN             reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    COPY            reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    DELETE          reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    IF              reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    ELSE            reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    TYPE            reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    SWITCH          reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    VAR             reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    FUNC            reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    INTEGER         reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    FLOAT           reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    NOT             reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    $end            reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    GREATER         reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    SMALLER         reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    GREATER_OR_EQUAL reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    SMALLER_OR_EQUAL reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    EQUAL_COMPARE   reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    NOT_EQUAL       reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    PLUS            reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    TIMES           reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    DIVIDE          reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    MINUS           reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    MOD             reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    RLLAVE          reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    INT32           reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    INT64           reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    FLOAT32         reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    FLOAT64         reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    BYTE            reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    WINT            reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    WFLOAT          reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    WSTRING         reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    BOOL            reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    DEFAULT         reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    CASE            reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    RETURN          reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    RPAREN          reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    AND             reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    OR              reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    LLLAVE          reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    RCORCHE         reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)
    COMA            reduce using rule 237 (adicionaEx -> op something_ex adicionaEx .)


state 246

    (87) cicloFor -> FOR LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    ID              reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    IF              reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    $end            reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 87 (cicloFor -> FOR LLLAVE codigo RLLAVE .)


state 247

    (88) cicloFor -> FOR comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 305


state 248

    (89) cicloFor -> FOR logic_operation LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 306


state 249

    (90) cicloFor -> FOR decVarOne COLON comparison . COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 307


state 250

    (156) decVarOne -> ID DEQUAL ID .

    COLON           reduce using rule 156 (decVarOne -> ID DEQUAL ID .)


state 251

    (157) decVarOne -> ID DEQUAL INTEGER .

    COLON           reduce using rule 157 (decVarOne -> ID DEQUAL INTEGER .)


state 252

    (207) index -> ID .
    (213) key -> ID .
    (238) something_ex -> ID .
    (177) value -> ID .
    (191) logic_value -> ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for RCORCHE resolved using rule 207 (index -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 207 (index -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 177 (value -> ID .)
    RCORCHE         reduce using rule 207 (index -> ID .)
    GREATER         reduce using rule 177 (value -> ID .)
    SMALLER         reduce using rule 177 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 177 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 177 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 177 (value -> ID .)
    NOT_EQUAL       reduce using rule 177 (value -> ID .)
    PLUS            reduce using rule 177 (value -> ID .)
    TIMES           reduce using rule 177 (value -> ID .)
    DIVIDE          reduce using rule 177 (value -> ID .)
    MINUS           reduce using rule 177 (value -> ID .)
    MOD             reduce using rule 177 (value -> ID .)
    AND             reduce using rule 191 (logic_value -> ID .)
    OR              reduce using rule 191 (logic_value -> ID .)
    LCORCHE         shift and go to state 172
    LPAREN          shift and go to state 111

  ! RCORCHE         [ reduce using rule 213 (key -> ID .) ]
  ! GREATER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 238 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 238 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 238 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 238 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 238 (something_ex -> ID .) ]


state 253

    (208) index -> INTEGER .
    (46) values -> INTEGER .
    (239) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 46 (values -> INTEGER .)
    RCORCHE         reduce using rule 46 (values -> INTEGER .)
    GREATER         reduce using rule 239 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 239 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 239 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 239 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 239 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 239 (something_ex -> INTEGER .)
    PLUS            reduce using rule 239 (something_ex -> INTEGER .)
    TIMES           reduce using rule 239 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 239 (something_ex -> INTEGER .)
    MINUS           reduce using rule 239 (something_ex -> INTEGER .)
    MOD             reduce using rule 239 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 208 (index -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 239 (something_ex -> INTEGER .) ]


state 254

    (209) index -> expression .
    (59) operations -> expression .
    (178) value -> expression .

  ! reduce/reduce conflict for RCORCHE resolved using rule 59 (operations -> expression .)
    RCORCHE         reduce using rule 59 (operations -> expression .)
    GREATER         reduce using rule 178 (value -> expression .)
    SMALLER         reduce using rule 178 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 178 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 178 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 178 (value -> expression .)
    NOT_EQUAL       reduce using rule 178 (value -> expression .)
    PLUS            reduce using rule 178 (value -> expression .)
    TIMES           reduce using rule 178 (value -> expression .)
    DIVIDE          reduce using rule 178 (value -> expression .)
    MINUS           reduce using rule 178 (value -> expression .)
    MOD             reduce using rule 178 (value -> expression .)

  ! RCORCHE         [ reduce using rule 209 (index -> expression .) ]


state 255

    (188) logic_recu -> logic_op logic_value logic_recu .

    PRINT           reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    SCAN            reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    FOR             reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    CONST           reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    ID              reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    APPEND          reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    LEN             reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    COPY            reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    DELETE          reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    IF              reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    ELSE            reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    TYPE            reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    SWITCH          reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    VAR             reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    FUNC            reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    INTEGER         reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    FLOAT           reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    NOT             reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    $end            reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    RLLAVE          reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    INT32           reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    INT64           reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    FLOAT32         reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    FLOAT64         reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    BYTE            reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    WINT            reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    WFLOAT          reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    WSTRING         reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    BOOL            reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    DEFAULT         reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    CASE            reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    RETURN          reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    LLLAVE          reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    COLON           reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    RPAREN          reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    RCORCHE         reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)
    COMA            reduce using rule 188 (logic_recu -> logic_op logic_value logic_recu .)


state 256

    (110) decConst -> CONST ID EQUAL ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE

    COLON           reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    PRINT           reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    SCAN            reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    FOR             reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    CONST           reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    ID              reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    APPEND          reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    LEN             reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    COPY            reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    DELETE          reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    IF              reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    ELSE            reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    TYPE            reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    SWITCH          reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    VAR             reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    FUNC            reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    INTEGER         reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    FLOAT           reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    NOT             reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    $end            reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    RLLAVE          reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    INT32           reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    INT64           reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    FLOAT32         reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    FLOAT64         reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    BYTE            reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    WINT            reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    WFLOAT          reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    WSTRING         reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    BOOL            reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    DEFAULT         reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    CASE            reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    RETURN          reduce using rule 110 (decConst -> CONST ID EQUAL ID .)
    LCORCHE         shift and go to state 172


state 257

    (111) decConst -> CONST ID EQUAL data_structure .

    COLON           reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    PRINT           reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    SCAN            reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    FOR             reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    CONST           reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    ID              reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    APPEND          reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    LEN             reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    COPY            reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    DELETE          reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    IF              reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    ELSE            reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    TYPE            reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    SWITCH          reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    VAR             reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    FUNC            reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    INTEGER         reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    FLOAT           reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    NOT             reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    $end            reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    RLLAVE          reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    INT32           reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    INT64           reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    FLOAT32         reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    FLOAT64         reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    BYTE            reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    WINT            reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    WFLOAT          reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    WSTRING         reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    BOOL            reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    DEFAULT         reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    CASE            reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)
    RETURN          reduce using rule 111 (decConst -> CONST ID EQUAL data_structure .)


state 258

    (93) data_type_and_value -> WSTRING EQUAL . STRING

    STRING          shift and go to state 308


state 259

    (94) data_type_and_value -> WINT EQUAL . int_value
    (101) int_value -> . INTEGER
    (102) int_value -> . expression
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 310
    ID              shift and go to state 166
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    int_value                      shift and go to state 309
    expression                     shift and go to state 311
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 260

    (95) data_type_and_value -> INT32 EQUAL . int_value
    (101) int_value -> . INTEGER
    (102) int_value -> . expression
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 310
    ID              shift and go to state 166
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    int_value                      shift and go to state 312
    expression                     shift and go to state 311
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 261

    (96) data_type_and_value -> INT64 EQUAL . int_value
    (101) int_value -> . INTEGER
    (102) int_value -> . expression
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 310
    ID              shift and go to state 166
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    int_value                      shift and go to state 313
    expression                     shift and go to state 311
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 262

    (97) data_type_and_value -> WFLOAT EQUAL . float_value
    (107) float_value -> . FLOAT
    (108) float_value -> . expression
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    FLOAT           shift and go to state 315
    ID              shift and go to state 166
    INTEGER         shift and go to state 54
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    float_value                    shift and go to state 314
    expression                     shift and go to state 316
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 263

    (98) data_type_and_value -> FLOAT32 EQUAL . float_value
    (107) float_value -> . FLOAT
    (108) float_value -> . expression
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    FLOAT           shift and go to state 315
    ID              shift and go to state 166
    INTEGER         shift and go to state 54
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    float_value                    shift and go to state 317
    expression                     shift and go to state 316
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 264

    (99) data_type_and_value -> FLOAT64 EQUAL . float_value
    (107) float_value -> . FLOAT
    (108) float_value -> . expression
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    FLOAT           shift and go to state 315
    ID              shift and go to state 166
    INTEGER         shift and go to state 54
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    float_value                    shift and go to state 318
    expression                     shift and go to state 316
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 265

    (100) data_type_and_value -> BOOL EQUAL . bool_value
    (103) bool_value -> . TRUE
    (104) bool_value -> . FALSE
    (105) bool_value -> . comparison
    (106) bool_value -> . logic_operation
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    TRUE            shift and go to state 320
    FALSE           shift and go to state 321
    ID              shift and go to state 324
    NOT             shift and go to state 56
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    bool_value                     shift and go to state 319
    comparison                     shift and go to state 322
    logic_operation                shift and go to state 323
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    expression                     shift and go to state 98
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 266

    (169) cStruct -> ID DEQUAL ID LLLAVE . asignaciones RLLAVE
    (170) asignaciones -> . ID POINTS valor
    (171) asignaciones -> . ID POINTS valor COMA asignaciones

    ID              shift and go to state 325

    asignaciones                   shift and go to state 326

state 267

    (135) slice_declaration -> ID DEQUAL LCORCHE RCORCHE . data_types arr_content
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WINT
    (56) data_types -> . WFLOAT
    (57) data_types -> . WSTRING
    (58) data_types -> . BOOL

    INT32           shift and go to state 131
    INT64           shift and go to state 132
    FLOAT32         shift and go to state 133
    FLOAT64         shift and go to state 134
    BYTE            shift and go to state 135
    WINT            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    BOOL            shift and go to state 139

    data_types                     shift and go to state 327

state 268

    (136) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap RPAREN
    (137) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LCORCHE         shift and go to state 328


state 269

    (206) array_var -> ID LCORCHE index RCORCHE .

    COLON           reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    EQUAL           reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    PRINT           reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    SCAN            reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    FOR             reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    CONST           reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    ID              reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    APPEND          reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    LEN             reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    COPY            reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    DELETE          reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    IF              reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    ELSE            reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    TYPE            reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    SWITCH          reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    VAR             reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    FUNC            reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    INTEGER         reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    FLOAT           reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    NOT             reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    $end            reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    GREATER         reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    SMALLER         reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    GREATER_OR_EQUAL reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    SMALLER_OR_EQUAL reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    EQUAL_COMPARE   reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    NOT_EQUAL       reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    PLUS            reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    TIMES           reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    DIVIDE          reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    MINUS           reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    MOD             reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    RLLAVE          reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    INT32           reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    INT64           reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    FLOAT32         reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    FLOAT64         reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    BYTE            reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    WINT            reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    WFLOAT          reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    WSTRING         reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    BOOL            reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    DEFAULT         reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    CASE            reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    RETURN          reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    RPAREN          reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    AND             reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    OR              reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    LLLAVE          reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    RCORCHE         reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)
    COMA            reduce using rule 206 (array_var -> ID LCORCHE index RCORCHE .)


state 270

    (141) slice_var -> ID LCORCHE index_s RCORCHE .

    COLON           reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    EQUAL           reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    PRINT           reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    SCAN            reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FOR             reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    CONST           reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    ID              reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    APPEND          reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    LEN             reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    COPY            reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    DELETE          reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    IF              reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    ELSE            reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    TYPE            reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    SWITCH          reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    VAR             reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FUNC            reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    INTEGER         reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FLOAT           reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    NOT             reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    $end            reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    RLLAVE          reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    INT32           reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    INT64           reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FLOAT32         reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FLOAT64         reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    BYTE            reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    WINT            reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    WFLOAT          reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    WSTRING         reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    BOOL            reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    DEFAULT         reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    CASE            reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)
    RETURN          reduce using rule 141 (slice_var -> ID LCORCHE index_s RCORCHE .)


state 271

    (212) map_var -> ID LCORCHE key RCORCHE .

    EQUAL           reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    GREATER         reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    SMALLER         reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    GREATER_OR_EQUAL reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    SMALLER_OR_EQUAL reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    EQUAL_COMPARE   reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    NOT_EQUAL       reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    PLUS            reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    TIMES           reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    DIVIDE          reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    MINUS           reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    MOD             reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    COLON           reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    PRINT           reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    SCAN            reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    FOR             reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    CONST           reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    ID              reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    APPEND          reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    LEN             reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    COPY            reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    DELETE          reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    IF              reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    ELSE            reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    TYPE            reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    SWITCH          reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    VAR             reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    FUNC            reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    INTEGER         reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    FLOAT           reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    NOT             reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    $end            reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    RLLAVE          reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    INT32           reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    INT64           reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    FLOAT32         reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    FLOAT64         reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    BYTE            reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    WINT            reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    WFLOAT          reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    WSTRING         reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    BOOL            reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    DEFAULT         reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    CASE            reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    RETURN          reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    RPAREN          reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    AND             reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    OR              reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    LLLAVE          reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    RCORCHE         reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)
    COMA            reduce using rule 212 (map_var -> ID LCORCHE key RCORCHE .)


state 272

    (85) list_params -> ID COMA . more_p
    (86) more_p -> . list_params
    (84) list_params -> . ID
    (85) list_params -> . ID COMA more_p

    ID              shift and go to state 211

    more_p                         shift and go to state 329
    list_params                    shift and go to state 330

state 273

    (82) call_func -> ID LPAREN list_params RPAREN .

    COLON           reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    PRINT           reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    SCAN            reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    FOR             reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    CONST           reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    ID              reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    APPEND          reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    LEN             reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    COPY            reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    DELETE          reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    IF              reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    ELSE            reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    TYPE            reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    SWITCH          reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    VAR             reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    FUNC            reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    INTEGER         reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    FLOAT           reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    NOT             reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    $end            reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    GREATER         reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    SMALLER         reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    GREATER_OR_EQUAL reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    EQUAL_COMPARE   reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    NOT_EQUAL       reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    PLUS            reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    TIMES           reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    DIVIDE          reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    MINUS           reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    MOD             reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    RLLAVE          reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    INT32           reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    INT64           reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    FLOAT32         reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    FLOAT64         reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    BYTE            reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    WINT            reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    WFLOAT          reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    WSTRING         reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    BOOL            reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    DEFAULT         reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    CASE            reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    RETURN          reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    RPAREN          reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    AND             reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    OR              reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    LLLAVE          reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    RCORCHE         reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)
    COMA            reduce using rule 82 (call_func -> ID LPAREN list_params RPAREN .)


state 274

    (150) funciones -> APPEND LPAREN ID COMA . values RPAREN
    (151) funciones -> APPEND LPAREN ID COMA . ID RPAREN
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE

    ID              shift and go to state 331
    STRING          shift and go to state 145
    INTEGER         shift and go to state 333
    FLOAT           shift and go to state 334
    TRUE            shift and go to state 148
    FALSE           shift and go to state 149

    values                         shift and go to state 332

state 275

    (152) funciones -> LEN LPAREN ID RPAREN .

    COLON           reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    PRINT           reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    SCAN            reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    FOR             reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    CONST           reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    ID              reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    APPEND          reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    LEN             reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    COPY            reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    DELETE          reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    IF              reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    ELSE            reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    TYPE            reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    SWITCH          reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    VAR             reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    FUNC            reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    INTEGER         reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    FLOAT           reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    NOT             reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    $end            reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    GREATER         reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    SMALLER         reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    NOT_EQUAL       reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    PLUS            reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    TIMES           reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    DIVIDE          reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    MINUS           reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    MOD             reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    RLLAVE          reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    INT32           reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    INT64           reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    FLOAT32         reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    FLOAT64         reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    BYTE            reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    WINT            reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    WFLOAT          reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    WSTRING         reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    BOOL            reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    DEFAULT         reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    CASE            reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    RETURN          reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    RPAREN          reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    AND             reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    OR              reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    LLLAVE          reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    RCORCHE         reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)
    COMA            reduce using rule 152 (funciones -> LEN LPAREN ID RPAREN .)


state 276

    (153) funciones -> COPY LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 335


state 277

    (154) funciones -> DELETE LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 336


state 278

    (158) SenIF -> IF comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 337


state 279

    (159) SenIF -> IF TRUE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 338


state 280

    (160) SenIF -> IF FALSE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 339


state 281

    (161) SenElseIF -> ELSE IF comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    comparison                     shift and go to state 8
    codigo                         shift and go to state 340
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 282

    (162) SenElseIF -> ELSE IF TRUE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 341
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 283

    (163) SenElseIF -> ELSE IF FALSE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 342
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 284

    (164) SenElse -> ELSE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 164 (SenElse -> ELSE LLLAVE codigo RLLAVE .)


state 285

    (165) SenStruct -> TYPE ID STRUCT LLLAVE . declaration RLLAVE
    (166) declaration -> . variable data_types
    (167) declaration -> . declaration variable data_types
    (168) variable -> . ID

    ID              shift and go to state 343

    declaration                    shift and go to state 344
    variable                       shift and go to state 345

state 286

    (196) switch_statement -> SWITCH ID LLLAVE cases . RLLAVE

    RLLAVE          shift and go to state 346


state 287

    (197) cases -> CASE . values POINTS codigo
    (198) cases -> CASE . values POINTS codigo more
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE

    STRING          shift and go to state 145
    INTEGER         shift and go to state 333
    FLOAT           shift and go to state 334
    TRUE            shift and go to state 148
    FALSE           shift and go to state 149

    values                         shift and go to state 347

state 288

    (204) capacity -> ID .
    (238) something_ex -> ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for RCORCHE resolved using rule 204 (capacity -> ID .)
    RCORCHE         reduce using rule 204 (capacity -> ID .)
    GREATER         reduce using rule 238 (something_ex -> ID .)
    SMALLER         reduce using rule 238 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 238 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 238 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 238 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 238 (something_ex -> ID .)
    PLUS            reduce using rule 238 (something_ex -> ID .)
    TIMES           reduce using rule 238 (something_ex -> ID .)
    DIVIDE          reduce using rule 238 (something_ex -> ID .)
    MINUS           reduce using rule 238 (something_ex -> ID .)
    MOD             reduce using rule 238 (something_ex -> ID .)
    LCORCHE         shift and go to state 172
    LPAREN          shift and go to state 111

  ! RCORCHE         [ reduce using rule 238 (something_ex -> ID .) ]


state 289

    (201) array_declaration -> VAR ID LCORCHE capacity . RCORCHE data_types

    RCORCHE         shift and go to state 348


state 290

    (131) slice_declaration -> VAR ID LCORCHE RCORCHE . data_types
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WINT
    (56) data_types -> . WFLOAT
    (57) data_types -> . WSTRING
    (58) data_types -> . BOOL

    INT32           shift and go to state 131
    INT64           shift and go to state 132
    FLOAT32         shift and go to state 133
    FLOAT64         shift and go to state 134
    BYTE            shift and go to state 135
    WINT            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    BOOL            shift and go to state 139

    data_types                     shift and go to state 349

state 291

    (211) map_declaration -> VAR ID LCORCHE data_types . RCORCHE data_types

    RCORCHE         shift and go to state 350


state 292

    (203) capacity -> INTEGER .
    (239) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 203 (capacity -> INTEGER .)
    RCORCHE         reduce using rule 203 (capacity -> INTEGER .)
    GREATER         reduce using rule 239 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 239 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 239 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 239 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 239 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 239 (something_ex -> INTEGER .)
    PLUS            reduce using rule 239 (something_ex -> INTEGER .)
    TIMES           reduce using rule 239 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 239 (something_ex -> INTEGER .)
    MINUS           reduce using rule 239 (something_ex -> INTEGER .)
    MOD             reduce using rule 239 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 239 (something_ex -> INTEGER .) ]


state 293

    (205) capacity -> expression .

    RCORCHE         reduce using rule 205 (capacity -> expression .)


state 294

    (121) single -> VAR ID data_types EQUAL . funciones
    (122) single -> VAR ID data_types EQUAL . ID
    (123) single -> VAR ID data_types EQUAL . data_structure
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 351
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    funciones                      shift and go to state 352
    data_structure                 shift and go to state 353
    call_func                      shift and go to state 46
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101

state 295

    (202) array_declaration -> VAR ID EQUAL LCORCHE . capacity RCORCHE data_types arr_content
    (132) slice_declaration -> VAR ID EQUAL LCORCHE . RCORCHE data_types arr_content
    (203) capacity -> . INTEGER
    (204) capacity -> . ID
    (205) capacity -> . expression
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    RCORCHE         shift and go to state 355
    INTEGER         shift and go to state 292
    ID              shift and go to state 288
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    capacity                       shift and go to state 354
    expression                     shift and go to state 293
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 296

    (133) slice_declaration -> VAR ID EQUAL funM .

    COLON           reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    PRINT           reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    SCAN            reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    FOR             reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    CONST           reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    ID              reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    APPEND          reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    LEN             reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    COPY            reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    DELETE          reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    IF              reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    ELSE            reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    TYPE            reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    SWITCH          reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    VAR             reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    FUNC            reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    INTEGER         reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    FLOAT           reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    NOT             reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    $end            reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    RLLAVE          reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    INT32           reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    INT64           reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    FLOAT32         reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    FLOAT64         reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    BYTE            reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    WINT            reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    WFLOAT          reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    WSTRING         reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    BOOL            reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    DEFAULT         reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    CASE            reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)
    RETURN          reduce using rule 133 (slice_declaration -> VAR ID EQUAL funM .)


state 297

    (118) more -> ID .
    (119) more -> ID . COMA more

    INT32           reduce using rule 118 (more -> ID .)
    INT64           reduce using rule 118 (more -> ID .)
    FLOAT32         reduce using rule 118 (more -> ID .)
    FLOAT64         reduce using rule 118 (more -> ID .)
    BYTE            reduce using rule 118 (more -> ID .)
    WINT            reduce using rule 118 (more -> ID .)
    WFLOAT          reduce using rule 118 (more -> ID .)
    WSTRING         reduce using rule 118 (more -> ID .)
    BOOL            reduce using rule 118 (more -> ID .)
    RLLAVE          reduce using rule 118 (more -> ID .)
    COMA            shift and go to state 356


state 298

    (117) list_var -> VAR ID COMA more .

    INT32           reduce using rule 117 (list_var -> VAR ID COMA more .)
    INT64           reduce using rule 117 (list_var -> VAR ID COMA more .)
    FLOAT32         reduce using rule 117 (list_var -> VAR ID COMA more .)
    FLOAT64         reduce using rule 117 (list_var -> VAR ID COMA more .)
    BYTE            reduce using rule 117 (list_var -> VAR ID COMA more .)
    WINT            reduce using rule 117 (list_var -> VAR ID COMA more .)
    WFLOAT          reduce using rule 117 (list_var -> VAR ID COMA more .)
    WSTRING         reduce using rule 117 (list_var -> VAR ID COMA more .)
    BOOL            reduce using rule 117 (list_var -> VAR ID COMA more .)


state 299

    (199) more -> cases .

    INT32           reduce using rule 199 (more -> cases .)
    INT64           reduce using rule 199 (more -> cases .)
    FLOAT32         reduce using rule 199 (more -> cases .)
    FLOAT64         reduce using rule 199 (more -> cases .)
    BYTE            reduce using rule 199 (more -> cases .)
    WINT            reduce using rule 199 (more -> cases .)
    WFLOAT          reduce using rule 199 (more -> cases .)
    WSTRING         reduce using rule 199 (more -> cases .)
    BOOL            reduce using rule 199 (more -> cases .)
    RLLAVE          reduce using rule 199 (more -> cases .)


state 300

    (200) more -> DEFAULT . POINTS codigo

    POINTS          shift and go to state 357


state 301

    (225) params -> ID . data_types
    (227) more_params -> ID . data_types COMA params
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WINT
    (56) data_types -> . WFLOAT
    (57) data_types -> . WSTRING
    (58) data_types -> . BOOL

    INT32           shift and go to state 131
    INT64           shift and go to state 132
    FLOAT32         shift and go to state 133
    FLOAT64         shift and go to state 134
    BYTE            shift and go to state 135
    WINT            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    BOOL            shift and go to state 139

    data_types                     shift and go to state 358

state 302

    (217) func_declaration -> FUNC ID LPAREN params . RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> FUNC ID LPAREN params . RPAREN data_types LLLAVE RETURN return_value RLLAVE

    RPAREN          shift and go to state 359


state 303

    (226) params -> more_params .

    RPAREN          reduce using rule 226 (params -> more_params .)


state 304

    (80) main_func -> FUNC MAIN LPAREN RPAREN . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 360


state 305

    (88) cicloFor -> FOR comparison LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    ID              reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    IF              reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    $end            reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 88 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)


state 306

    (89) cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    ID              reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    IF              reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    $end            reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 89 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)


state 307

    (90) cicloFor -> FOR decVarOne COLON comparison COLON . incre LLLAVE codigo RLLAVE
    (91) incre -> . ID INCREASE
    (92) incre -> . ID DECREASE

    ID              shift and go to state 362

    incre                          shift and go to state 361

state 308

    (93) data_type_and_value -> WSTRING EQUAL STRING .

    COLON           reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    PRINT           reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    SCAN            reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    FOR             reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    CONST           reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    ID              reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    APPEND          reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    LEN             reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    COPY            reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    DELETE          reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    IF              reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    ELSE            reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    TYPE            reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    SWITCH          reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    VAR             reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    FUNC            reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    INTEGER         reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    FLOAT           reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    NOT             reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    $end            reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    RLLAVE          reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    INT32           reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    INT64           reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    FLOAT32         reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    FLOAT64         reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    BYTE            reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    WINT            reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    WFLOAT          reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    WSTRING         reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    BOOL            reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    DEFAULT         reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    CASE            reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)
    RETURN          reduce using rule 93 (data_type_and_value -> WSTRING EQUAL STRING .)


state 309

    (94) data_type_and_value -> WINT EQUAL int_value .

    COLON           reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    PRINT           reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    SCAN            reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    FOR             reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    CONST           reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    ID              reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    APPEND          reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    LEN             reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    COPY            reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    DELETE          reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    IF              reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    ELSE            reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    TYPE            reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    SWITCH          reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    VAR             reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    FUNC            reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    INTEGER         reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    FLOAT           reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    NOT             reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    $end            reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    RLLAVE          reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    INT32           reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    INT64           reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    FLOAT32         reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    FLOAT64         reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    BYTE            reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    WINT            reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    WFLOAT          reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    WSTRING         reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    BOOL            reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    DEFAULT         reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    CASE            reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)
    RETURN          reduce using rule 94 (data_type_and_value -> WINT EQUAL int_value .)


state 310

    (101) int_value -> INTEGER .
    (239) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for PRINT resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for SCAN resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for FOR resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for CONST resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for ID resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for APPEND resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for LEN resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for COPY resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for DELETE resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for IF resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for ELSE resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for TYPE resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for SWITCH resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for VAR resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for FUNC resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for INTEGER resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for FLOAT resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for NOT resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for INT32 resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for INT64 resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for BYTE resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for WINT resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for WSTRING resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for BOOL resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 101 (int_value -> INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 101 (int_value -> INTEGER .)
    COLON           reduce using rule 101 (int_value -> INTEGER .)
    PRINT           reduce using rule 101 (int_value -> INTEGER .)
    SCAN            reduce using rule 101 (int_value -> INTEGER .)
    FOR             reduce using rule 101 (int_value -> INTEGER .)
    CONST           reduce using rule 101 (int_value -> INTEGER .)
    ID              reduce using rule 101 (int_value -> INTEGER .)
    APPEND          reduce using rule 101 (int_value -> INTEGER .)
    LEN             reduce using rule 101 (int_value -> INTEGER .)
    COPY            reduce using rule 101 (int_value -> INTEGER .)
    DELETE          reduce using rule 101 (int_value -> INTEGER .)
    IF              reduce using rule 101 (int_value -> INTEGER .)
    ELSE            reduce using rule 101 (int_value -> INTEGER .)
    TYPE            reduce using rule 101 (int_value -> INTEGER .)
    SWITCH          reduce using rule 101 (int_value -> INTEGER .)
    VAR             reduce using rule 101 (int_value -> INTEGER .)
    FUNC            reduce using rule 101 (int_value -> INTEGER .)
    INTEGER         reduce using rule 101 (int_value -> INTEGER .)
    FLOAT           reduce using rule 101 (int_value -> INTEGER .)
    NOT             reduce using rule 101 (int_value -> INTEGER .)
    $end            reduce using rule 101 (int_value -> INTEGER .)
    RLLAVE          reduce using rule 101 (int_value -> INTEGER .)
    INT32           reduce using rule 101 (int_value -> INTEGER .)
    INT64           reduce using rule 101 (int_value -> INTEGER .)
    FLOAT32         reduce using rule 101 (int_value -> INTEGER .)
    FLOAT64         reduce using rule 101 (int_value -> INTEGER .)
    BYTE            reduce using rule 101 (int_value -> INTEGER .)
    WINT            reduce using rule 101 (int_value -> INTEGER .)
    WFLOAT          reduce using rule 101 (int_value -> INTEGER .)
    WSTRING         reduce using rule 101 (int_value -> INTEGER .)
    BOOL            reduce using rule 101 (int_value -> INTEGER .)
    DEFAULT         reduce using rule 101 (int_value -> INTEGER .)
    CASE            reduce using rule 101 (int_value -> INTEGER .)
    RETURN          reduce using rule 101 (int_value -> INTEGER .)
    GREATER         reduce using rule 239 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 239 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 239 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 239 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 239 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 239 (something_ex -> INTEGER .)
    PLUS            reduce using rule 239 (something_ex -> INTEGER .)
    TIMES           reduce using rule 239 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 239 (something_ex -> INTEGER .)
    MINUS           reduce using rule 239 (something_ex -> INTEGER .)
    MOD             reduce using rule 239 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! PRINT           [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! SCAN            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! FOR             [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! CONST           [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! ID              [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! APPEND          [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! LEN             [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! COPY            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! DELETE          [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! IF              [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! ELSE            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! TYPE            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! SWITCH          [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! VAR             [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! FUNC            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! INTEGER         [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! FLOAT           [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! NOT             [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! INT32           [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! INT64           [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! FLOAT32         [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! FLOAT64         [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! BYTE            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! WINT            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! WFLOAT          [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! WSTRING         [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! BOOL            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 239 (something_ex -> INTEGER .) ]


state 311

    (102) int_value -> expression .

    COLON           reduce using rule 102 (int_value -> expression .)
    PRINT           reduce using rule 102 (int_value -> expression .)
    SCAN            reduce using rule 102 (int_value -> expression .)
    FOR             reduce using rule 102 (int_value -> expression .)
    CONST           reduce using rule 102 (int_value -> expression .)
    ID              reduce using rule 102 (int_value -> expression .)
    APPEND          reduce using rule 102 (int_value -> expression .)
    LEN             reduce using rule 102 (int_value -> expression .)
    COPY            reduce using rule 102 (int_value -> expression .)
    DELETE          reduce using rule 102 (int_value -> expression .)
    IF              reduce using rule 102 (int_value -> expression .)
    ELSE            reduce using rule 102 (int_value -> expression .)
    TYPE            reduce using rule 102 (int_value -> expression .)
    SWITCH          reduce using rule 102 (int_value -> expression .)
    VAR             reduce using rule 102 (int_value -> expression .)
    FUNC            reduce using rule 102 (int_value -> expression .)
    INTEGER         reduce using rule 102 (int_value -> expression .)
    FLOAT           reduce using rule 102 (int_value -> expression .)
    NOT             reduce using rule 102 (int_value -> expression .)
    $end            reduce using rule 102 (int_value -> expression .)
    RLLAVE          reduce using rule 102 (int_value -> expression .)
    INT32           reduce using rule 102 (int_value -> expression .)
    INT64           reduce using rule 102 (int_value -> expression .)
    FLOAT32         reduce using rule 102 (int_value -> expression .)
    FLOAT64         reduce using rule 102 (int_value -> expression .)
    BYTE            reduce using rule 102 (int_value -> expression .)
    WINT            reduce using rule 102 (int_value -> expression .)
    WFLOAT          reduce using rule 102 (int_value -> expression .)
    WSTRING         reduce using rule 102 (int_value -> expression .)
    BOOL            reduce using rule 102 (int_value -> expression .)
    DEFAULT         reduce using rule 102 (int_value -> expression .)
    CASE            reduce using rule 102 (int_value -> expression .)
    RETURN          reduce using rule 102 (int_value -> expression .)


state 312

    (95) data_type_and_value -> INT32 EQUAL int_value .

    COLON           reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    PRINT           reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    SCAN            reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    FOR             reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    CONST           reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    ID              reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    APPEND          reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    LEN             reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    COPY            reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    DELETE          reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    IF              reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    ELSE            reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    TYPE            reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    SWITCH          reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    VAR             reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    FUNC            reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    INTEGER         reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    FLOAT           reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    NOT             reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    $end            reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    RLLAVE          reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    INT32           reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    INT64           reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    FLOAT32         reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    FLOAT64         reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    BYTE            reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    WINT            reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    WFLOAT          reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    WSTRING         reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    BOOL            reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    DEFAULT         reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    CASE            reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)
    RETURN          reduce using rule 95 (data_type_and_value -> INT32 EQUAL int_value .)


state 313

    (96) data_type_and_value -> INT64 EQUAL int_value .

    COLON           reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    PRINT           reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    SCAN            reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    FOR             reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    CONST           reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    ID              reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    APPEND          reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    LEN             reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    COPY            reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    DELETE          reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    IF              reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    ELSE            reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    TYPE            reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    SWITCH          reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    VAR             reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    FUNC            reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    INTEGER         reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    FLOAT           reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    NOT             reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    $end            reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    RLLAVE          reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    INT32           reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    INT64           reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    FLOAT32         reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    FLOAT64         reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    BYTE            reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    WINT            reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    WFLOAT          reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    WSTRING         reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    BOOL            reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    DEFAULT         reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    CASE            reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)
    RETURN          reduce using rule 96 (data_type_and_value -> INT64 EQUAL int_value .)


state 314

    (97) data_type_and_value -> WFLOAT EQUAL float_value .

    COLON           reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    PRINT           reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    SCAN            reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    FOR             reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    CONST           reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    ID              reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    APPEND          reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    LEN             reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    COPY            reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    DELETE          reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    IF              reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    ELSE            reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    TYPE            reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    SWITCH          reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    VAR             reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    FUNC            reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    INTEGER         reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    FLOAT           reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    NOT             reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    $end            reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    RLLAVE          reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    INT32           reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    INT64           reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    FLOAT32         reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    FLOAT64         reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    BYTE            reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    WINT            reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    WFLOAT          reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    WSTRING         reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    BOOL            reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    DEFAULT         reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    CASE            reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)
    RETURN          reduce using rule 97 (data_type_and_value -> WFLOAT EQUAL float_value .)


state 315

    (107) float_value -> FLOAT .
    (240) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for PRINT resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for SCAN resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for FOR resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for CONST resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for ID resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for APPEND resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for LEN resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for COPY resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for DELETE resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for IF resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for ELSE resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for TYPE resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for SWITCH resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for VAR resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for FUNC resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for INTEGER resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for FLOAT resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for NOT resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for INT32 resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for INT64 resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for BYTE resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for WINT resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for WSTRING resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for BOOL resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 107 (float_value -> FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 107 (float_value -> FLOAT .)
    COLON           reduce using rule 107 (float_value -> FLOAT .)
    PRINT           reduce using rule 107 (float_value -> FLOAT .)
    SCAN            reduce using rule 107 (float_value -> FLOAT .)
    FOR             reduce using rule 107 (float_value -> FLOAT .)
    CONST           reduce using rule 107 (float_value -> FLOAT .)
    ID              reduce using rule 107 (float_value -> FLOAT .)
    APPEND          reduce using rule 107 (float_value -> FLOAT .)
    LEN             reduce using rule 107 (float_value -> FLOAT .)
    COPY            reduce using rule 107 (float_value -> FLOAT .)
    DELETE          reduce using rule 107 (float_value -> FLOAT .)
    IF              reduce using rule 107 (float_value -> FLOAT .)
    ELSE            reduce using rule 107 (float_value -> FLOAT .)
    TYPE            reduce using rule 107 (float_value -> FLOAT .)
    SWITCH          reduce using rule 107 (float_value -> FLOAT .)
    VAR             reduce using rule 107 (float_value -> FLOAT .)
    FUNC            reduce using rule 107 (float_value -> FLOAT .)
    INTEGER         reduce using rule 107 (float_value -> FLOAT .)
    FLOAT           reduce using rule 107 (float_value -> FLOAT .)
    NOT             reduce using rule 107 (float_value -> FLOAT .)
    $end            reduce using rule 107 (float_value -> FLOAT .)
    RLLAVE          reduce using rule 107 (float_value -> FLOAT .)
    INT32           reduce using rule 107 (float_value -> FLOAT .)
    INT64           reduce using rule 107 (float_value -> FLOAT .)
    FLOAT32         reduce using rule 107 (float_value -> FLOAT .)
    FLOAT64         reduce using rule 107 (float_value -> FLOAT .)
    BYTE            reduce using rule 107 (float_value -> FLOAT .)
    WINT            reduce using rule 107 (float_value -> FLOAT .)
    WFLOAT          reduce using rule 107 (float_value -> FLOAT .)
    WSTRING         reduce using rule 107 (float_value -> FLOAT .)
    BOOL            reduce using rule 107 (float_value -> FLOAT .)
    DEFAULT         reduce using rule 107 (float_value -> FLOAT .)
    CASE            reduce using rule 107 (float_value -> FLOAT .)
    RETURN          reduce using rule 107 (float_value -> FLOAT .)
    GREATER         reduce using rule 240 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 240 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 240 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 240 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 240 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 240 (something_ex -> FLOAT .)
    PLUS            reduce using rule 240 (something_ex -> FLOAT .)
    TIMES           reduce using rule 240 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 240 (something_ex -> FLOAT .)
    MINUS           reduce using rule 240 (something_ex -> FLOAT .)
    MOD             reduce using rule 240 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! PRINT           [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! SCAN            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! FOR             [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! CONST           [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! ID              [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! APPEND          [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! LEN             [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! COPY            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! DELETE          [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! IF              [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! ELSE            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! TYPE            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! SWITCH          [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! VAR             [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! FUNC            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! INTEGER         [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! FLOAT           [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! NOT             [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! INT32           [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! INT64           [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! FLOAT32         [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! FLOAT64         [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! BYTE            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! WINT            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! WFLOAT          [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! WSTRING         [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! BOOL            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 240 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 240 (something_ex -> FLOAT .) ]


state 316

    (108) float_value -> expression .

    COLON           reduce using rule 108 (float_value -> expression .)
    PRINT           reduce using rule 108 (float_value -> expression .)
    SCAN            reduce using rule 108 (float_value -> expression .)
    FOR             reduce using rule 108 (float_value -> expression .)
    CONST           reduce using rule 108 (float_value -> expression .)
    ID              reduce using rule 108 (float_value -> expression .)
    APPEND          reduce using rule 108 (float_value -> expression .)
    LEN             reduce using rule 108 (float_value -> expression .)
    COPY            reduce using rule 108 (float_value -> expression .)
    DELETE          reduce using rule 108 (float_value -> expression .)
    IF              reduce using rule 108 (float_value -> expression .)
    ELSE            reduce using rule 108 (float_value -> expression .)
    TYPE            reduce using rule 108 (float_value -> expression .)
    SWITCH          reduce using rule 108 (float_value -> expression .)
    VAR             reduce using rule 108 (float_value -> expression .)
    FUNC            reduce using rule 108 (float_value -> expression .)
    INTEGER         reduce using rule 108 (float_value -> expression .)
    FLOAT           reduce using rule 108 (float_value -> expression .)
    NOT             reduce using rule 108 (float_value -> expression .)
    $end            reduce using rule 108 (float_value -> expression .)
    RLLAVE          reduce using rule 108 (float_value -> expression .)
    INT32           reduce using rule 108 (float_value -> expression .)
    INT64           reduce using rule 108 (float_value -> expression .)
    FLOAT32         reduce using rule 108 (float_value -> expression .)
    FLOAT64         reduce using rule 108 (float_value -> expression .)
    BYTE            reduce using rule 108 (float_value -> expression .)
    WINT            reduce using rule 108 (float_value -> expression .)
    WFLOAT          reduce using rule 108 (float_value -> expression .)
    WSTRING         reduce using rule 108 (float_value -> expression .)
    BOOL            reduce using rule 108 (float_value -> expression .)
    DEFAULT         reduce using rule 108 (float_value -> expression .)
    CASE            reduce using rule 108 (float_value -> expression .)
    RETURN          reduce using rule 108 (float_value -> expression .)


state 317

    (98) data_type_and_value -> FLOAT32 EQUAL float_value .

    COLON           reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    PRINT           reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    SCAN            reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    FOR             reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    CONST           reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    ID              reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    APPEND          reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    LEN             reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    COPY            reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    DELETE          reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    IF              reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    ELSE            reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    TYPE            reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    SWITCH          reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    VAR             reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    FUNC            reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    INTEGER         reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    FLOAT           reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    NOT             reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    $end            reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    RLLAVE          reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    INT32           reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    INT64           reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    FLOAT32         reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    FLOAT64         reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    BYTE            reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    WINT            reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    WFLOAT          reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    WSTRING         reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    BOOL            reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    DEFAULT         reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    CASE            reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    RETURN          reduce using rule 98 (data_type_and_value -> FLOAT32 EQUAL float_value .)


state 318

    (99) data_type_and_value -> FLOAT64 EQUAL float_value .

    COLON           reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    PRINT           reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    SCAN            reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    FOR             reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    CONST           reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    ID              reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    APPEND          reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    LEN             reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    COPY            reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    DELETE          reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    IF              reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    ELSE            reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    TYPE            reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    SWITCH          reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    VAR             reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    FUNC            reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    INTEGER         reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    FLOAT           reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    NOT             reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    $end            reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    RLLAVE          reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    INT32           reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    INT64           reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    FLOAT32         reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    FLOAT64         reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    BYTE            reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    WINT            reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    WFLOAT          reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    WSTRING         reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    BOOL            reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    DEFAULT         reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    CASE            reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    RETURN          reduce using rule 99 (data_type_and_value -> FLOAT64 EQUAL float_value .)


state 319

    (100) data_type_and_value -> BOOL EQUAL bool_value .

    COLON           reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    PRINT           reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    SCAN            reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    FOR             reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    CONST           reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    ID              reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    APPEND          reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    LEN             reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    COPY            reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    DELETE          reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    IF              reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    ELSE            reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    TYPE            reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    SWITCH          reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    VAR             reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    FUNC            reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    INTEGER         reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    FLOAT           reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    NOT             reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    $end            reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    RLLAVE          reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    INT32           reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    INT64           reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    FLOAT32         reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    FLOAT64         reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    BYTE            reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    WINT            reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    WFLOAT          reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    WSTRING         reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    BOOL            reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    DEFAULT         reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    CASE            reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)
    RETURN          reduce using rule 100 (data_type_and_value -> BOOL EQUAL bool_value .)


state 320

    (103) bool_value -> TRUE .

    COLON           reduce using rule 103 (bool_value -> TRUE .)
    PRINT           reduce using rule 103 (bool_value -> TRUE .)
    SCAN            reduce using rule 103 (bool_value -> TRUE .)
    FOR             reduce using rule 103 (bool_value -> TRUE .)
    CONST           reduce using rule 103 (bool_value -> TRUE .)
    ID              reduce using rule 103 (bool_value -> TRUE .)
    APPEND          reduce using rule 103 (bool_value -> TRUE .)
    LEN             reduce using rule 103 (bool_value -> TRUE .)
    COPY            reduce using rule 103 (bool_value -> TRUE .)
    DELETE          reduce using rule 103 (bool_value -> TRUE .)
    IF              reduce using rule 103 (bool_value -> TRUE .)
    ELSE            reduce using rule 103 (bool_value -> TRUE .)
    TYPE            reduce using rule 103 (bool_value -> TRUE .)
    SWITCH          reduce using rule 103 (bool_value -> TRUE .)
    VAR             reduce using rule 103 (bool_value -> TRUE .)
    FUNC            reduce using rule 103 (bool_value -> TRUE .)
    INTEGER         reduce using rule 103 (bool_value -> TRUE .)
    FLOAT           reduce using rule 103 (bool_value -> TRUE .)
    NOT             reduce using rule 103 (bool_value -> TRUE .)
    $end            reduce using rule 103 (bool_value -> TRUE .)
    RLLAVE          reduce using rule 103 (bool_value -> TRUE .)
    INT32           reduce using rule 103 (bool_value -> TRUE .)
    INT64           reduce using rule 103 (bool_value -> TRUE .)
    FLOAT32         reduce using rule 103 (bool_value -> TRUE .)
    FLOAT64         reduce using rule 103 (bool_value -> TRUE .)
    BYTE            reduce using rule 103 (bool_value -> TRUE .)
    WINT            reduce using rule 103 (bool_value -> TRUE .)
    WFLOAT          reduce using rule 103 (bool_value -> TRUE .)
    WSTRING         reduce using rule 103 (bool_value -> TRUE .)
    BOOL            reduce using rule 103 (bool_value -> TRUE .)
    DEFAULT         reduce using rule 103 (bool_value -> TRUE .)
    CASE            reduce using rule 103 (bool_value -> TRUE .)
    RETURN          reduce using rule 103 (bool_value -> TRUE .)


state 321

    (104) bool_value -> FALSE .

    COLON           reduce using rule 104 (bool_value -> FALSE .)
    PRINT           reduce using rule 104 (bool_value -> FALSE .)
    SCAN            reduce using rule 104 (bool_value -> FALSE .)
    FOR             reduce using rule 104 (bool_value -> FALSE .)
    CONST           reduce using rule 104 (bool_value -> FALSE .)
    ID              reduce using rule 104 (bool_value -> FALSE .)
    APPEND          reduce using rule 104 (bool_value -> FALSE .)
    LEN             reduce using rule 104 (bool_value -> FALSE .)
    COPY            reduce using rule 104 (bool_value -> FALSE .)
    DELETE          reduce using rule 104 (bool_value -> FALSE .)
    IF              reduce using rule 104 (bool_value -> FALSE .)
    ELSE            reduce using rule 104 (bool_value -> FALSE .)
    TYPE            reduce using rule 104 (bool_value -> FALSE .)
    SWITCH          reduce using rule 104 (bool_value -> FALSE .)
    VAR             reduce using rule 104 (bool_value -> FALSE .)
    FUNC            reduce using rule 104 (bool_value -> FALSE .)
    INTEGER         reduce using rule 104 (bool_value -> FALSE .)
    FLOAT           reduce using rule 104 (bool_value -> FALSE .)
    NOT             reduce using rule 104 (bool_value -> FALSE .)
    $end            reduce using rule 104 (bool_value -> FALSE .)
    RLLAVE          reduce using rule 104 (bool_value -> FALSE .)
    INT32           reduce using rule 104 (bool_value -> FALSE .)
    INT64           reduce using rule 104 (bool_value -> FALSE .)
    FLOAT32         reduce using rule 104 (bool_value -> FALSE .)
    FLOAT64         reduce using rule 104 (bool_value -> FALSE .)
    BYTE            reduce using rule 104 (bool_value -> FALSE .)
    WINT            reduce using rule 104 (bool_value -> FALSE .)
    WFLOAT          reduce using rule 104 (bool_value -> FALSE .)
    WSTRING         reduce using rule 104 (bool_value -> FALSE .)
    BOOL            reduce using rule 104 (bool_value -> FALSE .)
    DEFAULT         reduce using rule 104 (bool_value -> FALSE .)
    CASE            reduce using rule 104 (bool_value -> FALSE .)
    RETURN          reduce using rule 104 (bool_value -> FALSE .)


state 322

    (105) bool_value -> comparison .
    (190) logic_value -> comparison .

    COLON           reduce using rule 105 (bool_value -> comparison .)
    PRINT           reduce using rule 105 (bool_value -> comparison .)
    SCAN            reduce using rule 105 (bool_value -> comparison .)
    FOR             reduce using rule 105 (bool_value -> comparison .)
    CONST           reduce using rule 105 (bool_value -> comparison .)
    ID              reduce using rule 105 (bool_value -> comparison .)
    APPEND          reduce using rule 105 (bool_value -> comparison .)
    LEN             reduce using rule 105 (bool_value -> comparison .)
    COPY            reduce using rule 105 (bool_value -> comparison .)
    DELETE          reduce using rule 105 (bool_value -> comparison .)
    IF              reduce using rule 105 (bool_value -> comparison .)
    ELSE            reduce using rule 105 (bool_value -> comparison .)
    TYPE            reduce using rule 105 (bool_value -> comparison .)
    SWITCH          reduce using rule 105 (bool_value -> comparison .)
    VAR             reduce using rule 105 (bool_value -> comparison .)
    FUNC            reduce using rule 105 (bool_value -> comparison .)
    INTEGER         reduce using rule 105 (bool_value -> comparison .)
    FLOAT           reduce using rule 105 (bool_value -> comparison .)
    NOT             reduce using rule 105 (bool_value -> comparison .)
    $end            reduce using rule 105 (bool_value -> comparison .)
    RLLAVE          reduce using rule 105 (bool_value -> comparison .)
    INT32           reduce using rule 105 (bool_value -> comparison .)
    INT64           reduce using rule 105 (bool_value -> comparison .)
    FLOAT32         reduce using rule 105 (bool_value -> comparison .)
    FLOAT64         reduce using rule 105 (bool_value -> comparison .)
    BYTE            reduce using rule 105 (bool_value -> comparison .)
    WINT            reduce using rule 105 (bool_value -> comparison .)
    WFLOAT          reduce using rule 105 (bool_value -> comparison .)
    WSTRING         reduce using rule 105 (bool_value -> comparison .)
    BOOL            reduce using rule 105 (bool_value -> comparison .)
    DEFAULT         reduce using rule 105 (bool_value -> comparison .)
    CASE            reduce using rule 105 (bool_value -> comparison .)
    RETURN          reduce using rule 105 (bool_value -> comparison .)
    AND             reduce using rule 190 (logic_value -> comparison .)
    OR              reduce using rule 190 (logic_value -> comparison .)


state 323

    (106) bool_value -> logic_operation .

    COLON           reduce using rule 106 (bool_value -> logic_operation .)
    PRINT           reduce using rule 106 (bool_value -> logic_operation .)
    SCAN            reduce using rule 106 (bool_value -> logic_operation .)
    FOR             reduce using rule 106 (bool_value -> logic_operation .)
    CONST           reduce using rule 106 (bool_value -> logic_operation .)
    ID              reduce using rule 106 (bool_value -> logic_operation .)
    APPEND          reduce using rule 106 (bool_value -> logic_operation .)
    LEN             reduce using rule 106 (bool_value -> logic_operation .)
    COPY            reduce using rule 106 (bool_value -> logic_operation .)
    DELETE          reduce using rule 106 (bool_value -> logic_operation .)
    IF              reduce using rule 106 (bool_value -> logic_operation .)
    ELSE            reduce using rule 106 (bool_value -> logic_operation .)
    TYPE            reduce using rule 106 (bool_value -> logic_operation .)
    SWITCH          reduce using rule 106 (bool_value -> logic_operation .)
    VAR             reduce using rule 106 (bool_value -> logic_operation .)
    FUNC            reduce using rule 106 (bool_value -> logic_operation .)
    INTEGER         reduce using rule 106 (bool_value -> logic_operation .)
    FLOAT           reduce using rule 106 (bool_value -> logic_operation .)
    NOT             reduce using rule 106 (bool_value -> logic_operation .)
    $end            reduce using rule 106 (bool_value -> logic_operation .)
    RLLAVE          reduce using rule 106 (bool_value -> logic_operation .)
    INT32           reduce using rule 106 (bool_value -> logic_operation .)
    INT64           reduce using rule 106 (bool_value -> logic_operation .)
    FLOAT32         reduce using rule 106 (bool_value -> logic_operation .)
    FLOAT64         reduce using rule 106 (bool_value -> logic_operation .)
    BYTE            reduce using rule 106 (bool_value -> logic_operation .)
    WINT            reduce using rule 106 (bool_value -> logic_operation .)
    WFLOAT          reduce using rule 106 (bool_value -> logic_operation .)
    WSTRING         reduce using rule 106 (bool_value -> logic_operation .)
    BOOL            reduce using rule 106 (bool_value -> logic_operation .)
    DEFAULT         reduce using rule 106 (bool_value -> logic_operation .)
    CASE            reduce using rule 106 (bool_value -> logic_operation .)
    RETURN          reduce using rule 106 (bool_value -> logic_operation .)


state 324

    (177) value -> ID .
    (191) logic_value -> ID .
    (238) something_ex -> ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 177 (value -> ID .)
    GREATER         reduce using rule 177 (value -> ID .)
    SMALLER         reduce using rule 177 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 177 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 177 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 177 (value -> ID .)
    NOT_EQUAL       reduce using rule 177 (value -> ID .)
    PLUS            reduce using rule 177 (value -> ID .)
    TIMES           reduce using rule 177 (value -> ID .)
    DIVIDE          reduce using rule 177 (value -> ID .)
    MINUS           reduce using rule 177 (value -> ID .)
    MOD             reduce using rule 177 (value -> ID .)
    AND             reduce using rule 191 (logic_value -> ID .)
    OR              reduce using rule 191 (logic_value -> ID .)
    LCORCHE         shift and go to state 172
    LPAREN          shift and go to state 111

  ! GREATER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 238 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 238 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 238 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 238 (something_ex -> ID .) ]


state 325

    (170) asignaciones -> ID . POINTS valor
    (171) asignaciones -> ID . POINTS valor COMA asignaciones

    POINTS          shift and go to state 363


state 326

    (169) cStruct -> ID DEQUAL ID LLLAVE asignaciones . RLLAVE

    RLLAVE          shift and go to state 364


state 327

    (135) slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types . arr_content
    (70) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (71) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 366

    arr_content                    shift and go to state 365

state 328

    (136) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap RPAREN
    (137) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap COMA cap RPAREN

    RCORCHE         shift and go to state 367


state 329

    (85) list_params -> ID COMA more_p .

    RPAREN          reduce using rule 85 (list_params -> ID COMA more_p .)


state 330

    (86) more_p -> list_params .

    RPAREN          reduce using rule 86 (more_p -> list_params .)


state 331

    (151) funciones -> APPEND LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 368


state 332

    (150) funciones -> APPEND LPAREN ID COMA values . RPAREN

    RPAREN          shift and go to state 369


state 333

    (46) values -> INTEGER .

    RPAREN          reduce using rule 46 (values -> INTEGER .)
    POINTS          reduce using rule 46 (values -> INTEGER .)


state 334

    (47) values -> FLOAT .

    RPAREN          reduce using rule 47 (values -> FLOAT .)
    POINTS          reduce using rule 47 (values -> FLOAT .)


state 335

    (153) funciones -> COPY LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 370


state 336

    (154) funciones -> DELETE LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 371


state 337

    (158) SenIF -> IF comparison LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    ID              reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    IF              reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    $end            reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 158 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)


state 338

    (159) SenIF -> IF TRUE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 159 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)


state 339

    (160) SenIF -> IF FALSE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 160 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)


state 340

    (161) SenElseIF -> ELSE IF comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 372


state 341

    (162) SenElseIF -> ELSE IF TRUE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 373


state 342

    (163) SenElseIF -> ELSE IF FALSE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 374


state 343

    (168) variable -> ID .

    INT32           reduce using rule 168 (variable -> ID .)
    INT64           reduce using rule 168 (variable -> ID .)
    FLOAT32         reduce using rule 168 (variable -> ID .)
    FLOAT64         reduce using rule 168 (variable -> ID .)
    BYTE            reduce using rule 168 (variable -> ID .)
    WINT            reduce using rule 168 (variable -> ID .)
    WFLOAT          reduce using rule 168 (variable -> ID .)
    WSTRING         reduce using rule 168 (variable -> ID .)
    BOOL            reduce using rule 168 (variable -> ID .)


state 344

    (165) SenStruct -> TYPE ID STRUCT LLLAVE declaration . RLLAVE
    (167) declaration -> declaration . variable data_types
    (168) variable -> . ID

    RLLAVE          shift and go to state 375
    ID              shift and go to state 343

    variable                       shift and go to state 376

state 345

    (166) declaration -> variable . data_types
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WINT
    (56) data_types -> . WFLOAT
    (57) data_types -> . WSTRING
    (58) data_types -> . BOOL

    INT32           shift and go to state 131
    INT64           shift and go to state 132
    FLOAT32         shift and go to state 133
    FLOAT64         shift and go to state 134
    BYTE            shift and go to state 135
    WINT            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    BOOL            shift and go to state 139

    data_types                     shift and go to state 377

state 346

    (196) switch_statement -> SWITCH ID LLLAVE cases RLLAVE .

    PRINT           reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    SCAN            reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FOR             reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    CONST           reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    ID              reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    APPEND          reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    LEN             reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    COPY            reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    DELETE          reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    IF              reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    ELSE            reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    TYPE            reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    SWITCH          reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    VAR             reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FUNC            reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    INTEGER         reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FLOAT           reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    NOT             reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    $end            reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RLLAVE          reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    INT32           reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    INT64           reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FLOAT32         reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FLOAT64         reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    BYTE            reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    WINT            reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    WFLOAT          reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    WSTRING         reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    BOOL            reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    DEFAULT         reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    CASE            reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RETURN          reduce using rule 196 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)


state 347

    (197) cases -> CASE values . POINTS codigo
    (198) cases -> CASE values . POINTS codigo more

    POINTS          shift and go to state 378


state 348

    (201) array_declaration -> VAR ID LCORCHE capacity RCORCHE . data_types
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WINT
    (56) data_types -> . WFLOAT
    (57) data_types -> . WSTRING
    (58) data_types -> . BOOL

    INT32           shift and go to state 131
    INT64           shift and go to state 132
    FLOAT32         shift and go to state 133
    FLOAT64         shift and go to state 134
    BYTE            shift and go to state 135
    WINT            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    BOOL            shift and go to state 139

    data_types                     shift and go to state 379

state 349

    (131) slice_declaration -> VAR ID LCORCHE RCORCHE data_types .

    COLON           reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    PRINT           reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    SCAN            reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FOR             reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    CONST           reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    ID              reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    APPEND          reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    LEN             reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    COPY            reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    DELETE          reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    IF              reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    ELSE            reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    TYPE            reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    SWITCH          reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    VAR             reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FUNC            reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    INTEGER         reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FLOAT           reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    NOT             reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    $end            reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    RLLAVE          reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    INT32           reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    INT64           reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FLOAT32         reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FLOAT64         reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    BYTE            reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    WINT            reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    WFLOAT          reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    WSTRING         reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    BOOL            reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    DEFAULT         reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    CASE            reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    RETURN          reduce using rule 131 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)


state 350

    (211) map_declaration -> VAR ID LCORCHE data_types RCORCHE . data_types
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WINT
    (56) data_types -> . WFLOAT
    (57) data_types -> . WSTRING
    (58) data_types -> . BOOL

    INT32           shift and go to state 131
    INT64           shift and go to state 132
    FLOAT32         shift and go to state 133
    FLOAT64         shift and go to state 134
    BYTE            shift and go to state 135
    WINT            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    BOOL            shift and go to state 139

    data_types                     shift and go to state 380

state 351

    (122) single -> VAR ID data_types EQUAL ID .
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE

    COLON           reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    PRINT           reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    SCAN            reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    FOR             reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    CONST           reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    ID              reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    APPEND          reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    LEN             reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    COPY            reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    DELETE          reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    IF              reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    ELSE            reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    TYPE            reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    SWITCH          reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    VAR             reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    FUNC            reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    INTEGER         reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    FLOAT           reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    NOT             reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    $end            reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    RLLAVE          reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    INT32           reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    INT64           reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    FLOAT32         reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    FLOAT64         reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    BYTE            reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    WINT            reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    WFLOAT          reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    WSTRING         reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    BOOL            reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    DEFAULT         reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    CASE            reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    RETURN          reduce using rule 122 (single -> VAR ID data_types EQUAL ID .)
    LPAREN          shift and go to state 111
    LCORCHE         shift and go to state 172


state 352

    (121) single -> VAR ID data_types EQUAL funciones .

    COLON           reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    PRINT           reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    SCAN            reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    FOR             reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    CONST           reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    ID              reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    APPEND          reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    LEN             reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    COPY            reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    DELETE          reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    IF              reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    ELSE            reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    TYPE            reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    SWITCH          reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    VAR             reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    FUNC            reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    INTEGER         reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    FLOAT           reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    NOT             reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    $end            reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    RLLAVE          reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    INT32           reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    INT64           reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    FLOAT32         reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    FLOAT64         reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    BYTE            reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    WINT            reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    WFLOAT          reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    WSTRING         reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    BOOL            reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    DEFAULT         reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    CASE            reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)
    RETURN          reduce using rule 121 (single -> VAR ID data_types EQUAL funciones .)


state 353

    (123) single -> VAR ID data_types EQUAL data_structure .

    COLON           reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    PRINT           reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    SCAN            reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    FOR             reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    CONST           reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    ID              reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    APPEND          reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    LEN             reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    COPY            reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    DELETE          reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    IF              reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    ELSE            reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    TYPE            reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    SWITCH          reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    VAR             reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    FUNC            reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    INTEGER         reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    FLOAT           reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    NOT             reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    $end            reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    RLLAVE          reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    INT32           reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    INT64           reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    FLOAT32         reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    FLOAT64         reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    BYTE            reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    WINT            reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    WFLOAT          reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    WSTRING         reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    BOOL            reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    DEFAULT         reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    CASE            reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)
    RETURN          reduce using rule 123 (single -> VAR ID data_types EQUAL data_structure .)


state 354

    (202) array_declaration -> VAR ID EQUAL LCORCHE capacity . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 381


state 355

    (132) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE . data_types arr_content
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WINT
    (56) data_types -> . WFLOAT
    (57) data_types -> . WSTRING
    (58) data_types -> . BOOL

    INT32           shift and go to state 131
    INT64           shift and go to state 132
    FLOAT32         shift and go to state 133
    FLOAT64         shift and go to state 134
    BYTE            shift and go to state 135
    WINT            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    BOOL            shift and go to state 139

    data_types                     shift and go to state 382

state 356

    (119) more -> ID COMA . more
    (118) more -> . ID
    (119) more -> . ID COMA more
    (199) more -> . cases
    (200) more -> . DEFAULT POINTS codigo
    (197) cases -> . CASE values POINTS codigo
    (198) cases -> . CASE values POINTS codigo more

    ID              shift and go to state 297
    DEFAULT         shift and go to state 300
    CASE            shift and go to state 287

    more                           shift and go to state 383
    cases                          shift and go to state 299

state 357

    (200) more -> DEFAULT POINTS . codigo
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 384
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 358

    (225) params -> ID data_types .
    (227) more_params -> ID data_types . COMA params

    RPAREN          reduce using rule 225 (params -> ID data_types .)
    COMA            shift and go to state 385


state 359

    (217) func_declaration -> FUNC ID LPAREN params RPAREN . data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> FUNC ID LPAREN params RPAREN . data_types LLLAVE RETURN return_value RLLAVE
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WINT
    (56) data_types -> . WFLOAT
    (57) data_types -> . WSTRING
    (58) data_types -> . BOOL

    INT32           shift and go to state 131
    INT64           shift and go to state 132
    FLOAT32         shift and go to state 133
    FLOAT64         shift and go to state 134
    BYTE            shift and go to state 135
    WINT            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    BOOL            shift and go to state 139

    data_types                     shift and go to state 386

state 360

    (80) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 387
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 361

    (90) cicloFor -> FOR decVarOne COLON comparison COLON incre . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 388


state 362

    (91) incre -> ID . INCREASE
    (92) incre -> ID . DECREASE

    INCREASE        shift and go to state 389
    DECREASE        shift and go to state 390


state 363

    (170) asignaciones -> ID POINTS . valor
    (171) asignaciones -> ID POINTS . valor COMA asignaciones
    (172) valor -> . ID
    (173) valor -> . INTEGER
    (174) valor -> . TRUE
    (175) valor -> . FALSE

    ID              shift and go to state 391
    INTEGER         shift and go to state 393
    TRUE            shift and go to state 394
    FALSE           shift and go to state 395

    valor                          shift and go to state 392

state 364

    (169) cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .

    PRINT           reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    SCAN            reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FOR             reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    CONST           reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    ID              reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    APPEND          reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    LEN             reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    COPY            reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    DELETE          reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    IF              reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    ELSE            reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    TYPE            reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    SWITCH          reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    VAR             reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FUNC            reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    INTEGER         reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FLOAT           reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    NOT             reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    $end            reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    RLLAVE          reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    INT32           reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    INT64           reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FLOAT32         reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FLOAT64         reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    BYTE            reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    WINT            reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    WFLOAT          reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    WSTRING         reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    BOOL            reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    DEFAULT         reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    CASE            reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    RETURN          reduce using rule 169 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)


state 365

    (135) slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .

    COLON           reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    PRINT           reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    SCAN            reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FOR             reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    CONST           reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    ID              reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    APPEND          reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    LEN             reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    COPY            reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    DELETE          reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    IF              reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    ELSE            reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    TYPE            reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    SWITCH          reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    VAR             reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FUNC            reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    INTEGER         reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT           reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    NOT             reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    $end            reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    INT32           reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    INT64           reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT32         reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT64         reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    BYTE            reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    WINT            reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    WFLOAT          reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    WSTRING         reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    BOOL            reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    CASE            reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RETURN          reduce using rule 135 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)


state 366

    (70) arr_content -> LLLAVE . items COMA more_items RLLAVE
    (71) arr_content -> LLLAVE . items RLLAVE
    (74) items -> . values
    (75) items -> . operations
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    STRING          shift and go to state 145
    INTEGER         shift and go to state 146
    FLOAT           shift and go to state 147
    TRUE            shift and go to state 148
    FALSE           shift and go to state 149
    ID              shift and go to state 399
    NOT             shift and go to state 56
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    items                          shift and go to state 396
    values                         shift and go to state 397
    operations                     shift and go to state 398
    expression                     shift and go to state 150
    comparison                     shift and go to state 151
    logic_operation                shift and go to state 152
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 367

    (136) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap RPAREN
    (137) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap COMA cap RPAREN
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WINT
    (56) data_types -> . WFLOAT
    (57) data_types -> . WSTRING
    (58) data_types -> . BOOL

    INT32           shift and go to state 131
    INT64           shift and go to state 132
    FLOAT32         shift and go to state 133
    FLOAT64         shift and go to state 134
    BYTE            shift and go to state 135
    WINT            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    BOOL            shift and go to state 139

    data_types                     shift and go to state 400

state 368

    (151) funciones -> APPEND LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    PRINT           reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SCAN            reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FOR             reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    CONST           reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    ID              reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    APPEND          reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    LEN             reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    COPY            reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DELETE          reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    IF              reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    ELSE            reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    TYPE            reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SWITCH          reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    VAR             reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FUNC            reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    INTEGER         reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FLOAT           reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    NOT             reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    MOD             reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    INT32           reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    INT64           reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FLOAT32         reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FLOAT64         reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    BYTE            reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    WINT            reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    WFLOAT          reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    WSTRING         reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    BOOL            reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 151 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)


state 369

    (150) funciones -> APPEND LPAREN ID COMA values RPAREN .

    COLON           reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    PRINT           reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SCAN            reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FOR             reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    CONST           reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    ID              reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    APPEND          reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    LEN             reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    COPY            reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DELETE          reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    IF              reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    ELSE            reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    TYPE            reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SWITCH          reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    VAR             reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FUNC            reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    INTEGER         reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FLOAT           reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    NOT             reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    $end            reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    GREATER         reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SMALLER         reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    GREATER_OR_EQUAL reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    EQUAL_COMPARE   reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    NOT_EQUAL       reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    PLUS            reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    TIMES           reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DIVIDE          reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    MINUS           reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    MOD             reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RLLAVE          reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    INT32           reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    INT64           reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FLOAT32         reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FLOAT64         reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    BYTE            reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    WINT            reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    WFLOAT          reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    WSTRING         reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    BOOL            reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DEFAULT         reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    CASE            reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RETURN          reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RPAREN          reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    AND             reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    OR              reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    LLLAVE          reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RCORCHE         reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    COMA            reduce using rule 150 (funciones -> APPEND LPAREN ID COMA values RPAREN .)


state 370

    (153) funciones -> COPY LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    PRINT           reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SCAN            reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FOR             reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    CONST           reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    ID              reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    APPEND          reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    LEN             reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    COPY            reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DELETE          reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    IF              reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    ELSE            reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    TYPE            reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SWITCH          reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    VAR             reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FUNC            reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    INTEGER         reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FLOAT           reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    NOT             reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    MOD             reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    INT32           reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    INT64           reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FLOAT32         reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FLOAT64         reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    BYTE            reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    WINT            reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    WFLOAT          reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    WSTRING         reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    BOOL            reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 153 (funciones -> COPY LPAREN ID COMA ID RPAREN .)


state 371

    (154) funciones -> DELETE LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    PRINT           reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SCAN            reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FOR             reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    CONST           reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    ID              reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    APPEND          reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    LEN             reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    COPY            reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DELETE          reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    IF              reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    ELSE            reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    TYPE            reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SWITCH          reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    VAR             reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FUNC            reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    INTEGER         reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FLOAT           reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    NOT             reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    MOD             reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    INT32           reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    INT64           reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FLOAT32         reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FLOAT64         reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    BYTE            reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    WINT            reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    WFLOAT          reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    WSTRING         reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    BOOL            reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 154 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)


state 372

    (161) SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    ID              reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    IF              reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    $end            reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 161 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)


state 373

    (162) SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 162 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)


state 374

    (163) SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 163 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)


state 375

    (165) SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .

    PRINT           reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    SCAN            reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FOR             reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    CONST           reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    ID              reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    APPEND          reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    LEN             reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    COPY            reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    DELETE          reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    IF              reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    ELSE            reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    TYPE            reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    SWITCH          reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    VAR             reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FUNC            reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    INTEGER         reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FLOAT           reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    NOT             reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    $end            reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RLLAVE          reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    INT32           reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    INT64           reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FLOAT32         reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FLOAT64         reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    BYTE            reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    WINT            reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    WFLOAT          reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    WSTRING         reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    BOOL            reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    DEFAULT         reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    CASE            reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RETURN          reduce using rule 165 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)


state 376

    (167) declaration -> declaration variable . data_types
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WINT
    (56) data_types -> . WFLOAT
    (57) data_types -> . WSTRING
    (58) data_types -> . BOOL

    INT32           shift and go to state 131
    INT64           shift and go to state 132
    FLOAT32         shift and go to state 133
    FLOAT64         shift and go to state 134
    BYTE            shift and go to state 135
    WINT            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    BOOL            shift and go to state 139

    data_types                     shift and go to state 401

state 377

    (166) declaration -> variable data_types .

    RLLAVE          reduce using rule 166 (declaration -> variable data_types .)
    ID              reduce using rule 166 (declaration -> variable data_types .)


state 378

    (197) cases -> CASE values POINTS . codigo
    (198) cases -> CASE values POINTS . codigo more
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 402
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 379

    (201) array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .

    COLON           reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    PRINT           reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    SCAN            reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FOR             reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    CONST           reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    ID              reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    APPEND          reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    LEN             reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    COPY            reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    DELETE          reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    IF              reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    ELSE            reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    TYPE            reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    SWITCH          reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    VAR             reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FUNC            reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    INTEGER         reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FLOAT           reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    NOT             reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    $end            reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RLLAVE          reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    INT32           reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    INT64           reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FLOAT32         reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FLOAT64         reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    BYTE            reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    WINT            reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    WFLOAT          reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    WSTRING         reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    BOOL            reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    DEFAULT         reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    CASE            reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RETURN          reduce using rule 201 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)


state 380

    (211) map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .

    COLON           reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    PRINT           reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    SCAN            reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FOR             reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    CONST           reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    ID              reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    APPEND          reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    LEN             reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    COPY            reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    DELETE          reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    IF              reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    ELSE            reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    TYPE            reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    SWITCH          reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    VAR             reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FUNC            reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    INTEGER         reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FLOAT           reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    NOT             reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    $end            reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    RLLAVE          reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    INT32           reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    INT64           reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FLOAT32         reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FLOAT64         reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    BYTE            reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    WINT            reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    WFLOAT          reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    WSTRING         reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    BOOL            reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    DEFAULT         reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    CASE            reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    RETURN          reduce using rule 211 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)


state 381

    (202) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE . data_types arr_content
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WINT
    (56) data_types -> . WFLOAT
    (57) data_types -> . WSTRING
    (58) data_types -> . BOOL

    INT32           shift and go to state 131
    INT64           shift and go to state 132
    FLOAT32         shift and go to state 133
    FLOAT64         shift and go to state 134
    BYTE            shift and go to state 135
    WINT            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    BOOL            shift and go to state 139

    data_types                     shift and go to state 403

state 382

    (132) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types . arr_content
    (70) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (71) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 366

    arr_content                    shift and go to state 404

state 383

    (119) more -> ID COMA more .

    INT32           reduce using rule 119 (more -> ID COMA more .)
    INT64           reduce using rule 119 (more -> ID COMA more .)
    FLOAT32         reduce using rule 119 (more -> ID COMA more .)
    FLOAT64         reduce using rule 119 (more -> ID COMA more .)
    BYTE            reduce using rule 119 (more -> ID COMA more .)
    WINT            reduce using rule 119 (more -> ID COMA more .)
    WFLOAT          reduce using rule 119 (more -> ID COMA more .)
    WSTRING         reduce using rule 119 (more -> ID COMA more .)
    BOOL            reduce using rule 119 (more -> ID COMA more .)
    RLLAVE          reduce using rule 119 (more -> ID COMA more .)


state 384

    (200) more -> DEFAULT POINTS codigo .

    INT32           reduce using rule 200 (more -> DEFAULT POINTS codigo .)
    INT64           reduce using rule 200 (more -> DEFAULT POINTS codigo .)
    FLOAT32         reduce using rule 200 (more -> DEFAULT POINTS codigo .)
    FLOAT64         reduce using rule 200 (more -> DEFAULT POINTS codigo .)
    BYTE            reduce using rule 200 (more -> DEFAULT POINTS codigo .)
    WINT            reduce using rule 200 (more -> DEFAULT POINTS codigo .)
    WFLOAT          reduce using rule 200 (more -> DEFAULT POINTS codigo .)
    WSTRING         reduce using rule 200 (more -> DEFAULT POINTS codigo .)
    BOOL            reduce using rule 200 (more -> DEFAULT POINTS codigo .)
    RLLAVE          reduce using rule 200 (more -> DEFAULT POINTS codigo .)


state 385

    (227) more_params -> ID data_types COMA . params
    (225) params -> . ID data_types
    (226) params -> . more_params
    (227) more_params -> . ID data_types COMA params

    ID              shift and go to state 301

    params                         shift and go to state 405
    more_params                    shift and go to state 303

state 386

    (217) func_declaration -> FUNC ID LPAREN params RPAREN data_types . LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> FUNC ID LPAREN params RPAREN data_types . LLLAVE RETURN return_value RLLAVE

    LLLAVE          shift and go to state 406


state 387

    (80) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 407


state 388

    (90) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    comparison                     shift and go to state 8
    codigo                         shift and go to state 408
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 389

    (91) incre -> ID INCREASE .

    LLLAVE          reduce using rule 91 (incre -> ID INCREASE .)


state 390

    (92) incre -> ID DECREASE .

    LLLAVE          reduce using rule 92 (incre -> ID DECREASE .)


state 391

    (172) valor -> ID .

    COMA            reduce using rule 172 (valor -> ID .)
    RLLAVE          reduce using rule 172 (valor -> ID .)


state 392

    (170) asignaciones -> ID POINTS valor .
    (171) asignaciones -> ID POINTS valor . COMA asignaciones

    RLLAVE          reduce using rule 170 (asignaciones -> ID POINTS valor .)
    COMA            shift and go to state 409


state 393

    (173) valor -> INTEGER .

    COMA            reduce using rule 173 (valor -> INTEGER .)
    RLLAVE          reduce using rule 173 (valor -> INTEGER .)


state 394

    (174) valor -> TRUE .

    COMA            reduce using rule 174 (valor -> TRUE .)
    RLLAVE          reduce using rule 174 (valor -> TRUE .)


state 395

    (175) valor -> FALSE .

    COMA            reduce using rule 175 (valor -> FALSE .)
    RLLAVE          reduce using rule 175 (valor -> FALSE .)


state 396

    (70) arr_content -> LLLAVE items . COMA more_items RLLAVE
    (71) arr_content -> LLLAVE items . RLLAVE

    COMA            shift and go to state 410
    RLLAVE          shift and go to state 411


state 397

    (74) items -> values .

    COMA            reduce using rule 74 (items -> values .)
    RLLAVE          reduce using rule 74 (items -> values .)


state 398

    (75) items -> operations .

    COMA            reduce using rule 75 (items -> operations .)
    RLLAVE          reduce using rule 75 (items -> operations .)


state 399

    (238) something_ex -> ID .
    (177) value -> ID .
    (191) logic_value -> ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 177 (value -> ID .)
    COMA            reduce using rule 238 (something_ex -> ID .)
    RLLAVE          reduce using rule 238 (something_ex -> ID .)
    GREATER         reduce using rule 177 (value -> ID .)
    SMALLER         reduce using rule 177 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 177 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 177 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 177 (value -> ID .)
    NOT_EQUAL       reduce using rule 177 (value -> ID .)
    PLUS            reduce using rule 177 (value -> ID .)
    TIMES           reduce using rule 177 (value -> ID .)
    DIVIDE          reduce using rule 177 (value -> ID .)
    MINUS           reduce using rule 177 (value -> ID .)
    MOD             reduce using rule 177 (value -> ID .)
    AND             reduce using rule 191 (logic_value -> ID .)
    OR              reduce using rule 191 (logic_value -> ID .)
    LCORCHE         shift and go to state 172
    LPAREN          shift and go to state 111

  ! GREATER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 238 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 238 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 238 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 238 (something_ex -> ID .) ]


state 400

    (136) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap RPAREN
    (137) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap COMA cap RPAREN

    COMA            shift and go to state 412


state 401

    (167) declaration -> declaration variable data_types .

    RLLAVE          reduce using rule 167 (declaration -> declaration variable data_types .)
    ID              reduce using rule 167 (declaration -> declaration variable data_types .)


state 402

    (197) cases -> CASE values POINTS codigo .
    (198) cases -> CASE values POINTS codigo . more
    (118) more -> . ID
    (119) more -> . ID COMA more
    (199) more -> . cases
    (200) more -> . DEFAULT POINTS codigo
    (197) cases -> . CASE values POINTS codigo
    (198) cases -> . CASE values POINTS codigo more

    RLLAVE          reduce using rule 197 (cases -> CASE values POINTS codigo .)
    INT32           reduce using rule 197 (cases -> CASE values POINTS codigo .)
    INT64           reduce using rule 197 (cases -> CASE values POINTS codigo .)
    FLOAT32         reduce using rule 197 (cases -> CASE values POINTS codigo .)
    FLOAT64         reduce using rule 197 (cases -> CASE values POINTS codigo .)
    BYTE            reduce using rule 197 (cases -> CASE values POINTS codigo .)
    WINT            reduce using rule 197 (cases -> CASE values POINTS codigo .)
    WFLOAT          reduce using rule 197 (cases -> CASE values POINTS codigo .)
    WSTRING         reduce using rule 197 (cases -> CASE values POINTS codigo .)
    BOOL            reduce using rule 197 (cases -> CASE values POINTS codigo .)
    ID              shift and go to state 297
    DEFAULT         shift and go to state 300
    CASE            shift and go to state 287

    more                           shift and go to state 413
    cases                          shift and go to state 299

state 403

    (202) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types . arr_content
    (70) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (71) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 366

    arr_content                    shift and go to state 414

state 404

    (132) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .

    COLON           reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    PRINT           reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    SCAN            reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FOR             reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    CONST           reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    ID              reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    APPEND          reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    LEN             reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    COPY            reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    DELETE          reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    IF              reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    ELSE            reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    TYPE            reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    SWITCH          reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    VAR             reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FUNC            reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    INTEGER         reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT           reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    NOT             reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    $end            reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    INT32           reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    INT64           reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT32         reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT64         reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    BYTE            reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    WINT            reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    WFLOAT          reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    WSTRING         reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    BOOL            reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    CASE            reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    RETURN          reduce using rule 132 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)


state 405

    (227) more_params -> ID data_types COMA params .

    RPAREN          reduce using rule 227 (more_params -> ID data_types COMA params .)


state 406

    (217) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE . codigo RETURN retorno RLLAVE
    (218) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE . RETURN return_value RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (228) impresion -> . PRINT LPAREN content RPAREN
    (81) scan_func -> . SCAN LPAREN POINTER RPAREN
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (87) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (112) decVar -> . static
    (113) decVar -> . dynamic
    (109) decConst -> . CONST ID data_type_and_value
    (110) decConst -> . CONST ID EQUAL ID
    (111) decConst -> . CONST ID EQUAL data_structure
    (64) var_asignation -> . ID EQUAL any
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (158) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (159) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (160) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (161) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (162) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (164) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (165) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (169) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (201) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (202) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (206) array_var -> . ID LCORCHE index RCORCHE
    (210) array_assignment -> . array_var EQUAL something
    (131) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (132) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (133) slice_declaration -> . VAR ID EQUAL funM
    (134) slice_declaration -> . ID DEQUAL funM
    (135) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (141) slice_var -> . ID LCORCHE index_s RCORCHE
    (145) slice_assignment -> . slice_var EQUAL something_s
    (211) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (216) map_assignment -> . map_var EQUAL something
    (217) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (218) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (80) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (114) static -> . single
    (115) static -> . multiple
    (125) dynamic -> . ID DEQUAL algo
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN
    (212) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (120) single -> . VAR ID data_types
    (121) single -> . VAR ID data_types EQUAL funciones
    (122) single -> . VAR ID data_types EQUAL ID
    (123) single -> . VAR ID data_types EQUAL data_structure
    (124) single -> . VAR ID data_type_and_value
    (116) multiple -> . list_var data_types
    (117) list_var -> . VAR ID COMA more

    RETURN          shift and go to state 416
    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 415
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 407

    (80) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    ID              reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    IF              reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    $end            reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 80 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)


state 408

    (90) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 417


state 409

    (171) asignaciones -> ID POINTS valor COMA . asignaciones
    (170) asignaciones -> . ID POINTS valor
    (171) asignaciones -> . ID POINTS valor COMA asignaciones

    ID              shift and go to state 325

    asignaciones                   shift and go to state 418

state 410

    (70) arr_content -> LLLAVE items COMA . more_items RLLAVE
    (72) more_items -> . items COMA more_items
    (73) more_items -> . items
    (74) items -> . values
    (75) items -> . operations
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    STRING          shift and go to state 145
    INTEGER         shift and go to state 146
    FLOAT           shift and go to state 147
    TRUE            shift and go to state 148
    FALSE           shift and go to state 149
    ID              shift and go to state 399
    NOT             shift and go to state 56
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    items                          shift and go to state 419
    more_items                     shift and go to state 420
    values                         shift and go to state 397
    operations                     shift and go to state 398
    expression                     shift and go to state 150
    comparison                     shift and go to state 151
    logic_operation                shift and go to state 152
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 411

    (71) arr_content -> LLLAVE items RLLAVE .

    COLON           reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    PRINT           reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    SCAN            reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    FOR             reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    CONST           reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    ID              reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    APPEND          reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    LEN             reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    COPY            reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    DELETE          reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    IF              reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    ELSE            reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    TYPE            reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    SWITCH          reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    VAR             reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    FUNC            reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    INTEGER         reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    FLOAT           reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    NOT             reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    $end            reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    RLLAVE          reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    INT32           reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    INT64           reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    FLOAT32         reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    FLOAT64         reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    BYTE            reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    WINT            reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    WFLOAT          reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    WSTRING         reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    BOOL            reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    DEFAULT         reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    CASE            reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)
    RETURN          reduce using rule 71 (arr_content -> LLLAVE items RLLAVE .)


state 412

    (136) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap RPAREN
    (137) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap COMA cap RPAREN
    (138) cap -> . INTEGER
    (139) cap -> . ID
    (140) cap -> . expression
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 422
    ID              shift and go to state 423
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    cap                            shift and go to state 421
    expression                     shift and go to state 424
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 413

    (198) cases -> CASE values POINTS codigo more .

    RLLAVE          reduce using rule 198 (cases -> CASE values POINTS codigo more .)
    INT32           reduce using rule 198 (cases -> CASE values POINTS codigo more .)
    INT64           reduce using rule 198 (cases -> CASE values POINTS codigo more .)
    FLOAT32         reduce using rule 198 (cases -> CASE values POINTS codigo more .)
    FLOAT64         reduce using rule 198 (cases -> CASE values POINTS codigo more .)
    BYTE            reduce using rule 198 (cases -> CASE values POINTS codigo more .)
    WINT            reduce using rule 198 (cases -> CASE values POINTS codigo more .)
    WFLOAT          reduce using rule 198 (cases -> CASE values POINTS codigo more .)
    WSTRING         reduce using rule 198 (cases -> CASE values POINTS codigo more .)
    BOOL            reduce using rule 198 (cases -> CASE values POINTS codigo more .)


state 414

    (202) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .

    COLON           reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    PRINT           reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    SCAN            reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FOR             reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    CONST           reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    ID              reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    APPEND          reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    LEN             reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    COPY            reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    DELETE          reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    IF              reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    ELSE            reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    TYPE            reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    SWITCH          reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    VAR             reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FUNC            reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    INTEGER         reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FLOAT           reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    NOT             reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    $end            reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    INT32           reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    INT64           reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FLOAT32         reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FLOAT64         reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    BYTE            reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    WINT            reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    WFLOAT          reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    WSTRING         reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    BOOL            reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    CASE            reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RETURN          reduce using rule 202 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)


state 415

    (217) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo . RETURN retorno RLLAVE

    RETURN          shift and go to state 425


state 416

    (218) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN . return_value RLLAVE
    (219) return_value -> . retorno COLON
    (220) return_value -> . retorno
    (221) retorno -> . ID
    (222) retorno -> . values
    (223) retorno -> . operations
    (224) retorno -> . data_structure
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 426
    STRING          shift and go to state 145
    INTEGER         shift and go to state 146
    FLOAT           shift and go to state 147
    TRUE            shift and go to state 148
    FALSE           shift and go to state 149
    NOT             shift and go to state 56
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    return_value                   shift and go to state 427
    retorno                        shift and go to state 428
    values                         shift and go to state 429
    operations                     shift and go to state 430
    data_structure                 shift and go to state 431
    expression                     shift and go to state 150
    comparison                     shift and go to state 151
    logic_operation                shift and go to state 152
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    funciones                      shift and go to state 99
    call_func                      shift and go to state 46

state 417

    (90) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    ID              reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    IF              reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    $end            reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 90 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)


state 418

    (171) asignaciones -> ID POINTS valor COMA asignaciones .

    RLLAVE          reduce using rule 171 (asignaciones -> ID POINTS valor COMA asignaciones .)


state 419

    (72) more_items -> items . COMA more_items
    (73) more_items -> items .

    COMA            shift and go to state 432
    RLLAVE          reduce using rule 73 (more_items -> items .)


state 420

    (70) arr_content -> LLLAVE items COMA more_items . RLLAVE

    RLLAVE          shift and go to state 433


state 421

    (136) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . RPAREN
    (137) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . COMA cap RPAREN

    RPAREN          shift and go to state 435
    COMA            shift and go to state 434


state 422

    (138) cap -> INTEGER .
    (239) something_ex -> INTEGER .

  ! reduce/reduce conflict for RPAREN resolved using rule 138 (cap -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 138 (cap -> INTEGER .)
    RPAREN          reduce using rule 138 (cap -> INTEGER .)
    COMA            reduce using rule 138 (cap -> INTEGER .)
    GREATER         reduce using rule 239 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 239 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 239 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 239 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 239 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 239 (something_ex -> INTEGER .)
    PLUS            reduce using rule 239 (something_ex -> INTEGER .)
    TIMES           reduce using rule 239 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 239 (something_ex -> INTEGER .)
    MINUS           reduce using rule 239 (something_ex -> INTEGER .)
    MOD             reduce using rule 239 (something_ex -> INTEGER .)

  ! RPAREN          [ reduce using rule 239 (something_ex -> INTEGER .) ]
  ! COMA            [ reduce using rule 239 (something_ex -> INTEGER .) ]


state 423

    (139) cap -> ID .
    (238) something_ex -> ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for RPAREN resolved using rule 139 (cap -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 139 (cap -> ID .)
    RPAREN          reduce using rule 139 (cap -> ID .)
    COMA            reduce using rule 139 (cap -> ID .)
    GREATER         reduce using rule 238 (something_ex -> ID .)
    SMALLER         reduce using rule 238 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 238 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 238 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 238 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 238 (something_ex -> ID .)
    PLUS            reduce using rule 238 (something_ex -> ID .)
    TIMES           reduce using rule 238 (something_ex -> ID .)
    DIVIDE          reduce using rule 238 (something_ex -> ID .)
    MINUS           reduce using rule 238 (something_ex -> ID .)
    MOD             reduce using rule 238 (something_ex -> ID .)
    LCORCHE         shift and go to state 172
    LPAREN          shift and go to state 111

  ! RPAREN          [ reduce using rule 238 (something_ex -> ID .) ]
  ! COMA            [ reduce using rule 238 (something_ex -> ID .) ]


state 424

    (140) cap -> expression .

    RPAREN          reduce using rule 140 (cap -> expression .)
    COMA            reduce using rule 140 (cap -> expression .)


state 425

    (217) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN . retorno RLLAVE
    (221) retorno -> . ID
    (222) retorno -> . values
    (223) retorno -> . operations
    (224) retorno -> . data_structure
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 426
    STRING          shift and go to state 145
    INTEGER         shift and go to state 146
    FLOAT           shift and go to state 147
    TRUE            shift and go to state 148
    FALSE           shift and go to state 149
    NOT             shift and go to state 56
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    retorno                        shift and go to state 436
    values                         shift and go to state 429
    operations                     shift and go to state 430
    data_structure                 shift and go to state 431
    expression                     shift and go to state 150
    comparison                     shift and go to state 151
    logic_operation                shift and go to state 152
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    funciones                      shift and go to state 99
    call_func                      shift and go to state 46

state 426

    (221) retorno -> ID .
    (206) array_var -> ID . LCORCHE index RCORCHE
    (212) map_var -> ID . LCORCHE key RCORCHE
    (238) something_ex -> ID .
    (177) value -> ID .
    (191) logic_value -> ID .
    (82) call_func -> ID . LPAREN list_params RPAREN
    (83) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for COLON resolved using rule 221 (retorno -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 221 (retorno -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 177 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 177 (value -> ID .)
    COLON           reduce using rule 221 (retorno -> ID .)
    RLLAVE          reduce using rule 221 (retorno -> ID .)
    LCORCHE         shift and go to state 172
    GREATER         reduce using rule 177 (value -> ID .)
    SMALLER         reduce using rule 177 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 177 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 177 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 177 (value -> ID .)
    NOT_EQUAL       reduce using rule 177 (value -> ID .)
    PLUS            reduce using rule 177 (value -> ID .)
    TIMES           reduce using rule 177 (value -> ID .)
    DIVIDE          reduce using rule 177 (value -> ID .)
    MINUS           reduce using rule 177 (value -> ID .)
    MOD             reduce using rule 177 (value -> ID .)
    AND             reduce using rule 191 (logic_value -> ID .)
    OR              reduce using rule 191 (logic_value -> ID .)
    LPAREN          shift and go to state 111

  ! GREATER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 238 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 238 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 238 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 238 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 238 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 238 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 238 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 238 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 238 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 238 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 238 (something_ex -> ID .) ]


state 427

    (218) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value . RLLAVE

    RLLAVE          shift and go to state 437


state 428

    (219) return_value -> retorno . COLON
    (220) return_value -> retorno .

    COLON           shift and go to state 438
    RLLAVE          reduce using rule 220 (return_value -> retorno .)


state 429

    (222) retorno -> values .

    COLON           reduce using rule 222 (retorno -> values .)
    RLLAVE          reduce using rule 222 (retorno -> values .)


state 430

    (223) retorno -> operations .

    COLON           reduce using rule 223 (retorno -> operations .)
    RLLAVE          reduce using rule 223 (retorno -> operations .)


state 431

    (224) retorno -> data_structure .
    (241) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 224 (retorno -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 224 (retorno -> data_structure .)
    COLON           reduce using rule 224 (retorno -> data_structure .)
    RLLAVE          reduce using rule 224 (retorno -> data_structure .)
    GREATER         reduce using rule 241 (something_ex -> data_structure .)
    SMALLER         reduce using rule 241 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 241 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 241 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 241 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 241 (something_ex -> data_structure .)
    PLUS            reduce using rule 241 (something_ex -> data_structure .)
    TIMES           reduce using rule 241 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 241 (something_ex -> data_structure .)
    MINUS           reduce using rule 241 (something_ex -> data_structure .)
    MOD             reduce using rule 241 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 241 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 241 (something_ex -> data_structure .) ]


state 432

    (72) more_items -> items COMA . more_items
    (72) more_items -> . items COMA more_items
    (73) more_items -> . items
    (74) items -> . values
    (75) items -> . operations
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (176) comparison -> . value op value
    (185) logic_operation -> . logic_value logic_recu
    (186) logic_operation -> . negation
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (177) value -> . ID
    (178) value -> . expression
    (189) logic_value -> . negation
    (190) logic_value -> . comparison
    (191) logic_value -> . ID
    (192) negation -> . NOT comparison
    (193) negation -> . NOT ID
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    STRING          shift and go to state 145
    INTEGER         shift and go to state 146
    FLOAT           shift and go to state 147
    TRUE            shift and go to state 148
    FALSE           shift and go to state 149
    ID              shift and go to state 399
    NOT             shift and go to state 56
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    items                          shift and go to state 419
    more_items                     shift and go to state 439
    values                         shift and go to state 397
    operations                     shift and go to state 398
    expression                     shift and go to state 150
    comparison                     shift and go to state 151
    logic_operation                shift and go to state 152
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 433

    (70) arr_content -> LLLAVE items COMA more_items RLLAVE .

    COLON           reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    PRINT           reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    SCAN            reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FOR             reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    CONST           reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    ID              reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    APPEND          reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    LEN             reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    COPY            reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    DELETE          reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    IF              reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    ELSE            reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    TYPE            reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    SWITCH          reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    VAR             reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FUNC            reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    INTEGER         reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FLOAT           reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    NOT             reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    $end            reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RLLAVE          reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    INT32           reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    INT64           reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FLOAT32         reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FLOAT64         reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    BYTE            reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    WINT            reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    WFLOAT          reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    WSTRING         reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    BOOL            reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    DEFAULT         reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    CASE            reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RETURN          reduce using rule 70 (arr_content -> LLLAVE items COMA more_items RLLAVE .)


state 434

    (137) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA . cap RPAREN
    (138) cap -> . INTEGER
    (139) cap -> . ID
    (140) cap -> . expression
    (234) expression -> . something_ex
    (235) expression -> . something_ex adicionaEx
    (238) something_ex -> . ID
    (239) something_ex -> . INTEGER
    (240) something_ex -> . FLOAT
    (241) something_ex -> . data_structure
    (242) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (150) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (151) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (152) funciones -> . LEN LPAREN ID RPAREN
    (153) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (154) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (155) funciones -> . call_func
    (206) array_var -> . ID LCORCHE index RCORCHE
    (212) map_var -> . ID LCORCHE key RCORCHE
    (82) call_func -> . ID LPAREN list_params RPAREN
    (83) call_func -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 422
    ID              shift and go to state 423
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    cap                            shift and go to state 440
    expression                     shift and go to state 424
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 435

    (136) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .

    COLON           reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    PRINT           reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    SCAN            reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FOR             reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    CONST           reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    ID              reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    APPEND          reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    LEN             reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    COPY            reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    DELETE          reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    IF              reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    ELSE            reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    TYPE            reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    SWITCH          reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    VAR             reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FUNC            reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    INTEGER         reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FLOAT           reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    NOT             reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    $end            reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RLLAVE          reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    INT32           reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    INT64           reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FLOAT32         reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FLOAT64         reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    BYTE            reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    WINT            reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    WFLOAT          reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    WSTRING         reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    BOOL            reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    DEFAULT         reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    CASE            reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RETURN          reduce using rule 136 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)


state 436

    (217) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno . RLLAVE

    RLLAVE          shift and go to state 441


state 437

    (218) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .

    PRINT           reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    SCAN            reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    FOR             reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    CONST           reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    ID              reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    APPEND          reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    LEN             reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    COPY            reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    DELETE          reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    IF              reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    ELSE            reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    TYPE            reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    SWITCH          reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    VAR             reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    FUNC            reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    INTEGER         reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    FLOAT           reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    NOT             reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    $end            reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    RLLAVE          reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    INT32           reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    INT64           reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    FLOAT32         reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    FLOAT64         reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    BYTE            reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    WINT            reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    WFLOAT          reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    WSTRING         reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    BOOL            reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    DEFAULT         reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    CASE            reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    RETURN          reduce using rule 218 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)


state 438

    (219) return_value -> retorno COLON .

    RLLAVE          reduce using rule 219 (return_value -> retorno COLON .)


state 439

    (72) more_items -> items COMA more_items .

    RLLAVE          reduce using rule 72 (more_items -> items COMA more_items .)


state 440

    (137) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap . RPAREN

    RPAREN          shift and go to state 442


state 441

    (217) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .

    PRINT           reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    SCAN            reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FOR             reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    CONST           reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    ID              reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    APPEND          reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    LEN             reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    COPY            reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    DELETE          reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    IF              reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    ELSE            reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    TYPE            reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    SWITCH          reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    VAR             reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FUNC            reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    INTEGER         reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FLOAT           reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    NOT             reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    $end            reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    RLLAVE          reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    INT32           reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    INT64           reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FLOAT32         reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FLOAT64         reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    BYTE            reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    WINT            reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    WFLOAT          reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    WSTRING         reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    BOOL            reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    DEFAULT         reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    CASE            reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    RETURN          reduce using rule 217 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)


state 442

    (137) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .

    COLON           reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    PRINT           reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    SCAN            reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FOR             reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    CONST           reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    ID              reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    APPEND          reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    LEN             reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    COPY            reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    DELETE          reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    IF              reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    ELSE            reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    TYPE            reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    SWITCH          reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    VAR             reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FUNC            reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    INTEGER         reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FLOAT           reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    NOT             reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    $end            reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RLLAVE          reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    INT32           reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    INT64           reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FLOAT32         reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FLOAT64         reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    BYTE            reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    WINT            reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    WFLOAT          reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    WSTRING         reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    BOOL            reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    DEFAULT         reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    CASE            reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RETURN          reduce using rule 137 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 2 resolved as shift
WARNING: shift/reduce conflict for COLON in state 13 resolved as shift
WARNING: shift/reduce conflict for COLON in state 21 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 32 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 32 resolved as shift
WARNING: shift/reduce conflict for GREATER_OR_EQUAL in state 32 resolved as shift
WARNING: shift/reduce conflict for SMALLER_OR_EQUAL in state 32 resolved as shift
WARNING: shift/reduce conflict for EQUAL_COMPARE in state 32 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 32 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 32 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 32 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 32 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 32 resolved as shift
WARNING: shift/reduce conflict for MOD in state 32 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 165 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 165 resolved as shift
WARNING: shift/reduce conflict for GREATER_OR_EQUAL in state 165 resolved as shift
WARNING: shift/reduce conflict for SMALLER_OR_EQUAL in state 165 resolved as shift
WARNING: shift/reduce conflict for EQUAL_COMPARE in state 165 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 165 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 165 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 165 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 165 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 165 resolved as shift
WARNING: shift/reduce conflict for MOD in state 165 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 232 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 233 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 234 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 235 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 236 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 237 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 238 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 239 resolved as shift
WARNING: reduce/reduce conflict in state 13 resolved using rule (rule -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 13
WARNING: reduce/reduce conflict in state 21 resolved using rule (rule -> array_var)
WARNING: rejected rule (data_structure -> array_var) in state 21
WARNING: reduce/reduce conflict in state 40 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 40
WARNING: reduce/reduce conflict in state 97 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 97
WARNING: reduce/reduce conflict in state 119 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 119
WARNING: reduce/reduce conflict in state 129 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 129
WARNING: reduce/reduce conflict in state 141 resolved using rule (something -> ID)
WARNING: rejected rule (something_ex -> ID) in state 141
WARNING: reduce/reduce conflict in state 141 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 141
WARNING: reduce/reduce conflict in state 142 resolved using rule (something -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 142
WARNING: reduce/reduce conflict in state 146 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 146
WARNING: reduce/reduce conflict in state 147 resolved using rule (values -> FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 147
WARNING: reduce/reduce conflict in state 154 resolved using rule (something_s -> ID)
WARNING: rejected rule (something_ex -> ID) in state 154
WARNING: reduce/reduce conflict in state 154 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 154
WARNING: reduce/reduce conflict in state 155 resolved using rule (data_structure -> array_var)
WARNING: rejected rule (something_s -> array_var) in state 155
WARNING: reduce/reduce conflict in state 161 resolved using rule (content -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 161
WARNING: reduce/reduce conflict in state 162 resolved using rule (content -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 162
WARNING: reduce/reduce conflict in state 163 resolved using rule (content -> ID)
WARNING: rejected rule (something_ex -> ID) in state 163
WARNING: reduce/reduce conflict in state 163 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 163
WARNING: reduce/reduce conflict in state 177 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 177
WARNING: reduce/reduce conflict in state 188 resolved using rule (any -> ID)
WARNING: rejected rule (something_ex -> ID) in state 188
WARNING: reduce/reduce conflict in state 188 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 188
WARNING: reduce/reduce conflict in state 192 resolved using rule (any -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 192
WARNING: reduce/reduce conflict in state 193 resolved using rule (any -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 193
WARNING: reduce/reduce conflict in state 194 resolved using rule (algo -> ID)
WARNING: rejected rule (something_ex -> ID) in state 194
WARNING: reduce/reduce conflict in state 194 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 194
WARNING: reduce/reduce conflict in state 201 resolved using rule (algo -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 201
WARNING: reduce/reduce conflict in state 202 resolved using rule (algo -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 202
WARNING: reduce/reduce conflict in state 203 resolved using rule (index_s -> ID)
WARNING: rejected rule (index -> ID) in state 203
WARNING: reduce/reduce conflict in state 203 resolved using rule (index_s -> ID)
WARNING: rejected rule (key -> ID) in state 203
WARNING: reduce/reduce conflict in state 203 resolved using rule (index_s -> ID)
WARNING: rejected rule (something_ex -> ID) in state 203
WARNING: reduce/reduce conflict in state 203 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 203
WARNING: reduce/reduce conflict in state 207 resolved using rule (index_s -> INTEGER)
WARNING: rejected rule (index -> INTEGER) in state 207
WARNING: reduce/reduce conflict in state 207 resolved using rule (values -> INTEGER)
WARNING: rejected rule (index_s -> INTEGER) in state 207
WARNING: reduce/reduce conflict in state 207 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 207
WARNING: reduce/reduce conflict in state 208 resolved using rule (index_s -> expression)
WARNING: rejected rule (index -> expression) in state 208
WARNING: reduce/reduce conflict in state 208 resolved using rule (operations -> expression)
WARNING: rejected rule (index_s -> expression) in state 208
WARNING: reduce/reduce conflict in state 252 resolved using rule (index -> ID)
WARNING: rejected rule (key -> ID) in state 252
WARNING: reduce/reduce conflict in state 252 resolved using rule (index -> ID)
WARNING: rejected rule (something_ex -> ID) in state 252
WARNING: reduce/reduce conflict in state 252 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 252
WARNING: reduce/reduce conflict in state 253 resolved using rule (values -> INTEGER)
WARNING: rejected rule (index -> INTEGER) in state 253
WARNING: reduce/reduce conflict in state 253 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 253
WARNING: reduce/reduce conflict in state 254 resolved using rule (operations -> expression)
WARNING: rejected rule (index -> expression) in state 254
WARNING: reduce/reduce conflict in state 288 resolved using rule (capacity -> ID)
WARNING: rejected rule (something_ex -> ID) in state 288
WARNING: reduce/reduce conflict in state 292 resolved using rule (capacity -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 292
WARNING: reduce/reduce conflict in state 310 resolved using rule (int_value -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 310
WARNING: reduce/reduce conflict in state 315 resolved using rule (float_value -> FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 315
WARNING: reduce/reduce conflict in state 324 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 324
WARNING: reduce/reduce conflict in state 399 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 399
WARNING: reduce/reduce conflict in state 422 resolved using rule (cap -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 422
WARNING: reduce/reduce conflict in state 423 resolved using rule (cap -> ID)
WARNING: rejected rule (something_ex -> ID) in state 423
WARNING: reduce/reduce conflict in state 426 resolved using rule (retorno -> ID)
WARNING: rejected rule (something_ex -> ID) in state 426
WARNING: reduce/reduce conflict in state 426 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 426
WARNING: reduce/reduce conflict in state 431 resolved using rule (retorno -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 431
WARNING: Rule (something_s -> array_var) is never reduced
WARNING: Rule (key -> ID) is never reduced
WARNING: Rule (index -> INTEGER) is never reduced
WARNING: Rule (index_s -> INTEGER) is never reduced
WARNING: Rule (index -> expression) is never reduced
WARNING: Rule (index_s -> expression) is never reduced
