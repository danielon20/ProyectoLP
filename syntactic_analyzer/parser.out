Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    CAP
    COMMENT
    INTERFACE
    JOIN
    MAP
    MULTI_COMMENT
    PACKAGE

Grammar

Rule 0     S' -> codigo
Rule 1     codigo -> rule
Rule 2     codigo -> more_rules
Rule 3     more_rules -> rule codigo
Rule 4     rule -> impresion COLON
Rule 5     rule -> impresion
Rule 6     rule -> scan_func COLON
Rule 7     rule -> scan_func
Rule 8     rule -> expression COLON
Rule 9     rule -> expression
Rule 10    rule -> cicloFor
Rule 11    rule -> comparison
Rule 12    rule -> logic_operation
Rule 13    rule -> decVar COLON
Rule 14    rule -> decVar
Rule 15    rule -> decConst COLON
Rule 16    rule -> decConst
Rule 17    rule -> var_asignation
Rule 18    rule -> var_asignation COLON
Rule 19    rule -> funciones
Rule 20    rule -> funciones COLON
Rule 21    rule -> SenIF
Rule 22    rule -> SenElseIF
Rule 23    rule -> SenElse
Rule 24    rule -> SenStruct
Rule 25    rule -> cStruct
Rule 26    rule -> switch_statement
Rule 27    rule -> array_declaration COLON
Rule 28    rule -> array_declaration
Rule 29    rule -> array_var COLON
Rule 30    rule -> array_var
Rule 31    rule -> array_assignment COLON
Rule 32    rule -> array_assignment
Rule 33    rule -> slice_declaration COLON
Rule 34    rule -> slice_declaration
Rule 35    rule -> slice_var COLON
Rule 36    rule -> slice_var
Rule 37    rule -> slice_assignment COLON
Rule 38    rule -> slice_assignment
Rule 39    rule -> map_declaration COLON
Rule 40    rule -> map_declaration
Rule 41    rule -> map_assignment COLON
Rule 42    rule -> map_assignment
Rule 43    rule -> func_declaration
Rule 44    rule -> main_func
Rule 45    values -> STRING
Rule 46    values -> INTEGER
Rule 47    values -> FLOAT
Rule 48    values -> TRUE
Rule 49    values -> FALSE
Rule 50    data_types -> INT32
Rule 51    data_types -> INT64
Rule 52    data_types -> FLOAT32
Rule 53    data_types -> FLOAT64
Rule 54    data_types -> BYTE
Rule 55    data_types -> WFLOAT
Rule 56    data_types -> WSTRING
Rule 57    data_types -> WINT
Rule 58    data_types -> BOOL
Rule 59    operations -> expression
Rule 60    operations -> comparison
Rule 61    operations -> logic_operation
Rule 62    data_structure -> array_var
Rule 63    data_structure -> map_var
Rule 64    data_structure -> slice_var
Rule 65    var_asignation -> ID EQUAL any
Rule 66    any -> values
Rule 67    any -> operations
Rule 68    any -> ID
Rule 69    any -> data_structure
Rule 70    any -> funciones
Rule 71    arr_content -> LLLAVE items COMA more_items RLLAVE
Rule 72    arr_content -> LLLAVE items RLLAVE
Rule 73    more_items -> items COMA more_items
Rule 74    more_items -> items
Rule 75    items -> values
Rule 76    items -> operations
Rule 77    something -> ID
Rule 78    something -> data_structure
Rule 79    something -> values
Rule 80    something -> operations
Rule 81    something -> funciones
Rule 82    main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
Rule 83    scan_func -> SCAN LPAREN POINTER RPAREN
Rule 84    call_func -> ID LPAREN list_params RPAREN
Rule 85    call_func -> ID LPAREN RPAREN
Rule 86    list_params -> ID
Rule 87    list_params -> ID COMA more_p
Rule 88    more_p -> list_params
Rule 89    cicloFor -> FOR LLLAVE codigo RLLAVE
Rule 90    cicloFor -> FOR comparison LLLAVE codigo RLLAVE
Rule 91    cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE
Rule 92    cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
Rule 93    incre -> ID INCREASE
Rule 94    incre -> ID DECREASE
Rule 95    data_type_and_value -> WSTRING EQUAL STRING
Rule 96    data_type_and_value -> WINT EQUAL int_value
Rule 97    data_type_and_value -> INT32 EQUAL int_value
Rule 98    data_type_and_value -> INT64 EQUAL int_value
Rule 99    data_type_and_value -> WFLOAT EQUAL float_value
Rule 100   data_type_and_value -> FLOAT32 EQUAL float_value
Rule 101   data_type_and_value -> FLOAT64 EQUAL float_value
Rule 102   data_type_and_value -> BOOL EQUAL bool_value
Rule 103   int_value -> INTEGER
Rule 104   int_value -> expression
Rule 105   bool_value -> TRUE
Rule 106   bool_value -> FALSE
Rule 107   bool_value -> comparison
Rule 108   bool_value -> logic_operation
Rule 109   float_value -> FLOAT
Rule 110   float_value -> expression
Rule 111   decConst -> CONST ID data_type_and_value
Rule 112   decConst -> CONST ID EQUAL ID
Rule 113   decConst -> CONST ID EQUAL data_structure
Rule 114   decVar -> static
Rule 115   decVar -> dynamic
Rule 116   static -> single
Rule 117   static -> multiple
Rule 118   multiple -> list_var data_types
Rule 119   list_var -> VAR ID COMA more
Rule 120   more -> ID
Rule 121   more -> ID COMA more
Rule 122   single -> VAR ID data_types
Rule 123   single -> VAR ID data_types EQUAL funciones
Rule 124   single -> VAR ID data_types EQUAL ID
Rule 125   single -> VAR ID data_types EQUAL data_structure
Rule 126   single -> VAR ID data_type_and_value
Rule 127   dynamic -> ID DEQUAL algo
Rule 128   algo -> values
Rule 129   algo -> operations
Rule 130   algo -> ID
Rule 131   algo -> data_structure
Rule 132   algo -> funciones
Rule 133   slice_declaration -> VAR ID LCORCHE RCORCHE data_types
Rule 134   slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
Rule 135   slice_declaration -> VAR ID EQUAL funM
Rule 136   slice_declaration -> ID DEQUAL funM
Rule 137   slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content
Rule 138   funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
Rule 139   funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
Rule 140   cap -> INTEGER
Rule 141   cap -> ID
Rule 142   cap -> expression
Rule 143   slice_var -> ID LCORCHE index_s RCORCHE
Rule 144   index_s -> ID
Rule 145   index_s -> INTEGER
Rule 146   index_s -> expression
Rule 147   slice_assignment -> slice_var EQUAL something_s
Rule 148   something_s -> ID
Rule 149   something_s -> array_var
Rule 150   something_s -> values
Rule 151   something_s -> operations
Rule 152   funciones -> APPEND LPAREN ID COMA values RPAREN
Rule 153   funciones -> APPEND LPAREN ID COMA ID RPAREN
Rule 154   funciones -> LEN LPAREN ID RPAREN
Rule 155   funciones -> COPY LPAREN ID COMA ID RPAREN
Rule 156   funciones -> DELETE LPAREN ID COMA ID RPAREN
Rule 157   funciones -> call_func
Rule 158   decVarOne -> ID DEQUAL ID
Rule 159   decVarOne -> ID DEQUAL INTEGER
Rule 160   SenIF -> IF comparison LLLAVE codigo RLLAVE
Rule 161   SenIF -> IF TRUE LLLAVE codigo RLLAVE
Rule 162   SenIF -> IF FALSE LLLAVE codigo RLLAVE
Rule 163   SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE
Rule 164   SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE
Rule 165   SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE
Rule 166   SenElse -> ELSE LLLAVE codigo RLLAVE
Rule 167   SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE
Rule 168   declaration -> variable data_types
Rule 169   declaration -> declaration variable data_types
Rule 170   variable -> ID
Rule 171   cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE
Rule 172   asignaciones -> ID POINTS valor
Rule 173   asignaciones -> ID POINTS valor COMA asignaciones
Rule 174   valor -> ID
Rule 175   valor -> INTEGER
Rule 176   valor -> TRUE
Rule 177   valor -> FALSE
Rule 178   comparison -> value op value
Rule 179   value -> ID
Rule 180   value -> expression
Rule 181   op -> GREATER
Rule 182   op -> SMALLER
Rule 183   op -> GREATER_OR_EQUAL
Rule 184   op -> SMALLER_OR_EQUAL
Rule 185   op -> EQUAL_COMPARE
Rule 186   op -> NOT_EQUAL
Rule 187   logic_operation -> logic_value logic_recu
Rule 188   logic_operation -> negation
Rule 189   logic_recu -> logic_op logic_value
Rule 190   logic_recu -> logic_op logic_value logic_recu
Rule 191   logic_value -> negation
Rule 192   logic_value -> comparison
Rule 193   logic_value -> ID
Rule 194   negation -> NOT comparison
Rule 195   negation -> NOT ID
Rule 196   logic_op -> AND
Rule 197   logic_op -> OR
Rule 198   switch_statement -> SWITCH ID LLLAVE cases RLLAVE
Rule 199   cases -> CASE values POINTS codigo
Rule 200   cases -> CASE values POINTS codigo more
Rule 201   more -> cases
Rule 202   more -> DEFAULT POINTS codigo
Rule 203   array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types
Rule 204   array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
Rule 205   capacity -> INTEGER
Rule 206   capacity -> ID
Rule 207   capacity -> expression
Rule 208   array_var -> ID LCORCHE index RCORCHE
Rule 209   index -> ID
Rule 210   index -> INTEGER
Rule 211   index -> expression
Rule 212   array_assignment -> array_var EQUAL something
Rule 213   map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types
Rule 214   map_var -> ID LCORCHE key RCORCHE
Rule 215   key -> ID
Rule 216   key -> values
Rule 217   key -> operations
Rule 218   map_assignment -> map_var EQUAL something
Rule 219   func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
Rule 220   func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
Rule 221   body -> codigo return_value
Rule 222   body -> return_value
Rule 223   return_value -> retorno COLON
Rule 224   return_value -> retorno
Rule 225   retorno -> ID
Rule 226   retorno -> values
Rule 227   retorno -> operations
Rule 228   retorno -> data_structure
Rule 229   params -> ID data_types
Rule 230   params -> more_params
Rule 231   more_params -> ID data_types COMA params
Rule 232   impresion -> PRINT LPAREN content RPAREN
Rule 233   content -> values
Rule 234   content -> operations
Rule 235   content -> funciones
Rule 236   content -> data_structure
Rule 237   content -> ID
Rule 238   expression -> something_ex
Rule 239   expression -> something_ex adicionaEx
Rule 240   adicionaEx -> op something_ex
Rule 241   adicionaEx -> op something_ex adicionaEx
Rule 242   something_ex -> ID
Rule 243   something_ex -> INTEGER
Rule 244   something_ex -> FLOAT
Rule 245   something_ex -> data_structure
Rule 246   something_ex -> funciones
Rule 247   op -> PLUS
Rule 248   op -> TIMES
Rule 249   op -> DIVIDE
Rule 250   op -> MINUS
Rule 251   op -> MOD

Terminals, with rules where they appear

AND                  : 196
APPEND               : 152 153
ARRAY                : 
BOOL                 : 58 102
BYTE                 : 54
CAP                  : 
CASE                 : 199 200
COLON                : 4 6 8 13 15 18 20 27 29 31 33 35 37 39 41 92 92 223
COMA                 : 71 73 87 119 121 138 139 139 152 153 155 156 173 231
COMMENT              : 
CONST                : 111 112 113
COPY                 : 155
DECREASE             : 94
DEFAULT              : 202
DELETE               : 156
DEQUAL               : 127 136 137 158 159 171
DIVIDE               : 249
ELSE                 : 163 164 165 166
EQUAL                : 65 95 96 97 98 99 100 101 102 112 113 123 124 125 134 135 147 204 212 218
EQUAL_COMPARE        : 185
FALSE                : 49 106 162 165 177
FLOAT                : 47 109 244
FLOAT32              : 52 100
FLOAT64              : 53 101
FOR                  : 89 90 91 92
FUNC                 : 82 219 220
GREATER              : 181
GREATER_OR_EQUAL     : 183
ID                   : 65 68 77 84 85 86 87 93 94 111 112 112 113 119 120 121 122 123 124 124 125 126 127 130 133 134 135 136 137 141 143 144 148 152 153 153 154 155 155 156 156 158 158 159 167 170 171 171 172 173 174 179 193 195 198 203 204 206 208 209 213 214 215 219 220 225 229 231 237 242
IF                   : 160 161 162 163 164 165
INCREASE             : 93
INT32                : 50 97
INT64                : 51 98
INTEGER              : 46 103 140 145 159 175 205 210 243
INTERFACE            : 
JOIN                 : 
LCORCHE              : 133 134 137 138 139 143 203 204 208 213 214
LEN                  : 154
LLLAVE               : 71 72 82 89 90 91 92 160 161 162 163 164 165 166 167 171 198 219 220
LPAREN               : 82 83 84 85 138 139 152 153 154 155 156 219 220 232
MAIN                 : 82
MAKE                 : 138 139
MAP                  : 
MINUS                : 250
MOD                  : 251
MULTI_COMMENT        : 
NOT                  : 194 195
NOT_EQUAL            : 186
OR                   : 197
PACKAGE              : 
PLUS                 : 247
POINTER              : 83
POINTS               : 172 173 199 200 202
PRINT                : 232
RCORCHE              : 133 134 137 138 139 143 203 204 208 213 214
RETURN               : 219 220
RLLAVE               : 71 72 82 89 90 91 92 160 161 162 163 164 165 166 167 171 198 219 220
RPAREN               : 82 83 84 85 138 139 152 153 154 155 156 219 220 232
SCAN                 : 83
SMALLER              : 182
SMALLER_OR_EQUAL     : 184
STRING               : 45 95
STRUCT               : 167
SWITCH               : 198
TIMES                : 248
TRUE                 : 48 105 161 164 176
TYPE                 : 167
VAR                  : 119 122 123 124 125 126 133 134 135 203 204 213
WFLOAT               : 55 99
WINT                 : 57 96
WSTRING              : 56 95
error                : 

Nonterminals, with rules where they appear

SenElse              : 23
SenElseIF            : 22
SenIF                : 21
SenStruct            : 24
adicionaEx           : 239 241
algo                 : 127
any                  : 65
arr_content          : 134 137 204
array_assignment     : 31 32
array_declaration    : 27 28
array_var            : 29 30 62 149 212
asignaciones         : 171 173
body                 : 220
bool_value           : 102
cStruct              : 25
call_func            : 157
cap                  : 138 139 139
capacity             : 203 204
cases                : 198 201
cicloFor             : 10
codigo               : 3 82 89 90 91 92 160 161 162 163 164 165 166 199 200 202 219 221 0
comparison           : 11 60 90 92 107 160 163 192 194
content              : 232
data_structure       : 69 78 113 125 131 228 236 245
data_type_and_value  : 111 126
data_types           : 118 122 123 124 125 133 134 137 138 139 168 169 203 204 213 213 219 220 229 231
decConst             : 15 16
decVar               : 13 14
decVarOne            : 92
declaration          : 167 169
dynamic              : 115
expression           : 8 9 59 104 110 142 146 180 207 211
float_value          : 99 100 101
funM                 : 135 136
func_declaration     : 43
funciones            : 19 20 70 81 123 132 235 246
impresion            : 4 5
incre                : 92
index                : 208
index_s              : 143
int_value            : 96 97 98
items                : 71 72 73 74
key                  : 214
list_params          : 84 88
list_var             : 118
logic_op             : 189 190
logic_operation      : 12 61 91 108
logic_recu           : 187 190
logic_value          : 187 189 190
main_func            : 44
map_assignment       : 41 42
map_declaration      : 39 40
map_var              : 63 218
more                 : 119 121 200
more_items           : 71 73
more_p               : 87
more_params          : 230
more_rules           : 2
multiple             : 117
negation             : 188 191
op                   : 178 240 241
operations           : 67 76 80 129 151 217 227 234
params               : 219 220 231
retorno              : 219 223 224
return_value         : 221 222
rule                 : 1 3
scan_func            : 6 7
single               : 116
slice_assignment     : 37 38
slice_declaration    : 33 34
slice_var            : 35 36 64 147
something            : 212 218
something_ex         : 238 239 240 241
something_s          : 147
static               : 114
switch_statement     : 26
valor                : 172 173
value                : 178 178
values               : 66 75 79 128 150 152 199 200 216 226 233
var_asignation       : 17 18
variable             : 168 169

Parsing method: LALR

state 0

    (0) S' -> . codigo
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 1
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 1

    (0) S' -> codigo .



state 2

    (1) codigo -> rule .
    (3) more_rules -> rule . codigo
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

  ! shift/reduce conflict for ID resolved as shift
  ! shift/reduce conflict for APPEND resolved as shift
  ! shift/reduce conflict for LEN resolved as shift
  ! shift/reduce conflict for COPY resolved as shift
  ! shift/reduce conflict for DELETE resolved as shift
  ! shift/reduce conflict for INTEGER resolved as shift
  ! shift/reduce conflict for FLOAT resolved as shift
  ! shift/reduce conflict for NOT resolved as shift
    $end            reduce using rule 1 (codigo -> rule .)
    RLLAVE          reduce using rule 1 (codigo -> rule .)
    INT32           reduce using rule 1 (codigo -> rule .)
    INT64           reduce using rule 1 (codigo -> rule .)
    FLOAT32         reduce using rule 1 (codigo -> rule .)
    FLOAT64         reduce using rule 1 (codigo -> rule .)
    BYTE            reduce using rule 1 (codigo -> rule .)
    WFLOAT          reduce using rule 1 (codigo -> rule .)
    WSTRING         reduce using rule 1 (codigo -> rule .)
    WINT            reduce using rule 1 (codigo -> rule .)
    BOOL            reduce using rule 1 (codigo -> rule .)
    DEFAULT         reduce using rule 1 (codigo -> rule .)
    CASE            reduce using rule 1 (codigo -> rule .)
    RETURN          reduce using rule 1 (codigo -> rule .)
    STRING          reduce using rule 1 (codigo -> rule .)
    TRUE            reduce using rule 1 (codigo -> rule .)
    FALSE           reduce using rule 1 (codigo -> rule .)
    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

  ! ID              [ reduce using rule 1 (codigo -> rule .) ]
  ! INTEGER         [ reduce using rule 1 (codigo -> rule .) ]
  ! FLOAT           [ reduce using rule 1 (codigo -> rule .) ]
  ! NOT             [ reduce using rule 1 (codigo -> rule .) ]
  ! APPEND          [ reduce using rule 1 (codigo -> rule .) ]
  ! LEN             [ reduce using rule 1 (codigo -> rule .) ]
  ! COPY            [ reduce using rule 1 (codigo -> rule .) ]
  ! DELETE          [ reduce using rule 1 (codigo -> rule .) ]

    rule                           shift and go to state 2
    codigo                         shift and go to state 60
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 3

    (2) codigo -> more_rules .

    $end            reduce using rule 2 (codigo -> more_rules .)
    RLLAVE          reduce using rule 2 (codigo -> more_rules .)
    INT32           reduce using rule 2 (codigo -> more_rules .)
    INT64           reduce using rule 2 (codigo -> more_rules .)
    FLOAT32         reduce using rule 2 (codigo -> more_rules .)
    FLOAT64         reduce using rule 2 (codigo -> more_rules .)
    BYTE            reduce using rule 2 (codigo -> more_rules .)
    WFLOAT          reduce using rule 2 (codigo -> more_rules .)
    WSTRING         reduce using rule 2 (codigo -> more_rules .)
    WINT            reduce using rule 2 (codigo -> more_rules .)
    BOOL            reduce using rule 2 (codigo -> more_rules .)
    ID              reduce using rule 2 (codigo -> more_rules .)
    DEFAULT         reduce using rule 2 (codigo -> more_rules .)
    CASE            reduce using rule 2 (codigo -> more_rules .)
    RETURN          reduce using rule 2 (codigo -> more_rules .)
    STRING          reduce using rule 2 (codigo -> more_rules .)
    INTEGER         reduce using rule 2 (codigo -> more_rules .)
    FLOAT           reduce using rule 2 (codigo -> more_rules .)
    TRUE            reduce using rule 2 (codigo -> more_rules .)
    FALSE           reduce using rule 2 (codigo -> more_rules .)
    NOT             reduce using rule 2 (codigo -> more_rules .)
    APPEND          reduce using rule 2 (codigo -> more_rules .)
    LEN             reduce using rule 2 (codigo -> more_rules .)
    COPY            reduce using rule 2 (codigo -> more_rules .)
    DELETE          reduce using rule 2 (codigo -> more_rules .)


state 4

    (4) rule -> impresion . COLON
    (5) rule -> impresion .

    COLON           shift and go to state 61
    PRINT           reduce using rule 5 (rule -> impresion .)
    SCAN            reduce using rule 5 (rule -> impresion .)
    FOR             reduce using rule 5 (rule -> impresion .)
    CONST           reduce using rule 5 (rule -> impresion .)
    ID              reduce using rule 5 (rule -> impresion .)
    APPEND          reduce using rule 5 (rule -> impresion .)
    LEN             reduce using rule 5 (rule -> impresion .)
    COPY            reduce using rule 5 (rule -> impresion .)
    DELETE          reduce using rule 5 (rule -> impresion .)
    IF              reduce using rule 5 (rule -> impresion .)
    ELSE            reduce using rule 5 (rule -> impresion .)
    TYPE            reduce using rule 5 (rule -> impresion .)
    SWITCH          reduce using rule 5 (rule -> impresion .)
    VAR             reduce using rule 5 (rule -> impresion .)
    FUNC            reduce using rule 5 (rule -> impresion .)
    INTEGER         reduce using rule 5 (rule -> impresion .)
    FLOAT           reduce using rule 5 (rule -> impresion .)
    NOT             reduce using rule 5 (rule -> impresion .)
    $end            reduce using rule 5 (rule -> impresion .)
    RLLAVE          reduce using rule 5 (rule -> impresion .)
    INT32           reduce using rule 5 (rule -> impresion .)
    INT64           reduce using rule 5 (rule -> impresion .)
    FLOAT32         reduce using rule 5 (rule -> impresion .)
    FLOAT64         reduce using rule 5 (rule -> impresion .)
    BYTE            reduce using rule 5 (rule -> impresion .)
    WFLOAT          reduce using rule 5 (rule -> impresion .)
    WSTRING         reduce using rule 5 (rule -> impresion .)
    WINT            reduce using rule 5 (rule -> impresion .)
    BOOL            reduce using rule 5 (rule -> impresion .)
    DEFAULT         reduce using rule 5 (rule -> impresion .)
    CASE            reduce using rule 5 (rule -> impresion .)
    RETURN          reduce using rule 5 (rule -> impresion .)
    STRING          reduce using rule 5 (rule -> impresion .)
    TRUE            reduce using rule 5 (rule -> impresion .)
    FALSE           reduce using rule 5 (rule -> impresion .)


state 5

    (6) rule -> scan_func . COLON
    (7) rule -> scan_func .

    COLON           shift and go to state 62
    PRINT           reduce using rule 7 (rule -> scan_func .)
    SCAN            reduce using rule 7 (rule -> scan_func .)
    FOR             reduce using rule 7 (rule -> scan_func .)
    CONST           reduce using rule 7 (rule -> scan_func .)
    ID              reduce using rule 7 (rule -> scan_func .)
    APPEND          reduce using rule 7 (rule -> scan_func .)
    LEN             reduce using rule 7 (rule -> scan_func .)
    COPY            reduce using rule 7 (rule -> scan_func .)
    DELETE          reduce using rule 7 (rule -> scan_func .)
    IF              reduce using rule 7 (rule -> scan_func .)
    ELSE            reduce using rule 7 (rule -> scan_func .)
    TYPE            reduce using rule 7 (rule -> scan_func .)
    SWITCH          reduce using rule 7 (rule -> scan_func .)
    VAR             reduce using rule 7 (rule -> scan_func .)
    FUNC            reduce using rule 7 (rule -> scan_func .)
    INTEGER         reduce using rule 7 (rule -> scan_func .)
    FLOAT           reduce using rule 7 (rule -> scan_func .)
    NOT             reduce using rule 7 (rule -> scan_func .)
    $end            reduce using rule 7 (rule -> scan_func .)
    RLLAVE          reduce using rule 7 (rule -> scan_func .)
    INT32           reduce using rule 7 (rule -> scan_func .)
    INT64           reduce using rule 7 (rule -> scan_func .)
    FLOAT32         reduce using rule 7 (rule -> scan_func .)
    FLOAT64         reduce using rule 7 (rule -> scan_func .)
    BYTE            reduce using rule 7 (rule -> scan_func .)
    WFLOAT          reduce using rule 7 (rule -> scan_func .)
    WSTRING         reduce using rule 7 (rule -> scan_func .)
    WINT            reduce using rule 7 (rule -> scan_func .)
    BOOL            reduce using rule 7 (rule -> scan_func .)
    DEFAULT         reduce using rule 7 (rule -> scan_func .)
    CASE            reduce using rule 7 (rule -> scan_func .)
    RETURN          reduce using rule 7 (rule -> scan_func .)
    STRING          reduce using rule 7 (rule -> scan_func .)
    TRUE            reduce using rule 7 (rule -> scan_func .)
    FALSE           reduce using rule 7 (rule -> scan_func .)


state 6

    (8) rule -> expression . COLON
    (9) rule -> expression .
    (180) value -> expression .

    COLON           shift and go to state 63
    PRINT           reduce using rule 9 (rule -> expression .)
    SCAN            reduce using rule 9 (rule -> expression .)
    FOR             reduce using rule 9 (rule -> expression .)
    CONST           reduce using rule 9 (rule -> expression .)
    ID              reduce using rule 9 (rule -> expression .)
    APPEND          reduce using rule 9 (rule -> expression .)
    LEN             reduce using rule 9 (rule -> expression .)
    COPY            reduce using rule 9 (rule -> expression .)
    DELETE          reduce using rule 9 (rule -> expression .)
    IF              reduce using rule 9 (rule -> expression .)
    ELSE            reduce using rule 9 (rule -> expression .)
    TYPE            reduce using rule 9 (rule -> expression .)
    SWITCH          reduce using rule 9 (rule -> expression .)
    VAR             reduce using rule 9 (rule -> expression .)
    FUNC            reduce using rule 9 (rule -> expression .)
    INTEGER         reduce using rule 9 (rule -> expression .)
    FLOAT           reduce using rule 9 (rule -> expression .)
    NOT             reduce using rule 9 (rule -> expression .)
    $end            reduce using rule 9 (rule -> expression .)
    RLLAVE          reduce using rule 9 (rule -> expression .)
    INT32           reduce using rule 9 (rule -> expression .)
    INT64           reduce using rule 9 (rule -> expression .)
    FLOAT32         reduce using rule 9 (rule -> expression .)
    FLOAT64         reduce using rule 9 (rule -> expression .)
    BYTE            reduce using rule 9 (rule -> expression .)
    WFLOAT          reduce using rule 9 (rule -> expression .)
    WSTRING         reduce using rule 9 (rule -> expression .)
    WINT            reduce using rule 9 (rule -> expression .)
    BOOL            reduce using rule 9 (rule -> expression .)
    DEFAULT         reduce using rule 9 (rule -> expression .)
    CASE            reduce using rule 9 (rule -> expression .)
    RETURN          reduce using rule 9 (rule -> expression .)
    STRING          reduce using rule 9 (rule -> expression .)
    TRUE            reduce using rule 9 (rule -> expression .)
    FALSE           reduce using rule 9 (rule -> expression .)
    GREATER         reduce using rule 180 (value -> expression .)
    SMALLER         reduce using rule 180 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 180 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 180 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 180 (value -> expression .)
    NOT_EQUAL       reduce using rule 180 (value -> expression .)
    PLUS            reduce using rule 180 (value -> expression .)
    TIMES           reduce using rule 180 (value -> expression .)
    DIVIDE          reduce using rule 180 (value -> expression .)
    MINUS           reduce using rule 180 (value -> expression .)
    MOD             reduce using rule 180 (value -> expression .)


state 7

    (10) rule -> cicloFor .

    PRINT           reduce using rule 10 (rule -> cicloFor .)
    SCAN            reduce using rule 10 (rule -> cicloFor .)
    FOR             reduce using rule 10 (rule -> cicloFor .)
    CONST           reduce using rule 10 (rule -> cicloFor .)
    ID              reduce using rule 10 (rule -> cicloFor .)
    APPEND          reduce using rule 10 (rule -> cicloFor .)
    LEN             reduce using rule 10 (rule -> cicloFor .)
    COPY            reduce using rule 10 (rule -> cicloFor .)
    DELETE          reduce using rule 10 (rule -> cicloFor .)
    IF              reduce using rule 10 (rule -> cicloFor .)
    ELSE            reduce using rule 10 (rule -> cicloFor .)
    TYPE            reduce using rule 10 (rule -> cicloFor .)
    SWITCH          reduce using rule 10 (rule -> cicloFor .)
    VAR             reduce using rule 10 (rule -> cicloFor .)
    FUNC            reduce using rule 10 (rule -> cicloFor .)
    INTEGER         reduce using rule 10 (rule -> cicloFor .)
    FLOAT           reduce using rule 10 (rule -> cicloFor .)
    NOT             reduce using rule 10 (rule -> cicloFor .)
    $end            reduce using rule 10 (rule -> cicloFor .)
    RLLAVE          reduce using rule 10 (rule -> cicloFor .)
    INT32           reduce using rule 10 (rule -> cicloFor .)
    INT64           reduce using rule 10 (rule -> cicloFor .)
    FLOAT32         reduce using rule 10 (rule -> cicloFor .)
    FLOAT64         reduce using rule 10 (rule -> cicloFor .)
    BYTE            reduce using rule 10 (rule -> cicloFor .)
    WFLOAT          reduce using rule 10 (rule -> cicloFor .)
    WSTRING         reduce using rule 10 (rule -> cicloFor .)
    WINT            reduce using rule 10 (rule -> cicloFor .)
    BOOL            reduce using rule 10 (rule -> cicloFor .)
    DEFAULT         reduce using rule 10 (rule -> cicloFor .)
    CASE            reduce using rule 10 (rule -> cicloFor .)
    RETURN          reduce using rule 10 (rule -> cicloFor .)
    STRING          reduce using rule 10 (rule -> cicloFor .)
    TRUE            reduce using rule 10 (rule -> cicloFor .)
    FALSE           reduce using rule 10 (rule -> cicloFor .)


state 8

    (11) rule -> comparison .
    (192) logic_value -> comparison .

    PRINT           reduce using rule 11 (rule -> comparison .)
    SCAN            reduce using rule 11 (rule -> comparison .)
    FOR             reduce using rule 11 (rule -> comparison .)
    CONST           reduce using rule 11 (rule -> comparison .)
    ID              reduce using rule 11 (rule -> comparison .)
    APPEND          reduce using rule 11 (rule -> comparison .)
    LEN             reduce using rule 11 (rule -> comparison .)
    COPY            reduce using rule 11 (rule -> comparison .)
    DELETE          reduce using rule 11 (rule -> comparison .)
    IF              reduce using rule 11 (rule -> comparison .)
    ELSE            reduce using rule 11 (rule -> comparison .)
    TYPE            reduce using rule 11 (rule -> comparison .)
    SWITCH          reduce using rule 11 (rule -> comparison .)
    VAR             reduce using rule 11 (rule -> comparison .)
    FUNC            reduce using rule 11 (rule -> comparison .)
    INTEGER         reduce using rule 11 (rule -> comparison .)
    FLOAT           reduce using rule 11 (rule -> comparison .)
    NOT             reduce using rule 11 (rule -> comparison .)
    $end            reduce using rule 11 (rule -> comparison .)
    RLLAVE          reduce using rule 11 (rule -> comparison .)
    INT32           reduce using rule 11 (rule -> comparison .)
    INT64           reduce using rule 11 (rule -> comparison .)
    FLOAT32         reduce using rule 11 (rule -> comparison .)
    FLOAT64         reduce using rule 11 (rule -> comparison .)
    BYTE            reduce using rule 11 (rule -> comparison .)
    WFLOAT          reduce using rule 11 (rule -> comparison .)
    WSTRING         reduce using rule 11 (rule -> comparison .)
    WINT            reduce using rule 11 (rule -> comparison .)
    BOOL            reduce using rule 11 (rule -> comparison .)
    DEFAULT         reduce using rule 11 (rule -> comparison .)
    CASE            reduce using rule 11 (rule -> comparison .)
    RETURN          reduce using rule 11 (rule -> comparison .)
    STRING          reduce using rule 11 (rule -> comparison .)
    TRUE            reduce using rule 11 (rule -> comparison .)
    FALSE           reduce using rule 11 (rule -> comparison .)
    AND             reduce using rule 192 (logic_value -> comparison .)
    OR              reduce using rule 192 (logic_value -> comparison .)


state 9

    (12) rule -> logic_operation .

    PRINT           reduce using rule 12 (rule -> logic_operation .)
    SCAN            reduce using rule 12 (rule -> logic_operation .)
    FOR             reduce using rule 12 (rule -> logic_operation .)
    CONST           reduce using rule 12 (rule -> logic_operation .)
    ID              reduce using rule 12 (rule -> logic_operation .)
    APPEND          reduce using rule 12 (rule -> logic_operation .)
    LEN             reduce using rule 12 (rule -> logic_operation .)
    COPY            reduce using rule 12 (rule -> logic_operation .)
    DELETE          reduce using rule 12 (rule -> logic_operation .)
    IF              reduce using rule 12 (rule -> logic_operation .)
    ELSE            reduce using rule 12 (rule -> logic_operation .)
    TYPE            reduce using rule 12 (rule -> logic_operation .)
    SWITCH          reduce using rule 12 (rule -> logic_operation .)
    VAR             reduce using rule 12 (rule -> logic_operation .)
    FUNC            reduce using rule 12 (rule -> logic_operation .)
    INTEGER         reduce using rule 12 (rule -> logic_operation .)
    FLOAT           reduce using rule 12 (rule -> logic_operation .)
    NOT             reduce using rule 12 (rule -> logic_operation .)
    $end            reduce using rule 12 (rule -> logic_operation .)
    RLLAVE          reduce using rule 12 (rule -> logic_operation .)
    INT32           reduce using rule 12 (rule -> logic_operation .)
    INT64           reduce using rule 12 (rule -> logic_operation .)
    FLOAT32         reduce using rule 12 (rule -> logic_operation .)
    FLOAT64         reduce using rule 12 (rule -> logic_operation .)
    BYTE            reduce using rule 12 (rule -> logic_operation .)
    WFLOAT          reduce using rule 12 (rule -> logic_operation .)
    WSTRING         reduce using rule 12 (rule -> logic_operation .)
    WINT            reduce using rule 12 (rule -> logic_operation .)
    BOOL            reduce using rule 12 (rule -> logic_operation .)
    DEFAULT         reduce using rule 12 (rule -> logic_operation .)
    CASE            reduce using rule 12 (rule -> logic_operation .)
    RETURN          reduce using rule 12 (rule -> logic_operation .)
    STRING          reduce using rule 12 (rule -> logic_operation .)
    TRUE            reduce using rule 12 (rule -> logic_operation .)
    FALSE           reduce using rule 12 (rule -> logic_operation .)


state 10

    (13) rule -> decVar . COLON
    (14) rule -> decVar .

    COLON           shift and go to state 64
    PRINT           reduce using rule 14 (rule -> decVar .)
    SCAN            reduce using rule 14 (rule -> decVar .)
    FOR             reduce using rule 14 (rule -> decVar .)
    CONST           reduce using rule 14 (rule -> decVar .)
    ID              reduce using rule 14 (rule -> decVar .)
    APPEND          reduce using rule 14 (rule -> decVar .)
    LEN             reduce using rule 14 (rule -> decVar .)
    COPY            reduce using rule 14 (rule -> decVar .)
    DELETE          reduce using rule 14 (rule -> decVar .)
    IF              reduce using rule 14 (rule -> decVar .)
    ELSE            reduce using rule 14 (rule -> decVar .)
    TYPE            reduce using rule 14 (rule -> decVar .)
    SWITCH          reduce using rule 14 (rule -> decVar .)
    VAR             reduce using rule 14 (rule -> decVar .)
    FUNC            reduce using rule 14 (rule -> decVar .)
    INTEGER         reduce using rule 14 (rule -> decVar .)
    FLOAT           reduce using rule 14 (rule -> decVar .)
    NOT             reduce using rule 14 (rule -> decVar .)
    $end            reduce using rule 14 (rule -> decVar .)
    RLLAVE          reduce using rule 14 (rule -> decVar .)
    INT32           reduce using rule 14 (rule -> decVar .)
    INT64           reduce using rule 14 (rule -> decVar .)
    FLOAT32         reduce using rule 14 (rule -> decVar .)
    FLOAT64         reduce using rule 14 (rule -> decVar .)
    BYTE            reduce using rule 14 (rule -> decVar .)
    WFLOAT          reduce using rule 14 (rule -> decVar .)
    WSTRING         reduce using rule 14 (rule -> decVar .)
    WINT            reduce using rule 14 (rule -> decVar .)
    BOOL            reduce using rule 14 (rule -> decVar .)
    DEFAULT         reduce using rule 14 (rule -> decVar .)
    CASE            reduce using rule 14 (rule -> decVar .)
    RETURN          reduce using rule 14 (rule -> decVar .)
    STRING          reduce using rule 14 (rule -> decVar .)
    TRUE            reduce using rule 14 (rule -> decVar .)
    FALSE           reduce using rule 14 (rule -> decVar .)


state 11

    (15) rule -> decConst . COLON
    (16) rule -> decConst .

    COLON           shift and go to state 65
    PRINT           reduce using rule 16 (rule -> decConst .)
    SCAN            reduce using rule 16 (rule -> decConst .)
    FOR             reduce using rule 16 (rule -> decConst .)
    CONST           reduce using rule 16 (rule -> decConst .)
    ID              reduce using rule 16 (rule -> decConst .)
    APPEND          reduce using rule 16 (rule -> decConst .)
    LEN             reduce using rule 16 (rule -> decConst .)
    COPY            reduce using rule 16 (rule -> decConst .)
    DELETE          reduce using rule 16 (rule -> decConst .)
    IF              reduce using rule 16 (rule -> decConst .)
    ELSE            reduce using rule 16 (rule -> decConst .)
    TYPE            reduce using rule 16 (rule -> decConst .)
    SWITCH          reduce using rule 16 (rule -> decConst .)
    VAR             reduce using rule 16 (rule -> decConst .)
    FUNC            reduce using rule 16 (rule -> decConst .)
    INTEGER         reduce using rule 16 (rule -> decConst .)
    FLOAT           reduce using rule 16 (rule -> decConst .)
    NOT             reduce using rule 16 (rule -> decConst .)
    $end            reduce using rule 16 (rule -> decConst .)
    RLLAVE          reduce using rule 16 (rule -> decConst .)
    INT32           reduce using rule 16 (rule -> decConst .)
    INT64           reduce using rule 16 (rule -> decConst .)
    FLOAT32         reduce using rule 16 (rule -> decConst .)
    FLOAT64         reduce using rule 16 (rule -> decConst .)
    BYTE            reduce using rule 16 (rule -> decConst .)
    WFLOAT          reduce using rule 16 (rule -> decConst .)
    WSTRING         reduce using rule 16 (rule -> decConst .)
    WINT            reduce using rule 16 (rule -> decConst .)
    BOOL            reduce using rule 16 (rule -> decConst .)
    DEFAULT         reduce using rule 16 (rule -> decConst .)
    CASE            reduce using rule 16 (rule -> decConst .)
    RETURN          reduce using rule 16 (rule -> decConst .)
    STRING          reduce using rule 16 (rule -> decConst .)
    TRUE            reduce using rule 16 (rule -> decConst .)
    FALSE           reduce using rule 16 (rule -> decConst .)


state 12

    (17) rule -> var_asignation .
    (18) rule -> var_asignation . COLON

    PRINT           reduce using rule 17 (rule -> var_asignation .)
    SCAN            reduce using rule 17 (rule -> var_asignation .)
    FOR             reduce using rule 17 (rule -> var_asignation .)
    CONST           reduce using rule 17 (rule -> var_asignation .)
    ID              reduce using rule 17 (rule -> var_asignation .)
    APPEND          reduce using rule 17 (rule -> var_asignation .)
    LEN             reduce using rule 17 (rule -> var_asignation .)
    COPY            reduce using rule 17 (rule -> var_asignation .)
    DELETE          reduce using rule 17 (rule -> var_asignation .)
    IF              reduce using rule 17 (rule -> var_asignation .)
    ELSE            reduce using rule 17 (rule -> var_asignation .)
    TYPE            reduce using rule 17 (rule -> var_asignation .)
    SWITCH          reduce using rule 17 (rule -> var_asignation .)
    VAR             reduce using rule 17 (rule -> var_asignation .)
    FUNC            reduce using rule 17 (rule -> var_asignation .)
    INTEGER         reduce using rule 17 (rule -> var_asignation .)
    FLOAT           reduce using rule 17 (rule -> var_asignation .)
    NOT             reduce using rule 17 (rule -> var_asignation .)
    $end            reduce using rule 17 (rule -> var_asignation .)
    RLLAVE          reduce using rule 17 (rule -> var_asignation .)
    INT32           reduce using rule 17 (rule -> var_asignation .)
    INT64           reduce using rule 17 (rule -> var_asignation .)
    FLOAT32         reduce using rule 17 (rule -> var_asignation .)
    FLOAT64         reduce using rule 17 (rule -> var_asignation .)
    BYTE            reduce using rule 17 (rule -> var_asignation .)
    WFLOAT          reduce using rule 17 (rule -> var_asignation .)
    WSTRING         reduce using rule 17 (rule -> var_asignation .)
    WINT            reduce using rule 17 (rule -> var_asignation .)
    BOOL            reduce using rule 17 (rule -> var_asignation .)
    DEFAULT         reduce using rule 17 (rule -> var_asignation .)
    CASE            reduce using rule 17 (rule -> var_asignation .)
    RETURN          reduce using rule 17 (rule -> var_asignation .)
    STRING          reduce using rule 17 (rule -> var_asignation .)
    TRUE            reduce using rule 17 (rule -> var_asignation .)
    FALSE           reduce using rule 17 (rule -> var_asignation .)
    COLON           shift and go to state 66


state 13

    (19) rule -> funciones .
    (20) rule -> funciones . COLON
    (246) something_ex -> funciones .

  ! shift/reduce conflict for COLON resolved as shift
  ! reduce/reduce conflict for PRINT resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for SCAN resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for FOR resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for CONST resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for ID resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for APPEND resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for LEN resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for COPY resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for DELETE resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for IF resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for ELSE resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for TYPE resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for SWITCH resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for VAR resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for FUNC resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for INTEGER resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for FLOAT resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for NOT resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for $end resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for INT32 resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for INT64 resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for BYTE resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for WSTRING resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for WINT resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for BOOL resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for CASE resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for RETURN resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for STRING resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for TRUE resolved using rule 19 (rule -> funciones .)
  ! reduce/reduce conflict for FALSE resolved using rule 19 (rule -> funciones .)
    PRINT           reduce using rule 19 (rule -> funciones .)
    SCAN            reduce using rule 19 (rule -> funciones .)
    FOR             reduce using rule 19 (rule -> funciones .)
    CONST           reduce using rule 19 (rule -> funciones .)
    ID              reduce using rule 19 (rule -> funciones .)
    APPEND          reduce using rule 19 (rule -> funciones .)
    LEN             reduce using rule 19 (rule -> funciones .)
    COPY            reduce using rule 19 (rule -> funciones .)
    DELETE          reduce using rule 19 (rule -> funciones .)
    IF              reduce using rule 19 (rule -> funciones .)
    ELSE            reduce using rule 19 (rule -> funciones .)
    TYPE            reduce using rule 19 (rule -> funciones .)
    SWITCH          reduce using rule 19 (rule -> funciones .)
    VAR             reduce using rule 19 (rule -> funciones .)
    FUNC            reduce using rule 19 (rule -> funciones .)
    INTEGER         reduce using rule 19 (rule -> funciones .)
    FLOAT           reduce using rule 19 (rule -> funciones .)
    NOT             reduce using rule 19 (rule -> funciones .)
    $end            reduce using rule 19 (rule -> funciones .)
    RLLAVE          reduce using rule 19 (rule -> funciones .)
    INT32           reduce using rule 19 (rule -> funciones .)
    INT64           reduce using rule 19 (rule -> funciones .)
    FLOAT32         reduce using rule 19 (rule -> funciones .)
    FLOAT64         reduce using rule 19 (rule -> funciones .)
    BYTE            reduce using rule 19 (rule -> funciones .)
    WFLOAT          reduce using rule 19 (rule -> funciones .)
    WSTRING         reduce using rule 19 (rule -> funciones .)
    WINT            reduce using rule 19 (rule -> funciones .)
    BOOL            reduce using rule 19 (rule -> funciones .)
    DEFAULT         reduce using rule 19 (rule -> funciones .)
    CASE            reduce using rule 19 (rule -> funciones .)
    RETURN          reduce using rule 19 (rule -> funciones .)
    STRING          reduce using rule 19 (rule -> funciones .)
    TRUE            reduce using rule 19 (rule -> funciones .)
    FALSE           reduce using rule 19 (rule -> funciones .)
    COLON           shift and go to state 67
    GREATER         reduce using rule 246 (something_ex -> funciones .)
    SMALLER         reduce using rule 246 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 246 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 246 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 246 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 246 (something_ex -> funciones .)
    PLUS            reduce using rule 246 (something_ex -> funciones .)
    TIMES           reduce using rule 246 (something_ex -> funciones .)
    DIVIDE          reduce using rule 246 (something_ex -> funciones .)
    MINUS           reduce using rule 246 (something_ex -> funciones .)
    MOD             reduce using rule 246 (something_ex -> funciones .)

  ! COLON           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! PRINT           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! SCAN            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FOR             [ reduce using rule 246 (something_ex -> funciones .) ]
  ! CONST           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! ID              [ reduce using rule 246 (something_ex -> funciones .) ]
  ! APPEND          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! LEN             [ reduce using rule 246 (something_ex -> funciones .) ]
  ! COPY            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! DELETE          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! IF              [ reduce using rule 246 (something_ex -> funciones .) ]
  ! ELSE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! TYPE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! SWITCH          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! VAR             [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FUNC            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! INTEGER         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FLOAT           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! NOT             [ reduce using rule 246 (something_ex -> funciones .) ]
  ! $end            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! RLLAVE          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! INT32           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! INT64           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FLOAT32         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FLOAT64         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! BYTE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! WFLOAT          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! WSTRING         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! WINT            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! BOOL            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! DEFAULT         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! CASE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! RETURN          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! STRING          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! TRUE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FALSE           [ reduce using rule 246 (something_ex -> funciones .) ]


state 14

    (21) rule -> SenIF .

    PRINT           reduce using rule 21 (rule -> SenIF .)
    SCAN            reduce using rule 21 (rule -> SenIF .)
    FOR             reduce using rule 21 (rule -> SenIF .)
    CONST           reduce using rule 21 (rule -> SenIF .)
    ID              reduce using rule 21 (rule -> SenIF .)
    APPEND          reduce using rule 21 (rule -> SenIF .)
    LEN             reduce using rule 21 (rule -> SenIF .)
    COPY            reduce using rule 21 (rule -> SenIF .)
    DELETE          reduce using rule 21 (rule -> SenIF .)
    IF              reduce using rule 21 (rule -> SenIF .)
    ELSE            reduce using rule 21 (rule -> SenIF .)
    TYPE            reduce using rule 21 (rule -> SenIF .)
    SWITCH          reduce using rule 21 (rule -> SenIF .)
    VAR             reduce using rule 21 (rule -> SenIF .)
    FUNC            reduce using rule 21 (rule -> SenIF .)
    INTEGER         reduce using rule 21 (rule -> SenIF .)
    FLOAT           reduce using rule 21 (rule -> SenIF .)
    NOT             reduce using rule 21 (rule -> SenIF .)
    $end            reduce using rule 21 (rule -> SenIF .)
    RLLAVE          reduce using rule 21 (rule -> SenIF .)
    INT32           reduce using rule 21 (rule -> SenIF .)
    INT64           reduce using rule 21 (rule -> SenIF .)
    FLOAT32         reduce using rule 21 (rule -> SenIF .)
    FLOAT64         reduce using rule 21 (rule -> SenIF .)
    BYTE            reduce using rule 21 (rule -> SenIF .)
    WFLOAT          reduce using rule 21 (rule -> SenIF .)
    WSTRING         reduce using rule 21 (rule -> SenIF .)
    WINT            reduce using rule 21 (rule -> SenIF .)
    BOOL            reduce using rule 21 (rule -> SenIF .)
    DEFAULT         reduce using rule 21 (rule -> SenIF .)
    CASE            reduce using rule 21 (rule -> SenIF .)
    RETURN          reduce using rule 21 (rule -> SenIF .)
    STRING          reduce using rule 21 (rule -> SenIF .)
    TRUE            reduce using rule 21 (rule -> SenIF .)
    FALSE           reduce using rule 21 (rule -> SenIF .)


state 15

    (22) rule -> SenElseIF .

    PRINT           reduce using rule 22 (rule -> SenElseIF .)
    SCAN            reduce using rule 22 (rule -> SenElseIF .)
    FOR             reduce using rule 22 (rule -> SenElseIF .)
    CONST           reduce using rule 22 (rule -> SenElseIF .)
    ID              reduce using rule 22 (rule -> SenElseIF .)
    APPEND          reduce using rule 22 (rule -> SenElseIF .)
    LEN             reduce using rule 22 (rule -> SenElseIF .)
    COPY            reduce using rule 22 (rule -> SenElseIF .)
    DELETE          reduce using rule 22 (rule -> SenElseIF .)
    IF              reduce using rule 22 (rule -> SenElseIF .)
    ELSE            reduce using rule 22 (rule -> SenElseIF .)
    TYPE            reduce using rule 22 (rule -> SenElseIF .)
    SWITCH          reduce using rule 22 (rule -> SenElseIF .)
    VAR             reduce using rule 22 (rule -> SenElseIF .)
    FUNC            reduce using rule 22 (rule -> SenElseIF .)
    INTEGER         reduce using rule 22 (rule -> SenElseIF .)
    FLOAT           reduce using rule 22 (rule -> SenElseIF .)
    NOT             reduce using rule 22 (rule -> SenElseIF .)
    $end            reduce using rule 22 (rule -> SenElseIF .)
    RLLAVE          reduce using rule 22 (rule -> SenElseIF .)
    INT32           reduce using rule 22 (rule -> SenElseIF .)
    INT64           reduce using rule 22 (rule -> SenElseIF .)
    FLOAT32         reduce using rule 22 (rule -> SenElseIF .)
    FLOAT64         reduce using rule 22 (rule -> SenElseIF .)
    BYTE            reduce using rule 22 (rule -> SenElseIF .)
    WFLOAT          reduce using rule 22 (rule -> SenElseIF .)
    WSTRING         reduce using rule 22 (rule -> SenElseIF .)
    WINT            reduce using rule 22 (rule -> SenElseIF .)
    BOOL            reduce using rule 22 (rule -> SenElseIF .)
    DEFAULT         reduce using rule 22 (rule -> SenElseIF .)
    CASE            reduce using rule 22 (rule -> SenElseIF .)
    RETURN          reduce using rule 22 (rule -> SenElseIF .)
    STRING          reduce using rule 22 (rule -> SenElseIF .)
    TRUE            reduce using rule 22 (rule -> SenElseIF .)
    FALSE           reduce using rule 22 (rule -> SenElseIF .)


state 16

    (23) rule -> SenElse .

    PRINT           reduce using rule 23 (rule -> SenElse .)
    SCAN            reduce using rule 23 (rule -> SenElse .)
    FOR             reduce using rule 23 (rule -> SenElse .)
    CONST           reduce using rule 23 (rule -> SenElse .)
    ID              reduce using rule 23 (rule -> SenElse .)
    APPEND          reduce using rule 23 (rule -> SenElse .)
    LEN             reduce using rule 23 (rule -> SenElse .)
    COPY            reduce using rule 23 (rule -> SenElse .)
    DELETE          reduce using rule 23 (rule -> SenElse .)
    IF              reduce using rule 23 (rule -> SenElse .)
    ELSE            reduce using rule 23 (rule -> SenElse .)
    TYPE            reduce using rule 23 (rule -> SenElse .)
    SWITCH          reduce using rule 23 (rule -> SenElse .)
    VAR             reduce using rule 23 (rule -> SenElse .)
    FUNC            reduce using rule 23 (rule -> SenElse .)
    INTEGER         reduce using rule 23 (rule -> SenElse .)
    FLOAT           reduce using rule 23 (rule -> SenElse .)
    NOT             reduce using rule 23 (rule -> SenElse .)
    $end            reduce using rule 23 (rule -> SenElse .)
    RLLAVE          reduce using rule 23 (rule -> SenElse .)
    INT32           reduce using rule 23 (rule -> SenElse .)
    INT64           reduce using rule 23 (rule -> SenElse .)
    FLOAT32         reduce using rule 23 (rule -> SenElse .)
    FLOAT64         reduce using rule 23 (rule -> SenElse .)
    BYTE            reduce using rule 23 (rule -> SenElse .)
    WFLOAT          reduce using rule 23 (rule -> SenElse .)
    WSTRING         reduce using rule 23 (rule -> SenElse .)
    WINT            reduce using rule 23 (rule -> SenElse .)
    BOOL            reduce using rule 23 (rule -> SenElse .)
    DEFAULT         reduce using rule 23 (rule -> SenElse .)
    CASE            reduce using rule 23 (rule -> SenElse .)
    RETURN          reduce using rule 23 (rule -> SenElse .)
    STRING          reduce using rule 23 (rule -> SenElse .)
    TRUE            reduce using rule 23 (rule -> SenElse .)
    FALSE           reduce using rule 23 (rule -> SenElse .)


state 17

    (24) rule -> SenStruct .

    PRINT           reduce using rule 24 (rule -> SenStruct .)
    SCAN            reduce using rule 24 (rule -> SenStruct .)
    FOR             reduce using rule 24 (rule -> SenStruct .)
    CONST           reduce using rule 24 (rule -> SenStruct .)
    ID              reduce using rule 24 (rule -> SenStruct .)
    APPEND          reduce using rule 24 (rule -> SenStruct .)
    LEN             reduce using rule 24 (rule -> SenStruct .)
    COPY            reduce using rule 24 (rule -> SenStruct .)
    DELETE          reduce using rule 24 (rule -> SenStruct .)
    IF              reduce using rule 24 (rule -> SenStruct .)
    ELSE            reduce using rule 24 (rule -> SenStruct .)
    TYPE            reduce using rule 24 (rule -> SenStruct .)
    SWITCH          reduce using rule 24 (rule -> SenStruct .)
    VAR             reduce using rule 24 (rule -> SenStruct .)
    FUNC            reduce using rule 24 (rule -> SenStruct .)
    INTEGER         reduce using rule 24 (rule -> SenStruct .)
    FLOAT           reduce using rule 24 (rule -> SenStruct .)
    NOT             reduce using rule 24 (rule -> SenStruct .)
    $end            reduce using rule 24 (rule -> SenStruct .)
    RLLAVE          reduce using rule 24 (rule -> SenStruct .)
    INT32           reduce using rule 24 (rule -> SenStruct .)
    INT64           reduce using rule 24 (rule -> SenStruct .)
    FLOAT32         reduce using rule 24 (rule -> SenStruct .)
    FLOAT64         reduce using rule 24 (rule -> SenStruct .)
    BYTE            reduce using rule 24 (rule -> SenStruct .)
    WFLOAT          reduce using rule 24 (rule -> SenStruct .)
    WSTRING         reduce using rule 24 (rule -> SenStruct .)
    WINT            reduce using rule 24 (rule -> SenStruct .)
    BOOL            reduce using rule 24 (rule -> SenStruct .)
    DEFAULT         reduce using rule 24 (rule -> SenStruct .)
    CASE            reduce using rule 24 (rule -> SenStruct .)
    RETURN          reduce using rule 24 (rule -> SenStruct .)
    STRING          reduce using rule 24 (rule -> SenStruct .)
    TRUE            reduce using rule 24 (rule -> SenStruct .)
    FALSE           reduce using rule 24 (rule -> SenStruct .)


state 18

    (25) rule -> cStruct .

    PRINT           reduce using rule 25 (rule -> cStruct .)
    SCAN            reduce using rule 25 (rule -> cStruct .)
    FOR             reduce using rule 25 (rule -> cStruct .)
    CONST           reduce using rule 25 (rule -> cStruct .)
    ID              reduce using rule 25 (rule -> cStruct .)
    APPEND          reduce using rule 25 (rule -> cStruct .)
    LEN             reduce using rule 25 (rule -> cStruct .)
    COPY            reduce using rule 25 (rule -> cStruct .)
    DELETE          reduce using rule 25 (rule -> cStruct .)
    IF              reduce using rule 25 (rule -> cStruct .)
    ELSE            reduce using rule 25 (rule -> cStruct .)
    TYPE            reduce using rule 25 (rule -> cStruct .)
    SWITCH          reduce using rule 25 (rule -> cStruct .)
    VAR             reduce using rule 25 (rule -> cStruct .)
    FUNC            reduce using rule 25 (rule -> cStruct .)
    INTEGER         reduce using rule 25 (rule -> cStruct .)
    FLOAT           reduce using rule 25 (rule -> cStruct .)
    NOT             reduce using rule 25 (rule -> cStruct .)
    $end            reduce using rule 25 (rule -> cStruct .)
    RLLAVE          reduce using rule 25 (rule -> cStruct .)
    INT32           reduce using rule 25 (rule -> cStruct .)
    INT64           reduce using rule 25 (rule -> cStruct .)
    FLOAT32         reduce using rule 25 (rule -> cStruct .)
    FLOAT64         reduce using rule 25 (rule -> cStruct .)
    BYTE            reduce using rule 25 (rule -> cStruct .)
    WFLOAT          reduce using rule 25 (rule -> cStruct .)
    WSTRING         reduce using rule 25 (rule -> cStruct .)
    WINT            reduce using rule 25 (rule -> cStruct .)
    BOOL            reduce using rule 25 (rule -> cStruct .)
    DEFAULT         reduce using rule 25 (rule -> cStruct .)
    CASE            reduce using rule 25 (rule -> cStruct .)
    RETURN          reduce using rule 25 (rule -> cStruct .)
    STRING          reduce using rule 25 (rule -> cStruct .)
    TRUE            reduce using rule 25 (rule -> cStruct .)
    FALSE           reduce using rule 25 (rule -> cStruct .)


state 19

    (26) rule -> switch_statement .

    PRINT           reduce using rule 26 (rule -> switch_statement .)
    SCAN            reduce using rule 26 (rule -> switch_statement .)
    FOR             reduce using rule 26 (rule -> switch_statement .)
    CONST           reduce using rule 26 (rule -> switch_statement .)
    ID              reduce using rule 26 (rule -> switch_statement .)
    APPEND          reduce using rule 26 (rule -> switch_statement .)
    LEN             reduce using rule 26 (rule -> switch_statement .)
    COPY            reduce using rule 26 (rule -> switch_statement .)
    DELETE          reduce using rule 26 (rule -> switch_statement .)
    IF              reduce using rule 26 (rule -> switch_statement .)
    ELSE            reduce using rule 26 (rule -> switch_statement .)
    TYPE            reduce using rule 26 (rule -> switch_statement .)
    SWITCH          reduce using rule 26 (rule -> switch_statement .)
    VAR             reduce using rule 26 (rule -> switch_statement .)
    FUNC            reduce using rule 26 (rule -> switch_statement .)
    INTEGER         reduce using rule 26 (rule -> switch_statement .)
    FLOAT           reduce using rule 26 (rule -> switch_statement .)
    NOT             reduce using rule 26 (rule -> switch_statement .)
    $end            reduce using rule 26 (rule -> switch_statement .)
    RLLAVE          reduce using rule 26 (rule -> switch_statement .)
    INT32           reduce using rule 26 (rule -> switch_statement .)
    INT64           reduce using rule 26 (rule -> switch_statement .)
    FLOAT32         reduce using rule 26 (rule -> switch_statement .)
    FLOAT64         reduce using rule 26 (rule -> switch_statement .)
    BYTE            reduce using rule 26 (rule -> switch_statement .)
    WFLOAT          reduce using rule 26 (rule -> switch_statement .)
    WSTRING         reduce using rule 26 (rule -> switch_statement .)
    WINT            reduce using rule 26 (rule -> switch_statement .)
    BOOL            reduce using rule 26 (rule -> switch_statement .)
    DEFAULT         reduce using rule 26 (rule -> switch_statement .)
    CASE            reduce using rule 26 (rule -> switch_statement .)
    RETURN          reduce using rule 26 (rule -> switch_statement .)
    STRING          reduce using rule 26 (rule -> switch_statement .)
    TRUE            reduce using rule 26 (rule -> switch_statement .)
    FALSE           reduce using rule 26 (rule -> switch_statement .)


state 20

    (27) rule -> array_declaration . COLON
    (28) rule -> array_declaration .

    COLON           shift and go to state 68
    PRINT           reduce using rule 28 (rule -> array_declaration .)
    SCAN            reduce using rule 28 (rule -> array_declaration .)
    FOR             reduce using rule 28 (rule -> array_declaration .)
    CONST           reduce using rule 28 (rule -> array_declaration .)
    ID              reduce using rule 28 (rule -> array_declaration .)
    APPEND          reduce using rule 28 (rule -> array_declaration .)
    LEN             reduce using rule 28 (rule -> array_declaration .)
    COPY            reduce using rule 28 (rule -> array_declaration .)
    DELETE          reduce using rule 28 (rule -> array_declaration .)
    IF              reduce using rule 28 (rule -> array_declaration .)
    ELSE            reduce using rule 28 (rule -> array_declaration .)
    TYPE            reduce using rule 28 (rule -> array_declaration .)
    SWITCH          reduce using rule 28 (rule -> array_declaration .)
    VAR             reduce using rule 28 (rule -> array_declaration .)
    FUNC            reduce using rule 28 (rule -> array_declaration .)
    INTEGER         reduce using rule 28 (rule -> array_declaration .)
    FLOAT           reduce using rule 28 (rule -> array_declaration .)
    NOT             reduce using rule 28 (rule -> array_declaration .)
    $end            reduce using rule 28 (rule -> array_declaration .)
    RLLAVE          reduce using rule 28 (rule -> array_declaration .)
    INT32           reduce using rule 28 (rule -> array_declaration .)
    INT64           reduce using rule 28 (rule -> array_declaration .)
    FLOAT32         reduce using rule 28 (rule -> array_declaration .)
    FLOAT64         reduce using rule 28 (rule -> array_declaration .)
    BYTE            reduce using rule 28 (rule -> array_declaration .)
    WFLOAT          reduce using rule 28 (rule -> array_declaration .)
    WSTRING         reduce using rule 28 (rule -> array_declaration .)
    WINT            reduce using rule 28 (rule -> array_declaration .)
    BOOL            reduce using rule 28 (rule -> array_declaration .)
    DEFAULT         reduce using rule 28 (rule -> array_declaration .)
    CASE            reduce using rule 28 (rule -> array_declaration .)
    RETURN          reduce using rule 28 (rule -> array_declaration .)
    STRING          reduce using rule 28 (rule -> array_declaration .)
    TRUE            reduce using rule 28 (rule -> array_declaration .)
    FALSE           reduce using rule 28 (rule -> array_declaration .)


state 21

    (29) rule -> array_var . COLON
    (30) rule -> array_var .
    (212) array_assignment -> array_var . EQUAL something
    (62) data_structure -> array_var .

  ! shift/reduce conflict for COLON resolved as shift
  ! reduce/reduce conflict for PRINT resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for SCAN resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for FOR resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for CONST resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for ID resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for APPEND resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for LEN resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for COPY resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for DELETE resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for IF resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for ELSE resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for TYPE resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for SWITCH resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for VAR resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for FUNC resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for INTEGER resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for FLOAT resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for NOT resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for $end resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for INT32 resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for INT64 resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for BYTE resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for WSTRING resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for WINT resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for BOOL resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for CASE resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for RETURN resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for STRING resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for TRUE resolved using rule 30 (rule -> array_var .)
  ! reduce/reduce conflict for FALSE resolved using rule 30 (rule -> array_var .)
    COLON           shift and go to state 69
    PRINT           reduce using rule 30 (rule -> array_var .)
    SCAN            reduce using rule 30 (rule -> array_var .)
    FOR             reduce using rule 30 (rule -> array_var .)
    CONST           reduce using rule 30 (rule -> array_var .)
    ID              reduce using rule 30 (rule -> array_var .)
    APPEND          reduce using rule 30 (rule -> array_var .)
    LEN             reduce using rule 30 (rule -> array_var .)
    COPY            reduce using rule 30 (rule -> array_var .)
    DELETE          reduce using rule 30 (rule -> array_var .)
    IF              reduce using rule 30 (rule -> array_var .)
    ELSE            reduce using rule 30 (rule -> array_var .)
    TYPE            reduce using rule 30 (rule -> array_var .)
    SWITCH          reduce using rule 30 (rule -> array_var .)
    VAR             reduce using rule 30 (rule -> array_var .)
    FUNC            reduce using rule 30 (rule -> array_var .)
    INTEGER         reduce using rule 30 (rule -> array_var .)
    FLOAT           reduce using rule 30 (rule -> array_var .)
    NOT             reduce using rule 30 (rule -> array_var .)
    $end            reduce using rule 30 (rule -> array_var .)
    RLLAVE          reduce using rule 30 (rule -> array_var .)
    INT32           reduce using rule 30 (rule -> array_var .)
    INT64           reduce using rule 30 (rule -> array_var .)
    FLOAT32         reduce using rule 30 (rule -> array_var .)
    FLOAT64         reduce using rule 30 (rule -> array_var .)
    BYTE            reduce using rule 30 (rule -> array_var .)
    WFLOAT          reduce using rule 30 (rule -> array_var .)
    WSTRING         reduce using rule 30 (rule -> array_var .)
    WINT            reduce using rule 30 (rule -> array_var .)
    BOOL            reduce using rule 30 (rule -> array_var .)
    DEFAULT         reduce using rule 30 (rule -> array_var .)
    CASE            reduce using rule 30 (rule -> array_var .)
    RETURN          reduce using rule 30 (rule -> array_var .)
    STRING          reduce using rule 30 (rule -> array_var .)
    TRUE            reduce using rule 30 (rule -> array_var .)
    FALSE           reduce using rule 30 (rule -> array_var .)
    EQUAL           shift and go to state 70
    GREATER         reduce using rule 62 (data_structure -> array_var .)
    SMALLER         reduce using rule 62 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 62 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 62 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 62 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 62 (data_structure -> array_var .)
    PLUS            reduce using rule 62 (data_structure -> array_var .)
    TIMES           reduce using rule 62 (data_structure -> array_var .)
    DIVIDE          reduce using rule 62 (data_structure -> array_var .)
    MINUS           reduce using rule 62 (data_structure -> array_var .)
    MOD             reduce using rule 62 (data_structure -> array_var .)

  ! COLON           [ reduce using rule 62 (data_structure -> array_var .) ]
  ! PRINT           [ reduce using rule 62 (data_structure -> array_var .) ]
  ! SCAN            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! FOR             [ reduce using rule 62 (data_structure -> array_var .) ]
  ! CONST           [ reduce using rule 62 (data_structure -> array_var .) ]
  ! ID              [ reduce using rule 62 (data_structure -> array_var .) ]
  ! APPEND          [ reduce using rule 62 (data_structure -> array_var .) ]
  ! LEN             [ reduce using rule 62 (data_structure -> array_var .) ]
  ! COPY            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! DELETE          [ reduce using rule 62 (data_structure -> array_var .) ]
  ! IF              [ reduce using rule 62 (data_structure -> array_var .) ]
  ! ELSE            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! TYPE            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! SWITCH          [ reduce using rule 62 (data_structure -> array_var .) ]
  ! VAR             [ reduce using rule 62 (data_structure -> array_var .) ]
  ! FUNC            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! INTEGER         [ reduce using rule 62 (data_structure -> array_var .) ]
  ! FLOAT           [ reduce using rule 62 (data_structure -> array_var .) ]
  ! NOT             [ reduce using rule 62 (data_structure -> array_var .) ]
  ! $end            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! RLLAVE          [ reduce using rule 62 (data_structure -> array_var .) ]
  ! INT32           [ reduce using rule 62 (data_structure -> array_var .) ]
  ! INT64           [ reduce using rule 62 (data_structure -> array_var .) ]
  ! FLOAT32         [ reduce using rule 62 (data_structure -> array_var .) ]
  ! FLOAT64         [ reduce using rule 62 (data_structure -> array_var .) ]
  ! BYTE            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! WFLOAT          [ reduce using rule 62 (data_structure -> array_var .) ]
  ! WSTRING         [ reduce using rule 62 (data_structure -> array_var .) ]
  ! WINT            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! BOOL            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! DEFAULT         [ reduce using rule 62 (data_structure -> array_var .) ]
  ! CASE            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! RETURN          [ reduce using rule 62 (data_structure -> array_var .) ]
  ! STRING          [ reduce using rule 62 (data_structure -> array_var .) ]
  ! TRUE            [ reduce using rule 62 (data_structure -> array_var .) ]
  ! FALSE           [ reduce using rule 62 (data_structure -> array_var .) ]


state 22

    (31) rule -> array_assignment . COLON
    (32) rule -> array_assignment .

    COLON           shift and go to state 71
    PRINT           reduce using rule 32 (rule -> array_assignment .)
    SCAN            reduce using rule 32 (rule -> array_assignment .)
    FOR             reduce using rule 32 (rule -> array_assignment .)
    CONST           reduce using rule 32 (rule -> array_assignment .)
    ID              reduce using rule 32 (rule -> array_assignment .)
    APPEND          reduce using rule 32 (rule -> array_assignment .)
    LEN             reduce using rule 32 (rule -> array_assignment .)
    COPY            reduce using rule 32 (rule -> array_assignment .)
    DELETE          reduce using rule 32 (rule -> array_assignment .)
    IF              reduce using rule 32 (rule -> array_assignment .)
    ELSE            reduce using rule 32 (rule -> array_assignment .)
    TYPE            reduce using rule 32 (rule -> array_assignment .)
    SWITCH          reduce using rule 32 (rule -> array_assignment .)
    VAR             reduce using rule 32 (rule -> array_assignment .)
    FUNC            reduce using rule 32 (rule -> array_assignment .)
    INTEGER         reduce using rule 32 (rule -> array_assignment .)
    FLOAT           reduce using rule 32 (rule -> array_assignment .)
    NOT             reduce using rule 32 (rule -> array_assignment .)
    $end            reduce using rule 32 (rule -> array_assignment .)
    RLLAVE          reduce using rule 32 (rule -> array_assignment .)
    INT32           reduce using rule 32 (rule -> array_assignment .)
    INT64           reduce using rule 32 (rule -> array_assignment .)
    FLOAT32         reduce using rule 32 (rule -> array_assignment .)
    FLOAT64         reduce using rule 32 (rule -> array_assignment .)
    BYTE            reduce using rule 32 (rule -> array_assignment .)
    WFLOAT          reduce using rule 32 (rule -> array_assignment .)
    WSTRING         reduce using rule 32 (rule -> array_assignment .)
    WINT            reduce using rule 32 (rule -> array_assignment .)
    BOOL            reduce using rule 32 (rule -> array_assignment .)
    DEFAULT         reduce using rule 32 (rule -> array_assignment .)
    CASE            reduce using rule 32 (rule -> array_assignment .)
    RETURN          reduce using rule 32 (rule -> array_assignment .)
    STRING          reduce using rule 32 (rule -> array_assignment .)
    TRUE            reduce using rule 32 (rule -> array_assignment .)
    FALSE           reduce using rule 32 (rule -> array_assignment .)


state 23

    (33) rule -> slice_declaration . COLON
    (34) rule -> slice_declaration .

    COLON           shift and go to state 72
    PRINT           reduce using rule 34 (rule -> slice_declaration .)
    SCAN            reduce using rule 34 (rule -> slice_declaration .)
    FOR             reduce using rule 34 (rule -> slice_declaration .)
    CONST           reduce using rule 34 (rule -> slice_declaration .)
    ID              reduce using rule 34 (rule -> slice_declaration .)
    APPEND          reduce using rule 34 (rule -> slice_declaration .)
    LEN             reduce using rule 34 (rule -> slice_declaration .)
    COPY            reduce using rule 34 (rule -> slice_declaration .)
    DELETE          reduce using rule 34 (rule -> slice_declaration .)
    IF              reduce using rule 34 (rule -> slice_declaration .)
    ELSE            reduce using rule 34 (rule -> slice_declaration .)
    TYPE            reduce using rule 34 (rule -> slice_declaration .)
    SWITCH          reduce using rule 34 (rule -> slice_declaration .)
    VAR             reduce using rule 34 (rule -> slice_declaration .)
    FUNC            reduce using rule 34 (rule -> slice_declaration .)
    INTEGER         reduce using rule 34 (rule -> slice_declaration .)
    FLOAT           reduce using rule 34 (rule -> slice_declaration .)
    NOT             reduce using rule 34 (rule -> slice_declaration .)
    $end            reduce using rule 34 (rule -> slice_declaration .)
    RLLAVE          reduce using rule 34 (rule -> slice_declaration .)
    INT32           reduce using rule 34 (rule -> slice_declaration .)
    INT64           reduce using rule 34 (rule -> slice_declaration .)
    FLOAT32         reduce using rule 34 (rule -> slice_declaration .)
    FLOAT64         reduce using rule 34 (rule -> slice_declaration .)
    BYTE            reduce using rule 34 (rule -> slice_declaration .)
    WFLOAT          reduce using rule 34 (rule -> slice_declaration .)
    WSTRING         reduce using rule 34 (rule -> slice_declaration .)
    WINT            reduce using rule 34 (rule -> slice_declaration .)
    BOOL            reduce using rule 34 (rule -> slice_declaration .)
    DEFAULT         reduce using rule 34 (rule -> slice_declaration .)
    CASE            reduce using rule 34 (rule -> slice_declaration .)
    RETURN          reduce using rule 34 (rule -> slice_declaration .)
    STRING          reduce using rule 34 (rule -> slice_declaration .)
    TRUE            reduce using rule 34 (rule -> slice_declaration .)
    FALSE           reduce using rule 34 (rule -> slice_declaration .)


state 24

    (35) rule -> slice_var . COLON
    (36) rule -> slice_var .
    (147) slice_assignment -> slice_var . EQUAL something_s
    (64) data_structure -> slice_var .

  ! shift/reduce conflict for COLON resolved as shift
  ! reduce/reduce conflict for PRINT resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for SCAN resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for FOR resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for CONST resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for ID resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for APPEND resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for LEN resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for COPY resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for DELETE resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for IF resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for ELSE resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for TYPE resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for SWITCH resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for VAR resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for FUNC resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for INTEGER resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for FLOAT resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for NOT resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for $end resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for INT32 resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for INT64 resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for BYTE resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for WSTRING resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for WINT resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for BOOL resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for CASE resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for RETURN resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for STRING resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for TRUE resolved using rule 36 (rule -> slice_var .)
  ! reduce/reduce conflict for FALSE resolved using rule 36 (rule -> slice_var .)
    COLON           shift and go to state 73
    PRINT           reduce using rule 36 (rule -> slice_var .)
    SCAN            reduce using rule 36 (rule -> slice_var .)
    FOR             reduce using rule 36 (rule -> slice_var .)
    CONST           reduce using rule 36 (rule -> slice_var .)
    ID              reduce using rule 36 (rule -> slice_var .)
    APPEND          reduce using rule 36 (rule -> slice_var .)
    LEN             reduce using rule 36 (rule -> slice_var .)
    COPY            reduce using rule 36 (rule -> slice_var .)
    DELETE          reduce using rule 36 (rule -> slice_var .)
    IF              reduce using rule 36 (rule -> slice_var .)
    ELSE            reduce using rule 36 (rule -> slice_var .)
    TYPE            reduce using rule 36 (rule -> slice_var .)
    SWITCH          reduce using rule 36 (rule -> slice_var .)
    VAR             reduce using rule 36 (rule -> slice_var .)
    FUNC            reduce using rule 36 (rule -> slice_var .)
    INTEGER         reduce using rule 36 (rule -> slice_var .)
    FLOAT           reduce using rule 36 (rule -> slice_var .)
    NOT             reduce using rule 36 (rule -> slice_var .)
    $end            reduce using rule 36 (rule -> slice_var .)
    RLLAVE          reduce using rule 36 (rule -> slice_var .)
    INT32           reduce using rule 36 (rule -> slice_var .)
    INT64           reduce using rule 36 (rule -> slice_var .)
    FLOAT32         reduce using rule 36 (rule -> slice_var .)
    FLOAT64         reduce using rule 36 (rule -> slice_var .)
    BYTE            reduce using rule 36 (rule -> slice_var .)
    WFLOAT          reduce using rule 36 (rule -> slice_var .)
    WSTRING         reduce using rule 36 (rule -> slice_var .)
    WINT            reduce using rule 36 (rule -> slice_var .)
    BOOL            reduce using rule 36 (rule -> slice_var .)
    DEFAULT         reduce using rule 36 (rule -> slice_var .)
    CASE            reduce using rule 36 (rule -> slice_var .)
    RETURN          reduce using rule 36 (rule -> slice_var .)
    STRING          reduce using rule 36 (rule -> slice_var .)
    TRUE            reduce using rule 36 (rule -> slice_var .)
    FALSE           reduce using rule 36 (rule -> slice_var .)
    EQUAL           shift and go to state 74
    GREATER         reduce using rule 64 (data_structure -> slice_var .)
    SMALLER         reduce using rule 64 (data_structure -> slice_var .)
    GREATER_OR_EQUAL reduce using rule 64 (data_structure -> slice_var .)
    SMALLER_OR_EQUAL reduce using rule 64 (data_structure -> slice_var .)
    EQUAL_COMPARE   reduce using rule 64 (data_structure -> slice_var .)
    NOT_EQUAL       reduce using rule 64 (data_structure -> slice_var .)
    PLUS            reduce using rule 64 (data_structure -> slice_var .)
    TIMES           reduce using rule 64 (data_structure -> slice_var .)
    DIVIDE          reduce using rule 64 (data_structure -> slice_var .)
    MINUS           reduce using rule 64 (data_structure -> slice_var .)
    MOD             reduce using rule 64 (data_structure -> slice_var .)

  ! COLON           [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! PRINT           [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! SCAN            [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! FOR             [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! CONST           [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! ID              [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! APPEND          [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! LEN             [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! COPY            [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! DELETE          [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! IF              [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! ELSE            [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! TYPE            [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! SWITCH          [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! VAR             [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! FUNC            [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! INTEGER         [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! FLOAT           [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! NOT             [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! $end            [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! RLLAVE          [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! INT32           [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! INT64           [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! FLOAT32         [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! FLOAT64         [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! BYTE            [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! WFLOAT          [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! WSTRING         [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! WINT            [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! BOOL            [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! DEFAULT         [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! CASE            [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! RETURN          [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! STRING          [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! TRUE            [ reduce using rule 64 (data_structure -> slice_var .) ]
  ! FALSE           [ reduce using rule 64 (data_structure -> slice_var .) ]


state 25

    (37) rule -> slice_assignment . COLON
    (38) rule -> slice_assignment .

    COLON           shift and go to state 75
    PRINT           reduce using rule 38 (rule -> slice_assignment .)
    SCAN            reduce using rule 38 (rule -> slice_assignment .)
    FOR             reduce using rule 38 (rule -> slice_assignment .)
    CONST           reduce using rule 38 (rule -> slice_assignment .)
    ID              reduce using rule 38 (rule -> slice_assignment .)
    APPEND          reduce using rule 38 (rule -> slice_assignment .)
    LEN             reduce using rule 38 (rule -> slice_assignment .)
    COPY            reduce using rule 38 (rule -> slice_assignment .)
    DELETE          reduce using rule 38 (rule -> slice_assignment .)
    IF              reduce using rule 38 (rule -> slice_assignment .)
    ELSE            reduce using rule 38 (rule -> slice_assignment .)
    TYPE            reduce using rule 38 (rule -> slice_assignment .)
    SWITCH          reduce using rule 38 (rule -> slice_assignment .)
    VAR             reduce using rule 38 (rule -> slice_assignment .)
    FUNC            reduce using rule 38 (rule -> slice_assignment .)
    INTEGER         reduce using rule 38 (rule -> slice_assignment .)
    FLOAT           reduce using rule 38 (rule -> slice_assignment .)
    NOT             reduce using rule 38 (rule -> slice_assignment .)
    $end            reduce using rule 38 (rule -> slice_assignment .)
    RLLAVE          reduce using rule 38 (rule -> slice_assignment .)
    INT32           reduce using rule 38 (rule -> slice_assignment .)
    INT64           reduce using rule 38 (rule -> slice_assignment .)
    FLOAT32         reduce using rule 38 (rule -> slice_assignment .)
    FLOAT64         reduce using rule 38 (rule -> slice_assignment .)
    BYTE            reduce using rule 38 (rule -> slice_assignment .)
    WFLOAT          reduce using rule 38 (rule -> slice_assignment .)
    WSTRING         reduce using rule 38 (rule -> slice_assignment .)
    WINT            reduce using rule 38 (rule -> slice_assignment .)
    BOOL            reduce using rule 38 (rule -> slice_assignment .)
    DEFAULT         reduce using rule 38 (rule -> slice_assignment .)
    CASE            reduce using rule 38 (rule -> slice_assignment .)
    RETURN          reduce using rule 38 (rule -> slice_assignment .)
    STRING          reduce using rule 38 (rule -> slice_assignment .)
    TRUE            reduce using rule 38 (rule -> slice_assignment .)
    FALSE           reduce using rule 38 (rule -> slice_assignment .)


state 26

    (39) rule -> map_declaration . COLON
    (40) rule -> map_declaration .

    COLON           shift and go to state 76
    PRINT           reduce using rule 40 (rule -> map_declaration .)
    SCAN            reduce using rule 40 (rule -> map_declaration .)
    FOR             reduce using rule 40 (rule -> map_declaration .)
    CONST           reduce using rule 40 (rule -> map_declaration .)
    ID              reduce using rule 40 (rule -> map_declaration .)
    APPEND          reduce using rule 40 (rule -> map_declaration .)
    LEN             reduce using rule 40 (rule -> map_declaration .)
    COPY            reduce using rule 40 (rule -> map_declaration .)
    DELETE          reduce using rule 40 (rule -> map_declaration .)
    IF              reduce using rule 40 (rule -> map_declaration .)
    ELSE            reduce using rule 40 (rule -> map_declaration .)
    TYPE            reduce using rule 40 (rule -> map_declaration .)
    SWITCH          reduce using rule 40 (rule -> map_declaration .)
    VAR             reduce using rule 40 (rule -> map_declaration .)
    FUNC            reduce using rule 40 (rule -> map_declaration .)
    INTEGER         reduce using rule 40 (rule -> map_declaration .)
    FLOAT           reduce using rule 40 (rule -> map_declaration .)
    NOT             reduce using rule 40 (rule -> map_declaration .)
    $end            reduce using rule 40 (rule -> map_declaration .)
    RLLAVE          reduce using rule 40 (rule -> map_declaration .)
    INT32           reduce using rule 40 (rule -> map_declaration .)
    INT64           reduce using rule 40 (rule -> map_declaration .)
    FLOAT32         reduce using rule 40 (rule -> map_declaration .)
    FLOAT64         reduce using rule 40 (rule -> map_declaration .)
    BYTE            reduce using rule 40 (rule -> map_declaration .)
    WFLOAT          reduce using rule 40 (rule -> map_declaration .)
    WSTRING         reduce using rule 40 (rule -> map_declaration .)
    WINT            reduce using rule 40 (rule -> map_declaration .)
    BOOL            reduce using rule 40 (rule -> map_declaration .)
    DEFAULT         reduce using rule 40 (rule -> map_declaration .)
    CASE            reduce using rule 40 (rule -> map_declaration .)
    RETURN          reduce using rule 40 (rule -> map_declaration .)
    STRING          reduce using rule 40 (rule -> map_declaration .)
    TRUE            reduce using rule 40 (rule -> map_declaration .)
    FALSE           reduce using rule 40 (rule -> map_declaration .)


state 27

    (41) rule -> map_assignment . COLON
    (42) rule -> map_assignment .

    COLON           shift and go to state 77
    PRINT           reduce using rule 42 (rule -> map_assignment .)
    SCAN            reduce using rule 42 (rule -> map_assignment .)
    FOR             reduce using rule 42 (rule -> map_assignment .)
    CONST           reduce using rule 42 (rule -> map_assignment .)
    ID              reduce using rule 42 (rule -> map_assignment .)
    APPEND          reduce using rule 42 (rule -> map_assignment .)
    LEN             reduce using rule 42 (rule -> map_assignment .)
    COPY            reduce using rule 42 (rule -> map_assignment .)
    DELETE          reduce using rule 42 (rule -> map_assignment .)
    IF              reduce using rule 42 (rule -> map_assignment .)
    ELSE            reduce using rule 42 (rule -> map_assignment .)
    TYPE            reduce using rule 42 (rule -> map_assignment .)
    SWITCH          reduce using rule 42 (rule -> map_assignment .)
    VAR             reduce using rule 42 (rule -> map_assignment .)
    FUNC            reduce using rule 42 (rule -> map_assignment .)
    INTEGER         reduce using rule 42 (rule -> map_assignment .)
    FLOAT           reduce using rule 42 (rule -> map_assignment .)
    NOT             reduce using rule 42 (rule -> map_assignment .)
    $end            reduce using rule 42 (rule -> map_assignment .)
    RLLAVE          reduce using rule 42 (rule -> map_assignment .)
    INT32           reduce using rule 42 (rule -> map_assignment .)
    INT64           reduce using rule 42 (rule -> map_assignment .)
    FLOAT32         reduce using rule 42 (rule -> map_assignment .)
    FLOAT64         reduce using rule 42 (rule -> map_assignment .)
    BYTE            reduce using rule 42 (rule -> map_assignment .)
    WFLOAT          reduce using rule 42 (rule -> map_assignment .)
    WSTRING         reduce using rule 42 (rule -> map_assignment .)
    WINT            reduce using rule 42 (rule -> map_assignment .)
    BOOL            reduce using rule 42 (rule -> map_assignment .)
    DEFAULT         reduce using rule 42 (rule -> map_assignment .)
    CASE            reduce using rule 42 (rule -> map_assignment .)
    RETURN          reduce using rule 42 (rule -> map_assignment .)
    STRING          reduce using rule 42 (rule -> map_assignment .)
    TRUE            reduce using rule 42 (rule -> map_assignment .)
    FALSE           reduce using rule 42 (rule -> map_assignment .)


state 28

    (43) rule -> func_declaration .

    PRINT           reduce using rule 43 (rule -> func_declaration .)
    SCAN            reduce using rule 43 (rule -> func_declaration .)
    FOR             reduce using rule 43 (rule -> func_declaration .)
    CONST           reduce using rule 43 (rule -> func_declaration .)
    ID              reduce using rule 43 (rule -> func_declaration .)
    APPEND          reduce using rule 43 (rule -> func_declaration .)
    LEN             reduce using rule 43 (rule -> func_declaration .)
    COPY            reduce using rule 43 (rule -> func_declaration .)
    DELETE          reduce using rule 43 (rule -> func_declaration .)
    IF              reduce using rule 43 (rule -> func_declaration .)
    ELSE            reduce using rule 43 (rule -> func_declaration .)
    TYPE            reduce using rule 43 (rule -> func_declaration .)
    SWITCH          reduce using rule 43 (rule -> func_declaration .)
    VAR             reduce using rule 43 (rule -> func_declaration .)
    FUNC            reduce using rule 43 (rule -> func_declaration .)
    INTEGER         reduce using rule 43 (rule -> func_declaration .)
    FLOAT           reduce using rule 43 (rule -> func_declaration .)
    NOT             reduce using rule 43 (rule -> func_declaration .)
    $end            reduce using rule 43 (rule -> func_declaration .)
    RLLAVE          reduce using rule 43 (rule -> func_declaration .)
    INT32           reduce using rule 43 (rule -> func_declaration .)
    INT64           reduce using rule 43 (rule -> func_declaration .)
    FLOAT32         reduce using rule 43 (rule -> func_declaration .)
    FLOAT64         reduce using rule 43 (rule -> func_declaration .)
    BYTE            reduce using rule 43 (rule -> func_declaration .)
    WFLOAT          reduce using rule 43 (rule -> func_declaration .)
    WSTRING         reduce using rule 43 (rule -> func_declaration .)
    WINT            reduce using rule 43 (rule -> func_declaration .)
    BOOL            reduce using rule 43 (rule -> func_declaration .)
    DEFAULT         reduce using rule 43 (rule -> func_declaration .)
    CASE            reduce using rule 43 (rule -> func_declaration .)
    RETURN          reduce using rule 43 (rule -> func_declaration .)
    STRING          reduce using rule 43 (rule -> func_declaration .)
    TRUE            reduce using rule 43 (rule -> func_declaration .)
    FALSE           reduce using rule 43 (rule -> func_declaration .)


state 29

    (44) rule -> main_func .

    PRINT           reduce using rule 44 (rule -> main_func .)
    SCAN            reduce using rule 44 (rule -> main_func .)
    FOR             reduce using rule 44 (rule -> main_func .)
    CONST           reduce using rule 44 (rule -> main_func .)
    ID              reduce using rule 44 (rule -> main_func .)
    APPEND          reduce using rule 44 (rule -> main_func .)
    LEN             reduce using rule 44 (rule -> main_func .)
    COPY            reduce using rule 44 (rule -> main_func .)
    DELETE          reduce using rule 44 (rule -> main_func .)
    IF              reduce using rule 44 (rule -> main_func .)
    ELSE            reduce using rule 44 (rule -> main_func .)
    TYPE            reduce using rule 44 (rule -> main_func .)
    SWITCH          reduce using rule 44 (rule -> main_func .)
    VAR             reduce using rule 44 (rule -> main_func .)
    FUNC            reduce using rule 44 (rule -> main_func .)
    INTEGER         reduce using rule 44 (rule -> main_func .)
    FLOAT           reduce using rule 44 (rule -> main_func .)
    NOT             reduce using rule 44 (rule -> main_func .)
    $end            reduce using rule 44 (rule -> main_func .)
    RLLAVE          reduce using rule 44 (rule -> main_func .)
    INT32           reduce using rule 44 (rule -> main_func .)
    INT64           reduce using rule 44 (rule -> main_func .)
    FLOAT32         reduce using rule 44 (rule -> main_func .)
    FLOAT64         reduce using rule 44 (rule -> main_func .)
    BYTE            reduce using rule 44 (rule -> main_func .)
    WFLOAT          reduce using rule 44 (rule -> main_func .)
    WSTRING         reduce using rule 44 (rule -> main_func .)
    WINT            reduce using rule 44 (rule -> main_func .)
    BOOL            reduce using rule 44 (rule -> main_func .)
    DEFAULT         reduce using rule 44 (rule -> main_func .)
    CASE            reduce using rule 44 (rule -> main_func .)
    RETURN          reduce using rule 44 (rule -> main_func .)
    STRING          reduce using rule 44 (rule -> main_func .)
    TRUE            reduce using rule 44 (rule -> main_func .)
    FALSE           reduce using rule 44 (rule -> main_func .)


state 30

    (232) impresion -> PRINT . LPAREN content RPAREN

    LPAREN          shift and go to state 78


state 31

    (83) scan_func -> SCAN . LPAREN POINTER RPAREN

    LPAREN          shift and go to state 79


state 32

    (238) expression -> something_ex .
    (239) expression -> something_ex . adicionaEx
    (240) adicionaEx -> . op something_ex
    (241) adicionaEx -> . op something_ex adicionaEx
    (181) op -> . GREATER
    (182) op -> . SMALLER
    (183) op -> . GREATER_OR_EQUAL
    (184) op -> . SMALLER_OR_EQUAL
    (185) op -> . EQUAL_COMPARE
    (186) op -> . NOT_EQUAL
    (247) op -> . PLUS
    (248) op -> . TIMES
    (249) op -> . DIVIDE
    (250) op -> . MINUS
    (251) op -> . MOD

  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL_COMPARE resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
    COLON           reduce using rule 238 (expression -> something_ex .)
    PRINT           reduce using rule 238 (expression -> something_ex .)
    SCAN            reduce using rule 238 (expression -> something_ex .)
    FOR             reduce using rule 238 (expression -> something_ex .)
    CONST           reduce using rule 238 (expression -> something_ex .)
    ID              reduce using rule 238 (expression -> something_ex .)
    APPEND          reduce using rule 238 (expression -> something_ex .)
    LEN             reduce using rule 238 (expression -> something_ex .)
    COPY            reduce using rule 238 (expression -> something_ex .)
    DELETE          reduce using rule 238 (expression -> something_ex .)
    IF              reduce using rule 238 (expression -> something_ex .)
    ELSE            reduce using rule 238 (expression -> something_ex .)
    TYPE            reduce using rule 238 (expression -> something_ex .)
    SWITCH          reduce using rule 238 (expression -> something_ex .)
    VAR             reduce using rule 238 (expression -> something_ex .)
    FUNC            reduce using rule 238 (expression -> something_ex .)
    INTEGER         reduce using rule 238 (expression -> something_ex .)
    FLOAT           reduce using rule 238 (expression -> something_ex .)
    NOT             reduce using rule 238 (expression -> something_ex .)
    $end            reduce using rule 238 (expression -> something_ex .)
    RLLAVE          reduce using rule 238 (expression -> something_ex .)
    INT32           reduce using rule 238 (expression -> something_ex .)
    INT64           reduce using rule 238 (expression -> something_ex .)
    FLOAT32         reduce using rule 238 (expression -> something_ex .)
    FLOAT64         reduce using rule 238 (expression -> something_ex .)
    BYTE            reduce using rule 238 (expression -> something_ex .)
    WFLOAT          reduce using rule 238 (expression -> something_ex .)
    WSTRING         reduce using rule 238 (expression -> something_ex .)
    WINT            reduce using rule 238 (expression -> something_ex .)
    BOOL            reduce using rule 238 (expression -> something_ex .)
    DEFAULT         reduce using rule 238 (expression -> something_ex .)
    CASE            reduce using rule 238 (expression -> something_ex .)
    RETURN          reduce using rule 238 (expression -> something_ex .)
    STRING          reduce using rule 238 (expression -> something_ex .)
    TRUE            reduce using rule 238 (expression -> something_ex .)
    FALSE           reduce using rule 238 (expression -> something_ex .)
    RPAREN          reduce using rule 238 (expression -> something_ex .)
    AND             reduce using rule 238 (expression -> something_ex .)
    OR              reduce using rule 238 (expression -> something_ex .)
    LLLAVE          reduce using rule 238 (expression -> something_ex .)
    RCORCHE         reduce using rule 238 (expression -> something_ex .)
    COMA            reduce using rule 238 (expression -> something_ex .)
    GREATER         shift and go to state 82
    SMALLER         shift and go to state 83
    GREATER_OR_EQUAL shift and go to state 84
    SMALLER_OR_EQUAL shift and go to state 85
    EQUAL_COMPARE   shift and go to state 86
    NOT_EQUAL       shift and go to state 87
    PLUS            shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MINUS           shift and go to state 91
    MOD             shift and go to state 92

  ! GREATER         [ reduce using rule 238 (expression -> something_ex .) ]
  ! SMALLER         [ reduce using rule 238 (expression -> something_ex .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 238 (expression -> something_ex .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 238 (expression -> something_ex .) ]
  ! EQUAL_COMPARE   [ reduce using rule 238 (expression -> something_ex .) ]
  ! NOT_EQUAL       [ reduce using rule 238 (expression -> something_ex .) ]
  ! PLUS            [ reduce using rule 238 (expression -> something_ex .) ]
  ! TIMES           [ reduce using rule 238 (expression -> something_ex .) ]
  ! DIVIDE          [ reduce using rule 238 (expression -> something_ex .) ]
  ! MINUS           [ reduce using rule 238 (expression -> something_ex .) ]
  ! MOD             [ reduce using rule 238 (expression -> something_ex .) ]

    adicionaEx                     shift and go to state 80
    op                             shift and go to state 81

state 33

    (89) cicloFor -> FOR . LLLAVE codigo RLLAVE
    (90) cicloFor -> FOR . comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> FOR . logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> FOR . decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (158) decVarOne -> . ID DEQUAL ID
    (159) decVarOne -> . ID DEQUAL INTEGER
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    LLLAVE          shift and go to state 93
    ID              shift and go to state 97
    NOT             shift and go to state 56
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    comparison                     shift and go to state 94
    logic_operation                shift and go to state 95
    decVarOne                      shift and go to state 96
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    expression                     shift and go to state 98
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 34

    (178) comparison -> value . op value
    (181) op -> . GREATER
    (182) op -> . SMALLER
    (183) op -> . GREATER_OR_EQUAL
    (184) op -> . SMALLER_OR_EQUAL
    (185) op -> . EQUAL_COMPARE
    (186) op -> . NOT_EQUAL
    (247) op -> . PLUS
    (248) op -> . TIMES
    (249) op -> . DIVIDE
    (250) op -> . MINUS
    (251) op -> . MOD

    GREATER         shift and go to state 82
    SMALLER         shift and go to state 83
    GREATER_OR_EQUAL shift and go to state 84
    SMALLER_OR_EQUAL shift and go to state 85
    EQUAL_COMPARE   shift and go to state 86
    NOT_EQUAL       shift and go to state 87
    PLUS            shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MINUS           shift and go to state 91
    MOD             shift and go to state 92

    op                             shift and go to state 103

state 35

    (187) logic_operation -> logic_value . logic_recu
    (189) logic_recu -> . logic_op logic_value
    (190) logic_recu -> . logic_op logic_value logic_recu
    (196) logic_op -> . AND
    (197) logic_op -> . OR

    AND             shift and go to state 106
    OR              shift and go to state 107

    logic_recu                     shift and go to state 104
    logic_op                       shift and go to state 105

state 36

    (188) logic_operation -> negation .
    (191) logic_value -> negation .

    PRINT           reduce using rule 188 (logic_operation -> negation .)
    SCAN            reduce using rule 188 (logic_operation -> negation .)
    FOR             reduce using rule 188 (logic_operation -> negation .)
    CONST           reduce using rule 188 (logic_operation -> negation .)
    ID              reduce using rule 188 (logic_operation -> negation .)
    APPEND          reduce using rule 188 (logic_operation -> negation .)
    LEN             reduce using rule 188 (logic_operation -> negation .)
    COPY            reduce using rule 188 (logic_operation -> negation .)
    DELETE          reduce using rule 188 (logic_operation -> negation .)
    IF              reduce using rule 188 (logic_operation -> negation .)
    ELSE            reduce using rule 188 (logic_operation -> negation .)
    TYPE            reduce using rule 188 (logic_operation -> negation .)
    SWITCH          reduce using rule 188 (logic_operation -> negation .)
    VAR             reduce using rule 188 (logic_operation -> negation .)
    FUNC            reduce using rule 188 (logic_operation -> negation .)
    INTEGER         reduce using rule 188 (logic_operation -> negation .)
    FLOAT           reduce using rule 188 (logic_operation -> negation .)
    NOT             reduce using rule 188 (logic_operation -> negation .)
    $end            reduce using rule 188 (logic_operation -> negation .)
    RLLAVE          reduce using rule 188 (logic_operation -> negation .)
    INT32           reduce using rule 188 (logic_operation -> negation .)
    INT64           reduce using rule 188 (logic_operation -> negation .)
    FLOAT32         reduce using rule 188 (logic_operation -> negation .)
    FLOAT64         reduce using rule 188 (logic_operation -> negation .)
    BYTE            reduce using rule 188 (logic_operation -> negation .)
    WFLOAT          reduce using rule 188 (logic_operation -> negation .)
    WSTRING         reduce using rule 188 (logic_operation -> negation .)
    WINT            reduce using rule 188 (logic_operation -> negation .)
    BOOL            reduce using rule 188 (logic_operation -> negation .)
    DEFAULT         reduce using rule 188 (logic_operation -> negation .)
    CASE            reduce using rule 188 (logic_operation -> negation .)
    RETURN          reduce using rule 188 (logic_operation -> negation .)
    STRING          reduce using rule 188 (logic_operation -> negation .)
    TRUE            reduce using rule 188 (logic_operation -> negation .)
    FALSE           reduce using rule 188 (logic_operation -> negation .)
    LLLAVE          reduce using rule 188 (logic_operation -> negation .)
    COLON           reduce using rule 188 (logic_operation -> negation .)
    RPAREN          reduce using rule 188 (logic_operation -> negation .)
    RCORCHE         reduce using rule 188 (logic_operation -> negation .)
    COMA            reduce using rule 188 (logic_operation -> negation .)
    AND             reduce using rule 191 (logic_value -> negation .)
    OR              reduce using rule 191 (logic_value -> negation .)


state 37

    (114) decVar -> static .

    COLON           reduce using rule 114 (decVar -> static .)
    PRINT           reduce using rule 114 (decVar -> static .)
    SCAN            reduce using rule 114 (decVar -> static .)
    FOR             reduce using rule 114 (decVar -> static .)
    CONST           reduce using rule 114 (decVar -> static .)
    ID              reduce using rule 114 (decVar -> static .)
    APPEND          reduce using rule 114 (decVar -> static .)
    LEN             reduce using rule 114 (decVar -> static .)
    COPY            reduce using rule 114 (decVar -> static .)
    DELETE          reduce using rule 114 (decVar -> static .)
    IF              reduce using rule 114 (decVar -> static .)
    ELSE            reduce using rule 114 (decVar -> static .)
    TYPE            reduce using rule 114 (decVar -> static .)
    SWITCH          reduce using rule 114 (decVar -> static .)
    VAR             reduce using rule 114 (decVar -> static .)
    FUNC            reduce using rule 114 (decVar -> static .)
    INTEGER         reduce using rule 114 (decVar -> static .)
    FLOAT           reduce using rule 114 (decVar -> static .)
    NOT             reduce using rule 114 (decVar -> static .)
    $end            reduce using rule 114 (decVar -> static .)
    RLLAVE          reduce using rule 114 (decVar -> static .)
    INT32           reduce using rule 114 (decVar -> static .)
    INT64           reduce using rule 114 (decVar -> static .)
    FLOAT32         reduce using rule 114 (decVar -> static .)
    FLOAT64         reduce using rule 114 (decVar -> static .)
    BYTE            reduce using rule 114 (decVar -> static .)
    WFLOAT          reduce using rule 114 (decVar -> static .)
    WSTRING         reduce using rule 114 (decVar -> static .)
    WINT            reduce using rule 114 (decVar -> static .)
    BOOL            reduce using rule 114 (decVar -> static .)
    DEFAULT         reduce using rule 114 (decVar -> static .)
    CASE            reduce using rule 114 (decVar -> static .)
    RETURN          reduce using rule 114 (decVar -> static .)
    STRING          reduce using rule 114 (decVar -> static .)
    TRUE            reduce using rule 114 (decVar -> static .)
    FALSE           reduce using rule 114 (decVar -> static .)


state 38

    (115) decVar -> dynamic .

    COLON           reduce using rule 115 (decVar -> dynamic .)
    PRINT           reduce using rule 115 (decVar -> dynamic .)
    SCAN            reduce using rule 115 (decVar -> dynamic .)
    FOR             reduce using rule 115 (decVar -> dynamic .)
    CONST           reduce using rule 115 (decVar -> dynamic .)
    ID              reduce using rule 115 (decVar -> dynamic .)
    APPEND          reduce using rule 115 (decVar -> dynamic .)
    LEN             reduce using rule 115 (decVar -> dynamic .)
    COPY            reduce using rule 115 (decVar -> dynamic .)
    DELETE          reduce using rule 115 (decVar -> dynamic .)
    IF              reduce using rule 115 (decVar -> dynamic .)
    ELSE            reduce using rule 115 (decVar -> dynamic .)
    TYPE            reduce using rule 115 (decVar -> dynamic .)
    SWITCH          reduce using rule 115 (decVar -> dynamic .)
    VAR             reduce using rule 115 (decVar -> dynamic .)
    FUNC            reduce using rule 115 (decVar -> dynamic .)
    INTEGER         reduce using rule 115 (decVar -> dynamic .)
    FLOAT           reduce using rule 115 (decVar -> dynamic .)
    NOT             reduce using rule 115 (decVar -> dynamic .)
    $end            reduce using rule 115 (decVar -> dynamic .)
    RLLAVE          reduce using rule 115 (decVar -> dynamic .)
    INT32           reduce using rule 115 (decVar -> dynamic .)
    INT64           reduce using rule 115 (decVar -> dynamic .)
    FLOAT32         reduce using rule 115 (decVar -> dynamic .)
    FLOAT64         reduce using rule 115 (decVar -> dynamic .)
    BYTE            reduce using rule 115 (decVar -> dynamic .)
    WFLOAT          reduce using rule 115 (decVar -> dynamic .)
    WSTRING         reduce using rule 115 (decVar -> dynamic .)
    WINT            reduce using rule 115 (decVar -> dynamic .)
    BOOL            reduce using rule 115 (decVar -> dynamic .)
    DEFAULT         reduce using rule 115 (decVar -> dynamic .)
    CASE            reduce using rule 115 (decVar -> dynamic .)
    RETURN          reduce using rule 115 (decVar -> dynamic .)
    STRING          reduce using rule 115 (decVar -> dynamic .)
    TRUE            reduce using rule 115 (decVar -> dynamic .)
    FALSE           reduce using rule 115 (decVar -> dynamic .)


state 39

    (111) decConst -> CONST . ID data_type_and_value
    (112) decConst -> CONST . ID EQUAL ID
    (113) decConst -> CONST . ID EQUAL data_structure

    ID              shift and go to state 108


state 40

    (65) var_asignation -> ID . EQUAL any
    (171) cStruct -> ID . DEQUAL ID LLLAVE asignaciones RLLAVE
    (208) array_var -> ID . LCORCHE index RCORCHE
    (136) slice_declaration -> ID . DEQUAL funM
    (137) slice_declaration -> ID . DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (242) something_ex -> ID .
    (179) value -> ID .
    (193) logic_value -> ID .
    (127) dynamic -> ID . DEQUAL algo
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN
    (214) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 179 (value -> ID .)
    EQUAL           shift and go to state 109
    DEQUAL          shift and go to state 110
    LCORCHE         shift and go to state 111
    COLON           reduce using rule 242 (something_ex -> ID .)
    PRINT           reduce using rule 242 (something_ex -> ID .)
    SCAN            reduce using rule 242 (something_ex -> ID .)
    FOR             reduce using rule 242 (something_ex -> ID .)
    CONST           reduce using rule 242 (something_ex -> ID .)
    ID              reduce using rule 242 (something_ex -> ID .)
    APPEND          reduce using rule 242 (something_ex -> ID .)
    LEN             reduce using rule 242 (something_ex -> ID .)
    COPY            reduce using rule 242 (something_ex -> ID .)
    DELETE          reduce using rule 242 (something_ex -> ID .)
    IF              reduce using rule 242 (something_ex -> ID .)
    ELSE            reduce using rule 242 (something_ex -> ID .)
    TYPE            reduce using rule 242 (something_ex -> ID .)
    SWITCH          reduce using rule 242 (something_ex -> ID .)
    VAR             reduce using rule 242 (something_ex -> ID .)
    FUNC            reduce using rule 242 (something_ex -> ID .)
    INTEGER         reduce using rule 242 (something_ex -> ID .)
    FLOAT           reduce using rule 242 (something_ex -> ID .)
    NOT             reduce using rule 242 (something_ex -> ID .)
    $end            reduce using rule 242 (something_ex -> ID .)
    RLLAVE          reduce using rule 242 (something_ex -> ID .)
    INT32           reduce using rule 242 (something_ex -> ID .)
    INT64           reduce using rule 242 (something_ex -> ID .)
    FLOAT32         reduce using rule 242 (something_ex -> ID .)
    FLOAT64         reduce using rule 242 (something_ex -> ID .)
    BYTE            reduce using rule 242 (something_ex -> ID .)
    WFLOAT          reduce using rule 242 (something_ex -> ID .)
    WSTRING         reduce using rule 242 (something_ex -> ID .)
    WINT            reduce using rule 242 (something_ex -> ID .)
    BOOL            reduce using rule 242 (something_ex -> ID .)
    DEFAULT         reduce using rule 242 (something_ex -> ID .)
    CASE            reduce using rule 242 (something_ex -> ID .)
    RETURN          reduce using rule 242 (something_ex -> ID .)
    STRING          reduce using rule 242 (something_ex -> ID .)
    TRUE            reduce using rule 242 (something_ex -> ID .)
    FALSE           reduce using rule 242 (something_ex -> ID .)
    GREATER         reduce using rule 179 (value -> ID .)
    SMALLER         reduce using rule 179 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 179 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 179 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 179 (value -> ID .)
    NOT_EQUAL       reduce using rule 179 (value -> ID .)
    PLUS            reduce using rule 179 (value -> ID .)
    TIMES           reduce using rule 179 (value -> ID .)
    DIVIDE          reduce using rule 179 (value -> ID .)
    MINUS           reduce using rule 179 (value -> ID .)
    MOD             reduce using rule 179 (value -> ID .)
    AND             reduce using rule 193 (logic_value -> ID .)
    OR              reduce using rule 193 (logic_value -> ID .)
    LPAREN          shift and go to state 112

  ! GREATER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 242 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 242 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 242 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 242 (something_ex -> ID .) ]


state 41

    (245) something_ex -> data_structure .

    GREATER         reduce using rule 245 (something_ex -> data_structure .)
    SMALLER         reduce using rule 245 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 245 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 245 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 245 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 245 (something_ex -> data_structure .)
    PLUS            reduce using rule 245 (something_ex -> data_structure .)
    TIMES           reduce using rule 245 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 245 (something_ex -> data_structure .)
    MINUS           reduce using rule 245 (something_ex -> data_structure .)
    MOD             reduce using rule 245 (something_ex -> data_structure .)
    COLON           reduce using rule 245 (something_ex -> data_structure .)
    PRINT           reduce using rule 245 (something_ex -> data_structure .)
    SCAN            reduce using rule 245 (something_ex -> data_structure .)
    FOR             reduce using rule 245 (something_ex -> data_structure .)
    CONST           reduce using rule 245 (something_ex -> data_structure .)
    ID              reduce using rule 245 (something_ex -> data_structure .)
    APPEND          reduce using rule 245 (something_ex -> data_structure .)
    LEN             reduce using rule 245 (something_ex -> data_structure .)
    COPY            reduce using rule 245 (something_ex -> data_structure .)
    DELETE          reduce using rule 245 (something_ex -> data_structure .)
    IF              reduce using rule 245 (something_ex -> data_structure .)
    ELSE            reduce using rule 245 (something_ex -> data_structure .)
    TYPE            reduce using rule 245 (something_ex -> data_structure .)
    SWITCH          reduce using rule 245 (something_ex -> data_structure .)
    VAR             reduce using rule 245 (something_ex -> data_structure .)
    FUNC            reduce using rule 245 (something_ex -> data_structure .)
    INTEGER         reduce using rule 245 (something_ex -> data_structure .)
    FLOAT           reduce using rule 245 (something_ex -> data_structure .)
    NOT             reduce using rule 245 (something_ex -> data_structure .)
    $end            reduce using rule 245 (something_ex -> data_structure .)
    RLLAVE          reduce using rule 245 (something_ex -> data_structure .)
    INT32           reduce using rule 245 (something_ex -> data_structure .)
    INT64           reduce using rule 245 (something_ex -> data_structure .)
    FLOAT32         reduce using rule 245 (something_ex -> data_structure .)
    FLOAT64         reduce using rule 245 (something_ex -> data_structure .)
    BYTE            reduce using rule 245 (something_ex -> data_structure .)
    WFLOAT          reduce using rule 245 (something_ex -> data_structure .)
    WSTRING         reduce using rule 245 (something_ex -> data_structure .)
    WINT            reduce using rule 245 (something_ex -> data_structure .)
    BOOL            reduce using rule 245 (something_ex -> data_structure .)
    DEFAULT         reduce using rule 245 (something_ex -> data_structure .)
    CASE            reduce using rule 245 (something_ex -> data_structure .)
    RETURN          reduce using rule 245 (something_ex -> data_structure .)
    STRING          reduce using rule 245 (something_ex -> data_structure .)
    TRUE            reduce using rule 245 (something_ex -> data_structure .)
    FALSE           reduce using rule 245 (something_ex -> data_structure .)
    RPAREN          reduce using rule 245 (something_ex -> data_structure .)
    AND             reduce using rule 245 (something_ex -> data_structure .)
    OR              reduce using rule 245 (something_ex -> data_structure .)
    LLLAVE          reduce using rule 245 (something_ex -> data_structure .)
    RCORCHE         reduce using rule 245 (something_ex -> data_structure .)
    COMA            reduce using rule 245 (something_ex -> data_structure .)


state 42

    (152) funciones -> APPEND . LPAREN ID COMA values RPAREN
    (153) funciones -> APPEND . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 113


state 43

    (154) funciones -> LEN . LPAREN ID RPAREN

    LPAREN          shift and go to state 114


state 44

    (155) funciones -> COPY . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 115


state 45

    (156) funciones -> DELETE . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 116


state 46

    (157) funciones -> call_func .

    COLON           reduce using rule 157 (funciones -> call_func .)
    PRINT           reduce using rule 157 (funciones -> call_func .)
    SCAN            reduce using rule 157 (funciones -> call_func .)
    FOR             reduce using rule 157 (funciones -> call_func .)
    CONST           reduce using rule 157 (funciones -> call_func .)
    ID              reduce using rule 157 (funciones -> call_func .)
    APPEND          reduce using rule 157 (funciones -> call_func .)
    LEN             reduce using rule 157 (funciones -> call_func .)
    COPY            reduce using rule 157 (funciones -> call_func .)
    DELETE          reduce using rule 157 (funciones -> call_func .)
    IF              reduce using rule 157 (funciones -> call_func .)
    ELSE            reduce using rule 157 (funciones -> call_func .)
    TYPE            reduce using rule 157 (funciones -> call_func .)
    SWITCH          reduce using rule 157 (funciones -> call_func .)
    VAR             reduce using rule 157 (funciones -> call_func .)
    FUNC            reduce using rule 157 (funciones -> call_func .)
    INTEGER         reduce using rule 157 (funciones -> call_func .)
    FLOAT           reduce using rule 157 (funciones -> call_func .)
    NOT             reduce using rule 157 (funciones -> call_func .)
    $end            reduce using rule 157 (funciones -> call_func .)
    GREATER         reduce using rule 157 (funciones -> call_func .)
    SMALLER         reduce using rule 157 (funciones -> call_func .)
    GREATER_OR_EQUAL reduce using rule 157 (funciones -> call_func .)
    SMALLER_OR_EQUAL reduce using rule 157 (funciones -> call_func .)
    EQUAL_COMPARE   reduce using rule 157 (funciones -> call_func .)
    NOT_EQUAL       reduce using rule 157 (funciones -> call_func .)
    PLUS            reduce using rule 157 (funciones -> call_func .)
    TIMES           reduce using rule 157 (funciones -> call_func .)
    DIVIDE          reduce using rule 157 (funciones -> call_func .)
    MINUS           reduce using rule 157 (funciones -> call_func .)
    MOD             reduce using rule 157 (funciones -> call_func .)
    RLLAVE          reduce using rule 157 (funciones -> call_func .)
    INT32           reduce using rule 157 (funciones -> call_func .)
    INT64           reduce using rule 157 (funciones -> call_func .)
    FLOAT32         reduce using rule 157 (funciones -> call_func .)
    FLOAT64         reduce using rule 157 (funciones -> call_func .)
    BYTE            reduce using rule 157 (funciones -> call_func .)
    WFLOAT          reduce using rule 157 (funciones -> call_func .)
    WSTRING         reduce using rule 157 (funciones -> call_func .)
    WINT            reduce using rule 157 (funciones -> call_func .)
    BOOL            reduce using rule 157 (funciones -> call_func .)
    DEFAULT         reduce using rule 157 (funciones -> call_func .)
    CASE            reduce using rule 157 (funciones -> call_func .)
    RETURN          reduce using rule 157 (funciones -> call_func .)
    STRING          reduce using rule 157 (funciones -> call_func .)
    TRUE            reduce using rule 157 (funciones -> call_func .)
    FALSE           reduce using rule 157 (funciones -> call_func .)
    RPAREN          reduce using rule 157 (funciones -> call_func .)
    AND             reduce using rule 157 (funciones -> call_func .)
    OR              reduce using rule 157 (funciones -> call_func .)
    LLLAVE          reduce using rule 157 (funciones -> call_func .)
    RCORCHE         reduce using rule 157 (funciones -> call_func .)
    COMA            reduce using rule 157 (funciones -> call_func .)


state 47

    (160) SenIF -> IF . comparison LLLAVE codigo RLLAVE
    (161) SenIF -> IF . TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> IF . FALSE LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (179) value -> . ID
    (180) value -> . expression
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    TRUE            shift and go to state 118
    FALSE           shift and go to state 119
    ID              shift and go to state 120
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    comparison                     shift and go to state 117
    value                          shift and go to state 34
    expression                     shift and go to state 98
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 48

    (163) SenElseIF -> ELSE . IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> ELSE . IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> ELSE . IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> ELSE . LLLAVE codigo RLLAVE

    IF              shift and go to state 121
    LLLAVE          shift and go to state 122


state 49

    (167) SenStruct -> TYPE . ID STRUCT LLLAVE declaration RLLAVE

    ID              shift and go to state 123


state 50

    (198) switch_statement -> SWITCH . ID LLLAVE cases RLLAVE

    ID              shift and go to state 124


state 51

    (203) array_declaration -> VAR . ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> VAR . ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (133) slice_declaration -> VAR . ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> VAR . ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> VAR . ID EQUAL funM
    (213) map_declaration -> VAR . ID LCORCHE data_types RCORCHE data_types
    (122) single -> VAR . ID data_types
    (123) single -> VAR . ID data_types EQUAL funciones
    (124) single -> VAR . ID data_types EQUAL ID
    (125) single -> VAR . ID data_types EQUAL data_structure
    (126) single -> VAR . ID data_type_and_value
    (119) list_var -> VAR . ID COMA more

    ID              shift and go to state 125


state 52

    (218) map_assignment -> map_var . EQUAL something
    (63) data_structure -> map_var .

    EQUAL           shift and go to state 126
    GREATER         reduce using rule 63 (data_structure -> map_var .)
    SMALLER         reduce using rule 63 (data_structure -> map_var .)
    GREATER_OR_EQUAL reduce using rule 63 (data_structure -> map_var .)
    SMALLER_OR_EQUAL reduce using rule 63 (data_structure -> map_var .)
    EQUAL_COMPARE   reduce using rule 63 (data_structure -> map_var .)
    NOT_EQUAL       reduce using rule 63 (data_structure -> map_var .)
    PLUS            reduce using rule 63 (data_structure -> map_var .)
    TIMES           reduce using rule 63 (data_structure -> map_var .)
    DIVIDE          reduce using rule 63 (data_structure -> map_var .)
    MINUS           reduce using rule 63 (data_structure -> map_var .)
    MOD             reduce using rule 63 (data_structure -> map_var .)
    COLON           reduce using rule 63 (data_structure -> map_var .)
    PRINT           reduce using rule 63 (data_structure -> map_var .)
    SCAN            reduce using rule 63 (data_structure -> map_var .)
    FOR             reduce using rule 63 (data_structure -> map_var .)
    CONST           reduce using rule 63 (data_structure -> map_var .)
    ID              reduce using rule 63 (data_structure -> map_var .)
    APPEND          reduce using rule 63 (data_structure -> map_var .)
    LEN             reduce using rule 63 (data_structure -> map_var .)
    COPY            reduce using rule 63 (data_structure -> map_var .)
    DELETE          reduce using rule 63 (data_structure -> map_var .)
    IF              reduce using rule 63 (data_structure -> map_var .)
    ELSE            reduce using rule 63 (data_structure -> map_var .)
    TYPE            reduce using rule 63 (data_structure -> map_var .)
    SWITCH          reduce using rule 63 (data_structure -> map_var .)
    VAR             reduce using rule 63 (data_structure -> map_var .)
    FUNC            reduce using rule 63 (data_structure -> map_var .)
    INTEGER         reduce using rule 63 (data_structure -> map_var .)
    FLOAT           reduce using rule 63 (data_structure -> map_var .)
    NOT             reduce using rule 63 (data_structure -> map_var .)
    $end            reduce using rule 63 (data_structure -> map_var .)
    RLLAVE          reduce using rule 63 (data_structure -> map_var .)
    INT32           reduce using rule 63 (data_structure -> map_var .)
    INT64           reduce using rule 63 (data_structure -> map_var .)
    FLOAT32         reduce using rule 63 (data_structure -> map_var .)
    FLOAT64         reduce using rule 63 (data_structure -> map_var .)
    BYTE            reduce using rule 63 (data_structure -> map_var .)
    WFLOAT          reduce using rule 63 (data_structure -> map_var .)
    WSTRING         reduce using rule 63 (data_structure -> map_var .)
    WINT            reduce using rule 63 (data_structure -> map_var .)
    BOOL            reduce using rule 63 (data_structure -> map_var .)
    DEFAULT         reduce using rule 63 (data_structure -> map_var .)
    CASE            reduce using rule 63 (data_structure -> map_var .)
    RETURN          reduce using rule 63 (data_structure -> map_var .)
    STRING          reduce using rule 63 (data_structure -> map_var .)
    TRUE            reduce using rule 63 (data_structure -> map_var .)
    FALSE           reduce using rule 63 (data_structure -> map_var .)


state 53

    (219) func_declaration -> FUNC . ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> FUNC . ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> FUNC . MAIN LPAREN RPAREN LLLAVE codigo RLLAVE

    ID              shift and go to state 127
    MAIN            shift and go to state 128


state 54

    (243) something_ex -> INTEGER .

    GREATER         reduce using rule 243 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 243 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 243 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 243 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 243 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 243 (something_ex -> INTEGER .)
    PLUS            reduce using rule 243 (something_ex -> INTEGER .)
    TIMES           reduce using rule 243 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 243 (something_ex -> INTEGER .)
    MINUS           reduce using rule 243 (something_ex -> INTEGER .)
    MOD             reduce using rule 243 (something_ex -> INTEGER .)
    COLON           reduce using rule 243 (something_ex -> INTEGER .)
    PRINT           reduce using rule 243 (something_ex -> INTEGER .)
    SCAN            reduce using rule 243 (something_ex -> INTEGER .)
    FOR             reduce using rule 243 (something_ex -> INTEGER .)
    CONST           reduce using rule 243 (something_ex -> INTEGER .)
    ID              reduce using rule 243 (something_ex -> INTEGER .)
    APPEND          reduce using rule 243 (something_ex -> INTEGER .)
    LEN             reduce using rule 243 (something_ex -> INTEGER .)
    COPY            reduce using rule 243 (something_ex -> INTEGER .)
    DELETE          reduce using rule 243 (something_ex -> INTEGER .)
    IF              reduce using rule 243 (something_ex -> INTEGER .)
    ELSE            reduce using rule 243 (something_ex -> INTEGER .)
    TYPE            reduce using rule 243 (something_ex -> INTEGER .)
    SWITCH          reduce using rule 243 (something_ex -> INTEGER .)
    VAR             reduce using rule 243 (something_ex -> INTEGER .)
    FUNC            reduce using rule 243 (something_ex -> INTEGER .)
    INTEGER         reduce using rule 243 (something_ex -> INTEGER .)
    FLOAT           reduce using rule 243 (something_ex -> INTEGER .)
    NOT             reduce using rule 243 (something_ex -> INTEGER .)
    $end            reduce using rule 243 (something_ex -> INTEGER .)
    RLLAVE          reduce using rule 243 (something_ex -> INTEGER .)
    INT32           reduce using rule 243 (something_ex -> INTEGER .)
    INT64           reduce using rule 243 (something_ex -> INTEGER .)
    FLOAT32         reduce using rule 243 (something_ex -> INTEGER .)
    FLOAT64         reduce using rule 243 (something_ex -> INTEGER .)
    BYTE            reduce using rule 243 (something_ex -> INTEGER .)
    WFLOAT          reduce using rule 243 (something_ex -> INTEGER .)
    WSTRING         reduce using rule 243 (something_ex -> INTEGER .)
    WINT            reduce using rule 243 (something_ex -> INTEGER .)
    BOOL            reduce using rule 243 (something_ex -> INTEGER .)
    DEFAULT         reduce using rule 243 (something_ex -> INTEGER .)
    CASE            reduce using rule 243 (something_ex -> INTEGER .)
    RETURN          reduce using rule 243 (something_ex -> INTEGER .)
    STRING          reduce using rule 243 (something_ex -> INTEGER .)
    TRUE            reduce using rule 243 (something_ex -> INTEGER .)
    FALSE           reduce using rule 243 (something_ex -> INTEGER .)
    RPAREN          reduce using rule 243 (something_ex -> INTEGER .)
    AND             reduce using rule 243 (something_ex -> INTEGER .)
    OR              reduce using rule 243 (something_ex -> INTEGER .)
    LLLAVE          reduce using rule 243 (something_ex -> INTEGER .)
    RCORCHE         reduce using rule 243 (something_ex -> INTEGER .)
    COMA            reduce using rule 243 (something_ex -> INTEGER .)


state 55

    (244) something_ex -> FLOAT .

    GREATER         reduce using rule 244 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 244 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 244 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 244 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 244 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 244 (something_ex -> FLOAT .)
    PLUS            reduce using rule 244 (something_ex -> FLOAT .)
    TIMES           reduce using rule 244 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 244 (something_ex -> FLOAT .)
    MINUS           reduce using rule 244 (something_ex -> FLOAT .)
    MOD             reduce using rule 244 (something_ex -> FLOAT .)
    COLON           reduce using rule 244 (something_ex -> FLOAT .)
    PRINT           reduce using rule 244 (something_ex -> FLOAT .)
    SCAN            reduce using rule 244 (something_ex -> FLOAT .)
    FOR             reduce using rule 244 (something_ex -> FLOAT .)
    CONST           reduce using rule 244 (something_ex -> FLOAT .)
    ID              reduce using rule 244 (something_ex -> FLOAT .)
    APPEND          reduce using rule 244 (something_ex -> FLOAT .)
    LEN             reduce using rule 244 (something_ex -> FLOAT .)
    COPY            reduce using rule 244 (something_ex -> FLOAT .)
    DELETE          reduce using rule 244 (something_ex -> FLOAT .)
    IF              reduce using rule 244 (something_ex -> FLOAT .)
    ELSE            reduce using rule 244 (something_ex -> FLOAT .)
    TYPE            reduce using rule 244 (something_ex -> FLOAT .)
    SWITCH          reduce using rule 244 (something_ex -> FLOAT .)
    VAR             reduce using rule 244 (something_ex -> FLOAT .)
    FUNC            reduce using rule 244 (something_ex -> FLOAT .)
    INTEGER         reduce using rule 244 (something_ex -> FLOAT .)
    FLOAT           reduce using rule 244 (something_ex -> FLOAT .)
    NOT             reduce using rule 244 (something_ex -> FLOAT .)
    $end            reduce using rule 244 (something_ex -> FLOAT .)
    RLLAVE          reduce using rule 244 (something_ex -> FLOAT .)
    INT32           reduce using rule 244 (something_ex -> FLOAT .)
    INT64           reduce using rule 244 (something_ex -> FLOAT .)
    FLOAT32         reduce using rule 244 (something_ex -> FLOAT .)
    FLOAT64         reduce using rule 244 (something_ex -> FLOAT .)
    BYTE            reduce using rule 244 (something_ex -> FLOAT .)
    WFLOAT          reduce using rule 244 (something_ex -> FLOAT .)
    WSTRING         reduce using rule 244 (something_ex -> FLOAT .)
    WINT            reduce using rule 244 (something_ex -> FLOAT .)
    BOOL            reduce using rule 244 (something_ex -> FLOAT .)
    DEFAULT         reduce using rule 244 (something_ex -> FLOAT .)
    CASE            reduce using rule 244 (something_ex -> FLOAT .)
    RETURN          reduce using rule 244 (something_ex -> FLOAT .)
    STRING          reduce using rule 244 (something_ex -> FLOAT .)
    TRUE            reduce using rule 244 (something_ex -> FLOAT .)
    FALSE           reduce using rule 244 (something_ex -> FLOAT .)
    RPAREN          reduce using rule 244 (something_ex -> FLOAT .)
    AND             reduce using rule 244 (something_ex -> FLOAT .)
    OR              reduce using rule 244 (something_ex -> FLOAT .)
    LLLAVE          reduce using rule 244 (something_ex -> FLOAT .)
    RCORCHE         reduce using rule 244 (something_ex -> FLOAT .)
    COMA            reduce using rule 244 (something_ex -> FLOAT .)


state 56

    (194) negation -> NOT . comparison
    (195) negation -> NOT . ID
    (178) comparison -> . value op value
    (179) value -> . ID
    (180) value -> . expression
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 130
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    comparison                     shift and go to state 129
    value                          shift and go to state 34
    expression                     shift and go to state 98
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 57

    (116) static -> single .

    COLON           reduce using rule 116 (static -> single .)
    PRINT           reduce using rule 116 (static -> single .)
    SCAN            reduce using rule 116 (static -> single .)
    FOR             reduce using rule 116 (static -> single .)
    CONST           reduce using rule 116 (static -> single .)
    ID              reduce using rule 116 (static -> single .)
    APPEND          reduce using rule 116 (static -> single .)
    LEN             reduce using rule 116 (static -> single .)
    COPY            reduce using rule 116 (static -> single .)
    DELETE          reduce using rule 116 (static -> single .)
    IF              reduce using rule 116 (static -> single .)
    ELSE            reduce using rule 116 (static -> single .)
    TYPE            reduce using rule 116 (static -> single .)
    SWITCH          reduce using rule 116 (static -> single .)
    VAR             reduce using rule 116 (static -> single .)
    FUNC            reduce using rule 116 (static -> single .)
    INTEGER         reduce using rule 116 (static -> single .)
    FLOAT           reduce using rule 116 (static -> single .)
    NOT             reduce using rule 116 (static -> single .)
    $end            reduce using rule 116 (static -> single .)
    RLLAVE          reduce using rule 116 (static -> single .)
    INT32           reduce using rule 116 (static -> single .)
    INT64           reduce using rule 116 (static -> single .)
    FLOAT32         reduce using rule 116 (static -> single .)
    FLOAT64         reduce using rule 116 (static -> single .)
    BYTE            reduce using rule 116 (static -> single .)
    WFLOAT          reduce using rule 116 (static -> single .)
    WSTRING         reduce using rule 116 (static -> single .)
    WINT            reduce using rule 116 (static -> single .)
    BOOL            reduce using rule 116 (static -> single .)
    DEFAULT         reduce using rule 116 (static -> single .)
    CASE            reduce using rule 116 (static -> single .)
    RETURN          reduce using rule 116 (static -> single .)
    STRING          reduce using rule 116 (static -> single .)
    TRUE            reduce using rule 116 (static -> single .)
    FALSE           reduce using rule 116 (static -> single .)


state 58

    (117) static -> multiple .

    COLON           reduce using rule 117 (static -> multiple .)
    PRINT           reduce using rule 117 (static -> multiple .)
    SCAN            reduce using rule 117 (static -> multiple .)
    FOR             reduce using rule 117 (static -> multiple .)
    CONST           reduce using rule 117 (static -> multiple .)
    ID              reduce using rule 117 (static -> multiple .)
    APPEND          reduce using rule 117 (static -> multiple .)
    LEN             reduce using rule 117 (static -> multiple .)
    COPY            reduce using rule 117 (static -> multiple .)
    DELETE          reduce using rule 117 (static -> multiple .)
    IF              reduce using rule 117 (static -> multiple .)
    ELSE            reduce using rule 117 (static -> multiple .)
    TYPE            reduce using rule 117 (static -> multiple .)
    SWITCH          reduce using rule 117 (static -> multiple .)
    VAR             reduce using rule 117 (static -> multiple .)
    FUNC            reduce using rule 117 (static -> multiple .)
    INTEGER         reduce using rule 117 (static -> multiple .)
    FLOAT           reduce using rule 117 (static -> multiple .)
    NOT             reduce using rule 117 (static -> multiple .)
    $end            reduce using rule 117 (static -> multiple .)
    RLLAVE          reduce using rule 117 (static -> multiple .)
    INT32           reduce using rule 117 (static -> multiple .)
    INT64           reduce using rule 117 (static -> multiple .)
    FLOAT32         reduce using rule 117 (static -> multiple .)
    FLOAT64         reduce using rule 117 (static -> multiple .)
    BYTE            reduce using rule 117 (static -> multiple .)
    WFLOAT          reduce using rule 117 (static -> multiple .)
    WSTRING         reduce using rule 117 (static -> multiple .)
    WINT            reduce using rule 117 (static -> multiple .)
    BOOL            reduce using rule 117 (static -> multiple .)
    DEFAULT         reduce using rule 117 (static -> multiple .)
    CASE            reduce using rule 117 (static -> multiple .)
    RETURN          reduce using rule 117 (static -> multiple .)
    STRING          reduce using rule 117 (static -> multiple .)
    TRUE            reduce using rule 117 (static -> multiple .)
    FALSE           reduce using rule 117 (static -> multiple .)


state 59

    (118) multiple -> list_var . data_types
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WFLOAT
    (56) data_types -> . WSTRING
    (57) data_types -> . WINT
    (58) data_types -> . BOOL

    INT32           shift and go to state 132
    INT64           shift and go to state 133
    FLOAT32         shift and go to state 134
    FLOAT64         shift and go to state 135
    BYTE            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    WINT            shift and go to state 139
    BOOL            shift and go to state 140

    data_types                     shift and go to state 131

state 60

    (3) more_rules -> rule codigo .

    $end            reduce using rule 3 (more_rules -> rule codigo .)
    RLLAVE          reduce using rule 3 (more_rules -> rule codigo .)
    INT32           reduce using rule 3 (more_rules -> rule codigo .)
    INT64           reduce using rule 3 (more_rules -> rule codigo .)
    FLOAT32         reduce using rule 3 (more_rules -> rule codigo .)
    FLOAT64         reduce using rule 3 (more_rules -> rule codigo .)
    BYTE            reduce using rule 3 (more_rules -> rule codigo .)
    WFLOAT          reduce using rule 3 (more_rules -> rule codigo .)
    WSTRING         reduce using rule 3 (more_rules -> rule codigo .)
    WINT            reduce using rule 3 (more_rules -> rule codigo .)
    BOOL            reduce using rule 3 (more_rules -> rule codigo .)
    ID              reduce using rule 3 (more_rules -> rule codigo .)
    DEFAULT         reduce using rule 3 (more_rules -> rule codigo .)
    CASE            reduce using rule 3 (more_rules -> rule codigo .)
    RETURN          reduce using rule 3 (more_rules -> rule codigo .)
    STRING          reduce using rule 3 (more_rules -> rule codigo .)
    INTEGER         reduce using rule 3 (more_rules -> rule codigo .)
    FLOAT           reduce using rule 3 (more_rules -> rule codigo .)
    TRUE            reduce using rule 3 (more_rules -> rule codigo .)
    FALSE           reduce using rule 3 (more_rules -> rule codigo .)
    NOT             reduce using rule 3 (more_rules -> rule codigo .)
    APPEND          reduce using rule 3 (more_rules -> rule codigo .)
    LEN             reduce using rule 3 (more_rules -> rule codigo .)
    COPY            reduce using rule 3 (more_rules -> rule codigo .)
    DELETE          reduce using rule 3 (more_rules -> rule codigo .)


state 61

    (4) rule -> impresion COLON .

    PRINT           reduce using rule 4 (rule -> impresion COLON .)
    SCAN            reduce using rule 4 (rule -> impresion COLON .)
    FOR             reduce using rule 4 (rule -> impresion COLON .)
    CONST           reduce using rule 4 (rule -> impresion COLON .)
    ID              reduce using rule 4 (rule -> impresion COLON .)
    APPEND          reduce using rule 4 (rule -> impresion COLON .)
    LEN             reduce using rule 4 (rule -> impresion COLON .)
    COPY            reduce using rule 4 (rule -> impresion COLON .)
    DELETE          reduce using rule 4 (rule -> impresion COLON .)
    IF              reduce using rule 4 (rule -> impresion COLON .)
    ELSE            reduce using rule 4 (rule -> impresion COLON .)
    TYPE            reduce using rule 4 (rule -> impresion COLON .)
    SWITCH          reduce using rule 4 (rule -> impresion COLON .)
    VAR             reduce using rule 4 (rule -> impresion COLON .)
    FUNC            reduce using rule 4 (rule -> impresion COLON .)
    INTEGER         reduce using rule 4 (rule -> impresion COLON .)
    FLOAT           reduce using rule 4 (rule -> impresion COLON .)
    NOT             reduce using rule 4 (rule -> impresion COLON .)
    $end            reduce using rule 4 (rule -> impresion COLON .)
    RLLAVE          reduce using rule 4 (rule -> impresion COLON .)
    INT32           reduce using rule 4 (rule -> impresion COLON .)
    INT64           reduce using rule 4 (rule -> impresion COLON .)
    FLOAT32         reduce using rule 4 (rule -> impresion COLON .)
    FLOAT64         reduce using rule 4 (rule -> impresion COLON .)
    BYTE            reduce using rule 4 (rule -> impresion COLON .)
    WFLOAT          reduce using rule 4 (rule -> impresion COLON .)
    WSTRING         reduce using rule 4 (rule -> impresion COLON .)
    WINT            reduce using rule 4 (rule -> impresion COLON .)
    BOOL            reduce using rule 4 (rule -> impresion COLON .)
    DEFAULT         reduce using rule 4 (rule -> impresion COLON .)
    CASE            reduce using rule 4 (rule -> impresion COLON .)
    RETURN          reduce using rule 4 (rule -> impresion COLON .)
    STRING          reduce using rule 4 (rule -> impresion COLON .)
    TRUE            reduce using rule 4 (rule -> impresion COLON .)
    FALSE           reduce using rule 4 (rule -> impresion COLON .)


state 62

    (6) rule -> scan_func COLON .

    PRINT           reduce using rule 6 (rule -> scan_func COLON .)
    SCAN            reduce using rule 6 (rule -> scan_func COLON .)
    FOR             reduce using rule 6 (rule -> scan_func COLON .)
    CONST           reduce using rule 6 (rule -> scan_func COLON .)
    ID              reduce using rule 6 (rule -> scan_func COLON .)
    APPEND          reduce using rule 6 (rule -> scan_func COLON .)
    LEN             reduce using rule 6 (rule -> scan_func COLON .)
    COPY            reduce using rule 6 (rule -> scan_func COLON .)
    DELETE          reduce using rule 6 (rule -> scan_func COLON .)
    IF              reduce using rule 6 (rule -> scan_func COLON .)
    ELSE            reduce using rule 6 (rule -> scan_func COLON .)
    TYPE            reduce using rule 6 (rule -> scan_func COLON .)
    SWITCH          reduce using rule 6 (rule -> scan_func COLON .)
    VAR             reduce using rule 6 (rule -> scan_func COLON .)
    FUNC            reduce using rule 6 (rule -> scan_func COLON .)
    INTEGER         reduce using rule 6 (rule -> scan_func COLON .)
    FLOAT           reduce using rule 6 (rule -> scan_func COLON .)
    NOT             reduce using rule 6 (rule -> scan_func COLON .)
    $end            reduce using rule 6 (rule -> scan_func COLON .)
    RLLAVE          reduce using rule 6 (rule -> scan_func COLON .)
    INT32           reduce using rule 6 (rule -> scan_func COLON .)
    INT64           reduce using rule 6 (rule -> scan_func COLON .)
    FLOAT32         reduce using rule 6 (rule -> scan_func COLON .)
    FLOAT64         reduce using rule 6 (rule -> scan_func COLON .)
    BYTE            reduce using rule 6 (rule -> scan_func COLON .)
    WFLOAT          reduce using rule 6 (rule -> scan_func COLON .)
    WSTRING         reduce using rule 6 (rule -> scan_func COLON .)
    WINT            reduce using rule 6 (rule -> scan_func COLON .)
    BOOL            reduce using rule 6 (rule -> scan_func COLON .)
    DEFAULT         reduce using rule 6 (rule -> scan_func COLON .)
    CASE            reduce using rule 6 (rule -> scan_func COLON .)
    RETURN          reduce using rule 6 (rule -> scan_func COLON .)
    STRING          reduce using rule 6 (rule -> scan_func COLON .)
    TRUE            reduce using rule 6 (rule -> scan_func COLON .)
    FALSE           reduce using rule 6 (rule -> scan_func COLON .)


state 63

    (8) rule -> expression COLON .

    PRINT           reduce using rule 8 (rule -> expression COLON .)
    SCAN            reduce using rule 8 (rule -> expression COLON .)
    FOR             reduce using rule 8 (rule -> expression COLON .)
    CONST           reduce using rule 8 (rule -> expression COLON .)
    ID              reduce using rule 8 (rule -> expression COLON .)
    APPEND          reduce using rule 8 (rule -> expression COLON .)
    LEN             reduce using rule 8 (rule -> expression COLON .)
    COPY            reduce using rule 8 (rule -> expression COLON .)
    DELETE          reduce using rule 8 (rule -> expression COLON .)
    IF              reduce using rule 8 (rule -> expression COLON .)
    ELSE            reduce using rule 8 (rule -> expression COLON .)
    TYPE            reduce using rule 8 (rule -> expression COLON .)
    SWITCH          reduce using rule 8 (rule -> expression COLON .)
    VAR             reduce using rule 8 (rule -> expression COLON .)
    FUNC            reduce using rule 8 (rule -> expression COLON .)
    INTEGER         reduce using rule 8 (rule -> expression COLON .)
    FLOAT           reduce using rule 8 (rule -> expression COLON .)
    NOT             reduce using rule 8 (rule -> expression COLON .)
    $end            reduce using rule 8 (rule -> expression COLON .)
    RLLAVE          reduce using rule 8 (rule -> expression COLON .)
    INT32           reduce using rule 8 (rule -> expression COLON .)
    INT64           reduce using rule 8 (rule -> expression COLON .)
    FLOAT32         reduce using rule 8 (rule -> expression COLON .)
    FLOAT64         reduce using rule 8 (rule -> expression COLON .)
    BYTE            reduce using rule 8 (rule -> expression COLON .)
    WFLOAT          reduce using rule 8 (rule -> expression COLON .)
    WSTRING         reduce using rule 8 (rule -> expression COLON .)
    WINT            reduce using rule 8 (rule -> expression COLON .)
    BOOL            reduce using rule 8 (rule -> expression COLON .)
    DEFAULT         reduce using rule 8 (rule -> expression COLON .)
    CASE            reduce using rule 8 (rule -> expression COLON .)
    RETURN          reduce using rule 8 (rule -> expression COLON .)
    STRING          reduce using rule 8 (rule -> expression COLON .)
    TRUE            reduce using rule 8 (rule -> expression COLON .)
    FALSE           reduce using rule 8 (rule -> expression COLON .)


state 64

    (13) rule -> decVar COLON .

    PRINT           reduce using rule 13 (rule -> decVar COLON .)
    SCAN            reduce using rule 13 (rule -> decVar COLON .)
    FOR             reduce using rule 13 (rule -> decVar COLON .)
    CONST           reduce using rule 13 (rule -> decVar COLON .)
    ID              reduce using rule 13 (rule -> decVar COLON .)
    APPEND          reduce using rule 13 (rule -> decVar COLON .)
    LEN             reduce using rule 13 (rule -> decVar COLON .)
    COPY            reduce using rule 13 (rule -> decVar COLON .)
    DELETE          reduce using rule 13 (rule -> decVar COLON .)
    IF              reduce using rule 13 (rule -> decVar COLON .)
    ELSE            reduce using rule 13 (rule -> decVar COLON .)
    TYPE            reduce using rule 13 (rule -> decVar COLON .)
    SWITCH          reduce using rule 13 (rule -> decVar COLON .)
    VAR             reduce using rule 13 (rule -> decVar COLON .)
    FUNC            reduce using rule 13 (rule -> decVar COLON .)
    INTEGER         reduce using rule 13 (rule -> decVar COLON .)
    FLOAT           reduce using rule 13 (rule -> decVar COLON .)
    NOT             reduce using rule 13 (rule -> decVar COLON .)
    $end            reduce using rule 13 (rule -> decVar COLON .)
    RLLAVE          reduce using rule 13 (rule -> decVar COLON .)
    INT32           reduce using rule 13 (rule -> decVar COLON .)
    INT64           reduce using rule 13 (rule -> decVar COLON .)
    FLOAT32         reduce using rule 13 (rule -> decVar COLON .)
    FLOAT64         reduce using rule 13 (rule -> decVar COLON .)
    BYTE            reduce using rule 13 (rule -> decVar COLON .)
    WFLOAT          reduce using rule 13 (rule -> decVar COLON .)
    WSTRING         reduce using rule 13 (rule -> decVar COLON .)
    WINT            reduce using rule 13 (rule -> decVar COLON .)
    BOOL            reduce using rule 13 (rule -> decVar COLON .)
    DEFAULT         reduce using rule 13 (rule -> decVar COLON .)
    CASE            reduce using rule 13 (rule -> decVar COLON .)
    RETURN          reduce using rule 13 (rule -> decVar COLON .)
    STRING          reduce using rule 13 (rule -> decVar COLON .)
    TRUE            reduce using rule 13 (rule -> decVar COLON .)
    FALSE           reduce using rule 13 (rule -> decVar COLON .)


state 65

    (15) rule -> decConst COLON .

    PRINT           reduce using rule 15 (rule -> decConst COLON .)
    SCAN            reduce using rule 15 (rule -> decConst COLON .)
    FOR             reduce using rule 15 (rule -> decConst COLON .)
    CONST           reduce using rule 15 (rule -> decConst COLON .)
    ID              reduce using rule 15 (rule -> decConst COLON .)
    APPEND          reduce using rule 15 (rule -> decConst COLON .)
    LEN             reduce using rule 15 (rule -> decConst COLON .)
    COPY            reduce using rule 15 (rule -> decConst COLON .)
    DELETE          reduce using rule 15 (rule -> decConst COLON .)
    IF              reduce using rule 15 (rule -> decConst COLON .)
    ELSE            reduce using rule 15 (rule -> decConst COLON .)
    TYPE            reduce using rule 15 (rule -> decConst COLON .)
    SWITCH          reduce using rule 15 (rule -> decConst COLON .)
    VAR             reduce using rule 15 (rule -> decConst COLON .)
    FUNC            reduce using rule 15 (rule -> decConst COLON .)
    INTEGER         reduce using rule 15 (rule -> decConst COLON .)
    FLOAT           reduce using rule 15 (rule -> decConst COLON .)
    NOT             reduce using rule 15 (rule -> decConst COLON .)
    $end            reduce using rule 15 (rule -> decConst COLON .)
    RLLAVE          reduce using rule 15 (rule -> decConst COLON .)
    INT32           reduce using rule 15 (rule -> decConst COLON .)
    INT64           reduce using rule 15 (rule -> decConst COLON .)
    FLOAT32         reduce using rule 15 (rule -> decConst COLON .)
    FLOAT64         reduce using rule 15 (rule -> decConst COLON .)
    BYTE            reduce using rule 15 (rule -> decConst COLON .)
    WFLOAT          reduce using rule 15 (rule -> decConst COLON .)
    WSTRING         reduce using rule 15 (rule -> decConst COLON .)
    WINT            reduce using rule 15 (rule -> decConst COLON .)
    BOOL            reduce using rule 15 (rule -> decConst COLON .)
    DEFAULT         reduce using rule 15 (rule -> decConst COLON .)
    CASE            reduce using rule 15 (rule -> decConst COLON .)
    RETURN          reduce using rule 15 (rule -> decConst COLON .)
    STRING          reduce using rule 15 (rule -> decConst COLON .)
    TRUE            reduce using rule 15 (rule -> decConst COLON .)
    FALSE           reduce using rule 15 (rule -> decConst COLON .)


state 66

    (18) rule -> var_asignation COLON .

    PRINT           reduce using rule 18 (rule -> var_asignation COLON .)
    SCAN            reduce using rule 18 (rule -> var_asignation COLON .)
    FOR             reduce using rule 18 (rule -> var_asignation COLON .)
    CONST           reduce using rule 18 (rule -> var_asignation COLON .)
    ID              reduce using rule 18 (rule -> var_asignation COLON .)
    APPEND          reduce using rule 18 (rule -> var_asignation COLON .)
    LEN             reduce using rule 18 (rule -> var_asignation COLON .)
    COPY            reduce using rule 18 (rule -> var_asignation COLON .)
    DELETE          reduce using rule 18 (rule -> var_asignation COLON .)
    IF              reduce using rule 18 (rule -> var_asignation COLON .)
    ELSE            reduce using rule 18 (rule -> var_asignation COLON .)
    TYPE            reduce using rule 18 (rule -> var_asignation COLON .)
    SWITCH          reduce using rule 18 (rule -> var_asignation COLON .)
    VAR             reduce using rule 18 (rule -> var_asignation COLON .)
    FUNC            reduce using rule 18 (rule -> var_asignation COLON .)
    INTEGER         reduce using rule 18 (rule -> var_asignation COLON .)
    FLOAT           reduce using rule 18 (rule -> var_asignation COLON .)
    NOT             reduce using rule 18 (rule -> var_asignation COLON .)
    $end            reduce using rule 18 (rule -> var_asignation COLON .)
    RLLAVE          reduce using rule 18 (rule -> var_asignation COLON .)
    INT32           reduce using rule 18 (rule -> var_asignation COLON .)
    INT64           reduce using rule 18 (rule -> var_asignation COLON .)
    FLOAT32         reduce using rule 18 (rule -> var_asignation COLON .)
    FLOAT64         reduce using rule 18 (rule -> var_asignation COLON .)
    BYTE            reduce using rule 18 (rule -> var_asignation COLON .)
    WFLOAT          reduce using rule 18 (rule -> var_asignation COLON .)
    WSTRING         reduce using rule 18 (rule -> var_asignation COLON .)
    WINT            reduce using rule 18 (rule -> var_asignation COLON .)
    BOOL            reduce using rule 18 (rule -> var_asignation COLON .)
    DEFAULT         reduce using rule 18 (rule -> var_asignation COLON .)
    CASE            reduce using rule 18 (rule -> var_asignation COLON .)
    RETURN          reduce using rule 18 (rule -> var_asignation COLON .)
    STRING          reduce using rule 18 (rule -> var_asignation COLON .)
    TRUE            reduce using rule 18 (rule -> var_asignation COLON .)
    FALSE           reduce using rule 18 (rule -> var_asignation COLON .)


state 67

    (20) rule -> funciones COLON .

    PRINT           reduce using rule 20 (rule -> funciones COLON .)
    SCAN            reduce using rule 20 (rule -> funciones COLON .)
    FOR             reduce using rule 20 (rule -> funciones COLON .)
    CONST           reduce using rule 20 (rule -> funciones COLON .)
    ID              reduce using rule 20 (rule -> funciones COLON .)
    APPEND          reduce using rule 20 (rule -> funciones COLON .)
    LEN             reduce using rule 20 (rule -> funciones COLON .)
    COPY            reduce using rule 20 (rule -> funciones COLON .)
    DELETE          reduce using rule 20 (rule -> funciones COLON .)
    IF              reduce using rule 20 (rule -> funciones COLON .)
    ELSE            reduce using rule 20 (rule -> funciones COLON .)
    TYPE            reduce using rule 20 (rule -> funciones COLON .)
    SWITCH          reduce using rule 20 (rule -> funciones COLON .)
    VAR             reduce using rule 20 (rule -> funciones COLON .)
    FUNC            reduce using rule 20 (rule -> funciones COLON .)
    INTEGER         reduce using rule 20 (rule -> funciones COLON .)
    FLOAT           reduce using rule 20 (rule -> funciones COLON .)
    NOT             reduce using rule 20 (rule -> funciones COLON .)
    $end            reduce using rule 20 (rule -> funciones COLON .)
    RLLAVE          reduce using rule 20 (rule -> funciones COLON .)
    INT32           reduce using rule 20 (rule -> funciones COLON .)
    INT64           reduce using rule 20 (rule -> funciones COLON .)
    FLOAT32         reduce using rule 20 (rule -> funciones COLON .)
    FLOAT64         reduce using rule 20 (rule -> funciones COLON .)
    BYTE            reduce using rule 20 (rule -> funciones COLON .)
    WFLOAT          reduce using rule 20 (rule -> funciones COLON .)
    WSTRING         reduce using rule 20 (rule -> funciones COLON .)
    WINT            reduce using rule 20 (rule -> funciones COLON .)
    BOOL            reduce using rule 20 (rule -> funciones COLON .)
    DEFAULT         reduce using rule 20 (rule -> funciones COLON .)
    CASE            reduce using rule 20 (rule -> funciones COLON .)
    RETURN          reduce using rule 20 (rule -> funciones COLON .)
    STRING          reduce using rule 20 (rule -> funciones COLON .)
    TRUE            reduce using rule 20 (rule -> funciones COLON .)
    FALSE           reduce using rule 20 (rule -> funciones COLON .)


state 68

    (27) rule -> array_declaration COLON .

    PRINT           reduce using rule 27 (rule -> array_declaration COLON .)
    SCAN            reduce using rule 27 (rule -> array_declaration COLON .)
    FOR             reduce using rule 27 (rule -> array_declaration COLON .)
    CONST           reduce using rule 27 (rule -> array_declaration COLON .)
    ID              reduce using rule 27 (rule -> array_declaration COLON .)
    APPEND          reduce using rule 27 (rule -> array_declaration COLON .)
    LEN             reduce using rule 27 (rule -> array_declaration COLON .)
    COPY            reduce using rule 27 (rule -> array_declaration COLON .)
    DELETE          reduce using rule 27 (rule -> array_declaration COLON .)
    IF              reduce using rule 27 (rule -> array_declaration COLON .)
    ELSE            reduce using rule 27 (rule -> array_declaration COLON .)
    TYPE            reduce using rule 27 (rule -> array_declaration COLON .)
    SWITCH          reduce using rule 27 (rule -> array_declaration COLON .)
    VAR             reduce using rule 27 (rule -> array_declaration COLON .)
    FUNC            reduce using rule 27 (rule -> array_declaration COLON .)
    INTEGER         reduce using rule 27 (rule -> array_declaration COLON .)
    FLOAT           reduce using rule 27 (rule -> array_declaration COLON .)
    NOT             reduce using rule 27 (rule -> array_declaration COLON .)
    $end            reduce using rule 27 (rule -> array_declaration COLON .)
    RLLAVE          reduce using rule 27 (rule -> array_declaration COLON .)
    INT32           reduce using rule 27 (rule -> array_declaration COLON .)
    INT64           reduce using rule 27 (rule -> array_declaration COLON .)
    FLOAT32         reduce using rule 27 (rule -> array_declaration COLON .)
    FLOAT64         reduce using rule 27 (rule -> array_declaration COLON .)
    BYTE            reduce using rule 27 (rule -> array_declaration COLON .)
    WFLOAT          reduce using rule 27 (rule -> array_declaration COLON .)
    WSTRING         reduce using rule 27 (rule -> array_declaration COLON .)
    WINT            reduce using rule 27 (rule -> array_declaration COLON .)
    BOOL            reduce using rule 27 (rule -> array_declaration COLON .)
    DEFAULT         reduce using rule 27 (rule -> array_declaration COLON .)
    CASE            reduce using rule 27 (rule -> array_declaration COLON .)
    RETURN          reduce using rule 27 (rule -> array_declaration COLON .)
    STRING          reduce using rule 27 (rule -> array_declaration COLON .)
    TRUE            reduce using rule 27 (rule -> array_declaration COLON .)
    FALSE           reduce using rule 27 (rule -> array_declaration COLON .)


state 69

    (29) rule -> array_var COLON .

    PRINT           reduce using rule 29 (rule -> array_var COLON .)
    SCAN            reduce using rule 29 (rule -> array_var COLON .)
    FOR             reduce using rule 29 (rule -> array_var COLON .)
    CONST           reduce using rule 29 (rule -> array_var COLON .)
    ID              reduce using rule 29 (rule -> array_var COLON .)
    APPEND          reduce using rule 29 (rule -> array_var COLON .)
    LEN             reduce using rule 29 (rule -> array_var COLON .)
    COPY            reduce using rule 29 (rule -> array_var COLON .)
    DELETE          reduce using rule 29 (rule -> array_var COLON .)
    IF              reduce using rule 29 (rule -> array_var COLON .)
    ELSE            reduce using rule 29 (rule -> array_var COLON .)
    TYPE            reduce using rule 29 (rule -> array_var COLON .)
    SWITCH          reduce using rule 29 (rule -> array_var COLON .)
    VAR             reduce using rule 29 (rule -> array_var COLON .)
    FUNC            reduce using rule 29 (rule -> array_var COLON .)
    INTEGER         reduce using rule 29 (rule -> array_var COLON .)
    FLOAT           reduce using rule 29 (rule -> array_var COLON .)
    NOT             reduce using rule 29 (rule -> array_var COLON .)
    $end            reduce using rule 29 (rule -> array_var COLON .)
    RLLAVE          reduce using rule 29 (rule -> array_var COLON .)
    INT32           reduce using rule 29 (rule -> array_var COLON .)
    INT64           reduce using rule 29 (rule -> array_var COLON .)
    FLOAT32         reduce using rule 29 (rule -> array_var COLON .)
    FLOAT64         reduce using rule 29 (rule -> array_var COLON .)
    BYTE            reduce using rule 29 (rule -> array_var COLON .)
    WFLOAT          reduce using rule 29 (rule -> array_var COLON .)
    WSTRING         reduce using rule 29 (rule -> array_var COLON .)
    WINT            reduce using rule 29 (rule -> array_var COLON .)
    BOOL            reduce using rule 29 (rule -> array_var COLON .)
    DEFAULT         reduce using rule 29 (rule -> array_var COLON .)
    CASE            reduce using rule 29 (rule -> array_var COLON .)
    RETURN          reduce using rule 29 (rule -> array_var COLON .)
    STRING          reduce using rule 29 (rule -> array_var COLON .)
    TRUE            reduce using rule 29 (rule -> array_var COLON .)
    FALSE           reduce using rule 29 (rule -> array_var COLON .)


state 70

    (212) array_assignment -> array_var EQUAL . something
    (77) something -> . ID
    (78) something -> . data_structure
    (79) something -> . values
    (80) something -> . operations
    (81) something -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID

    ID              shift and go to state 142
    STRING          shift and go to state 147
    INTEGER         shift and go to state 148
    FLOAT           shift and go to state 149
    TRUE            shift and go to state 150
    FALSE           shift and go to state 151
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    NOT             shift and go to state 56

    array_var                      shift and go to state 100
    something                      shift and go to state 141
    data_structure                 shift and go to state 143
    values                         shift and go to state 144
    operations                     shift and go to state 145
    funciones                      shift and go to state 146
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    expression                     shift and go to state 152
    comparison                     shift and go to state 153
    logic_operation                shift and go to state 154
    call_func                      shift and go to state 46
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36

state 71

    (31) rule -> array_assignment COLON .

    PRINT           reduce using rule 31 (rule -> array_assignment COLON .)
    SCAN            reduce using rule 31 (rule -> array_assignment COLON .)
    FOR             reduce using rule 31 (rule -> array_assignment COLON .)
    CONST           reduce using rule 31 (rule -> array_assignment COLON .)
    ID              reduce using rule 31 (rule -> array_assignment COLON .)
    APPEND          reduce using rule 31 (rule -> array_assignment COLON .)
    LEN             reduce using rule 31 (rule -> array_assignment COLON .)
    COPY            reduce using rule 31 (rule -> array_assignment COLON .)
    DELETE          reduce using rule 31 (rule -> array_assignment COLON .)
    IF              reduce using rule 31 (rule -> array_assignment COLON .)
    ELSE            reduce using rule 31 (rule -> array_assignment COLON .)
    TYPE            reduce using rule 31 (rule -> array_assignment COLON .)
    SWITCH          reduce using rule 31 (rule -> array_assignment COLON .)
    VAR             reduce using rule 31 (rule -> array_assignment COLON .)
    FUNC            reduce using rule 31 (rule -> array_assignment COLON .)
    INTEGER         reduce using rule 31 (rule -> array_assignment COLON .)
    FLOAT           reduce using rule 31 (rule -> array_assignment COLON .)
    NOT             reduce using rule 31 (rule -> array_assignment COLON .)
    $end            reduce using rule 31 (rule -> array_assignment COLON .)
    RLLAVE          reduce using rule 31 (rule -> array_assignment COLON .)
    INT32           reduce using rule 31 (rule -> array_assignment COLON .)
    INT64           reduce using rule 31 (rule -> array_assignment COLON .)
    FLOAT32         reduce using rule 31 (rule -> array_assignment COLON .)
    FLOAT64         reduce using rule 31 (rule -> array_assignment COLON .)
    BYTE            reduce using rule 31 (rule -> array_assignment COLON .)
    WFLOAT          reduce using rule 31 (rule -> array_assignment COLON .)
    WSTRING         reduce using rule 31 (rule -> array_assignment COLON .)
    WINT            reduce using rule 31 (rule -> array_assignment COLON .)
    BOOL            reduce using rule 31 (rule -> array_assignment COLON .)
    DEFAULT         reduce using rule 31 (rule -> array_assignment COLON .)
    CASE            reduce using rule 31 (rule -> array_assignment COLON .)
    RETURN          reduce using rule 31 (rule -> array_assignment COLON .)
    STRING          reduce using rule 31 (rule -> array_assignment COLON .)
    TRUE            reduce using rule 31 (rule -> array_assignment COLON .)
    FALSE           reduce using rule 31 (rule -> array_assignment COLON .)


state 72

    (33) rule -> slice_declaration COLON .

    PRINT           reduce using rule 33 (rule -> slice_declaration COLON .)
    SCAN            reduce using rule 33 (rule -> slice_declaration COLON .)
    FOR             reduce using rule 33 (rule -> slice_declaration COLON .)
    CONST           reduce using rule 33 (rule -> slice_declaration COLON .)
    ID              reduce using rule 33 (rule -> slice_declaration COLON .)
    APPEND          reduce using rule 33 (rule -> slice_declaration COLON .)
    LEN             reduce using rule 33 (rule -> slice_declaration COLON .)
    COPY            reduce using rule 33 (rule -> slice_declaration COLON .)
    DELETE          reduce using rule 33 (rule -> slice_declaration COLON .)
    IF              reduce using rule 33 (rule -> slice_declaration COLON .)
    ELSE            reduce using rule 33 (rule -> slice_declaration COLON .)
    TYPE            reduce using rule 33 (rule -> slice_declaration COLON .)
    SWITCH          reduce using rule 33 (rule -> slice_declaration COLON .)
    VAR             reduce using rule 33 (rule -> slice_declaration COLON .)
    FUNC            reduce using rule 33 (rule -> slice_declaration COLON .)
    INTEGER         reduce using rule 33 (rule -> slice_declaration COLON .)
    FLOAT           reduce using rule 33 (rule -> slice_declaration COLON .)
    NOT             reduce using rule 33 (rule -> slice_declaration COLON .)
    $end            reduce using rule 33 (rule -> slice_declaration COLON .)
    RLLAVE          reduce using rule 33 (rule -> slice_declaration COLON .)
    INT32           reduce using rule 33 (rule -> slice_declaration COLON .)
    INT64           reduce using rule 33 (rule -> slice_declaration COLON .)
    FLOAT32         reduce using rule 33 (rule -> slice_declaration COLON .)
    FLOAT64         reduce using rule 33 (rule -> slice_declaration COLON .)
    BYTE            reduce using rule 33 (rule -> slice_declaration COLON .)
    WFLOAT          reduce using rule 33 (rule -> slice_declaration COLON .)
    WSTRING         reduce using rule 33 (rule -> slice_declaration COLON .)
    WINT            reduce using rule 33 (rule -> slice_declaration COLON .)
    BOOL            reduce using rule 33 (rule -> slice_declaration COLON .)
    DEFAULT         reduce using rule 33 (rule -> slice_declaration COLON .)
    CASE            reduce using rule 33 (rule -> slice_declaration COLON .)
    RETURN          reduce using rule 33 (rule -> slice_declaration COLON .)
    STRING          reduce using rule 33 (rule -> slice_declaration COLON .)
    TRUE            reduce using rule 33 (rule -> slice_declaration COLON .)
    FALSE           reduce using rule 33 (rule -> slice_declaration COLON .)


state 73

    (35) rule -> slice_var COLON .

    PRINT           reduce using rule 35 (rule -> slice_var COLON .)
    SCAN            reduce using rule 35 (rule -> slice_var COLON .)
    FOR             reduce using rule 35 (rule -> slice_var COLON .)
    CONST           reduce using rule 35 (rule -> slice_var COLON .)
    ID              reduce using rule 35 (rule -> slice_var COLON .)
    APPEND          reduce using rule 35 (rule -> slice_var COLON .)
    LEN             reduce using rule 35 (rule -> slice_var COLON .)
    COPY            reduce using rule 35 (rule -> slice_var COLON .)
    DELETE          reduce using rule 35 (rule -> slice_var COLON .)
    IF              reduce using rule 35 (rule -> slice_var COLON .)
    ELSE            reduce using rule 35 (rule -> slice_var COLON .)
    TYPE            reduce using rule 35 (rule -> slice_var COLON .)
    SWITCH          reduce using rule 35 (rule -> slice_var COLON .)
    VAR             reduce using rule 35 (rule -> slice_var COLON .)
    FUNC            reduce using rule 35 (rule -> slice_var COLON .)
    INTEGER         reduce using rule 35 (rule -> slice_var COLON .)
    FLOAT           reduce using rule 35 (rule -> slice_var COLON .)
    NOT             reduce using rule 35 (rule -> slice_var COLON .)
    $end            reduce using rule 35 (rule -> slice_var COLON .)
    RLLAVE          reduce using rule 35 (rule -> slice_var COLON .)
    INT32           reduce using rule 35 (rule -> slice_var COLON .)
    INT64           reduce using rule 35 (rule -> slice_var COLON .)
    FLOAT32         reduce using rule 35 (rule -> slice_var COLON .)
    FLOAT64         reduce using rule 35 (rule -> slice_var COLON .)
    BYTE            reduce using rule 35 (rule -> slice_var COLON .)
    WFLOAT          reduce using rule 35 (rule -> slice_var COLON .)
    WSTRING         reduce using rule 35 (rule -> slice_var COLON .)
    WINT            reduce using rule 35 (rule -> slice_var COLON .)
    BOOL            reduce using rule 35 (rule -> slice_var COLON .)
    DEFAULT         reduce using rule 35 (rule -> slice_var COLON .)
    CASE            reduce using rule 35 (rule -> slice_var COLON .)
    RETURN          reduce using rule 35 (rule -> slice_var COLON .)
    STRING          reduce using rule 35 (rule -> slice_var COLON .)
    TRUE            reduce using rule 35 (rule -> slice_var COLON .)
    FALSE           reduce using rule 35 (rule -> slice_var COLON .)


state 74

    (147) slice_assignment -> slice_var EQUAL . something_s
    (148) something_s -> . ID
    (149) something_s -> . array_var
    (150) something_s -> . values
    (151) something_s -> . operations
    (208) array_var -> . ID LCORCHE index RCORCHE
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 156
    STRING          shift and go to state 147
    INTEGER         shift and go to state 148
    FLOAT           shift and go to state 149
    TRUE            shift and go to state 150
    FALSE           shift and go to state 151
    NOT             shift and go to state 56
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    slice_var                      shift and go to state 102
    something_s                    shift and go to state 155
    array_var                      shift and go to state 157
    values                         shift and go to state 158
    operations                     shift and go to state 159
    expression                     shift and go to state 152
    comparison                     shift and go to state 153
    logic_operation                shift and go to state 154
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    map_var                        shift and go to state 101
    call_func                      shift and go to state 46

state 75

    (37) rule -> slice_assignment COLON .

    PRINT           reduce using rule 37 (rule -> slice_assignment COLON .)
    SCAN            reduce using rule 37 (rule -> slice_assignment COLON .)
    FOR             reduce using rule 37 (rule -> slice_assignment COLON .)
    CONST           reduce using rule 37 (rule -> slice_assignment COLON .)
    ID              reduce using rule 37 (rule -> slice_assignment COLON .)
    APPEND          reduce using rule 37 (rule -> slice_assignment COLON .)
    LEN             reduce using rule 37 (rule -> slice_assignment COLON .)
    COPY            reduce using rule 37 (rule -> slice_assignment COLON .)
    DELETE          reduce using rule 37 (rule -> slice_assignment COLON .)
    IF              reduce using rule 37 (rule -> slice_assignment COLON .)
    ELSE            reduce using rule 37 (rule -> slice_assignment COLON .)
    TYPE            reduce using rule 37 (rule -> slice_assignment COLON .)
    SWITCH          reduce using rule 37 (rule -> slice_assignment COLON .)
    VAR             reduce using rule 37 (rule -> slice_assignment COLON .)
    FUNC            reduce using rule 37 (rule -> slice_assignment COLON .)
    INTEGER         reduce using rule 37 (rule -> slice_assignment COLON .)
    FLOAT           reduce using rule 37 (rule -> slice_assignment COLON .)
    NOT             reduce using rule 37 (rule -> slice_assignment COLON .)
    $end            reduce using rule 37 (rule -> slice_assignment COLON .)
    RLLAVE          reduce using rule 37 (rule -> slice_assignment COLON .)
    INT32           reduce using rule 37 (rule -> slice_assignment COLON .)
    INT64           reduce using rule 37 (rule -> slice_assignment COLON .)
    FLOAT32         reduce using rule 37 (rule -> slice_assignment COLON .)
    FLOAT64         reduce using rule 37 (rule -> slice_assignment COLON .)
    BYTE            reduce using rule 37 (rule -> slice_assignment COLON .)
    WFLOAT          reduce using rule 37 (rule -> slice_assignment COLON .)
    WSTRING         reduce using rule 37 (rule -> slice_assignment COLON .)
    WINT            reduce using rule 37 (rule -> slice_assignment COLON .)
    BOOL            reduce using rule 37 (rule -> slice_assignment COLON .)
    DEFAULT         reduce using rule 37 (rule -> slice_assignment COLON .)
    CASE            reduce using rule 37 (rule -> slice_assignment COLON .)
    RETURN          reduce using rule 37 (rule -> slice_assignment COLON .)
    STRING          reduce using rule 37 (rule -> slice_assignment COLON .)
    TRUE            reduce using rule 37 (rule -> slice_assignment COLON .)
    FALSE           reduce using rule 37 (rule -> slice_assignment COLON .)


state 76

    (39) rule -> map_declaration COLON .

    PRINT           reduce using rule 39 (rule -> map_declaration COLON .)
    SCAN            reduce using rule 39 (rule -> map_declaration COLON .)
    FOR             reduce using rule 39 (rule -> map_declaration COLON .)
    CONST           reduce using rule 39 (rule -> map_declaration COLON .)
    ID              reduce using rule 39 (rule -> map_declaration COLON .)
    APPEND          reduce using rule 39 (rule -> map_declaration COLON .)
    LEN             reduce using rule 39 (rule -> map_declaration COLON .)
    COPY            reduce using rule 39 (rule -> map_declaration COLON .)
    DELETE          reduce using rule 39 (rule -> map_declaration COLON .)
    IF              reduce using rule 39 (rule -> map_declaration COLON .)
    ELSE            reduce using rule 39 (rule -> map_declaration COLON .)
    TYPE            reduce using rule 39 (rule -> map_declaration COLON .)
    SWITCH          reduce using rule 39 (rule -> map_declaration COLON .)
    VAR             reduce using rule 39 (rule -> map_declaration COLON .)
    FUNC            reduce using rule 39 (rule -> map_declaration COLON .)
    INTEGER         reduce using rule 39 (rule -> map_declaration COLON .)
    FLOAT           reduce using rule 39 (rule -> map_declaration COLON .)
    NOT             reduce using rule 39 (rule -> map_declaration COLON .)
    $end            reduce using rule 39 (rule -> map_declaration COLON .)
    RLLAVE          reduce using rule 39 (rule -> map_declaration COLON .)
    INT32           reduce using rule 39 (rule -> map_declaration COLON .)
    INT64           reduce using rule 39 (rule -> map_declaration COLON .)
    FLOAT32         reduce using rule 39 (rule -> map_declaration COLON .)
    FLOAT64         reduce using rule 39 (rule -> map_declaration COLON .)
    BYTE            reduce using rule 39 (rule -> map_declaration COLON .)
    WFLOAT          reduce using rule 39 (rule -> map_declaration COLON .)
    WSTRING         reduce using rule 39 (rule -> map_declaration COLON .)
    WINT            reduce using rule 39 (rule -> map_declaration COLON .)
    BOOL            reduce using rule 39 (rule -> map_declaration COLON .)
    DEFAULT         reduce using rule 39 (rule -> map_declaration COLON .)
    CASE            reduce using rule 39 (rule -> map_declaration COLON .)
    RETURN          reduce using rule 39 (rule -> map_declaration COLON .)
    STRING          reduce using rule 39 (rule -> map_declaration COLON .)
    TRUE            reduce using rule 39 (rule -> map_declaration COLON .)
    FALSE           reduce using rule 39 (rule -> map_declaration COLON .)


state 77

    (41) rule -> map_assignment COLON .

    PRINT           reduce using rule 41 (rule -> map_assignment COLON .)
    SCAN            reduce using rule 41 (rule -> map_assignment COLON .)
    FOR             reduce using rule 41 (rule -> map_assignment COLON .)
    CONST           reduce using rule 41 (rule -> map_assignment COLON .)
    ID              reduce using rule 41 (rule -> map_assignment COLON .)
    APPEND          reduce using rule 41 (rule -> map_assignment COLON .)
    LEN             reduce using rule 41 (rule -> map_assignment COLON .)
    COPY            reduce using rule 41 (rule -> map_assignment COLON .)
    DELETE          reduce using rule 41 (rule -> map_assignment COLON .)
    IF              reduce using rule 41 (rule -> map_assignment COLON .)
    ELSE            reduce using rule 41 (rule -> map_assignment COLON .)
    TYPE            reduce using rule 41 (rule -> map_assignment COLON .)
    SWITCH          reduce using rule 41 (rule -> map_assignment COLON .)
    VAR             reduce using rule 41 (rule -> map_assignment COLON .)
    FUNC            reduce using rule 41 (rule -> map_assignment COLON .)
    INTEGER         reduce using rule 41 (rule -> map_assignment COLON .)
    FLOAT           reduce using rule 41 (rule -> map_assignment COLON .)
    NOT             reduce using rule 41 (rule -> map_assignment COLON .)
    $end            reduce using rule 41 (rule -> map_assignment COLON .)
    RLLAVE          reduce using rule 41 (rule -> map_assignment COLON .)
    INT32           reduce using rule 41 (rule -> map_assignment COLON .)
    INT64           reduce using rule 41 (rule -> map_assignment COLON .)
    FLOAT32         reduce using rule 41 (rule -> map_assignment COLON .)
    FLOAT64         reduce using rule 41 (rule -> map_assignment COLON .)
    BYTE            reduce using rule 41 (rule -> map_assignment COLON .)
    WFLOAT          reduce using rule 41 (rule -> map_assignment COLON .)
    WSTRING         reduce using rule 41 (rule -> map_assignment COLON .)
    WINT            reduce using rule 41 (rule -> map_assignment COLON .)
    BOOL            reduce using rule 41 (rule -> map_assignment COLON .)
    DEFAULT         reduce using rule 41 (rule -> map_assignment COLON .)
    CASE            reduce using rule 41 (rule -> map_assignment COLON .)
    RETURN          reduce using rule 41 (rule -> map_assignment COLON .)
    STRING          reduce using rule 41 (rule -> map_assignment COLON .)
    TRUE            reduce using rule 41 (rule -> map_assignment COLON .)
    FALSE           reduce using rule 41 (rule -> map_assignment COLON .)


state 78

    (232) impresion -> PRINT LPAREN . content RPAREN
    (233) content -> . values
    (234) content -> . operations
    (235) content -> . funciones
    (236) content -> . data_structure
    (237) content -> . ID
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID

    ID              shift and go to state 165
    STRING          shift and go to state 147
    INTEGER         shift and go to state 148
    FLOAT           shift and go to state 149
    TRUE            shift and go to state 150
    FALSE           shift and go to state 151
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    NOT             shift and go to state 56

    content                        shift and go to state 160
    values                         shift and go to state 161
    operations                     shift and go to state 162
    funciones                      shift and go to state 163
    data_structure                 shift and go to state 164
    expression                     shift and go to state 152
    comparison                     shift and go to state 153
    logic_operation                shift and go to state 154
    call_func                      shift and go to state 46
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36

state 79

    (83) scan_func -> SCAN LPAREN . POINTER RPAREN

    POINTER         shift and go to state 166


state 80

    (239) expression -> something_ex adicionaEx .

    COLON           reduce using rule 239 (expression -> something_ex adicionaEx .)
    PRINT           reduce using rule 239 (expression -> something_ex adicionaEx .)
    SCAN            reduce using rule 239 (expression -> something_ex adicionaEx .)
    FOR             reduce using rule 239 (expression -> something_ex adicionaEx .)
    CONST           reduce using rule 239 (expression -> something_ex adicionaEx .)
    ID              reduce using rule 239 (expression -> something_ex adicionaEx .)
    APPEND          reduce using rule 239 (expression -> something_ex adicionaEx .)
    LEN             reduce using rule 239 (expression -> something_ex adicionaEx .)
    COPY            reduce using rule 239 (expression -> something_ex adicionaEx .)
    DELETE          reduce using rule 239 (expression -> something_ex adicionaEx .)
    IF              reduce using rule 239 (expression -> something_ex adicionaEx .)
    ELSE            reduce using rule 239 (expression -> something_ex adicionaEx .)
    TYPE            reduce using rule 239 (expression -> something_ex adicionaEx .)
    SWITCH          reduce using rule 239 (expression -> something_ex adicionaEx .)
    VAR             reduce using rule 239 (expression -> something_ex adicionaEx .)
    FUNC            reduce using rule 239 (expression -> something_ex adicionaEx .)
    INTEGER         reduce using rule 239 (expression -> something_ex adicionaEx .)
    FLOAT           reduce using rule 239 (expression -> something_ex adicionaEx .)
    NOT             reduce using rule 239 (expression -> something_ex adicionaEx .)
    $end            reduce using rule 239 (expression -> something_ex adicionaEx .)
    GREATER         reduce using rule 239 (expression -> something_ex adicionaEx .)
    SMALLER         reduce using rule 239 (expression -> something_ex adicionaEx .)
    GREATER_OR_EQUAL reduce using rule 239 (expression -> something_ex adicionaEx .)
    SMALLER_OR_EQUAL reduce using rule 239 (expression -> something_ex adicionaEx .)
    EQUAL_COMPARE   reduce using rule 239 (expression -> something_ex adicionaEx .)
    NOT_EQUAL       reduce using rule 239 (expression -> something_ex adicionaEx .)
    PLUS            reduce using rule 239 (expression -> something_ex adicionaEx .)
    TIMES           reduce using rule 239 (expression -> something_ex adicionaEx .)
    DIVIDE          reduce using rule 239 (expression -> something_ex adicionaEx .)
    MINUS           reduce using rule 239 (expression -> something_ex adicionaEx .)
    MOD             reduce using rule 239 (expression -> something_ex adicionaEx .)
    RLLAVE          reduce using rule 239 (expression -> something_ex adicionaEx .)
    INT32           reduce using rule 239 (expression -> something_ex adicionaEx .)
    INT64           reduce using rule 239 (expression -> something_ex adicionaEx .)
    FLOAT32         reduce using rule 239 (expression -> something_ex adicionaEx .)
    FLOAT64         reduce using rule 239 (expression -> something_ex adicionaEx .)
    BYTE            reduce using rule 239 (expression -> something_ex adicionaEx .)
    WFLOAT          reduce using rule 239 (expression -> something_ex adicionaEx .)
    WSTRING         reduce using rule 239 (expression -> something_ex adicionaEx .)
    WINT            reduce using rule 239 (expression -> something_ex adicionaEx .)
    BOOL            reduce using rule 239 (expression -> something_ex adicionaEx .)
    DEFAULT         reduce using rule 239 (expression -> something_ex adicionaEx .)
    CASE            reduce using rule 239 (expression -> something_ex adicionaEx .)
    RETURN          reduce using rule 239 (expression -> something_ex adicionaEx .)
    STRING          reduce using rule 239 (expression -> something_ex adicionaEx .)
    TRUE            reduce using rule 239 (expression -> something_ex adicionaEx .)
    FALSE           reduce using rule 239 (expression -> something_ex adicionaEx .)
    RPAREN          reduce using rule 239 (expression -> something_ex adicionaEx .)
    AND             reduce using rule 239 (expression -> something_ex adicionaEx .)
    OR              reduce using rule 239 (expression -> something_ex adicionaEx .)
    LLLAVE          reduce using rule 239 (expression -> something_ex adicionaEx .)
    RCORCHE         reduce using rule 239 (expression -> something_ex adicionaEx .)
    COMA            reduce using rule 239 (expression -> something_ex adicionaEx .)


state 81

    (240) adicionaEx -> op . something_ex
    (241) adicionaEx -> op . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 168
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    something_ex                   shift and go to state 167
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 82

    (181) op -> GREATER .

    ID              reduce using rule 181 (op -> GREATER .)
    INTEGER         reduce using rule 181 (op -> GREATER .)
    FLOAT           reduce using rule 181 (op -> GREATER .)
    APPEND          reduce using rule 181 (op -> GREATER .)
    LEN             reduce using rule 181 (op -> GREATER .)
    COPY            reduce using rule 181 (op -> GREATER .)
    DELETE          reduce using rule 181 (op -> GREATER .)


state 83

    (182) op -> SMALLER .

    ID              reduce using rule 182 (op -> SMALLER .)
    INTEGER         reduce using rule 182 (op -> SMALLER .)
    FLOAT           reduce using rule 182 (op -> SMALLER .)
    APPEND          reduce using rule 182 (op -> SMALLER .)
    LEN             reduce using rule 182 (op -> SMALLER .)
    COPY            reduce using rule 182 (op -> SMALLER .)
    DELETE          reduce using rule 182 (op -> SMALLER .)


state 84

    (183) op -> GREATER_OR_EQUAL .

    ID              reduce using rule 183 (op -> GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 183 (op -> GREATER_OR_EQUAL .)
    FLOAT           reduce using rule 183 (op -> GREATER_OR_EQUAL .)
    APPEND          reduce using rule 183 (op -> GREATER_OR_EQUAL .)
    LEN             reduce using rule 183 (op -> GREATER_OR_EQUAL .)
    COPY            reduce using rule 183 (op -> GREATER_OR_EQUAL .)
    DELETE          reduce using rule 183 (op -> GREATER_OR_EQUAL .)


state 85

    (184) op -> SMALLER_OR_EQUAL .

    ID              reduce using rule 184 (op -> SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 184 (op -> SMALLER_OR_EQUAL .)
    FLOAT           reduce using rule 184 (op -> SMALLER_OR_EQUAL .)
    APPEND          reduce using rule 184 (op -> SMALLER_OR_EQUAL .)
    LEN             reduce using rule 184 (op -> SMALLER_OR_EQUAL .)
    COPY            reduce using rule 184 (op -> SMALLER_OR_EQUAL .)
    DELETE          reduce using rule 184 (op -> SMALLER_OR_EQUAL .)


state 86

    (185) op -> EQUAL_COMPARE .

    ID              reduce using rule 185 (op -> EQUAL_COMPARE .)
    INTEGER         reduce using rule 185 (op -> EQUAL_COMPARE .)
    FLOAT           reduce using rule 185 (op -> EQUAL_COMPARE .)
    APPEND          reduce using rule 185 (op -> EQUAL_COMPARE .)
    LEN             reduce using rule 185 (op -> EQUAL_COMPARE .)
    COPY            reduce using rule 185 (op -> EQUAL_COMPARE .)
    DELETE          reduce using rule 185 (op -> EQUAL_COMPARE .)


state 87

    (186) op -> NOT_EQUAL .

    ID              reduce using rule 186 (op -> NOT_EQUAL .)
    INTEGER         reduce using rule 186 (op -> NOT_EQUAL .)
    FLOAT           reduce using rule 186 (op -> NOT_EQUAL .)
    APPEND          reduce using rule 186 (op -> NOT_EQUAL .)
    LEN             reduce using rule 186 (op -> NOT_EQUAL .)
    COPY            reduce using rule 186 (op -> NOT_EQUAL .)
    DELETE          reduce using rule 186 (op -> NOT_EQUAL .)


state 88

    (247) op -> PLUS .

    ID              reduce using rule 247 (op -> PLUS .)
    INTEGER         reduce using rule 247 (op -> PLUS .)
    FLOAT           reduce using rule 247 (op -> PLUS .)
    APPEND          reduce using rule 247 (op -> PLUS .)
    LEN             reduce using rule 247 (op -> PLUS .)
    COPY            reduce using rule 247 (op -> PLUS .)
    DELETE          reduce using rule 247 (op -> PLUS .)


state 89

    (248) op -> TIMES .

    ID              reduce using rule 248 (op -> TIMES .)
    INTEGER         reduce using rule 248 (op -> TIMES .)
    FLOAT           reduce using rule 248 (op -> TIMES .)
    APPEND          reduce using rule 248 (op -> TIMES .)
    LEN             reduce using rule 248 (op -> TIMES .)
    COPY            reduce using rule 248 (op -> TIMES .)
    DELETE          reduce using rule 248 (op -> TIMES .)


state 90

    (249) op -> DIVIDE .

    ID              reduce using rule 249 (op -> DIVIDE .)
    INTEGER         reduce using rule 249 (op -> DIVIDE .)
    FLOAT           reduce using rule 249 (op -> DIVIDE .)
    APPEND          reduce using rule 249 (op -> DIVIDE .)
    LEN             reduce using rule 249 (op -> DIVIDE .)
    COPY            reduce using rule 249 (op -> DIVIDE .)
    DELETE          reduce using rule 249 (op -> DIVIDE .)


state 91

    (250) op -> MINUS .

    ID              reduce using rule 250 (op -> MINUS .)
    INTEGER         reduce using rule 250 (op -> MINUS .)
    FLOAT           reduce using rule 250 (op -> MINUS .)
    APPEND          reduce using rule 250 (op -> MINUS .)
    LEN             reduce using rule 250 (op -> MINUS .)
    COPY            reduce using rule 250 (op -> MINUS .)
    DELETE          reduce using rule 250 (op -> MINUS .)


state 92

    (251) op -> MOD .

    ID              reduce using rule 251 (op -> MOD .)
    INTEGER         reduce using rule 251 (op -> MOD .)
    FLOAT           reduce using rule 251 (op -> MOD .)
    APPEND          reduce using rule 251 (op -> MOD .)
    LEN             reduce using rule 251 (op -> MOD .)
    COPY            reduce using rule 251 (op -> MOD .)
    DELETE          reduce using rule 251 (op -> MOD .)


state 93

    (89) cicloFor -> FOR LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 169
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 94

    (90) cicloFor -> FOR comparison . LLLAVE codigo RLLAVE
    (192) logic_value -> comparison .

    LLLAVE          shift and go to state 170
    AND             reduce using rule 192 (logic_value -> comparison .)
    OR              reduce using rule 192 (logic_value -> comparison .)


state 95

    (91) cicloFor -> FOR logic_operation . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 171


state 96

    (92) cicloFor -> FOR decVarOne . COLON comparison COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 172


state 97

    (158) decVarOne -> ID . DEQUAL ID
    (159) decVarOne -> ID . DEQUAL INTEGER
    (179) value -> ID .
    (193) logic_value -> ID .
    (242) something_ex -> ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 179 (value -> ID .)
    DEQUAL          shift and go to state 173
    GREATER         reduce using rule 179 (value -> ID .)
    SMALLER         reduce using rule 179 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 179 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 179 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 179 (value -> ID .)
    NOT_EQUAL       reduce using rule 179 (value -> ID .)
    PLUS            reduce using rule 179 (value -> ID .)
    TIMES           reduce using rule 179 (value -> ID .)
    DIVIDE          reduce using rule 179 (value -> ID .)
    MINUS           reduce using rule 179 (value -> ID .)
    MOD             reduce using rule 179 (value -> ID .)
    AND             reduce using rule 193 (logic_value -> ID .)
    OR              reduce using rule 193 (logic_value -> ID .)
    LCORCHE         shift and go to state 174
    LPAREN          shift and go to state 112

  ! GREATER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 242 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 242 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 242 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 242 (something_ex -> ID .) ]


state 98

    (180) value -> expression .

    GREATER         reduce using rule 180 (value -> expression .)
    SMALLER         reduce using rule 180 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 180 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 180 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 180 (value -> expression .)
    NOT_EQUAL       reduce using rule 180 (value -> expression .)
    PLUS            reduce using rule 180 (value -> expression .)
    TIMES           reduce using rule 180 (value -> expression .)
    DIVIDE          reduce using rule 180 (value -> expression .)
    MINUS           reduce using rule 180 (value -> expression .)
    MOD             reduce using rule 180 (value -> expression .)
    PRINT           reduce using rule 180 (value -> expression .)
    SCAN            reduce using rule 180 (value -> expression .)
    FOR             reduce using rule 180 (value -> expression .)
    CONST           reduce using rule 180 (value -> expression .)
    ID              reduce using rule 180 (value -> expression .)
    APPEND          reduce using rule 180 (value -> expression .)
    LEN             reduce using rule 180 (value -> expression .)
    COPY            reduce using rule 180 (value -> expression .)
    DELETE          reduce using rule 180 (value -> expression .)
    IF              reduce using rule 180 (value -> expression .)
    ELSE            reduce using rule 180 (value -> expression .)
    TYPE            reduce using rule 180 (value -> expression .)
    SWITCH          reduce using rule 180 (value -> expression .)
    VAR             reduce using rule 180 (value -> expression .)
    FUNC            reduce using rule 180 (value -> expression .)
    INTEGER         reduce using rule 180 (value -> expression .)
    FLOAT           reduce using rule 180 (value -> expression .)
    NOT             reduce using rule 180 (value -> expression .)
    $end            reduce using rule 180 (value -> expression .)
    AND             reduce using rule 180 (value -> expression .)
    OR              reduce using rule 180 (value -> expression .)
    RLLAVE          reduce using rule 180 (value -> expression .)
    INT32           reduce using rule 180 (value -> expression .)
    INT64           reduce using rule 180 (value -> expression .)
    FLOAT32         reduce using rule 180 (value -> expression .)
    FLOAT64         reduce using rule 180 (value -> expression .)
    BYTE            reduce using rule 180 (value -> expression .)
    WFLOAT          reduce using rule 180 (value -> expression .)
    WSTRING         reduce using rule 180 (value -> expression .)
    WINT            reduce using rule 180 (value -> expression .)
    BOOL            reduce using rule 180 (value -> expression .)
    DEFAULT         reduce using rule 180 (value -> expression .)
    CASE            reduce using rule 180 (value -> expression .)
    RETURN          reduce using rule 180 (value -> expression .)
    STRING          reduce using rule 180 (value -> expression .)
    TRUE            reduce using rule 180 (value -> expression .)
    FALSE           reduce using rule 180 (value -> expression .)
    LLLAVE          reduce using rule 180 (value -> expression .)
    COLON           reduce using rule 180 (value -> expression .)
    RPAREN          reduce using rule 180 (value -> expression .)
    RCORCHE         reduce using rule 180 (value -> expression .)
    COMA            reduce using rule 180 (value -> expression .)


state 99

    (246) something_ex -> funciones .

    GREATER         reduce using rule 246 (something_ex -> funciones .)
    SMALLER         reduce using rule 246 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 246 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 246 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 246 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 246 (something_ex -> funciones .)
    PLUS            reduce using rule 246 (something_ex -> funciones .)
    TIMES           reduce using rule 246 (something_ex -> funciones .)
    DIVIDE          reduce using rule 246 (something_ex -> funciones .)
    MINUS           reduce using rule 246 (something_ex -> funciones .)
    MOD             reduce using rule 246 (something_ex -> funciones .)
    COLON           reduce using rule 246 (something_ex -> funciones .)
    PRINT           reduce using rule 246 (something_ex -> funciones .)
    SCAN            reduce using rule 246 (something_ex -> funciones .)
    FOR             reduce using rule 246 (something_ex -> funciones .)
    CONST           reduce using rule 246 (something_ex -> funciones .)
    ID              reduce using rule 246 (something_ex -> funciones .)
    APPEND          reduce using rule 246 (something_ex -> funciones .)
    LEN             reduce using rule 246 (something_ex -> funciones .)
    COPY            reduce using rule 246 (something_ex -> funciones .)
    DELETE          reduce using rule 246 (something_ex -> funciones .)
    IF              reduce using rule 246 (something_ex -> funciones .)
    ELSE            reduce using rule 246 (something_ex -> funciones .)
    TYPE            reduce using rule 246 (something_ex -> funciones .)
    SWITCH          reduce using rule 246 (something_ex -> funciones .)
    VAR             reduce using rule 246 (something_ex -> funciones .)
    FUNC            reduce using rule 246 (something_ex -> funciones .)
    INTEGER         reduce using rule 246 (something_ex -> funciones .)
    FLOAT           reduce using rule 246 (something_ex -> funciones .)
    NOT             reduce using rule 246 (something_ex -> funciones .)
    $end            reduce using rule 246 (something_ex -> funciones .)
    RLLAVE          reduce using rule 246 (something_ex -> funciones .)
    INT32           reduce using rule 246 (something_ex -> funciones .)
    INT64           reduce using rule 246 (something_ex -> funciones .)
    FLOAT32         reduce using rule 246 (something_ex -> funciones .)
    FLOAT64         reduce using rule 246 (something_ex -> funciones .)
    BYTE            reduce using rule 246 (something_ex -> funciones .)
    WFLOAT          reduce using rule 246 (something_ex -> funciones .)
    WSTRING         reduce using rule 246 (something_ex -> funciones .)
    WINT            reduce using rule 246 (something_ex -> funciones .)
    BOOL            reduce using rule 246 (something_ex -> funciones .)
    DEFAULT         reduce using rule 246 (something_ex -> funciones .)
    CASE            reduce using rule 246 (something_ex -> funciones .)
    RETURN          reduce using rule 246 (something_ex -> funciones .)
    STRING          reduce using rule 246 (something_ex -> funciones .)
    TRUE            reduce using rule 246 (something_ex -> funciones .)
    FALSE           reduce using rule 246 (something_ex -> funciones .)
    RPAREN          reduce using rule 246 (something_ex -> funciones .)
    AND             reduce using rule 246 (something_ex -> funciones .)
    OR              reduce using rule 246 (something_ex -> funciones .)
    LLLAVE          reduce using rule 246 (something_ex -> funciones .)
    RCORCHE         reduce using rule 246 (something_ex -> funciones .)
    COMA            reduce using rule 246 (something_ex -> funciones .)


state 100

    (62) data_structure -> array_var .

    GREATER         reduce using rule 62 (data_structure -> array_var .)
    SMALLER         reduce using rule 62 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 62 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 62 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 62 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 62 (data_structure -> array_var .)
    PLUS            reduce using rule 62 (data_structure -> array_var .)
    TIMES           reduce using rule 62 (data_structure -> array_var .)
    DIVIDE          reduce using rule 62 (data_structure -> array_var .)
    MINUS           reduce using rule 62 (data_structure -> array_var .)
    MOD             reduce using rule 62 (data_structure -> array_var .)
    COLON           reduce using rule 62 (data_structure -> array_var .)
    PRINT           reduce using rule 62 (data_structure -> array_var .)
    SCAN            reduce using rule 62 (data_structure -> array_var .)
    FOR             reduce using rule 62 (data_structure -> array_var .)
    CONST           reduce using rule 62 (data_structure -> array_var .)
    ID              reduce using rule 62 (data_structure -> array_var .)
    APPEND          reduce using rule 62 (data_structure -> array_var .)
    LEN             reduce using rule 62 (data_structure -> array_var .)
    COPY            reduce using rule 62 (data_structure -> array_var .)
    DELETE          reduce using rule 62 (data_structure -> array_var .)
    IF              reduce using rule 62 (data_structure -> array_var .)
    ELSE            reduce using rule 62 (data_structure -> array_var .)
    TYPE            reduce using rule 62 (data_structure -> array_var .)
    SWITCH          reduce using rule 62 (data_structure -> array_var .)
    VAR             reduce using rule 62 (data_structure -> array_var .)
    FUNC            reduce using rule 62 (data_structure -> array_var .)
    INTEGER         reduce using rule 62 (data_structure -> array_var .)
    FLOAT           reduce using rule 62 (data_structure -> array_var .)
    NOT             reduce using rule 62 (data_structure -> array_var .)
    $end            reduce using rule 62 (data_structure -> array_var .)
    RLLAVE          reduce using rule 62 (data_structure -> array_var .)
    INT32           reduce using rule 62 (data_structure -> array_var .)
    INT64           reduce using rule 62 (data_structure -> array_var .)
    FLOAT32         reduce using rule 62 (data_structure -> array_var .)
    FLOAT64         reduce using rule 62 (data_structure -> array_var .)
    BYTE            reduce using rule 62 (data_structure -> array_var .)
    WFLOAT          reduce using rule 62 (data_structure -> array_var .)
    WSTRING         reduce using rule 62 (data_structure -> array_var .)
    WINT            reduce using rule 62 (data_structure -> array_var .)
    BOOL            reduce using rule 62 (data_structure -> array_var .)
    DEFAULT         reduce using rule 62 (data_structure -> array_var .)
    CASE            reduce using rule 62 (data_structure -> array_var .)
    RETURN          reduce using rule 62 (data_structure -> array_var .)
    STRING          reduce using rule 62 (data_structure -> array_var .)
    TRUE            reduce using rule 62 (data_structure -> array_var .)
    FALSE           reduce using rule 62 (data_structure -> array_var .)
    RPAREN          reduce using rule 62 (data_structure -> array_var .)
    AND             reduce using rule 62 (data_structure -> array_var .)
    OR              reduce using rule 62 (data_structure -> array_var .)
    LLLAVE          reduce using rule 62 (data_structure -> array_var .)
    RCORCHE         reduce using rule 62 (data_structure -> array_var .)
    COMA            reduce using rule 62 (data_structure -> array_var .)


state 101

    (63) data_structure -> map_var .

    GREATER         reduce using rule 63 (data_structure -> map_var .)
    SMALLER         reduce using rule 63 (data_structure -> map_var .)
    GREATER_OR_EQUAL reduce using rule 63 (data_structure -> map_var .)
    SMALLER_OR_EQUAL reduce using rule 63 (data_structure -> map_var .)
    EQUAL_COMPARE   reduce using rule 63 (data_structure -> map_var .)
    NOT_EQUAL       reduce using rule 63 (data_structure -> map_var .)
    PLUS            reduce using rule 63 (data_structure -> map_var .)
    TIMES           reduce using rule 63 (data_structure -> map_var .)
    DIVIDE          reduce using rule 63 (data_structure -> map_var .)
    MINUS           reduce using rule 63 (data_structure -> map_var .)
    MOD             reduce using rule 63 (data_structure -> map_var .)
    COLON           reduce using rule 63 (data_structure -> map_var .)
    PRINT           reduce using rule 63 (data_structure -> map_var .)
    SCAN            reduce using rule 63 (data_structure -> map_var .)
    FOR             reduce using rule 63 (data_structure -> map_var .)
    CONST           reduce using rule 63 (data_structure -> map_var .)
    ID              reduce using rule 63 (data_structure -> map_var .)
    APPEND          reduce using rule 63 (data_structure -> map_var .)
    LEN             reduce using rule 63 (data_structure -> map_var .)
    COPY            reduce using rule 63 (data_structure -> map_var .)
    DELETE          reduce using rule 63 (data_structure -> map_var .)
    IF              reduce using rule 63 (data_structure -> map_var .)
    ELSE            reduce using rule 63 (data_structure -> map_var .)
    TYPE            reduce using rule 63 (data_structure -> map_var .)
    SWITCH          reduce using rule 63 (data_structure -> map_var .)
    VAR             reduce using rule 63 (data_structure -> map_var .)
    FUNC            reduce using rule 63 (data_structure -> map_var .)
    INTEGER         reduce using rule 63 (data_structure -> map_var .)
    FLOAT           reduce using rule 63 (data_structure -> map_var .)
    NOT             reduce using rule 63 (data_structure -> map_var .)
    $end            reduce using rule 63 (data_structure -> map_var .)
    RLLAVE          reduce using rule 63 (data_structure -> map_var .)
    INT32           reduce using rule 63 (data_structure -> map_var .)
    INT64           reduce using rule 63 (data_structure -> map_var .)
    FLOAT32         reduce using rule 63 (data_structure -> map_var .)
    FLOAT64         reduce using rule 63 (data_structure -> map_var .)
    BYTE            reduce using rule 63 (data_structure -> map_var .)
    WFLOAT          reduce using rule 63 (data_structure -> map_var .)
    WSTRING         reduce using rule 63 (data_structure -> map_var .)
    WINT            reduce using rule 63 (data_structure -> map_var .)
    BOOL            reduce using rule 63 (data_structure -> map_var .)
    DEFAULT         reduce using rule 63 (data_structure -> map_var .)
    CASE            reduce using rule 63 (data_structure -> map_var .)
    RETURN          reduce using rule 63 (data_structure -> map_var .)
    STRING          reduce using rule 63 (data_structure -> map_var .)
    TRUE            reduce using rule 63 (data_structure -> map_var .)
    FALSE           reduce using rule 63 (data_structure -> map_var .)
    RPAREN          reduce using rule 63 (data_structure -> map_var .)
    AND             reduce using rule 63 (data_structure -> map_var .)
    OR              reduce using rule 63 (data_structure -> map_var .)
    LLLAVE          reduce using rule 63 (data_structure -> map_var .)
    RCORCHE         reduce using rule 63 (data_structure -> map_var .)
    COMA            reduce using rule 63 (data_structure -> map_var .)


state 102

    (64) data_structure -> slice_var .

    GREATER         reduce using rule 64 (data_structure -> slice_var .)
    SMALLER         reduce using rule 64 (data_structure -> slice_var .)
    GREATER_OR_EQUAL reduce using rule 64 (data_structure -> slice_var .)
    SMALLER_OR_EQUAL reduce using rule 64 (data_structure -> slice_var .)
    EQUAL_COMPARE   reduce using rule 64 (data_structure -> slice_var .)
    NOT_EQUAL       reduce using rule 64 (data_structure -> slice_var .)
    PLUS            reduce using rule 64 (data_structure -> slice_var .)
    TIMES           reduce using rule 64 (data_structure -> slice_var .)
    DIVIDE          reduce using rule 64 (data_structure -> slice_var .)
    MINUS           reduce using rule 64 (data_structure -> slice_var .)
    MOD             reduce using rule 64 (data_structure -> slice_var .)
    COLON           reduce using rule 64 (data_structure -> slice_var .)
    PRINT           reduce using rule 64 (data_structure -> slice_var .)
    SCAN            reduce using rule 64 (data_structure -> slice_var .)
    FOR             reduce using rule 64 (data_structure -> slice_var .)
    CONST           reduce using rule 64 (data_structure -> slice_var .)
    ID              reduce using rule 64 (data_structure -> slice_var .)
    APPEND          reduce using rule 64 (data_structure -> slice_var .)
    LEN             reduce using rule 64 (data_structure -> slice_var .)
    COPY            reduce using rule 64 (data_structure -> slice_var .)
    DELETE          reduce using rule 64 (data_structure -> slice_var .)
    IF              reduce using rule 64 (data_structure -> slice_var .)
    ELSE            reduce using rule 64 (data_structure -> slice_var .)
    TYPE            reduce using rule 64 (data_structure -> slice_var .)
    SWITCH          reduce using rule 64 (data_structure -> slice_var .)
    VAR             reduce using rule 64 (data_structure -> slice_var .)
    FUNC            reduce using rule 64 (data_structure -> slice_var .)
    INTEGER         reduce using rule 64 (data_structure -> slice_var .)
    FLOAT           reduce using rule 64 (data_structure -> slice_var .)
    NOT             reduce using rule 64 (data_structure -> slice_var .)
    $end            reduce using rule 64 (data_structure -> slice_var .)
    RLLAVE          reduce using rule 64 (data_structure -> slice_var .)
    INT32           reduce using rule 64 (data_structure -> slice_var .)
    INT64           reduce using rule 64 (data_structure -> slice_var .)
    FLOAT32         reduce using rule 64 (data_structure -> slice_var .)
    FLOAT64         reduce using rule 64 (data_structure -> slice_var .)
    BYTE            reduce using rule 64 (data_structure -> slice_var .)
    WFLOAT          reduce using rule 64 (data_structure -> slice_var .)
    WSTRING         reduce using rule 64 (data_structure -> slice_var .)
    WINT            reduce using rule 64 (data_structure -> slice_var .)
    BOOL            reduce using rule 64 (data_structure -> slice_var .)
    DEFAULT         reduce using rule 64 (data_structure -> slice_var .)
    CASE            reduce using rule 64 (data_structure -> slice_var .)
    RETURN          reduce using rule 64 (data_structure -> slice_var .)
    STRING          reduce using rule 64 (data_structure -> slice_var .)
    TRUE            reduce using rule 64 (data_structure -> slice_var .)
    FALSE           reduce using rule 64 (data_structure -> slice_var .)
    RPAREN          reduce using rule 64 (data_structure -> slice_var .)
    AND             reduce using rule 64 (data_structure -> slice_var .)
    OR              reduce using rule 64 (data_structure -> slice_var .)
    LLLAVE          reduce using rule 64 (data_structure -> slice_var .)
    RCORCHE         reduce using rule 64 (data_structure -> slice_var .)
    COMA            reduce using rule 64 (data_structure -> slice_var .)


state 103

    (178) comparison -> value op . value
    (179) value -> . ID
    (180) value -> . expression
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 120
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    value                          shift and go to state 175
    expression                     shift and go to state 98
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 104

    (187) logic_operation -> logic_value logic_recu .

    PRINT           reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    SCAN            reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    FOR             reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    CONST           reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    ID              reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    APPEND          reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    LEN             reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    COPY            reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    DELETE          reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    IF              reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    ELSE            reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    TYPE            reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    SWITCH          reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    VAR             reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    FUNC            reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    INTEGER         reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    FLOAT           reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    NOT             reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    $end            reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    RLLAVE          reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    INT32           reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    INT64           reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    FLOAT32         reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    FLOAT64         reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    BYTE            reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    WFLOAT          reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    WSTRING         reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    WINT            reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    BOOL            reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    DEFAULT         reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    CASE            reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    RETURN          reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    STRING          reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    TRUE            reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    FALSE           reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    LLLAVE          reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    COLON           reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    RPAREN          reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    RCORCHE         reduce using rule 187 (logic_operation -> logic_value logic_recu .)
    COMA            reduce using rule 187 (logic_operation -> logic_value logic_recu .)


state 105

    (189) logic_recu -> logic_op . logic_value
    (190) logic_recu -> logic_op . logic_value logic_recu
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (178) comparison -> . value op value
    (179) value -> . ID
    (180) value -> . expression
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 179
    NOT             shift and go to state 56
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    logic_value                    shift and go to state 176
    negation                       shift and go to state 177
    comparison                     shift and go to state 178
    value                          shift and go to state 34
    expression                     shift and go to state 98
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 106

    (196) logic_op -> AND .

    ID              reduce using rule 196 (logic_op -> AND .)
    NOT             reduce using rule 196 (logic_op -> AND .)
    INTEGER         reduce using rule 196 (logic_op -> AND .)
    FLOAT           reduce using rule 196 (logic_op -> AND .)
    APPEND          reduce using rule 196 (logic_op -> AND .)
    LEN             reduce using rule 196 (logic_op -> AND .)
    COPY            reduce using rule 196 (logic_op -> AND .)
    DELETE          reduce using rule 196 (logic_op -> AND .)


state 107

    (197) logic_op -> OR .

    ID              reduce using rule 197 (logic_op -> OR .)
    NOT             reduce using rule 197 (logic_op -> OR .)
    INTEGER         reduce using rule 197 (logic_op -> OR .)
    FLOAT           reduce using rule 197 (logic_op -> OR .)
    APPEND          reduce using rule 197 (logic_op -> OR .)
    LEN             reduce using rule 197 (logic_op -> OR .)
    COPY            reduce using rule 197 (logic_op -> OR .)
    DELETE          reduce using rule 197 (logic_op -> OR .)


state 108

    (111) decConst -> CONST ID . data_type_and_value
    (112) decConst -> CONST ID . EQUAL ID
    (113) decConst -> CONST ID . EQUAL data_structure
    (95) data_type_and_value -> . WSTRING EQUAL STRING
    (96) data_type_and_value -> . WINT EQUAL int_value
    (97) data_type_and_value -> . INT32 EQUAL int_value
    (98) data_type_and_value -> . INT64 EQUAL int_value
    (99) data_type_and_value -> . WFLOAT EQUAL float_value
    (100) data_type_and_value -> . FLOAT32 EQUAL float_value
    (101) data_type_and_value -> . FLOAT64 EQUAL float_value
    (102) data_type_and_value -> . BOOL EQUAL bool_value

    EQUAL           shift and go to state 181
    WSTRING         shift and go to state 182
    WINT            shift and go to state 183
    INT32           shift and go to state 184
    INT64           shift and go to state 185
    WFLOAT          shift and go to state 186
    FLOAT32         shift and go to state 187
    FLOAT64         shift and go to state 188
    BOOL            shift and go to state 189

    data_type_and_value            shift and go to state 180

state 109

    (65) var_asignation -> ID EQUAL . any
    (66) any -> . values
    (67) any -> . operations
    (68) any -> . ID
    (69) any -> . data_structure
    (70) any -> . funciones
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID

    ID              shift and go to state 190
    STRING          shift and go to state 147
    INTEGER         shift and go to state 148
    FLOAT           shift and go to state 149
    TRUE            shift and go to state 150
    FALSE           shift and go to state 151
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    NOT             shift and go to state 56

    any                            shift and go to state 191
    values                         shift and go to state 192
    operations                     shift and go to state 193
    data_structure                 shift and go to state 194
    funciones                      shift and go to state 195
    expression                     shift and go to state 152
    comparison                     shift and go to state 153
    logic_operation                shift and go to state 154
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36

state 110

    (171) cStruct -> ID DEQUAL . ID LLLAVE asignaciones RLLAVE
    (136) slice_declaration -> ID DEQUAL . funM
    (137) slice_declaration -> ID DEQUAL . LCORCHE RCORCHE data_types arr_content
    (127) dynamic -> ID DEQUAL . algo
    (138) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (139) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
    (128) algo -> . values
    (129) algo -> . operations
    (130) algo -> . ID
    (131) algo -> . data_structure
    (132) algo -> . funciones
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID

    ID              shift and go to state 196
    LCORCHE         shift and go to state 198
    MAKE            shift and go to state 200
    STRING          shift and go to state 147
    INTEGER         shift and go to state 148
    FLOAT           shift and go to state 149
    TRUE            shift and go to state 150
    FALSE           shift and go to state 151
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    NOT             shift and go to state 56

    funM                           shift and go to state 197
    algo                           shift and go to state 199
    values                         shift and go to state 201
    operations                     shift and go to state 202
    data_structure                 shift and go to state 203
    funciones                      shift and go to state 204
    expression                     shift and go to state 152
    comparison                     shift and go to state 153
    logic_operation                shift and go to state 154
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36

state 111

    (208) array_var -> ID LCORCHE . index RCORCHE
    (143) slice_var -> ID LCORCHE . index_s RCORCHE
    (214) map_var -> ID LCORCHE . key RCORCHE
    (209) index -> . ID
    (210) index -> . INTEGER
    (211) index -> . expression
    (144) index_s -> . ID
    (145) index_s -> . INTEGER
    (146) index_s -> . expression
    (215) key -> . ID
    (216) key -> . values
    (217) key -> . operations
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 205
    INTEGER         shift and go to state 209
    STRING          shift and go to state 147
    FLOAT           shift and go to state 149
    TRUE            shift and go to state 150
    FALSE           shift and go to state 151
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    NOT             shift and go to state 56

    index                          shift and go to state 206
    index_s                        shift and go to state 207
    key                            shift and go to state 208
    expression                     shift and go to state 210
    values                         shift and go to state 211
    operations                     shift and go to state 212
    something_ex                   shift and go to state 32
    comparison                     shift and go to state 153
    logic_operation                shift and go to state 154
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 112

    (84) call_func -> ID LPAREN . list_params RPAREN
    (85) call_func -> ID LPAREN . RPAREN
    (86) list_params -> . ID
    (87) list_params -> . ID COMA more_p

    RPAREN          shift and go to state 215
    ID              shift and go to state 213

    list_params                    shift and go to state 214

state 113

    (152) funciones -> APPEND LPAREN . ID COMA values RPAREN
    (153) funciones -> APPEND LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 216


state 114

    (154) funciones -> LEN LPAREN . ID RPAREN

    ID              shift and go to state 217


state 115

    (155) funciones -> COPY LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 218


state 116

    (156) funciones -> DELETE LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 219


state 117

    (160) SenIF -> IF comparison . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 220


state 118

    (161) SenIF -> IF TRUE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 221


state 119

    (162) SenIF -> IF FALSE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 222


state 120

    (179) value -> ID .
    (242) something_ex -> ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for CONST resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for INT32 resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for INT64 resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for BYTE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for WSTRING resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for WINT resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for STRING resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TRUE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for FALSE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for LLLAVE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 179 (value -> ID .)
    GREATER         reduce using rule 179 (value -> ID .)
    SMALLER         reduce using rule 179 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 179 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 179 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 179 (value -> ID .)
    NOT_EQUAL       reduce using rule 179 (value -> ID .)
    PLUS            reduce using rule 179 (value -> ID .)
    TIMES           reduce using rule 179 (value -> ID .)
    DIVIDE          reduce using rule 179 (value -> ID .)
    MINUS           reduce using rule 179 (value -> ID .)
    MOD             reduce using rule 179 (value -> ID .)
    PRINT           reduce using rule 179 (value -> ID .)
    SCAN            reduce using rule 179 (value -> ID .)
    FOR             reduce using rule 179 (value -> ID .)
    CONST           reduce using rule 179 (value -> ID .)
    ID              reduce using rule 179 (value -> ID .)
    APPEND          reduce using rule 179 (value -> ID .)
    LEN             reduce using rule 179 (value -> ID .)
    COPY            reduce using rule 179 (value -> ID .)
    DELETE          reduce using rule 179 (value -> ID .)
    IF              reduce using rule 179 (value -> ID .)
    ELSE            reduce using rule 179 (value -> ID .)
    TYPE            reduce using rule 179 (value -> ID .)
    SWITCH          reduce using rule 179 (value -> ID .)
    VAR             reduce using rule 179 (value -> ID .)
    FUNC            reduce using rule 179 (value -> ID .)
    INTEGER         reduce using rule 179 (value -> ID .)
    FLOAT           reduce using rule 179 (value -> ID .)
    NOT             reduce using rule 179 (value -> ID .)
    $end            reduce using rule 179 (value -> ID .)
    AND             reduce using rule 179 (value -> ID .)
    OR              reduce using rule 179 (value -> ID .)
    RLLAVE          reduce using rule 179 (value -> ID .)
    INT32           reduce using rule 179 (value -> ID .)
    INT64           reduce using rule 179 (value -> ID .)
    FLOAT32         reduce using rule 179 (value -> ID .)
    FLOAT64         reduce using rule 179 (value -> ID .)
    BYTE            reduce using rule 179 (value -> ID .)
    WFLOAT          reduce using rule 179 (value -> ID .)
    WSTRING         reduce using rule 179 (value -> ID .)
    WINT            reduce using rule 179 (value -> ID .)
    BOOL            reduce using rule 179 (value -> ID .)
    DEFAULT         reduce using rule 179 (value -> ID .)
    CASE            reduce using rule 179 (value -> ID .)
    RETURN          reduce using rule 179 (value -> ID .)
    STRING          reduce using rule 179 (value -> ID .)
    TRUE            reduce using rule 179 (value -> ID .)
    FALSE           reduce using rule 179 (value -> ID .)
    LLLAVE          reduce using rule 179 (value -> ID .)
    COLON           reduce using rule 179 (value -> ID .)
    RPAREN          reduce using rule 179 (value -> ID .)
    RCORCHE         reduce using rule 179 (value -> ID .)
    COMA            reduce using rule 179 (value -> ID .)
    LCORCHE         shift and go to state 174
    LPAREN          shift and go to state 112

  ! GREATER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 242 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 242 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 242 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 242 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 242 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 242 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 242 (something_ex -> ID .) ]
  ! CONST           [ reduce using rule 242 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 242 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 242 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 242 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 242 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 242 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 242 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 242 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 242 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 242 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 242 (something_ex -> ID .) ]
  ! AND             [ reduce using rule 242 (something_ex -> ID .) ]
  ! OR              [ reduce using rule 242 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! INT32           [ reduce using rule 242 (something_ex -> ID .) ]
  ! INT64           [ reduce using rule 242 (something_ex -> ID .) ]
  ! FLOAT32         [ reduce using rule 242 (something_ex -> ID .) ]
  ! FLOAT64         [ reduce using rule 242 (something_ex -> ID .) ]
  ! BYTE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! WFLOAT          [ reduce using rule 242 (something_ex -> ID .) ]
  ! WSTRING         [ reduce using rule 242 (something_ex -> ID .) ]
  ! WINT            [ reduce using rule 242 (something_ex -> ID .) ]
  ! BOOL            [ reduce using rule 242 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 242 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 242 (something_ex -> ID .) ]
  ! STRING          [ reduce using rule 242 (something_ex -> ID .) ]
  ! TRUE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! FALSE           [ reduce using rule 242 (something_ex -> ID .) ]
  ! LLLAVE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 242 (something_ex -> ID .) ]
  ! RPAREN          [ reduce using rule 242 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 242 (something_ex -> ID .) ]
  ! COMA            [ reduce using rule 242 (something_ex -> ID .) ]


state 121

    (163) SenElseIF -> ELSE IF . comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> ELSE IF . TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> ELSE IF . FALSE LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (179) value -> . ID
    (180) value -> . expression
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    TRUE            shift and go to state 224
    FALSE           shift and go to state 225
    ID              shift and go to state 120
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    comparison                     shift and go to state 223
    value                          shift and go to state 34
    expression                     shift and go to state 98
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 122

    (166) SenElse -> ELSE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 226
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 123

    (167) SenStruct -> TYPE ID . STRUCT LLLAVE declaration RLLAVE

    STRUCT          shift and go to state 227


state 124

    (198) switch_statement -> SWITCH ID . LLLAVE cases RLLAVE

    LLLAVE          shift and go to state 228


state 125

    (203) array_declaration -> VAR ID . LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> VAR ID . EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (133) slice_declaration -> VAR ID . LCORCHE RCORCHE data_types
    (134) slice_declaration -> VAR ID . EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> VAR ID . EQUAL funM
    (213) map_declaration -> VAR ID . LCORCHE data_types RCORCHE data_types
    (122) single -> VAR ID . data_types
    (123) single -> VAR ID . data_types EQUAL funciones
    (124) single -> VAR ID . data_types EQUAL ID
    (125) single -> VAR ID . data_types EQUAL data_structure
    (126) single -> VAR ID . data_type_and_value
    (119) list_var -> VAR ID . COMA more
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WFLOAT
    (56) data_types -> . WSTRING
    (57) data_types -> . WINT
    (58) data_types -> . BOOL
    (95) data_type_and_value -> . WSTRING EQUAL STRING
    (96) data_type_and_value -> . WINT EQUAL int_value
    (97) data_type_and_value -> . INT32 EQUAL int_value
    (98) data_type_and_value -> . INT64 EQUAL int_value
    (99) data_type_and_value -> . WFLOAT EQUAL float_value
    (100) data_type_and_value -> . FLOAT32 EQUAL float_value
    (101) data_type_and_value -> . FLOAT64 EQUAL float_value
    (102) data_type_and_value -> . BOOL EQUAL bool_value

    LCORCHE         shift and go to state 229
    EQUAL           shift and go to state 231
    COMA            shift and go to state 233
    INT32           shift and go to state 234
    INT64           shift and go to state 235
    FLOAT32         shift and go to state 236
    FLOAT64         shift and go to state 237
    BYTE            shift and go to state 136
    WFLOAT          shift and go to state 238
    WSTRING         shift and go to state 239
    WINT            shift and go to state 240
    BOOL            shift and go to state 241

    data_types                     shift and go to state 230
    data_type_and_value            shift and go to state 232

state 126

    (218) map_assignment -> map_var EQUAL . something
    (77) something -> . ID
    (78) something -> . data_structure
    (79) something -> . values
    (80) something -> . operations
    (81) something -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID

    ID              shift and go to state 142
    STRING          shift and go to state 147
    INTEGER         shift and go to state 148
    FLOAT           shift and go to state 149
    TRUE            shift and go to state 150
    FALSE           shift and go to state 151
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    NOT             shift and go to state 56

    map_var                        shift and go to state 101
    something                      shift and go to state 242
    data_structure                 shift and go to state 143
    values                         shift and go to state 144
    operations                     shift and go to state 145
    funciones                      shift and go to state 146
    array_var                      shift and go to state 100
    slice_var                      shift and go to state 102
    expression                     shift and go to state 152
    comparison                     shift and go to state 153
    logic_operation                shift and go to state 154
    call_func                      shift and go to state 46
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36

state 127

    (219) func_declaration -> FUNC ID . LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> FUNC ID . LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE

    LPAREN          shift and go to state 243


state 128

    (82) main_func -> FUNC MAIN . LPAREN RPAREN LLLAVE codigo RLLAVE

    LPAREN          shift and go to state 244


state 129

    (194) negation -> NOT comparison .

    PRINT           reduce using rule 194 (negation -> NOT comparison .)
    SCAN            reduce using rule 194 (negation -> NOT comparison .)
    FOR             reduce using rule 194 (negation -> NOT comparison .)
    CONST           reduce using rule 194 (negation -> NOT comparison .)
    ID              reduce using rule 194 (negation -> NOT comparison .)
    APPEND          reduce using rule 194 (negation -> NOT comparison .)
    LEN             reduce using rule 194 (negation -> NOT comparison .)
    COPY            reduce using rule 194 (negation -> NOT comparison .)
    DELETE          reduce using rule 194 (negation -> NOT comparison .)
    IF              reduce using rule 194 (negation -> NOT comparison .)
    ELSE            reduce using rule 194 (negation -> NOT comparison .)
    TYPE            reduce using rule 194 (negation -> NOT comparison .)
    SWITCH          reduce using rule 194 (negation -> NOT comparison .)
    VAR             reduce using rule 194 (negation -> NOT comparison .)
    FUNC            reduce using rule 194 (negation -> NOT comparison .)
    INTEGER         reduce using rule 194 (negation -> NOT comparison .)
    FLOAT           reduce using rule 194 (negation -> NOT comparison .)
    NOT             reduce using rule 194 (negation -> NOT comparison .)
    $end            reduce using rule 194 (negation -> NOT comparison .)
    AND             reduce using rule 194 (negation -> NOT comparison .)
    OR              reduce using rule 194 (negation -> NOT comparison .)
    RLLAVE          reduce using rule 194 (negation -> NOT comparison .)
    INT32           reduce using rule 194 (negation -> NOT comparison .)
    INT64           reduce using rule 194 (negation -> NOT comparison .)
    FLOAT32         reduce using rule 194 (negation -> NOT comparison .)
    FLOAT64         reduce using rule 194 (negation -> NOT comparison .)
    BYTE            reduce using rule 194 (negation -> NOT comparison .)
    WFLOAT          reduce using rule 194 (negation -> NOT comparison .)
    WSTRING         reduce using rule 194 (negation -> NOT comparison .)
    WINT            reduce using rule 194 (negation -> NOT comparison .)
    BOOL            reduce using rule 194 (negation -> NOT comparison .)
    DEFAULT         reduce using rule 194 (negation -> NOT comparison .)
    CASE            reduce using rule 194 (negation -> NOT comparison .)
    RETURN          reduce using rule 194 (negation -> NOT comparison .)
    STRING          reduce using rule 194 (negation -> NOT comparison .)
    TRUE            reduce using rule 194 (negation -> NOT comparison .)
    FALSE           reduce using rule 194 (negation -> NOT comparison .)
    LLLAVE          reduce using rule 194 (negation -> NOT comparison .)
    COLON           reduce using rule 194 (negation -> NOT comparison .)
    RPAREN          reduce using rule 194 (negation -> NOT comparison .)
    RCORCHE         reduce using rule 194 (negation -> NOT comparison .)
    COMA            reduce using rule 194 (negation -> NOT comparison .)


state 130

    (195) negation -> NOT ID .
    (179) value -> ID .
    (242) something_ex -> ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 179 (value -> ID .)
    PRINT           reduce using rule 195 (negation -> NOT ID .)
    SCAN            reduce using rule 195 (negation -> NOT ID .)
    FOR             reduce using rule 195 (negation -> NOT ID .)
    CONST           reduce using rule 195 (negation -> NOT ID .)
    ID              reduce using rule 195 (negation -> NOT ID .)
    APPEND          reduce using rule 195 (negation -> NOT ID .)
    LEN             reduce using rule 195 (negation -> NOT ID .)
    COPY            reduce using rule 195 (negation -> NOT ID .)
    DELETE          reduce using rule 195 (negation -> NOT ID .)
    IF              reduce using rule 195 (negation -> NOT ID .)
    ELSE            reduce using rule 195 (negation -> NOT ID .)
    TYPE            reduce using rule 195 (negation -> NOT ID .)
    SWITCH          reduce using rule 195 (negation -> NOT ID .)
    VAR             reduce using rule 195 (negation -> NOT ID .)
    FUNC            reduce using rule 195 (negation -> NOT ID .)
    INTEGER         reduce using rule 195 (negation -> NOT ID .)
    FLOAT           reduce using rule 195 (negation -> NOT ID .)
    NOT             reduce using rule 195 (negation -> NOT ID .)
    $end            reduce using rule 195 (negation -> NOT ID .)
    AND             reduce using rule 195 (negation -> NOT ID .)
    OR              reduce using rule 195 (negation -> NOT ID .)
    RLLAVE          reduce using rule 195 (negation -> NOT ID .)
    INT32           reduce using rule 195 (negation -> NOT ID .)
    INT64           reduce using rule 195 (negation -> NOT ID .)
    FLOAT32         reduce using rule 195 (negation -> NOT ID .)
    FLOAT64         reduce using rule 195 (negation -> NOT ID .)
    BYTE            reduce using rule 195 (negation -> NOT ID .)
    WFLOAT          reduce using rule 195 (negation -> NOT ID .)
    WSTRING         reduce using rule 195 (negation -> NOT ID .)
    WINT            reduce using rule 195 (negation -> NOT ID .)
    BOOL            reduce using rule 195 (negation -> NOT ID .)
    DEFAULT         reduce using rule 195 (negation -> NOT ID .)
    CASE            reduce using rule 195 (negation -> NOT ID .)
    RETURN          reduce using rule 195 (negation -> NOT ID .)
    STRING          reduce using rule 195 (negation -> NOT ID .)
    TRUE            reduce using rule 195 (negation -> NOT ID .)
    FALSE           reduce using rule 195 (negation -> NOT ID .)
    LLLAVE          reduce using rule 195 (negation -> NOT ID .)
    COLON           reduce using rule 195 (negation -> NOT ID .)
    RPAREN          reduce using rule 195 (negation -> NOT ID .)
    RCORCHE         reduce using rule 195 (negation -> NOT ID .)
    COMA            reduce using rule 195 (negation -> NOT ID .)
    GREATER         reduce using rule 179 (value -> ID .)
    SMALLER         reduce using rule 179 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 179 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 179 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 179 (value -> ID .)
    NOT_EQUAL       reduce using rule 179 (value -> ID .)
    PLUS            reduce using rule 179 (value -> ID .)
    TIMES           reduce using rule 179 (value -> ID .)
    DIVIDE          reduce using rule 179 (value -> ID .)
    MINUS           reduce using rule 179 (value -> ID .)
    MOD             reduce using rule 179 (value -> ID .)
    LCORCHE         shift and go to state 174
    LPAREN          shift and go to state 112

  ! GREATER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 242 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 242 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 242 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 242 (something_ex -> ID .) ]


state 131

    (118) multiple -> list_var data_types .

    COLON           reduce using rule 118 (multiple -> list_var data_types .)
    PRINT           reduce using rule 118 (multiple -> list_var data_types .)
    SCAN            reduce using rule 118 (multiple -> list_var data_types .)
    FOR             reduce using rule 118 (multiple -> list_var data_types .)
    CONST           reduce using rule 118 (multiple -> list_var data_types .)
    ID              reduce using rule 118 (multiple -> list_var data_types .)
    APPEND          reduce using rule 118 (multiple -> list_var data_types .)
    LEN             reduce using rule 118 (multiple -> list_var data_types .)
    COPY            reduce using rule 118 (multiple -> list_var data_types .)
    DELETE          reduce using rule 118 (multiple -> list_var data_types .)
    IF              reduce using rule 118 (multiple -> list_var data_types .)
    ELSE            reduce using rule 118 (multiple -> list_var data_types .)
    TYPE            reduce using rule 118 (multiple -> list_var data_types .)
    SWITCH          reduce using rule 118 (multiple -> list_var data_types .)
    VAR             reduce using rule 118 (multiple -> list_var data_types .)
    FUNC            reduce using rule 118 (multiple -> list_var data_types .)
    INTEGER         reduce using rule 118 (multiple -> list_var data_types .)
    FLOAT           reduce using rule 118 (multiple -> list_var data_types .)
    NOT             reduce using rule 118 (multiple -> list_var data_types .)
    $end            reduce using rule 118 (multiple -> list_var data_types .)
    RLLAVE          reduce using rule 118 (multiple -> list_var data_types .)
    INT32           reduce using rule 118 (multiple -> list_var data_types .)
    INT64           reduce using rule 118 (multiple -> list_var data_types .)
    FLOAT32         reduce using rule 118 (multiple -> list_var data_types .)
    FLOAT64         reduce using rule 118 (multiple -> list_var data_types .)
    BYTE            reduce using rule 118 (multiple -> list_var data_types .)
    WFLOAT          reduce using rule 118 (multiple -> list_var data_types .)
    WSTRING         reduce using rule 118 (multiple -> list_var data_types .)
    WINT            reduce using rule 118 (multiple -> list_var data_types .)
    BOOL            reduce using rule 118 (multiple -> list_var data_types .)
    DEFAULT         reduce using rule 118 (multiple -> list_var data_types .)
    CASE            reduce using rule 118 (multiple -> list_var data_types .)
    RETURN          reduce using rule 118 (multiple -> list_var data_types .)
    STRING          reduce using rule 118 (multiple -> list_var data_types .)
    TRUE            reduce using rule 118 (multiple -> list_var data_types .)
    FALSE           reduce using rule 118 (multiple -> list_var data_types .)


state 132

    (50) data_types -> INT32 .

    COLON           reduce using rule 50 (data_types -> INT32 .)
    PRINT           reduce using rule 50 (data_types -> INT32 .)
    SCAN            reduce using rule 50 (data_types -> INT32 .)
    FOR             reduce using rule 50 (data_types -> INT32 .)
    CONST           reduce using rule 50 (data_types -> INT32 .)
    ID              reduce using rule 50 (data_types -> INT32 .)
    APPEND          reduce using rule 50 (data_types -> INT32 .)
    LEN             reduce using rule 50 (data_types -> INT32 .)
    COPY            reduce using rule 50 (data_types -> INT32 .)
    DELETE          reduce using rule 50 (data_types -> INT32 .)
    IF              reduce using rule 50 (data_types -> INT32 .)
    ELSE            reduce using rule 50 (data_types -> INT32 .)
    TYPE            reduce using rule 50 (data_types -> INT32 .)
    SWITCH          reduce using rule 50 (data_types -> INT32 .)
    VAR             reduce using rule 50 (data_types -> INT32 .)
    FUNC            reduce using rule 50 (data_types -> INT32 .)
    INTEGER         reduce using rule 50 (data_types -> INT32 .)
    FLOAT           reduce using rule 50 (data_types -> INT32 .)
    NOT             reduce using rule 50 (data_types -> INT32 .)
    $end            reduce using rule 50 (data_types -> INT32 .)
    RLLAVE          reduce using rule 50 (data_types -> INT32 .)
    INT32           reduce using rule 50 (data_types -> INT32 .)
    INT64           reduce using rule 50 (data_types -> INT32 .)
    FLOAT32         reduce using rule 50 (data_types -> INT32 .)
    FLOAT64         reduce using rule 50 (data_types -> INT32 .)
    BYTE            reduce using rule 50 (data_types -> INT32 .)
    WFLOAT          reduce using rule 50 (data_types -> INT32 .)
    WSTRING         reduce using rule 50 (data_types -> INT32 .)
    WINT            reduce using rule 50 (data_types -> INT32 .)
    BOOL            reduce using rule 50 (data_types -> INT32 .)
    DEFAULT         reduce using rule 50 (data_types -> INT32 .)
    CASE            reduce using rule 50 (data_types -> INT32 .)
    RETURN          reduce using rule 50 (data_types -> INT32 .)
    STRING          reduce using rule 50 (data_types -> INT32 .)
    TRUE            reduce using rule 50 (data_types -> INT32 .)
    FALSE           reduce using rule 50 (data_types -> INT32 .)
    RCORCHE         reduce using rule 50 (data_types -> INT32 .)
    LLLAVE          reduce using rule 50 (data_types -> INT32 .)
    COMA            reduce using rule 50 (data_types -> INT32 .)
    RPAREN          reduce using rule 50 (data_types -> INT32 .)


state 133

    (51) data_types -> INT64 .

    COLON           reduce using rule 51 (data_types -> INT64 .)
    PRINT           reduce using rule 51 (data_types -> INT64 .)
    SCAN            reduce using rule 51 (data_types -> INT64 .)
    FOR             reduce using rule 51 (data_types -> INT64 .)
    CONST           reduce using rule 51 (data_types -> INT64 .)
    ID              reduce using rule 51 (data_types -> INT64 .)
    APPEND          reduce using rule 51 (data_types -> INT64 .)
    LEN             reduce using rule 51 (data_types -> INT64 .)
    COPY            reduce using rule 51 (data_types -> INT64 .)
    DELETE          reduce using rule 51 (data_types -> INT64 .)
    IF              reduce using rule 51 (data_types -> INT64 .)
    ELSE            reduce using rule 51 (data_types -> INT64 .)
    TYPE            reduce using rule 51 (data_types -> INT64 .)
    SWITCH          reduce using rule 51 (data_types -> INT64 .)
    VAR             reduce using rule 51 (data_types -> INT64 .)
    FUNC            reduce using rule 51 (data_types -> INT64 .)
    INTEGER         reduce using rule 51 (data_types -> INT64 .)
    FLOAT           reduce using rule 51 (data_types -> INT64 .)
    NOT             reduce using rule 51 (data_types -> INT64 .)
    $end            reduce using rule 51 (data_types -> INT64 .)
    RLLAVE          reduce using rule 51 (data_types -> INT64 .)
    INT32           reduce using rule 51 (data_types -> INT64 .)
    INT64           reduce using rule 51 (data_types -> INT64 .)
    FLOAT32         reduce using rule 51 (data_types -> INT64 .)
    FLOAT64         reduce using rule 51 (data_types -> INT64 .)
    BYTE            reduce using rule 51 (data_types -> INT64 .)
    WFLOAT          reduce using rule 51 (data_types -> INT64 .)
    WSTRING         reduce using rule 51 (data_types -> INT64 .)
    WINT            reduce using rule 51 (data_types -> INT64 .)
    BOOL            reduce using rule 51 (data_types -> INT64 .)
    DEFAULT         reduce using rule 51 (data_types -> INT64 .)
    CASE            reduce using rule 51 (data_types -> INT64 .)
    RETURN          reduce using rule 51 (data_types -> INT64 .)
    STRING          reduce using rule 51 (data_types -> INT64 .)
    TRUE            reduce using rule 51 (data_types -> INT64 .)
    FALSE           reduce using rule 51 (data_types -> INT64 .)
    RCORCHE         reduce using rule 51 (data_types -> INT64 .)
    LLLAVE          reduce using rule 51 (data_types -> INT64 .)
    COMA            reduce using rule 51 (data_types -> INT64 .)
    RPAREN          reduce using rule 51 (data_types -> INT64 .)


state 134

    (52) data_types -> FLOAT32 .

    COLON           reduce using rule 52 (data_types -> FLOAT32 .)
    PRINT           reduce using rule 52 (data_types -> FLOAT32 .)
    SCAN            reduce using rule 52 (data_types -> FLOAT32 .)
    FOR             reduce using rule 52 (data_types -> FLOAT32 .)
    CONST           reduce using rule 52 (data_types -> FLOAT32 .)
    ID              reduce using rule 52 (data_types -> FLOAT32 .)
    APPEND          reduce using rule 52 (data_types -> FLOAT32 .)
    LEN             reduce using rule 52 (data_types -> FLOAT32 .)
    COPY            reduce using rule 52 (data_types -> FLOAT32 .)
    DELETE          reduce using rule 52 (data_types -> FLOAT32 .)
    IF              reduce using rule 52 (data_types -> FLOAT32 .)
    ELSE            reduce using rule 52 (data_types -> FLOAT32 .)
    TYPE            reduce using rule 52 (data_types -> FLOAT32 .)
    SWITCH          reduce using rule 52 (data_types -> FLOAT32 .)
    VAR             reduce using rule 52 (data_types -> FLOAT32 .)
    FUNC            reduce using rule 52 (data_types -> FLOAT32 .)
    INTEGER         reduce using rule 52 (data_types -> FLOAT32 .)
    FLOAT           reduce using rule 52 (data_types -> FLOAT32 .)
    NOT             reduce using rule 52 (data_types -> FLOAT32 .)
    $end            reduce using rule 52 (data_types -> FLOAT32 .)
    RLLAVE          reduce using rule 52 (data_types -> FLOAT32 .)
    INT32           reduce using rule 52 (data_types -> FLOAT32 .)
    INT64           reduce using rule 52 (data_types -> FLOAT32 .)
    FLOAT32         reduce using rule 52 (data_types -> FLOAT32 .)
    FLOAT64         reduce using rule 52 (data_types -> FLOAT32 .)
    BYTE            reduce using rule 52 (data_types -> FLOAT32 .)
    WFLOAT          reduce using rule 52 (data_types -> FLOAT32 .)
    WSTRING         reduce using rule 52 (data_types -> FLOAT32 .)
    WINT            reduce using rule 52 (data_types -> FLOAT32 .)
    BOOL            reduce using rule 52 (data_types -> FLOAT32 .)
    DEFAULT         reduce using rule 52 (data_types -> FLOAT32 .)
    CASE            reduce using rule 52 (data_types -> FLOAT32 .)
    RETURN          reduce using rule 52 (data_types -> FLOAT32 .)
    STRING          reduce using rule 52 (data_types -> FLOAT32 .)
    TRUE            reduce using rule 52 (data_types -> FLOAT32 .)
    FALSE           reduce using rule 52 (data_types -> FLOAT32 .)
    RCORCHE         reduce using rule 52 (data_types -> FLOAT32 .)
    LLLAVE          reduce using rule 52 (data_types -> FLOAT32 .)
    COMA            reduce using rule 52 (data_types -> FLOAT32 .)
    RPAREN          reduce using rule 52 (data_types -> FLOAT32 .)


state 135

    (53) data_types -> FLOAT64 .

    COLON           reduce using rule 53 (data_types -> FLOAT64 .)
    PRINT           reduce using rule 53 (data_types -> FLOAT64 .)
    SCAN            reduce using rule 53 (data_types -> FLOAT64 .)
    FOR             reduce using rule 53 (data_types -> FLOAT64 .)
    CONST           reduce using rule 53 (data_types -> FLOAT64 .)
    ID              reduce using rule 53 (data_types -> FLOAT64 .)
    APPEND          reduce using rule 53 (data_types -> FLOAT64 .)
    LEN             reduce using rule 53 (data_types -> FLOAT64 .)
    COPY            reduce using rule 53 (data_types -> FLOAT64 .)
    DELETE          reduce using rule 53 (data_types -> FLOAT64 .)
    IF              reduce using rule 53 (data_types -> FLOAT64 .)
    ELSE            reduce using rule 53 (data_types -> FLOAT64 .)
    TYPE            reduce using rule 53 (data_types -> FLOAT64 .)
    SWITCH          reduce using rule 53 (data_types -> FLOAT64 .)
    VAR             reduce using rule 53 (data_types -> FLOAT64 .)
    FUNC            reduce using rule 53 (data_types -> FLOAT64 .)
    INTEGER         reduce using rule 53 (data_types -> FLOAT64 .)
    FLOAT           reduce using rule 53 (data_types -> FLOAT64 .)
    NOT             reduce using rule 53 (data_types -> FLOAT64 .)
    $end            reduce using rule 53 (data_types -> FLOAT64 .)
    RLLAVE          reduce using rule 53 (data_types -> FLOAT64 .)
    INT32           reduce using rule 53 (data_types -> FLOAT64 .)
    INT64           reduce using rule 53 (data_types -> FLOAT64 .)
    FLOAT32         reduce using rule 53 (data_types -> FLOAT64 .)
    FLOAT64         reduce using rule 53 (data_types -> FLOAT64 .)
    BYTE            reduce using rule 53 (data_types -> FLOAT64 .)
    WFLOAT          reduce using rule 53 (data_types -> FLOAT64 .)
    WSTRING         reduce using rule 53 (data_types -> FLOAT64 .)
    WINT            reduce using rule 53 (data_types -> FLOAT64 .)
    BOOL            reduce using rule 53 (data_types -> FLOAT64 .)
    DEFAULT         reduce using rule 53 (data_types -> FLOAT64 .)
    CASE            reduce using rule 53 (data_types -> FLOAT64 .)
    RETURN          reduce using rule 53 (data_types -> FLOAT64 .)
    STRING          reduce using rule 53 (data_types -> FLOAT64 .)
    TRUE            reduce using rule 53 (data_types -> FLOAT64 .)
    FALSE           reduce using rule 53 (data_types -> FLOAT64 .)
    RCORCHE         reduce using rule 53 (data_types -> FLOAT64 .)
    LLLAVE          reduce using rule 53 (data_types -> FLOAT64 .)
    COMA            reduce using rule 53 (data_types -> FLOAT64 .)
    RPAREN          reduce using rule 53 (data_types -> FLOAT64 .)


state 136

    (54) data_types -> BYTE .

    COLON           reduce using rule 54 (data_types -> BYTE .)
    PRINT           reduce using rule 54 (data_types -> BYTE .)
    SCAN            reduce using rule 54 (data_types -> BYTE .)
    FOR             reduce using rule 54 (data_types -> BYTE .)
    CONST           reduce using rule 54 (data_types -> BYTE .)
    ID              reduce using rule 54 (data_types -> BYTE .)
    APPEND          reduce using rule 54 (data_types -> BYTE .)
    LEN             reduce using rule 54 (data_types -> BYTE .)
    COPY            reduce using rule 54 (data_types -> BYTE .)
    DELETE          reduce using rule 54 (data_types -> BYTE .)
    IF              reduce using rule 54 (data_types -> BYTE .)
    ELSE            reduce using rule 54 (data_types -> BYTE .)
    TYPE            reduce using rule 54 (data_types -> BYTE .)
    SWITCH          reduce using rule 54 (data_types -> BYTE .)
    VAR             reduce using rule 54 (data_types -> BYTE .)
    FUNC            reduce using rule 54 (data_types -> BYTE .)
    INTEGER         reduce using rule 54 (data_types -> BYTE .)
    FLOAT           reduce using rule 54 (data_types -> BYTE .)
    NOT             reduce using rule 54 (data_types -> BYTE .)
    $end            reduce using rule 54 (data_types -> BYTE .)
    RLLAVE          reduce using rule 54 (data_types -> BYTE .)
    INT32           reduce using rule 54 (data_types -> BYTE .)
    INT64           reduce using rule 54 (data_types -> BYTE .)
    FLOAT32         reduce using rule 54 (data_types -> BYTE .)
    FLOAT64         reduce using rule 54 (data_types -> BYTE .)
    BYTE            reduce using rule 54 (data_types -> BYTE .)
    WFLOAT          reduce using rule 54 (data_types -> BYTE .)
    WSTRING         reduce using rule 54 (data_types -> BYTE .)
    WINT            reduce using rule 54 (data_types -> BYTE .)
    BOOL            reduce using rule 54 (data_types -> BYTE .)
    DEFAULT         reduce using rule 54 (data_types -> BYTE .)
    CASE            reduce using rule 54 (data_types -> BYTE .)
    RETURN          reduce using rule 54 (data_types -> BYTE .)
    STRING          reduce using rule 54 (data_types -> BYTE .)
    TRUE            reduce using rule 54 (data_types -> BYTE .)
    FALSE           reduce using rule 54 (data_types -> BYTE .)
    EQUAL           reduce using rule 54 (data_types -> BYTE .)
    RCORCHE         reduce using rule 54 (data_types -> BYTE .)
    LLLAVE          reduce using rule 54 (data_types -> BYTE .)
    COMA            reduce using rule 54 (data_types -> BYTE .)
    RPAREN          reduce using rule 54 (data_types -> BYTE .)


state 137

    (55) data_types -> WFLOAT .

    COLON           reduce using rule 55 (data_types -> WFLOAT .)
    PRINT           reduce using rule 55 (data_types -> WFLOAT .)
    SCAN            reduce using rule 55 (data_types -> WFLOAT .)
    FOR             reduce using rule 55 (data_types -> WFLOAT .)
    CONST           reduce using rule 55 (data_types -> WFLOAT .)
    ID              reduce using rule 55 (data_types -> WFLOAT .)
    APPEND          reduce using rule 55 (data_types -> WFLOAT .)
    LEN             reduce using rule 55 (data_types -> WFLOAT .)
    COPY            reduce using rule 55 (data_types -> WFLOAT .)
    DELETE          reduce using rule 55 (data_types -> WFLOAT .)
    IF              reduce using rule 55 (data_types -> WFLOAT .)
    ELSE            reduce using rule 55 (data_types -> WFLOAT .)
    TYPE            reduce using rule 55 (data_types -> WFLOAT .)
    SWITCH          reduce using rule 55 (data_types -> WFLOAT .)
    VAR             reduce using rule 55 (data_types -> WFLOAT .)
    FUNC            reduce using rule 55 (data_types -> WFLOAT .)
    INTEGER         reduce using rule 55 (data_types -> WFLOAT .)
    FLOAT           reduce using rule 55 (data_types -> WFLOAT .)
    NOT             reduce using rule 55 (data_types -> WFLOAT .)
    $end            reduce using rule 55 (data_types -> WFLOAT .)
    RLLAVE          reduce using rule 55 (data_types -> WFLOAT .)
    INT32           reduce using rule 55 (data_types -> WFLOAT .)
    INT64           reduce using rule 55 (data_types -> WFLOAT .)
    FLOAT32         reduce using rule 55 (data_types -> WFLOAT .)
    FLOAT64         reduce using rule 55 (data_types -> WFLOAT .)
    BYTE            reduce using rule 55 (data_types -> WFLOAT .)
    WFLOAT          reduce using rule 55 (data_types -> WFLOAT .)
    WSTRING         reduce using rule 55 (data_types -> WFLOAT .)
    WINT            reduce using rule 55 (data_types -> WFLOAT .)
    BOOL            reduce using rule 55 (data_types -> WFLOAT .)
    DEFAULT         reduce using rule 55 (data_types -> WFLOAT .)
    CASE            reduce using rule 55 (data_types -> WFLOAT .)
    RETURN          reduce using rule 55 (data_types -> WFLOAT .)
    STRING          reduce using rule 55 (data_types -> WFLOAT .)
    TRUE            reduce using rule 55 (data_types -> WFLOAT .)
    FALSE           reduce using rule 55 (data_types -> WFLOAT .)
    RCORCHE         reduce using rule 55 (data_types -> WFLOAT .)
    LLLAVE          reduce using rule 55 (data_types -> WFLOAT .)
    COMA            reduce using rule 55 (data_types -> WFLOAT .)
    RPAREN          reduce using rule 55 (data_types -> WFLOAT .)


state 138

    (56) data_types -> WSTRING .

    COLON           reduce using rule 56 (data_types -> WSTRING .)
    PRINT           reduce using rule 56 (data_types -> WSTRING .)
    SCAN            reduce using rule 56 (data_types -> WSTRING .)
    FOR             reduce using rule 56 (data_types -> WSTRING .)
    CONST           reduce using rule 56 (data_types -> WSTRING .)
    ID              reduce using rule 56 (data_types -> WSTRING .)
    APPEND          reduce using rule 56 (data_types -> WSTRING .)
    LEN             reduce using rule 56 (data_types -> WSTRING .)
    COPY            reduce using rule 56 (data_types -> WSTRING .)
    DELETE          reduce using rule 56 (data_types -> WSTRING .)
    IF              reduce using rule 56 (data_types -> WSTRING .)
    ELSE            reduce using rule 56 (data_types -> WSTRING .)
    TYPE            reduce using rule 56 (data_types -> WSTRING .)
    SWITCH          reduce using rule 56 (data_types -> WSTRING .)
    VAR             reduce using rule 56 (data_types -> WSTRING .)
    FUNC            reduce using rule 56 (data_types -> WSTRING .)
    INTEGER         reduce using rule 56 (data_types -> WSTRING .)
    FLOAT           reduce using rule 56 (data_types -> WSTRING .)
    NOT             reduce using rule 56 (data_types -> WSTRING .)
    $end            reduce using rule 56 (data_types -> WSTRING .)
    RLLAVE          reduce using rule 56 (data_types -> WSTRING .)
    INT32           reduce using rule 56 (data_types -> WSTRING .)
    INT64           reduce using rule 56 (data_types -> WSTRING .)
    FLOAT32         reduce using rule 56 (data_types -> WSTRING .)
    FLOAT64         reduce using rule 56 (data_types -> WSTRING .)
    BYTE            reduce using rule 56 (data_types -> WSTRING .)
    WFLOAT          reduce using rule 56 (data_types -> WSTRING .)
    WSTRING         reduce using rule 56 (data_types -> WSTRING .)
    WINT            reduce using rule 56 (data_types -> WSTRING .)
    BOOL            reduce using rule 56 (data_types -> WSTRING .)
    DEFAULT         reduce using rule 56 (data_types -> WSTRING .)
    CASE            reduce using rule 56 (data_types -> WSTRING .)
    RETURN          reduce using rule 56 (data_types -> WSTRING .)
    STRING          reduce using rule 56 (data_types -> WSTRING .)
    TRUE            reduce using rule 56 (data_types -> WSTRING .)
    FALSE           reduce using rule 56 (data_types -> WSTRING .)
    RCORCHE         reduce using rule 56 (data_types -> WSTRING .)
    LLLAVE          reduce using rule 56 (data_types -> WSTRING .)
    COMA            reduce using rule 56 (data_types -> WSTRING .)
    RPAREN          reduce using rule 56 (data_types -> WSTRING .)


state 139

    (57) data_types -> WINT .

    COLON           reduce using rule 57 (data_types -> WINT .)
    PRINT           reduce using rule 57 (data_types -> WINT .)
    SCAN            reduce using rule 57 (data_types -> WINT .)
    FOR             reduce using rule 57 (data_types -> WINT .)
    CONST           reduce using rule 57 (data_types -> WINT .)
    ID              reduce using rule 57 (data_types -> WINT .)
    APPEND          reduce using rule 57 (data_types -> WINT .)
    LEN             reduce using rule 57 (data_types -> WINT .)
    COPY            reduce using rule 57 (data_types -> WINT .)
    DELETE          reduce using rule 57 (data_types -> WINT .)
    IF              reduce using rule 57 (data_types -> WINT .)
    ELSE            reduce using rule 57 (data_types -> WINT .)
    TYPE            reduce using rule 57 (data_types -> WINT .)
    SWITCH          reduce using rule 57 (data_types -> WINT .)
    VAR             reduce using rule 57 (data_types -> WINT .)
    FUNC            reduce using rule 57 (data_types -> WINT .)
    INTEGER         reduce using rule 57 (data_types -> WINT .)
    FLOAT           reduce using rule 57 (data_types -> WINT .)
    NOT             reduce using rule 57 (data_types -> WINT .)
    $end            reduce using rule 57 (data_types -> WINT .)
    RLLAVE          reduce using rule 57 (data_types -> WINT .)
    INT32           reduce using rule 57 (data_types -> WINT .)
    INT64           reduce using rule 57 (data_types -> WINT .)
    FLOAT32         reduce using rule 57 (data_types -> WINT .)
    FLOAT64         reduce using rule 57 (data_types -> WINT .)
    BYTE            reduce using rule 57 (data_types -> WINT .)
    WFLOAT          reduce using rule 57 (data_types -> WINT .)
    WSTRING         reduce using rule 57 (data_types -> WINT .)
    WINT            reduce using rule 57 (data_types -> WINT .)
    BOOL            reduce using rule 57 (data_types -> WINT .)
    DEFAULT         reduce using rule 57 (data_types -> WINT .)
    CASE            reduce using rule 57 (data_types -> WINT .)
    RETURN          reduce using rule 57 (data_types -> WINT .)
    STRING          reduce using rule 57 (data_types -> WINT .)
    TRUE            reduce using rule 57 (data_types -> WINT .)
    FALSE           reduce using rule 57 (data_types -> WINT .)
    RCORCHE         reduce using rule 57 (data_types -> WINT .)
    LLLAVE          reduce using rule 57 (data_types -> WINT .)
    COMA            reduce using rule 57 (data_types -> WINT .)
    RPAREN          reduce using rule 57 (data_types -> WINT .)


state 140

    (58) data_types -> BOOL .

    COLON           reduce using rule 58 (data_types -> BOOL .)
    PRINT           reduce using rule 58 (data_types -> BOOL .)
    SCAN            reduce using rule 58 (data_types -> BOOL .)
    FOR             reduce using rule 58 (data_types -> BOOL .)
    CONST           reduce using rule 58 (data_types -> BOOL .)
    ID              reduce using rule 58 (data_types -> BOOL .)
    APPEND          reduce using rule 58 (data_types -> BOOL .)
    LEN             reduce using rule 58 (data_types -> BOOL .)
    COPY            reduce using rule 58 (data_types -> BOOL .)
    DELETE          reduce using rule 58 (data_types -> BOOL .)
    IF              reduce using rule 58 (data_types -> BOOL .)
    ELSE            reduce using rule 58 (data_types -> BOOL .)
    TYPE            reduce using rule 58 (data_types -> BOOL .)
    SWITCH          reduce using rule 58 (data_types -> BOOL .)
    VAR             reduce using rule 58 (data_types -> BOOL .)
    FUNC            reduce using rule 58 (data_types -> BOOL .)
    INTEGER         reduce using rule 58 (data_types -> BOOL .)
    FLOAT           reduce using rule 58 (data_types -> BOOL .)
    NOT             reduce using rule 58 (data_types -> BOOL .)
    $end            reduce using rule 58 (data_types -> BOOL .)
    RLLAVE          reduce using rule 58 (data_types -> BOOL .)
    INT32           reduce using rule 58 (data_types -> BOOL .)
    INT64           reduce using rule 58 (data_types -> BOOL .)
    FLOAT32         reduce using rule 58 (data_types -> BOOL .)
    FLOAT64         reduce using rule 58 (data_types -> BOOL .)
    BYTE            reduce using rule 58 (data_types -> BOOL .)
    WFLOAT          reduce using rule 58 (data_types -> BOOL .)
    WSTRING         reduce using rule 58 (data_types -> BOOL .)
    WINT            reduce using rule 58 (data_types -> BOOL .)
    BOOL            reduce using rule 58 (data_types -> BOOL .)
    DEFAULT         reduce using rule 58 (data_types -> BOOL .)
    CASE            reduce using rule 58 (data_types -> BOOL .)
    RETURN          reduce using rule 58 (data_types -> BOOL .)
    STRING          reduce using rule 58 (data_types -> BOOL .)
    TRUE            reduce using rule 58 (data_types -> BOOL .)
    FALSE           reduce using rule 58 (data_types -> BOOL .)
    RCORCHE         reduce using rule 58 (data_types -> BOOL .)
    LLLAVE          reduce using rule 58 (data_types -> BOOL .)
    COMA            reduce using rule 58 (data_types -> BOOL .)
    RPAREN          reduce using rule 58 (data_types -> BOOL .)


state 141

    (212) array_assignment -> array_var EQUAL something .

    COLON           reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    PRINT           reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    SCAN            reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    FOR             reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    CONST           reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    ID              reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    APPEND          reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    LEN             reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    COPY            reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    DELETE          reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    IF              reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    ELSE            reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    TYPE            reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    SWITCH          reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    VAR             reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    FUNC            reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    INTEGER         reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    FLOAT           reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    NOT             reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    $end            reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    RLLAVE          reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    INT32           reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    INT64           reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    FLOAT32         reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    FLOAT64         reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    BYTE            reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    WFLOAT          reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    WSTRING         reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    WINT            reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    BOOL            reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    DEFAULT         reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    CASE            reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    RETURN          reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    STRING          reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    TRUE            reduce using rule 212 (array_assignment -> array_var EQUAL something .)
    FALSE           reduce using rule 212 (array_assignment -> array_var EQUAL something .)


state 142

    (77) something -> ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN
    (242) something_ex -> ID .
    (179) value -> ID .
    (193) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for CONST resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for INT32 resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for INT64 resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for BYTE resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for WSTRING resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for WINT resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for STRING resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for TRUE resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for FALSE resolved using rule 77 (something -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 179 (value -> ID .)
    COLON           reduce using rule 77 (something -> ID .)
    PRINT           reduce using rule 77 (something -> ID .)
    SCAN            reduce using rule 77 (something -> ID .)
    FOR             reduce using rule 77 (something -> ID .)
    CONST           reduce using rule 77 (something -> ID .)
    ID              reduce using rule 77 (something -> ID .)
    APPEND          reduce using rule 77 (something -> ID .)
    LEN             reduce using rule 77 (something -> ID .)
    COPY            reduce using rule 77 (something -> ID .)
    DELETE          reduce using rule 77 (something -> ID .)
    IF              reduce using rule 77 (something -> ID .)
    ELSE            reduce using rule 77 (something -> ID .)
    TYPE            reduce using rule 77 (something -> ID .)
    SWITCH          reduce using rule 77 (something -> ID .)
    VAR             reduce using rule 77 (something -> ID .)
    FUNC            reduce using rule 77 (something -> ID .)
    INTEGER         reduce using rule 77 (something -> ID .)
    FLOAT           reduce using rule 77 (something -> ID .)
    NOT             reduce using rule 77 (something -> ID .)
    $end            reduce using rule 77 (something -> ID .)
    RLLAVE          reduce using rule 77 (something -> ID .)
    INT32           reduce using rule 77 (something -> ID .)
    INT64           reduce using rule 77 (something -> ID .)
    FLOAT32         reduce using rule 77 (something -> ID .)
    FLOAT64         reduce using rule 77 (something -> ID .)
    BYTE            reduce using rule 77 (something -> ID .)
    WFLOAT          reduce using rule 77 (something -> ID .)
    WSTRING         reduce using rule 77 (something -> ID .)
    WINT            reduce using rule 77 (something -> ID .)
    BOOL            reduce using rule 77 (something -> ID .)
    DEFAULT         reduce using rule 77 (something -> ID .)
    CASE            reduce using rule 77 (something -> ID .)
    RETURN          reduce using rule 77 (something -> ID .)
    STRING          reduce using rule 77 (something -> ID .)
    TRUE            reduce using rule 77 (something -> ID .)
    FALSE           reduce using rule 77 (something -> ID .)
    LCORCHE         shift and go to state 174
    LPAREN          shift and go to state 112
    GREATER         reduce using rule 179 (value -> ID .)
    SMALLER         reduce using rule 179 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 179 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 179 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 179 (value -> ID .)
    NOT_EQUAL       reduce using rule 179 (value -> ID .)
    PLUS            reduce using rule 179 (value -> ID .)
    TIMES           reduce using rule 179 (value -> ID .)
    DIVIDE          reduce using rule 179 (value -> ID .)
    MINUS           reduce using rule 179 (value -> ID .)
    MOD             reduce using rule 179 (value -> ID .)
    AND             reduce using rule 193 (logic_value -> ID .)
    OR              reduce using rule 193 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 242 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 242 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 242 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 242 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 242 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 242 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 242 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 242 (something_ex -> ID .) ]
  ! CONST           [ reduce using rule 242 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 242 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 242 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 242 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 242 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 242 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 242 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 242 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 242 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 242 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 242 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! INT32           [ reduce using rule 242 (something_ex -> ID .) ]
  ! INT64           [ reduce using rule 242 (something_ex -> ID .) ]
  ! FLOAT32         [ reduce using rule 242 (something_ex -> ID .) ]
  ! FLOAT64         [ reduce using rule 242 (something_ex -> ID .) ]
  ! BYTE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! WFLOAT          [ reduce using rule 242 (something_ex -> ID .) ]
  ! WSTRING         [ reduce using rule 242 (something_ex -> ID .) ]
  ! WINT            [ reduce using rule 242 (something_ex -> ID .) ]
  ! BOOL            [ reduce using rule 242 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 242 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 242 (something_ex -> ID .) ]
  ! STRING          [ reduce using rule 242 (something_ex -> ID .) ]
  ! TRUE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! FALSE           [ reduce using rule 242 (something_ex -> ID .) ]


state 143

    (78) something -> data_structure .
    (245) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for PRINT resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for SCAN resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for FOR resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for CONST resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for ID resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for APPEND resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for LEN resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for COPY resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for DELETE resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for IF resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for ELSE resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for TYPE resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for SWITCH resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for VAR resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for FUNC resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for INTEGER resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for FLOAT resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for NOT resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for $end resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for INT32 resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for INT64 resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for BYTE resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for WSTRING resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for WINT resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for BOOL resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for CASE resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for RETURN resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for STRING resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for TRUE resolved using rule 78 (something -> data_structure .)
  ! reduce/reduce conflict for FALSE resolved using rule 78 (something -> data_structure .)
    COLON           reduce using rule 78 (something -> data_structure .)
    PRINT           reduce using rule 78 (something -> data_structure .)
    SCAN            reduce using rule 78 (something -> data_structure .)
    FOR             reduce using rule 78 (something -> data_structure .)
    CONST           reduce using rule 78 (something -> data_structure .)
    ID              reduce using rule 78 (something -> data_structure .)
    APPEND          reduce using rule 78 (something -> data_structure .)
    LEN             reduce using rule 78 (something -> data_structure .)
    COPY            reduce using rule 78 (something -> data_structure .)
    DELETE          reduce using rule 78 (something -> data_structure .)
    IF              reduce using rule 78 (something -> data_structure .)
    ELSE            reduce using rule 78 (something -> data_structure .)
    TYPE            reduce using rule 78 (something -> data_structure .)
    SWITCH          reduce using rule 78 (something -> data_structure .)
    VAR             reduce using rule 78 (something -> data_structure .)
    FUNC            reduce using rule 78 (something -> data_structure .)
    INTEGER         reduce using rule 78 (something -> data_structure .)
    FLOAT           reduce using rule 78 (something -> data_structure .)
    NOT             reduce using rule 78 (something -> data_structure .)
    $end            reduce using rule 78 (something -> data_structure .)
    RLLAVE          reduce using rule 78 (something -> data_structure .)
    INT32           reduce using rule 78 (something -> data_structure .)
    INT64           reduce using rule 78 (something -> data_structure .)
    FLOAT32         reduce using rule 78 (something -> data_structure .)
    FLOAT64         reduce using rule 78 (something -> data_structure .)
    BYTE            reduce using rule 78 (something -> data_structure .)
    WFLOAT          reduce using rule 78 (something -> data_structure .)
    WSTRING         reduce using rule 78 (something -> data_structure .)
    WINT            reduce using rule 78 (something -> data_structure .)
    BOOL            reduce using rule 78 (something -> data_structure .)
    DEFAULT         reduce using rule 78 (something -> data_structure .)
    CASE            reduce using rule 78 (something -> data_structure .)
    RETURN          reduce using rule 78 (something -> data_structure .)
    STRING          reduce using rule 78 (something -> data_structure .)
    TRUE            reduce using rule 78 (something -> data_structure .)
    FALSE           reduce using rule 78 (something -> data_structure .)
    GREATER         reduce using rule 245 (something_ex -> data_structure .)
    SMALLER         reduce using rule 245 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 245 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 245 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 245 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 245 (something_ex -> data_structure .)
    PLUS            reduce using rule 245 (something_ex -> data_structure .)
    TIMES           reduce using rule 245 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 245 (something_ex -> data_structure .)
    MINUS           reduce using rule 245 (something_ex -> data_structure .)
    MOD             reduce using rule 245 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! PRINT           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! SCAN            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FOR             [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! CONST           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! ID              [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! APPEND          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! LEN             [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! COPY            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! DELETE          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! IF              [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! ELSE            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! TYPE            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! SWITCH          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! VAR             [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FUNC            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! INTEGER         [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FLOAT           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! NOT             [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! $end            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! INT32           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! INT64           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FLOAT32         [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FLOAT64         [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! BYTE            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! WFLOAT          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! WSTRING         [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! WINT            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! BOOL            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! DEFAULT         [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! CASE            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! RETURN          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! STRING          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! TRUE            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FALSE           [ reduce using rule 245 (something_ex -> data_structure .) ]


state 144

    (79) something -> values .

    COLON           reduce using rule 79 (something -> values .)
    PRINT           reduce using rule 79 (something -> values .)
    SCAN            reduce using rule 79 (something -> values .)
    FOR             reduce using rule 79 (something -> values .)
    CONST           reduce using rule 79 (something -> values .)
    ID              reduce using rule 79 (something -> values .)
    APPEND          reduce using rule 79 (something -> values .)
    LEN             reduce using rule 79 (something -> values .)
    COPY            reduce using rule 79 (something -> values .)
    DELETE          reduce using rule 79 (something -> values .)
    IF              reduce using rule 79 (something -> values .)
    ELSE            reduce using rule 79 (something -> values .)
    TYPE            reduce using rule 79 (something -> values .)
    SWITCH          reduce using rule 79 (something -> values .)
    VAR             reduce using rule 79 (something -> values .)
    FUNC            reduce using rule 79 (something -> values .)
    INTEGER         reduce using rule 79 (something -> values .)
    FLOAT           reduce using rule 79 (something -> values .)
    NOT             reduce using rule 79 (something -> values .)
    $end            reduce using rule 79 (something -> values .)
    RLLAVE          reduce using rule 79 (something -> values .)
    INT32           reduce using rule 79 (something -> values .)
    INT64           reduce using rule 79 (something -> values .)
    FLOAT32         reduce using rule 79 (something -> values .)
    FLOAT64         reduce using rule 79 (something -> values .)
    BYTE            reduce using rule 79 (something -> values .)
    WFLOAT          reduce using rule 79 (something -> values .)
    WSTRING         reduce using rule 79 (something -> values .)
    WINT            reduce using rule 79 (something -> values .)
    BOOL            reduce using rule 79 (something -> values .)
    DEFAULT         reduce using rule 79 (something -> values .)
    CASE            reduce using rule 79 (something -> values .)
    RETURN          reduce using rule 79 (something -> values .)
    STRING          reduce using rule 79 (something -> values .)
    TRUE            reduce using rule 79 (something -> values .)
    FALSE           reduce using rule 79 (something -> values .)


state 145

    (80) something -> operations .

    COLON           reduce using rule 80 (something -> operations .)
    PRINT           reduce using rule 80 (something -> operations .)
    SCAN            reduce using rule 80 (something -> operations .)
    FOR             reduce using rule 80 (something -> operations .)
    CONST           reduce using rule 80 (something -> operations .)
    ID              reduce using rule 80 (something -> operations .)
    APPEND          reduce using rule 80 (something -> operations .)
    LEN             reduce using rule 80 (something -> operations .)
    COPY            reduce using rule 80 (something -> operations .)
    DELETE          reduce using rule 80 (something -> operations .)
    IF              reduce using rule 80 (something -> operations .)
    ELSE            reduce using rule 80 (something -> operations .)
    TYPE            reduce using rule 80 (something -> operations .)
    SWITCH          reduce using rule 80 (something -> operations .)
    VAR             reduce using rule 80 (something -> operations .)
    FUNC            reduce using rule 80 (something -> operations .)
    INTEGER         reduce using rule 80 (something -> operations .)
    FLOAT           reduce using rule 80 (something -> operations .)
    NOT             reduce using rule 80 (something -> operations .)
    $end            reduce using rule 80 (something -> operations .)
    RLLAVE          reduce using rule 80 (something -> operations .)
    INT32           reduce using rule 80 (something -> operations .)
    INT64           reduce using rule 80 (something -> operations .)
    FLOAT32         reduce using rule 80 (something -> operations .)
    FLOAT64         reduce using rule 80 (something -> operations .)
    BYTE            reduce using rule 80 (something -> operations .)
    WFLOAT          reduce using rule 80 (something -> operations .)
    WSTRING         reduce using rule 80 (something -> operations .)
    WINT            reduce using rule 80 (something -> operations .)
    BOOL            reduce using rule 80 (something -> operations .)
    DEFAULT         reduce using rule 80 (something -> operations .)
    CASE            reduce using rule 80 (something -> operations .)
    RETURN          reduce using rule 80 (something -> operations .)
    STRING          reduce using rule 80 (something -> operations .)
    TRUE            reduce using rule 80 (something -> operations .)
    FALSE           reduce using rule 80 (something -> operations .)


state 146

    (81) something -> funciones .
    (246) something_ex -> funciones .

  ! reduce/reduce conflict for COLON resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for PRINT resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for SCAN resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for FOR resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for CONST resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for ID resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for APPEND resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for LEN resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for COPY resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for DELETE resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for IF resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for ELSE resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for TYPE resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for SWITCH resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for VAR resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for FUNC resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for INTEGER resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for FLOAT resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for NOT resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for $end resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for INT32 resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for INT64 resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for BYTE resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for WSTRING resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for WINT resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for BOOL resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for CASE resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for RETURN resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for STRING resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for TRUE resolved using rule 81 (something -> funciones .)
  ! reduce/reduce conflict for FALSE resolved using rule 81 (something -> funciones .)
    COLON           reduce using rule 81 (something -> funciones .)
    PRINT           reduce using rule 81 (something -> funciones .)
    SCAN            reduce using rule 81 (something -> funciones .)
    FOR             reduce using rule 81 (something -> funciones .)
    CONST           reduce using rule 81 (something -> funciones .)
    ID              reduce using rule 81 (something -> funciones .)
    APPEND          reduce using rule 81 (something -> funciones .)
    LEN             reduce using rule 81 (something -> funciones .)
    COPY            reduce using rule 81 (something -> funciones .)
    DELETE          reduce using rule 81 (something -> funciones .)
    IF              reduce using rule 81 (something -> funciones .)
    ELSE            reduce using rule 81 (something -> funciones .)
    TYPE            reduce using rule 81 (something -> funciones .)
    SWITCH          reduce using rule 81 (something -> funciones .)
    VAR             reduce using rule 81 (something -> funciones .)
    FUNC            reduce using rule 81 (something -> funciones .)
    INTEGER         reduce using rule 81 (something -> funciones .)
    FLOAT           reduce using rule 81 (something -> funciones .)
    NOT             reduce using rule 81 (something -> funciones .)
    $end            reduce using rule 81 (something -> funciones .)
    RLLAVE          reduce using rule 81 (something -> funciones .)
    INT32           reduce using rule 81 (something -> funciones .)
    INT64           reduce using rule 81 (something -> funciones .)
    FLOAT32         reduce using rule 81 (something -> funciones .)
    FLOAT64         reduce using rule 81 (something -> funciones .)
    BYTE            reduce using rule 81 (something -> funciones .)
    WFLOAT          reduce using rule 81 (something -> funciones .)
    WSTRING         reduce using rule 81 (something -> funciones .)
    WINT            reduce using rule 81 (something -> funciones .)
    BOOL            reduce using rule 81 (something -> funciones .)
    DEFAULT         reduce using rule 81 (something -> funciones .)
    CASE            reduce using rule 81 (something -> funciones .)
    RETURN          reduce using rule 81 (something -> funciones .)
    STRING          reduce using rule 81 (something -> funciones .)
    TRUE            reduce using rule 81 (something -> funciones .)
    FALSE           reduce using rule 81 (something -> funciones .)
    GREATER         reduce using rule 246 (something_ex -> funciones .)
    SMALLER         reduce using rule 246 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 246 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 246 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 246 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 246 (something_ex -> funciones .)
    PLUS            reduce using rule 246 (something_ex -> funciones .)
    TIMES           reduce using rule 246 (something_ex -> funciones .)
    DIVIDE          reduce using rule 246 (something_ex -> funciones .)
    MINUS           reduce using rule 246 (something_ex -> funciones .)
    MOD             reduce using rule 246 (something_ex -> funciones .)

  ! COLON           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! PRINT           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! SCAN            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FOR             [ reduce using rule 246 (something_ex -> funciones .) ]
  ! CONST           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! ID              [ reduce using rule 246 (something_ex -> funciones .) ]
  ! APPEND          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! LEN             [ reduce using rule 246 (something_ex -> funciones .) ]
  ! COPY            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! DELETE          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! IF              [ reduce using rule 246 (something_ex -> funciones .) ]
  ! ELSE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! TYPE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! SWITCH          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! VAR             [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FUNC            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! INTEGER         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FLOAT           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! NOT             [ reduce using rule 246 (something_ex -> funciones .) ]
  ! $end            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! RLLAVE          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! INT32           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! INT64           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FLOAT32         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FLOAT64         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! BYTE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! WFLOAT          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! WSTRING         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! WINT            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! BOOL            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! DEFAULT         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! CASE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! RETURN          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! STRING          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! TRUE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FALSE           [ reduce using rule 246 (something_ex -> funciones .) ]


state 147

    (45) values -> STRING .

    COLON           reduce using rule 45 (values -> STRING .)
    PRINT           reduce using rule 45 (values -> STRING .)
    SCAN            reduce using rule 45 (values -> STRING .)
    FOR             reduce using rule 45 (values -> STRING .)
    CONST           reduce using rule 45 (values -> STRING .)
    ID              reduce using rule 45 (values -> STRING .)
    APPEND          reduce using rule 45 (values -> STRING .)
    LEN             reduce using rule 45 (values -> STRING .)
    COPY            reduce using rule 45 (values -> STRING .)
    DELETE          reduce using rule 45 (values -> STRING .)
    IF              reduce using rule 45 (values -> STRING .)
    ELSE            reduce using rule 45 (values -> STRING .)
    TYPE            reduce using rule 45 (values -> STRING .)
    SWITCH          reduce using rule 45 (values -> STRING .)
    VAR             reduce using rule 45 (values -> STRING .)
    FUNC            reduce using rule 45 (values -> STRING .)
    INTEGER         reduce using rule 45 (values -> STRING .)
    FLOAT           reduce using rule 45 (values -> STRING .)
    NOT             reduce using rule 45 (values -> STRING .)
    $end            reduce using rule 45 (values -> STRING .)
    RLLAVE          reduce using rule 45 (values -> STRING .)
    INT32           reduce using rule 45 (values -> STRING .)
    INT64           reduce using rule 45 (values -> STRING .)
    FLOAT32         reduce using rule 45 (values -> STRING .)
    FLOAT64         reduce using rule 45 (values -> STRING .)
    BYTE            reduce using rule 45 (values -> STRING .)
    WFLOAT          reduce using rule 45 (values -> STRING .)
    WSTRING         reduce using rule 45 (values -> STRING .)
    WINT            reduce using rule 45 (values -> STRING .)
    BOOL            reduce using rule 45 (values -> STRING .)
    DEFAULT         reduce using rule 45 (values -> STRING .)
    CASE            reduce using rule 45 (values -> STRING .)
    RETURN          reduce using rule 45 (values -> STRING .)
    STRING          reduce using rule 45 (values -> STRING .)
    TRUE            reduce using rule 45 (values -> STRING .)
    FALSE           reduce using rule 45 (values -> STRING .)
    RPAREN          reduce using rule 45 (values -> STRING .)
    RCORCHE         reduce using rule 45 (values -> STRING .)
    POINTS          reduce using rule 45 (values -> STRING .)
    COMA            reduce using rule 45 (values -> STRING .)


state 148

    (46) values -> INTEGER .
    (243) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for PRINT resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for SCAN resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for FOR resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for CONST resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for ID resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for APPEND resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for LEN resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for COPY resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for DELETE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for IF resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for ELSE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for TYPE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for SWITCH resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for VAR resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for FUNC resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for INTEGER resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for FLOAT resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for NOT resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for INT32 resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for INT64 resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for BYTE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for WSTRING resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for WINT resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for BOOL resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for STRING resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for TRUE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for FALSE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 46 (values -> INTEGER .)
    COLON           reduce using rule 46 (values -> INTEGER .)
    PRINT           reduce using rule 46 (values -> INTEGER .)
    SCAN            reduce using rule 46 (values -> INTEGER .)
    FOR             reduce using rule 46 (values -> INTEGER .)
    CONST           reduce using rule 46 (values -> INTEGER .)
    ID              reduce using rule 46 (values -> INTEGER .)
    APPEND          reduce using rule 46 (values -> INTEGER .)
    LEN             reduce using rule 46 (values -> INTEGER .)
    COPY            reduce using rule 46 (values -> INTEGER .)
    DELETE          reduce using rule 46 (values -> INTEGER .)
    IF              reduce using rule 46 (values -> INTEGER .)
    ELSE            reduce using rule 46 (values -> INTEGER .)
    TYPE            reduce using rule 46 (values -> INTEGER .)
    SWITCH          reduce using rule 46 (values -> INTEGER .)
    VAR             reduce using rule 46 (values -> INTEGER .)
    FUNC            reduce using rule 46 (values -> INTEGER .)
    INTEGER         reduce using rule 46 (values -> INTEGER .)
    FLOAT           reduce using rule 46 (values -> INTEGER .)
    NOT             reduce using rule 46 (values -> INTEGER .)
    $end            reduce using rule 46 (values -> INTEGER .)
    RLLAVE          reduce using rule 46 (values -> INTEGER .)
    INT32           reduce using rule 46 (values -> INTEGER .)
    INT64           reduce using rule 46 (values -> INTEGER .)
    FLOAT32         reduce using rule 46 (values -> INTEGER .)
    FLOAT64         reduce using rule 46 (values -> INTEGER .)
    BYTE            reduce using rule 46 (values -> INTEGER .)
    WFLOAT          reduce using rule 46 (values -> INTEGER .)
    WSTRING         reduce using rule 46 (values -> INTEGER .)
    WINT            reduce using rule 46 (values -> INTEGER .)
    BOOL            reduce using rule 46 (values -> INTEGER .)
    DEFAULT         reduce using rule 46 (values -> INTEGER .)
    CASE            reduce using rule 46 (values -> INTEGER .)
    RETURN          reduce using rule 46 (values -> INTEGER .)
    STRING          reduce using rule 46 (values -> INTEGER .)
    TRUE            reduce using rule 46 (values -> INTEGER .)
    FALSE           reduce using rule 46 (values -> INTEGER .)
    RPAREN          reduce using rule 46 (values -> INTEGER .)
    COMA            reduce using rule 46 (values -> INTEGER .)
    GREATER         reduce using rule 243 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 243 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 243 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 243 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 243 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 243 (something_ex -> INTEGER .)
    PLUS            reduce using rule 243 (something_ex -> INTEGER .)
    TIMES           reduce using rule 243 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 243 (something_ex -> INTEGER .)
    MINUS           reduce using rule 243 (something_ex -> INTEGER .)
    MOD             reduce using rule 243 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! PRINT           [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! SCAN            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! FOR             [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! CONST           [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! ID              [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! APPEND          [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! LEN             [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! COPY            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! DELETE          [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! IF              [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! ELSE            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! TYPE            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! SWITCH          [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! VAR             [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! FUNC            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! INTEGER         [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! FLOAT           [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! NOT             [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! INT32           [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! INT64           [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! FLOAT32         [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! FLOAT64         [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! BYTE            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! WFLOAT          [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! WSTRING         [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! WINT            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! BOOL            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! STRING          [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! TRUE            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! FALSE           [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! RPAREN          [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! COMA            [ reduce using rule 243 (something_ex -> INTEGER .) ]


state 149

    (47) values -> FLOAT .
    (244) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for PRINT resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for SCAN resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for FOR resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for CONST resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for ID resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for APPEND resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for LEN resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for COPY resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for DELETE resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for IF resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for ELSE resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for TYPE resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for SWITCH resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for VAR resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for FUNC resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for INTEGER resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for FLOAT resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for NOT resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for INT32 resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for INT64 resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for BYTE resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for WSTRING resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for WINT resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for BOOL resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for STRING resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for TRUE resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for FALSE resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for RPAREN resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 47 (values -> FLOAT .)
  ! reduce/reduce conflict for COMA resolved using rule 47 (values -> FLOAT .)
    COLON           reduce using rule 47 (values -> FLOAT .)
    PRINT           reduce using rule 47 (values -> FLOAT .)
    SCAN            reduce using rule 47 (values -> FLOAT .)
    FOR             reduce using rule 47 (values -> FLOAT .)
    CONST           reduce using rule 47 (values -> FLOAT .)
    ID              reduce using rule 47 (values -> FLOAT .)
    APPEND          reduce using rule 47 (values -> FLOAT .)
    LEN             reduce using rule 47 (values -> FLOAT .)
    COPY            reduce using rule 47 (values -> FLOAT .)
    DELETE          reduce using rule 47 (values -> FLOAT .)
    IF              reduce using rule 47 (values -> FLOAT .)
    ELSE            reduce using rule 47 (values -> FLOAT .)
    TYPE            reduce using rule 47 (values -> FLOAT .)
    SWITCH          reduce using rule 47 (values -> FLOAT .)
    VAR             reduce using rule 47 (values -> FLOAT .)
    FUNC            reduce using rule 47 (values -> FLOAT .)
    INTEGER         reduce using rule 47 (values -> FLOAT .)
    FLOAT           reduce using rule 47 (values -> FLOAT .)
    NOT             reduce using rule 47 (values -> FLOAT .)
    $end            reduce using rule 47 (values -> FLOAT .)
    RLLAVE          reduce using rule 47 (values -> FLOAT .)
    INT32           reduce using rule 47 (values -> FLOAT .)
    INT64           reduce using rule 47 (values -> FLOAT .)
    FLOAT32         reduce using rule 47 (values -> FLOAT .)
    FLOAT64         reduce using rule 47 (values -> FLOAT .)
    BYTE            reduce using rule 47 (values -> FLOAT .)
    WFLOAT          reduce using rule 47 (values -> FLOAT .)
    WSTRING         reduce using rule 47 (values -> FLOAT .)
    WINT            reduce using rule 47 (values -> FLOAT .)
    BOOL            reduce using rule 47 (values -> FLOAT .)
    DEFAULT         reduce using rule 47 (values -> FLOAT .)
    CASE            reduce using rule 47 (values -> FLOAT .)
    RETURN          reduce using rule 47 (values -> FLOAT .)
    STRING          reduce using rule 47 (values -> FLOAT .)
    TRUE            reduce using rule 47 (values -> FLOAT .)
    FALSE           reduce using rule 47 (values -> FLOAT .)
    RPAREN          reduce using rule 47 (values -> FLOAT .)
    RCORCHE         reduce using rule 47 (values -> FLOAT .)
    COMA            reduce using rule 47 (values -> FLOAT .)
    GREATER         reduce using rule 244 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 244 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 244 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 244 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 244 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 244 (something_ex -> FLOAT .)
    PLUS            reduce using rule 244 (something_ex -> FLOAT .)
    TIMES           reduce using rule 244 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 244 (something_ex -> FLOAT .)
    MINUS           reduce using rule 244 (something_ex -> FLOAT .)
    MOD             reduce using rule 244 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! PRINT           [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! SCAN            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! FOR             [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! CONST           [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! ID              [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! APPEND          [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! LEN             [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! COPY            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! DELETE          [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! IF              [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! ELSE            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! TYPE            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! SWITCH          [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! VAR             [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! FUNC            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! INTEGER         [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! FLOAT           [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! NOT             [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! INT32           [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! INT64           [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! FLOAT32         [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! FLOAT64         [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! BYTE            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! WFLOAT          [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! WSTRING         [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! WINT            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! BOOL            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! STRING          [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! TRUE            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! FALSE           [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! RPAREN          [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! RCORCHE         [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! COMA            [ reduce using rule 244 (something_ex -> FLOAT .) ]


state 150

    (48) values -> TRUE .

    COLON           reduce using rule 48 (values -> TRUE .)
    PRINT           reduce using rule 48 (values -> TRUE .)
    SCAN            reduce using rule 48 (values -> TRUE .)
    FOR             reduce using rule 48 (values -> TRUE .)
    CONST           reduce using rule 48 (values -> TRUE .)
    ID              reduce using rule 48 (values -> TRUE .)
    APPEND          reduce using rule 48 (values -> TRUE .)
    LEN             reduce using rule 48 (values -> TRUE .)
    COPY            reduce using rule 48 (values -> TRUE .)
    DELETE          reduce using rule 48 (values -> TRUE .)
    IF              reduce using rule 48 (values -> TRUE .)
    ELSE            reduce using rule 48 (values -> TRUE .)
    TYPE            reduce using rule 48 (values -> TRUE .)
    SWITCH          reduce using rule 48 (values -> TRUE .)
    VAR             reduce using rule 48 (values -> TRUE .)
    FUNC            reduce using rule 48 (values -> TRUE .)
    INTEGER         reduce using rule 48 (values -> TRUE .)
    FLOAT           reduce using rule 48 (values -> TRUE .)
    NOT             reduce using rule 48 (values -> TRUE .)
    $end            reduce using rule 48 (values -> TRUE .)
    RLLAVE          reduce using rule 48 (values -> TRUE .)
    INT32           reduce using rule 48 (values -> TRUE .)
    INT64           reduce using rule 48 (values -> TRUE .)
    FLOAT32         reduce using rule 48 (values -> TRUE .)
    FLOAT64         reduce using rule 48 (values -> TRUE .)
    BYTE            reduce using rule 48 (values -> TRUE .)
    WFLOAT          reduce using rule 48 (values -> TRUE .)
    WSTRING         reduce using rule 48 (values -> TRUE .)
    WINT            reduce using rule 48 (values -> TRUE .)
    BOOL            reduce using rule 48 (values -> TRUE .)
    DEFAULT         reduce using rule 48 (values -> TRUE .)
    CASE            reduce using rule 48 (values -> TRUE .)
    RETURN          reduce using rule 48 (values -> TRUE .)
    STRING          reduce using rule 48 (values -> TRUE .)
    TRUE            reduce using rule 48 (values -> TRUE .)
    FALSE           reduce using rule 48 (values -> TRUE .)
    RPAREN          reduce using rule 48 (values -> TRUE .)
    RCORCHE         reduce using rule 48 (values -> TRUE .)
    POINTS          reduce using rule 48 (values -> TRUE .)
    COMA            reduce using rule 48 (values -> TRUE .)


state 151

    (49) values -> FALSE .

    COLON           reduce using rule 49 (values -> FALSE .)
    PRINT           reduce using rule 49 (values -> FALSE .)
    SCAN            reduce using rule 49 (values -> FALSE .)
    FOR             reduce using rule 49 (values -> FALSE .)
    CONST           reduce using rule 49 (values -> FALSE .)
    ID              reduce using rule 49 (values -> FALSE .)
    APPEND          reduce using rule 49 (values -> FALSE .)
    LEN             reduce using rule 49 (values -> FALSE .)
    COPY            reduce using rule 49 (values -> FALSE .)
    DELETE          reduce using rule 49 (values -> FALSE .)
    IF              reduce using rule 49 (values -> FALSE .)
    ELSE            reduce using rule 49 (values -> FALSE .)
    TYPE            reduce using rule 49 (values -> FALSE .)
    SWITCH          reduce using rule 49 (values -> FALSE .)
    VAR             reduce using rule 49 (values -> FALSE .)
    FUNC            reduce using rule 49 (values -> FALSE .)
    INTEGER         reduce using rule 49 (values -> FALSE .)
    FLOAT           reduce using rule 49 (values -> FALSE .)
    NOT             reduce using rule 49 (values -> FALSE .)
    $end            reduce using rule 49 (values -> FALSE .)
    RLLAVE          reduce using rule 49 (values -> FALSE .)
    INT32           reduce using rule 49 (values -> FALSE .)
    INT64           reduce using rule 49 (values -> FALSE .)
    FLOAT32         reduce using rule 49 (values -> FALSE .)
    FLOAT64         reduce using rule 49 (values -> FALSE .)
    BYTE            reduce using rule 49 (values -> FALSE .)
    WFLOAT          reduce using rule 49 (values -> FALSE .)
    WSTRING         reduce using rule 49 (values -> FALSE .)
    WINT            reduce using rule 49 (values -> FALSE .)
    BOOL            reduce using rule 49 (values -> FALSE .)
    DEFAULT         reduce using rule 49 (values -> FALSE .)
    CASE            reduce using rule 49 (values -> FALSE .)
    RETURN          reduce using rule 49 (values -> FALSE .)
    STRING          reduce using rule 49 (values -> FALSE .)
    TRUE            reduce using rule 49 (values -> FALSE .)
    FALSE           reduce using rule 49 (values -> FALSE .)
    RPAREN          reduce using rule 49 (values -> FALSE .)
    RCORCHE         reduce using rule 49 (values -> FALSE .)
    POINTS          reduce using rule 49 (values -> FALSE .)
    COMA            reduce using rule 49 (values -> FALSE .)


state 152

    (59) operations -> expression .
    (180) value -> expression .

    COLON           reduce using rule 59 (operations -> expression .)
    PRINT           reduce using rule 59 (operations -> expression .)
    SCAN            reduce using rule 59 (operations -> expression .)
    FOR             reduce using rule 59 (operations -> expression .)
    CONST           reduce using rule 59 (operations -> expression .)
    ID              reduce using rule 59 (operations -> expression .)
    APPEND          reduce using rule 59 (operations -> expression .)
    LEN             reduce using rule 59 (operations -> expression .)
    COPY            reduce using rule 59 (operations -> expression .)
    DELETE          reduce using rule 59 (operations -> expression .)
    IF              reduce using rule 59 (operations -> expression .)
    ELSE            reduce using rule 59 (operations -> expression .)
    TYPE            reduce using rule 59 (operations -> expression .)
    SWITCH          reduce using rule 59 (operations -> expression .)
    VAR             reduce using rule 59 (operations -> expression .)
    FUNC            reduce using rule 59 (operations -> expression .)
    INTEGER         reduce using rule 59 (operations -> expression .)
    FLOAT           reduce using rule 59 (operations -> expression .)
    NOT             reduce using rule 59 (operations -> expression .)
    $end            reduce using rule 59 (operations -> expression .)
    RLLAVE          reduce using rule 59 (operations -> expression .)
    INT32           reduce using rule 59 (operations -> expression .)
    INT64           reduce using rule 59 (operations -> expression .)
    FLOAT32         reduce using rule 59 (operations -> expression .)
    FLOAT64         reduce using rule 59 (operations -> expression .)
    BYTE            reduce using rule 59 (operations -> expression .)
    WFLOAT          reduce using rule 59 (operations -> expression .)
    WSTRING         reduce using rule 59 (operations -> expression .)
    WINT            reduce using rule 59 (operations -> expression .)
    BOOL            reduce using rule 59 (operations -> expression .)
    DEFAULT         reduce using rule 59 (operations -> expression .)
    CASE            reduce using rule 59 (operations -> expression .)
    RETURN          reduce using rule 59 (operations -> expression .)
    STRING          reduce using rule 59 (operations -> expression .)
    TRUE            reduce using rule 59 (operations -> expression .)
    FALSE           reduce using rule 59 (operations -> expression .)
    RPAREN          reduce using rule 59 (operations -> expression .)
    COMA            reduce using rule 59 (operations -> expression .)
    GREATER         reduce using rule 180 (value -> expression .)
    SMALLER         reduce using rule 180 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 180 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 180 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 180 (value -> expression .)
    NOT_EQUAL       reduce using rule 180 (value -> expression .)
    PLUS            reduce using rule 180 (value -> expression .)
    TIMES           reduce using rule 180 (value -> expression .)
    DIVIDE          reduce using rule 180 (value -> expression .)
    MINUS           reduce using rule 180 (value -> expression .)
    MOD             reduce using rule 180 (value -> expression .)


state 153

    (60) operations -> comparison .
    (192) logic_value -> comparison .

    COLON           reduce using rule 60 (operations -> comparison .)
    PRINT           reduce using rule 60 (operations -> comparison .)
    SCAN            reduce using rule 60 (operations -> comparison .)
    FOR             reduce using rule 60 (operations -> comparison .)
    CONST           reduce using rule 60 (operations -> comparison .)
    ID              reduce using rule 60 (operations -> comparison .)
    APPEND          reduce using rule 60 (operations -> comparison .)
    LEN             reduce using rule 60 (operations -> comparison .)
    COPY            reduce using rule 60 (operations -> comparison .)
    DELETE          reduce using rule 60 (operations -> comparison .)
    IF              reduce using rule 60 (operations -> comparison .)
    ELSE            reduce using rule 60 (operations -> comparison .)
    TYPE            reduce using rule 60 (operations -> comparison .)
    SWITCH          reduce using rule 60 (operations -> comparison .)
    VAR             reduce using rule 60 (operations -> comparison .)
    FUNC            reduce using rule 60 (operations -> comparison .)
    INTEGER         reduce using rule 60 (operations -> comparison .)
    FLOAT           reduce using rule 60 (operations -> comparison .)
    NOT             reduce using rule 60 (operations -> comparison .)
    $end            reduce using rule 60 (operations -> comparison .)
    RLLAVE          reduce using rule 60 (operations -> comparison .)
    INT32           reduce using rule 60 (operations -> comparison .)
    INT64           reduce using rule 60 (operations -> comparison .)
    FLOAT32         reduce using rule 60 (operations -> comparison .)
    FLOAT64         reduce using rule 60 (operations -> comparison .)
    BYTE            reduce using rule 60 (operations -> comparison .)
    WFLOAT          reduce using rule 60 (operations -> comparison .)
    WSTRING         reduce using rule 60 (operations -> comparison .)
    WINT            reduce using rule 60 (operations -> comparison .)
    BOOL            reduce using rule 60 (operations -> comparison .)
    DEFAULT         reduce using rule 60 (operations -> comparison .)
    CASE            reduce using rule 60 (operations -> comparison .)
    RETURN          reduce using rule 60 (operations -> comparison .)
    STRING          reduce using rule 60 (operations -> comparison .)
    TRUE            reduce using rule 60 (operations -> comparison .)
    FALSE           reduce using rule 60 (operations -> comparison .)
    RPAREN          reduce using rule 60 (operations -> comparison .)
    RCORCHE         reduce using rule 60 (operations -> comparison .)
    COMA            reduce using rule 60 (operations -> comparison .)
    AND             reduce using rule 192 (logic_value -> comparison .)
    OR              reduce using rule 192 (logic_value -> comparison .)


state 154

    (61) operations -> logic_operation .

    COLON           reduce using rule 61 (operations -> logic_operation .)
    PRINT           reduce using rule 61 (operations -> logic_operation .)
    SCAN            reduce using rule 61 (operations -> logic_operation .)
    FOR             reduce using rule 61 (operations -> logic_operation .)
    CONST           reduce using rule 61 (operations -> logic_operation .)
    ID              reduce using rule 61 (operations -> logic_operation .)
    APPEND          reduce using rule 61 (operations -> logic_operation .)
    LEN             reduce using rule 61 (operations -> logic_operation .)
    COPY            reduce using rule 61 (operations -> logic_operation .)
    DELETE          reduce using rule 61 (operations -> logic_operation .)
    IF              reduce using rule 61 (operations -> logic_operation .)
    ELSE            reduce using rule 61 (operations -> logic_operation .)
    TYPE            reduce using rule 61 (operations -> logic_operation .)
    SWITCH          reduce using rule 61 (operations -> logic_operation .)
    VAR             reduce using rule 61 (operations -> logic_operation .)
    FUNC            reduce using rule 61 (operations -> logic_operation .)
    INTEGER         reduce using rule 61 (operations -> logic_operation .)
    FLOAT           reduce using rule 61 (operations -> logic_operation .)
    NOT             reduce using rule 61 (operations -> logic_operation .)
    $end            reduce using rule 61 (operations -> logic_operation .)
    RLLAVE          reduce using rule 61 (operations -> logic_operation .)
    INT32           reduce using rule 61 (operations -> logic_operation .)
    INT64           reduce using rule 61 (operations -> logic_operation .)
    FLOAT32         reduce using rule 61 (operations -> logic_operation .)
    FLOAT64         reduce using rule 61 (operations -> logic_operation .)
    BYTE            reduce using rule 61 (operations -> logic_operation .)
    WFLOAT          reduce using rule 61 (operations -> logic_operation .)
    WSTRING         reduce using rule 61 (operations -> logic_operation .)
    WINT            reduce using rule 61 (operations -> logic_operation .)
    BOOL            reduce using rule 61 (operations -> logic_operation .)
    DEFAULT         reduce using rule 61 (operations -> logic_operation .)
    CASE            reduce using rule 61 (operations -> logic_operation .)
    RETURN          reduce using rule 61 (operations -> logic_operation .)
    STRING          reduce using rule 61 (operations -> logic_operation .)
    TRUE            reduce using rule 61 (operations -> logic_operation .)
    FALSE           reduce using rule 61 (operations -> logic_operation .)
    RPAREN          reduce using rule 61 (operations -> logic_operation .)
    RCORCHE         reduce using rule 61 (operations -> logic_operation .)
    COMA            reduce using rule 61 (operations -> logic_operation .)


state 155

    (147) slice_assignment -> slice_var EQUAL something_s .

    COLON           reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    PRINT           reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    SCAN            reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    FOR             reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    CONST           reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    ID              reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    APPEND          reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    LEN             reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    COPY            reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    DELETE          reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    IF              reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    ELSE            reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    TYPE            reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    SWITCH          reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    VAR             reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    FUNC            reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    INTEGER         reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    FLOAT           reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    NOT             reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    $end            reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    RLLAVE          reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    INT32           reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    INT64           reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    FLOAT32         reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    FLOAT64         reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    BYTE            reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    WFLOAT          reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    WSTRING         reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    WINT            reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    BOOL            reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    DEFAULT         reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    CASE            reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    RETURN          reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    STRING          reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    TRUE            reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)
    FALSE           reduce using rule 147 (slice_assignment -> slice_var EQUAL something_s .)


state 156

    (148) something_s -> ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (242) something_ex -> ID .
    (179) value -> ID .
    (193) logic_value -> ID .
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for COLON resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for CONST resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for INT32 resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for INT64 resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for BYTE resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for WSTRING resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for WINT resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for STRING resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for TRUE resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for FALSE resolved using rule 148 (something_s -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 179 (value -> ID .)
    COLON           reduce using rule 148 (something_s -> ID .)
    PRINT           reduce using rule 148 (something_s -> ID .)
    SCAN            reduce using rule 148 (something_s -> ID .)
    FOR             reduce using rule 148 (something_s -> ID .)
    CONST           reduce using rule 148 (something_s -> ID .)
    ID              reduce using rule 148 (something_s -> ID .)
    APPEND          reduce using rule 148 (something_s -> ID .)
    LEN             reduce using rule 148 (something_s -> ID .)
    COPY            reduce using rule 148 (something_s -> ID .)
    DELETE          reduce using rule 148 (something_s -> ID .)
    IF              reduce using rule 148 (something_s -> ID .)
    ELSE            reduce using rule 148 (something_s -> ID .)
    TYPE            reduce using rule 148 (something_s -> ID .)
    SWITCH          reduce using rule 148 (something_s -> ID .)
    VAR             reduce using rule 148 (something_s -> ID .)
    FUNC            reduce using rule 148 (something_s -> ID .)
    INTEGER         reduce using rule 148 (something_s -> ID .)
    FLOAT           reduce using rule 148 (something_s -> ID .)
    NOT             reduce using rule 148 (something_s -> ID .)
    $end            reduce using rule 148 (something_s -> ID .)
    RLLAVE          reduce using rule 148 (something_s -> ID .)
    INT32           reduce using rule 148 (something_s -> ID .)
    INT64           reduce using rule 148 (something_s -> ID .)
    FLOAT32         reduce using rule 148 (something_s -> ID .)
    FLOAT64         reduce using rule 148 (something_s -> ID .)
    BYTE            reduce using rule 148 (something_s -> ID .)
    WFLOAT          reduce using rule 148 (something_s -> ID .)
    WSTRING         reduce using rule 148 (something_s -> ID .)
    WINT            reduce using rule 148 (something_s -> ID .)
    BOOL            reduce using rule 148 (something_s -> ID .)
    DEFAULT         reduce using rule 148 (something_s -> ID .)
    CASE            reduce using rule 148 (something_s -> ID .)
    RETURN          reduce using rule 148 (something_s -> ID .)
    STRING          reduce using rule 148 (something_s -> ID .)
    TRUE            reduce using rule 148 (something_s -> ID .)
    FALSE           reduce using rule 148 (something_s -> ID .)
    LCORCHE         shift and go to state 174
    GREATER         reduce using rule 179 (value -> ID .)
    SMALLER         reduce using rule 179 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 179 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 179 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 179 (value -> ID .)
    NOT_EQUAL       reduce using rule 179 (value -> ID .)
    PLUS            reduce using rule 179 (value -> ID .)
    TIMES           reduce using rule 179 (value -> ID .)
    DIVIDE          reduce using rule 179 (value -> ID .)
    MINUS           reduce using rule 179 (value -> ID .)
    MOD             reduce using rule 179 (value -> ID .)
    AND             reduce using rule 193 (logic_value -> ID .)
    OR              reduce using rule 193 (logic_value -> ID .)
    LPAREN          shift and go to state 112

  ! GREATER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 242 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 242 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 242 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 242 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 242 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 242 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 242 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 242 (something_ex -> ID .) ]
  ! CONST           [ reduce using rule 242 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 242 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 242 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 242 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 242 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 242 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 242 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 242 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 242 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 242 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 242 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! INT32           [ reduce using rule 242 (something_ex -> ID .) ]
  ! INT64           [ reduce using rule 242 (something_ex -> ID .) ]
  ! FLOAT32         [ reduce using rule 242 (something_ex -> ID .) ]
  ! FLOAT64         [ reduce using rule 242 (something_ex -> ID .) ]
  ! BYTE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! WFLOAT          [ reduce using rule 242 (something_ex -> ID .) ]
  ! WSTRING         [ reduce using rule 242 (something_ex -> ID .) ]
  ! WINT            [ reduce using rule 242 (something_ex -> ID .) ]
  ! BOOL            [ reduce using rule 242 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 242 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 242 (something_ex -> ID .) ]
  ! STRING          [ reduce using rule 242 (something_ex -> ID .) ]
  ! TRUE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! FALSE           [ reduce using rule 242 (something_ex -> ID .) ]


state 157

    (149) something_s -> array_var .
    (62) data_structure -> array_var .

  ! reduce/reduce conflict for COLON resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for PRINT resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for SCAN resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for FOR resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for CONST resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for ID resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for APPEND resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for LEN resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for COPY resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for DELETE resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for IF resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for ELSE resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for TYPE resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for SWITCH resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for VAR resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for FUNC resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for INTEGER resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for FLOAT resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for NOT resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for $end resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for INT32 resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for INT64 resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for BYTE resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for WSTRING resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for WINT resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for BOOL resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for CASE resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for RETURN resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for STRING resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for TRUE resolved using rule 62 (data_structure -> array_var .)
  ! reduce/reduce conflict for FALSE resolved using rule 62 (data_structure -> array_var .)
    GREATER         reduce using rule 62 (data_structure -> array_var .)
    SMALLER         reduce using rule 62 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 62 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 62 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 62 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 62 (data_structure -> array_var .)
    PLUS            reduce using rule 62 (data_structure -> array_var .)
    TIMES           reduce using rule 62 (data_structure -> array_var .)
    DIVIDE          reduce using rule 62 (data_structure -> array_var .)
    MINUS           reduce using rule 62 (data_structure -> array_var .)
    MOD             reduce using rule 62 (data_structure -> array_var .)
    COLON           reduce using rule 62 (data_structure -> array_var .)
    PRINT           reduce using rule 62 (data_structure -> array_var .)
    SCAN            reduce using rule 62 (data_structure -> array_var .)
    FOR             reduce using rule 62 (data_structure -> array_var .)
    CONST           reduce using rule 62 (data_structure -> array_var .)
    ID              reduce using rule 62 (data_structure -> array_var .)
    APPEND          reduce using rule 62 (data_structure -> array_var .)
    LEN             reduce using rule 62 (data_structure -> array_var .)
    COPY            reduce using rule 62 (data_structure -> array_var .)
    DELETE          reduce using rule 62 (data_structure -> array_var .)
    IF              reduce using rule 62 (data_structure -> array_var .)
    ELSE            reduce using rule 62 (data_structure -> array_var .)
    TYPE            reduce using rule 62 (data_structure -> array_var .)
    SWITCH          reduce using rule 62 (data_structure -> array_var .)
    VAR             reduce using rule 62 (data_structure -> array_var .)
    FUNC            reduce using rule 62 (data_structure -> array_var .)
    INTEGER         reduce using rule 62 (data_structure -> array_var .)
    FLOAT           reduce using rule 62 (data_structure -> array_var .)
    NOT             reduce using rule 62 (data_structure -> array_var .)
    $end            reduce using rule 62 (data_structure -> array_var .)
    RLLAVE          reduce using rule 62 (data_structure -> array_var .)
    INT32           reduce using rule 62 (data_structure -> array_var .)
    INT64           reduce using rule 62 (data_structure -> array_var .)
    FLOAT32         reduce using rule 62 (data_structure -> array_var .)
    FLOAT64         reduce using rule 62 (data_structure -> array_var .)
    BYTE            reduce using rule 62 (data_structure -> array_var .)
    WFLOAT          reduce using rule 62 (data_structure -> array_var .)
    WSTRING         reduce using rule 62 (data_structure -> array_var .)
    WINT            reduce using rule 62 (data_structure -> array_var .)
    BOOL            reduce using rule 62 (data_structure -> array_var .)
    DEFAULT         reduce using rule 62 (data_structure -> array_var .)
    CASE            reduce using rule 62 (data_structure -> array_var .)
    RETURN          reduce using rule 62 (data_structure -> array_var .)
    STRING          reduce using rule 62 (data_structure -> array_var .)
    TRUE            reduce using rule 62 (data_structure -> array_var .)
    FALSE           reduce using rule 62 (data_structure -> array_var .)

  ! COLON           [ reduce using rule 149 (something_s -> array_var .) ]
  ! PRINT           [ reduce using rule 149 (something_s -> array_var .) ]
  ! SCAN            [ reduce using rule 149 (something_s -> array_var .) ]
  ! FOR             [ reduce using rule 149 (something_s -> array_var .) ]
  ! CONST           [ reduce using rule 149 (something_s -> array_var .) ]
  ! ID              [ reduce using rule 149 (something_s -> array_var .) ]
  ! APPEND          [ reduce using rule 149 (something_s -> array_var .) ]
  ! LEN             [ reduce using rule 149 (something_s -> array_var .) ]
  ! COPY            [ reduce using rule 149 (something_s -> array_var .) ]
  ! DELETE          [ reduce using rule 149 (something_s -> array_var .) ]
  ! IF              [ reduce using rule 149 (something_s -> array_var .) ]
  ! ELSE            [ reduce using rule 149 (something_s -> array_var .) ]
  ! TYPE            [ reduce using rule 149 (something_s -> array_var .) ]
  ! SWITCH          [ reduce using rule 149 (something_s -> array_var .) ]
  ! VAR             [ reduce using rule 149 (something_s -> array_var .) ]
  ! FUNC            [ reduce using rule 149 (something_s -> array_var .) ]
  ! INTEGER         [ reduce using rule 149 (something_s -> array_var .) ]
  ! FLOAT           [ reduce using rule 149 (something_s -> array_var .) ]
  ! NOT             [ reduce using rule 149 (something_s -> array_var .) ]
  ! $end            [ reduce using rule 149 (something_s -> array_var .) ]
  ! RLLAVE          [ reduce using rule 149 (something_s -> array_var .) ]
  ! INT32           [ reduce using rule 149 (something_s -> array_var .) ]
  ! INT64           [ reduce using rule 149 (something_s -> array_var .) ]
  ! FLOAT32         [ reduce using rule 149 (something_s -> array_var .) ]
  ! FLOAT64         [ reduce using rule 149 (something_s -> array_var .) ]
  ! BYTE            [ reduce using rule 149 (something_s -> array_var .) ]
  ! WFLOAT          [ reduce using rule 149 (something_s -> array_var .) ]
  ! WSTRING         [ reduce using rule 149 (something_s -> array_var .) ]
  ! WINT            [ reduce using rule 149 (something_s -> array_var .) ]
  ! BOOL            [ reduce using rule 149 (something_s -> array_var .) ]
  ! DEFAULT         [ reduce using rule 149 (something_s -> array_var .) ]
  ! CASE            [ reduce using rule 149 (something_s -> array_var .) ]
  ! RETURN          [ reduce using rule 149 (something_s -> array_var .) ]
  ! STRING          [ reduce using rule 149 (something_s -> array_var .) ]
  ! TRUE            [ reduce using rule 149 (something_s -> array_var .) ]
  ! FALSE           [ reduce using rule 149 (something_s -> array_var .) ]


state 158

    (150) something_s -> values .

    COLON           reduce using rule 150 (something_s -> values .)
    PRINT           reduce using rule 150 (something_s -> values .)
    SCAN            reduce using rule 150 (something_s -> values .)
    FOR             reduce using rule 150 (something_s -> values .)
    CONST           reduce using rule 150 (something_s -> values .)
    ID              reduce using rule 150 (something_s -> values .)
    APPEND          reduce using rule 150 (something_s -> values .)
    LEN             reduce using rule 150 (something_s -> values .)
    COPY            reduce using rule 150 (something_s -> values .)
    DELETE          reduce using rule 150 (something_s -> values .)
    IF              reduce using rule 150 (something_s -> values .)
    ELSE            reduce using rule 150 (something_s -> values .)
    TYPE            reduce using rule 150 (something_s -> values .)
    SWITCH          reduce using rule 150 (something_s -> values .)
    VAR             reduce using rule 150 (something_s -> values .)
    FUNC            reduce using rule 150 (something_s -> values .)
    INTEGER         reduce using rule 150 (something_s -> values .)
    FLOAT           reduce using rule 150 (something_s -> values .)
    NOT             reduce using rule 150 (something_s -> values .)
    $end            reduce using rule 150 (something_s -> values .)
    RLLAVE          reduce using rule 150 (something_s -> values .)
    INT32           reduce using rule 150 (something_s -> values .)
    INT64           reduce using rule 150 (something_s -> values .)
    FLOAT32         reduce using rule 150 (something_s -> values .)
    FLOAT64         reduce using rule 150 (something_s -> values .)
    BYTE            reduce using rule 150 (something_s -> values .)
    WFLOAT          reduce using rule 150 (something_s -> values .)
    WSTRING         reduce using rule 150 (something_s -> values .)
    WINT            reduce using rule 150 (something_s -> values .)
    BOOL            reduce using rule 150 (something_s -> values .)
    DEFAULT         reduce using rule 150 (something_s -> values .)
    CASE            reduce using rule 150 (something_s -> values .)
    RETURN          reduce using rule 150 (something_s -> values .)
    STRING          reduce using rule 150 (something_s -> values .)
    TRUE            reduce using rule 150 (something_s -> values .)
    FALSE           reduce using rule 150 (something_s -> values .)


state 159

    (151) something_s -> operations .

    COLON           reduce using rule 151 (something_s -> operations .)
    PRINT           reduce using rule 151 (something_s -> operations .)
    SCAN            reduce using rule 151 (something_s -> operations .)
    FOR             reduce using rule 151 (something_s -> operations .)
    CONST           reduce using rule 151 (something_s -> operations .)
    ID              reduce using rule 151 (something_s -> operations .)
    APPEND          reduce using rule 151 (something_s -> operations .)
    LEN             reduce using rule 151 (something_s -> operations .)
    COPY            reduce using rule 151 (something_s -> operations .)
    DELETE          reduce using rule 151 (something_s -> operations .)
    IF              reduce using rule 151 (something_s -> operations .)
    ELSE            reduce using rule 151 (something_s -> operations .)
    TYPE            reduce using rule 151 (something_s -> operations .)
    SWITCH          reduce using rule 151 (something_s -> operations .)
    VAR             reduce using rule 151 (something_s -> operations .)
    FUNC            reduce using rule 151 (something_s -> operations .)
    INTEGER         reduce using rule 151 (something_s -> operations .)
    FLOAT           reduce using rule 151 (something_s -> operations .)
    NOT             reduce using rule 151 (something_s -> operations .)
    $end            reduce using rule 151 (something_s -> operations .)
    RLLAVE          reduce using rule 151 (something_s -> operations .)
    INT32           reduce using rule 151 (something_s -> operations .)
    INT64           reduce using rule 151 (something_s -> operations .)
    FLOAT32         reduce using rule 151 (something_s -> operations .)
    FLOAT64         reduce using rule 151 (something_s -> operations .)
    BYTE            reduce using rule 151 (something_s -> operations .)
    WFLOAT          reduce using rule 151 (something_s -> operations .)
    WSTRING         reduce using rule 151 (something_s -> operations .)
    WINT            reduce using rule 151 (something_s -> operations .)
    BOOL            reduce using rule 151 (something_s -> operations .)
    DEFAULT         reduce using rule 151 (something_s -> operations .)
    CASE            reduce using rule 151 (something_s -> operations .)
    RETURN          reduce using rule 151 (something_s -> operations .)
    STRING          reduce using rule 151 (something_s -> operations .)
    TRUE            reduce using rule 151 (something_s -> operations .)
    FALSE           reduce using rule 151 (something_s -> operations .)


state 160

    (232) impresion -> PRINT LPAREN content . RPAREN

    RPAREN          shift and go to state 245


state 161

    (233) content -> values .

    RPAREN          reduce using rule 233 (content -> values .)


state 162

    (234) content -> operations .

    RPAREN          reduce using rule 234 (content -> operations .)


state 163

    (235) content -> funciones .
    (246) something_ex -> funciones .

  ! reduce/reduce conflict for RPAREN resolved using rule 235 (content -> funciones .)
    RPAREN          reduce using rule 235 (content -> funciones .)
    GREATER         reduce using rule 246 (something_ex -> funciones .)
    SMALLER         reduce using rule 246 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 246 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 246 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 246 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 246 (something_ex -> funciones .)
    PLUS            reduce using rule 246 (something_ex -> funciones .)
    TIMES           reduce using rule 246 (something_ex -> funciones .)
    DIVIDE          reduce using rule 246 (something_ex -> funciones .)
    MINUS           reduce using rule 246 (something_ex -> funciones .)
    MOD             reduce using rule 246 (something_ex -> funciones .)

  ! RPAREN          [ reduce using rule 246 (something_ex -> funciones .) ]


state 164

    (236) content -> data_structure .
    (245) something_ex -> data_structure .

  ! reduce/reduce conflict for RPAREN resolved using rule 236 (content -> data_structure .)
    RPAREN          reduce using rule 236 (content -> data_structure .)
    GREATER         reduce using rule 245 (something_ex -> data_structure .)
    SMALLER         reduce using rule 245 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 245 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 245 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 245 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 245 (something_ex -> data_structure .)
    PLUS            reduce using rule 245 (something_ex -> data_structure .)
    TIMES           reduce using rule 245 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 245 (something_ex -> data_structure .)
    MINUS           reduce using rule 245 (something_ex -> data_structure .)
    MOD             reduce using rule 245 (something_ex -> data_structure .)

  ! RPAREN          [ reduce using rule 245 (something_ex -> data_structure .) ]


state 165

    (237) content -> ID .
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (242) something_ex -> ID .
    (179) value -> ID .
    (193) logic_value -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 237 (content -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 179 (value -> ID .)
    RPAREN          reduce using rule 237 (content -> ID .)
    LPAREN          shift and go to state 112
    LCORCHE         shift and go to state 174
    GREATER         reduce using rule 179 (value -> ID .)
    SMALLER         reduce using rule 179 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 179 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 179 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 179 (value -> ID .)
    NOT_EQUAL       reduce using rule 179 (value -> ID .)
    PLUS            reduce using rule 179 (value -> ID .)
    TIMES           reduce using rule 179 (value -> ID .)
    DIVIDE          reduce using rule 179 (value -> ID .)
    MINUS           reduce using rule 179 (value -> ID .)
    MOD             reduce using rule 179 (value -> ID .)
    AND             reduce using rule 193 (logic_value -> ID .)
    OR              reduce using rule 193 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 242 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 242 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 242 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 242 (something_ex -> ID .) ]
  ! RPAREN          [ reduce using rule 242 (something_ex -> ID .) ]


state 166

    (83) scan_func -> SCAN LPAREN POINTER . RPAREN

    RPAREN          shift and go to state 246


state 167

    (240) adicionaEx -> op something_ex .
    (241) adicionaEx -> op something_ex . adicionaEx
    (240) adicionaEx -> . op something_ex
    (241) adicionaEx -> . op something_ex adicionaEx
    (181) op -> . GREATER
    (182) op -> . SMALLER
    (183) op -> . GREATER_OR_EQUAL
    (184) op -> . SMALLER_OR_EQUAL
    (185) op -> . EQUAL_COMPARE
    (186) op -> . NOT_EQUAL
    (247) op -> . PLUS
    (248) op -> . TIMES
    (249) op -> . DIVIDE
    (250) op -> . MINUS
    (251) op -> . MOD

  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL_COMPARE resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
  ! shift/reduce conflict for MOD resolved as shift
    COLON           reduce using rule 240 (adicionaEx -> op something_ex .)
    PRINT           reduce using rule 240 (adicionaEx -> op something_ex .)
    SCAN            reduce using rule 240 (adicionaEx -> op something_ex .)
    FOR             reduce using rule 240 (adicionaEx -> op something_ex .)
    CONST           reduce using rule 240 (adicionaEx -> op something_ex .)
    ID              reduce using rule 240 (adicionaEx -> op something_ex .)
    APPEND          reduce using rule 240 (adicionaEx -> op something_ex .)
    LEN             reduce using rule 240 (adicionaEx -> op something_ex .)
    COPY            reduce using rule 240 (adicionaEx -> op something_ex .)
    DELETE          reduce using rule 240 (adicionaEx -> op something_ex .)
    IF              reduce using rule 240 (adicionaEx -> op something_ex .)
    ELSE            reduce using rule 240 (adicionaEx -> op something_ex .)
    TYPE            reduce using rule 240 (adicionaEx -> op something_ex .)
    SWITCH          reduce using rule 240 (adicionaEx -> op something_ex .)
    VAR             reduce using rule 240 (adicionaEx -> op something_ex .)
    FUNC            reduce using rule 240 (adicionaEx -> op something_ex .)
    INTEGER         reduce using rule 240 (adicionaEx -> op something_ex .)
    FLOAT           reduce using rule 240 (adicionaEx -> op something_ex .)
    NOT             reduce using rule 240 (adicionaEx -> op something_ex .)
    $end            reduce using rule 240 (adicionaEx -> op something_ex .)
    RLLAVE          reduce using rule 240 (adicionaEx -> op something_ex .)
    INT32           reduce using rule 240 (adicionaEx -> op something_ex .)
    INT64           reduce using rule 240 (adicionaEx -> op something_ex .)
    FLOAT32         reduce using rule 240 (adicionaEx -> op something_ex .)
    FLOAT64         reduce using rule 240 (adicionaEx -> op something_ex .)
    BYTE            reduce using rule 240 (adicionaEx -> op something_ex .)
    WFLOAT          reduce using rule 240 (adicionaEx -> op something_ex .)
    WSTRING         reduce using rule 240 (adicionaEx -> op something_ex .)
    WINT            reduce using rule 240 (adicionaEx -> op something_ex .)
    BOOL            reduce using rule 240 (adicionaEx -> op something_ex .)
    DEFAULT         reduce using rule 240 (adicionaEx -> op something_ex .)
    CASE            reduce using rule 240 (adicionaEx -> op something_ex .)
    RETURN          reduce using rule 240 (adicionaEx -> op something_ex .)
    STRING          reduce using rule 240 (adicionaEx -> op something_ex .)
    TRUE            reduce using rule 240 (adicionaEx -> op something_ex .)
    FALSE           reduce using rule 240 (adicionaEx -> op something_ex .)
    RPAREN          reduce using rule 240 (adicionaEx -> op something_ex .)
    AND             reduce using rule 240 (adicionaEx -> op something_ex .)
    OR              reduce using rule 240 (adicionaEx -> op something_ex .)
    LLLAVE          reduce using rule 240 (adicionaEx -> op something_ex .)
    RCORCHE         reduce using rule 240 (adicionaEx -> op something_ex .)
    COMA            reduce using rule 240 (adicionaEx -> op something_ex .)
    GREATER         shift and go to state 82
    SMALLER         shift and go to state 83
    GREATER_OR_EQUAL shift and go to state 84
    SMALLER_OR_EQUAL shift and go to state 85
    EQUAL_COMPARE   shift and go to state 86
    NOT_EQUAL       shift and go to state 87
    PLUS            shift and go to state 88
    TIMES           shift and go to state 89
    DIVIDE          shift and go to state 90
    MINUS           shift and go to state 91
    MOD             shift and go to state 92

  ! GREATER         [ reduce using rule 240 (adicionaEx -> op something_ex .) ]
  ! SMALLER         [ reduce using rule 240 (adicionaEx -> op something_ex .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 240 (adicionaEx -> op something_ex .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 240 (adicionaEx -> op something_ex .) ]
  ! EQUAL_COMPARE   [ reduce using rule 240 (adicionaEx -> op something_ex .) ]
  ! NOT_EQUAL       [ reduce using rule 240 (adicionaEx -> op something_ex .) ]
  ! PLUS            [ reduce using rule 240 (adicionaEx -> op something_ex .) ]
  ! TIMES           [ reduce using rule 240 (adicionaEx -> op something_ex .) ]
  ! DIVIDE          [ reduce using rule 240 (adicionaEx -> op something_ex .) ]
  ! MINUS           [ reduce using rule 240 (adicionaEx -> op something_ex .) ]
  ! MOD             [ reduce using rule 240 (adicionaEx -> op something_ex .) ]

    op                             shift and go to state 81
    adicionaEx                     shift and go to state 247

state 168

    (242) something_ex -> ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN

    GREATER         reduce using rule 242 (something_ex -> ID .)
    SMALLER         reduce using rule 242 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 242 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 242 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 242 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 242 (something_ex -> ID .)
    PLUS            reduce using rule 242 (something_ex -> ID .)
    TIMES           reduce using rule 242 (something_ex -> ID .)
    DIVIDE          reduce using rule 242 (something_ex -> ID .)
    MINUS           reduce using rule 242 (something_ex -> ID .)
    MOD             reduce using rule 242 (something_ex -> ID .)
    COLON           reduce using rule 242 (something_ex -> ID .)
    PRINT           reduce using rule 242 (something_ex -> ID .)
    SCAN            reduce using rule 242 (something_ex -> ID .)
    FOR             reduce using rule 242 (something_ex -> ID .)
    CONST           reduce using rule 242 (something_ex -> ID .)
    ID              reduce using rule 242 (something_ex -> ID .)
    APPEND          reduce using rule 242 (something_ex -> ID .)
    LEN             reduce using rule 242 (something_ex -> ID .)
    COPY            reduce using rule 242 (something_ex -> ID .)
    DELETE          reduce using rule 242 (something_ex -> ID .)
    IF              reduce using rule 242 (something_ex -> ID .)
    ELSE            reduce using rule 242 (something_ex -> ID .)
    TYPE            reduce using rule 242 (something_ex -> ID .)
    SWITCH          reduce using rule 242 (something_ex -> ID .)
    VAR             reduce using rule 242 (something_ex -> ID .)
    FUNC            reduce using rule 242 (something_ex -> ID .)
    INTEGER         reduce using rule 242 (something_ex -> ID .)
    FLOAT           reduce using rule 242 (something_ex -> ID .)
    NOT             reduce using rule 242 (something_ex -> ID .)
    $end            reduce using rule 242 (something_ex -> ID .)
    RLLAVE          reduce using rule 242 (something_ex -> ID .)
    INT32           reduce using rule 242 (something_ex -> ID .)
    INT64           reduce using rule 242 (something_ex -> ID .)
    FLOAT32         reduce using rule 242 (something_ex -> ID .)
    FLOAT64         reduce using rule 242 (something_ex -> ID .)
    BYTE            reduce using rule 242 (something_ex -> ID .)
    WFLOAT          reduce using rule 242 (something_ex -> ID .)
    WSTRING         reduce using rule 242 (something_ex -> ID .)
    WINT            reduce using rule 242 (something_ex -> ID .)
    BOOL            reduce using rule 242 (something_ex -> ID .)
    DEFAULT         reduce using rule 242 (something_ex -> ID .)
    CASE            reduce using rule 242 (something_ex -> ID .)
    RETURN          reduce using rule 242 (something_ex -> ID .)
    STRING          reduce using rule 242 (something_ex -> ID .)
    TRUE            reduce using rule 242 (something_ex -> ID .)
    FALSE           reduce using rule 242 (something_ex -> ID .)
    RPAREN          reduce using rule 242 (something_ex -> ID .)
    AND             reduce using rule 242 (something_ex -> ID .)
    OR              reduce using rule 242 (something_ex -> ID .)
    LLLAVE          reduce using rule 242 (something_ex -> ID .)
    RCORCHE         reduce using rule 242 (something_ex -> ID .)
    COMA            reduce using rule 242 (something_ex -> ID .)
    LCORCHE         shift and go to state 174
    LPAREN          shift and go to state 112


state 169

    (89) cicloFor -> FOR LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 248


state 170

    (90) cicloFor -> FOR comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    comparison                     shift and go to state 8
    codigo                         shift and go to state 249
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 171

    (91) cicloFor -> FOR logic_operation LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    logic_operation                shift and go to state 9
    codigo                         shift and go to state 250
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 172

    (92) cicloFor -> FOR decVarOne COLON . comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (179) value -> . ID
    (180) value -> . expression
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 120
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    comparison                     shift and go to state 251
    value                          shift and go to state 34
    expression                     shift and go to state 98
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 173

    (158) decVarOne -> ID DEQUAL . ID
    (159) decVarOne -> ID DEQUAL . INTEGER

    ID              shift and go to state 252
    INTEGER         shift and go to state 253


state 174

    (208) array_var -> ID LCORCHE . index RCORCHE
    (214) map_var -> ID LCORCHE . key RCORCHE
    (143) slice_var -> ID LCORCHE . index_s RCORCHE
    (209) index -> . ID
    (210) index -> . INTEGER
    (211) index -> . expression
    (215) key -> . ID
    (216) key -> . values
    (217) key -> . operations
    (144) index_s -> . ID
    (145) index_s -> . INTEGER
    (146) index_s -> . expression
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 254
    INTEGER         shift and go to state 209
    STRING          shift and go to state 147
    FLOAT           shift and go to state 149
    TRUE            shift and go to state 150
    FALSE           shift and go to state 151
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    NOT             shift and go to state 56

    index                          shift and go to state 206
    key                            shift and go to state 208
    index_s                        shift and go to state 207
    expression                     shift and go to state 210
    values                         shift and go to state 211
    operations                     shift and go to state 212
    something_ex                   shift and go to state 32
    comparison                     shift and go to state 153
    logic_operation                shift and go to state 154
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 175

    (178) comparison -> value op value .

    PRINT           reduce using rule 178 (comparison -> value op value .)
    SCAN            reduce using rule 178 (comparison -> value op value .)
    FOR             reduce using rule 178 (comparison -> value op value .)
    CONST           reduce using rule 178 (comparison -> value op value .)
    ID              reduce using rule 178 (comparison -> value op value .)
    APPEND          reduce using rule 178 (comparison -> value op value .)
    LEN             reduce using rule 178 (comparison -> value op value .)
    COPY            reduce using rule 178 (comparison -> value op value .)
    DELETE          reduce using rule 178 (comparison -> value op value .)
    IF              reduce using rule 178 (comparison -> value op value .)
    ELSE            reduce using rule 178 (comparison -> value op value .)
    TYPE            reduce using rule 178 (comparison -> value op value .)
    SWITCH          reduce using rule 178 (comparison -> value op value .)
    VAR             reduce using rule 178 (comparison -> value op value .)
    FUNC            reduce using rule 178 (comparison -> value op value .)
    INTEGER         reduce using rule 178 (comparison -> value op value .)
    FLOAT           reduce using rule 178 (comparison -> value op value .)
    NOT             reduce using rule 178 (comparison -> value op value .)
    $end            reduce using rule 178 (comparison -> value op value .)
    AND             reduce using rule 178 (comparison -> value op value .)
    OR              reduce using rule 178 (comparison -> value op value .)
    RLLAVE          reduce using rule 178 (comparison -> value op value .)
    INT32           reduce using rule 178 (comparison -> value op value .)
    INT64           reduce using rule 178 (comparison -> value op value .)
    FLOAT32         reduce using rule 178 (comparison -> value op value .)
    FLOAT64         reduce using rule 178 (comparison -> value op value .)
    BYTE            reduce using rule 178 (comparison -> value op value .)
    WFLOAT          reduce using rule 178 (comparison -> value op value .)
    WSTRING         reduce using rule 178 (comparison -> value op value .)
    WINT            reduce using rule 178 (comparison -> value op value .)
    BOOL            reduce using rule 178 (comparison -> value op value .)
    DEFAULT         reduce using rule 178 (comparison -> value op value .)
    CASE            reduce using rule 178 (comparison -> value op value .)
    RETURN          reduce using rule 178 (comparison -> value op value .)
    STRING          reduce using rule 178 (comparison -> value op value .)
    TRUE            reduce using rule 178 (comparison -> value op value .)
    FALSE           reduce using rule 178 (comparison -> value op value .)
    LLLAVE          reduce using rule 178 (comparison -> value op value .)
    COLON           reduce using rule 178 (comparison -> value op value .)
    RPAREN          reduce using rule 178 (comparison -> value op value .)
    RCORCHE         reduce using rule 178 (comparison -> value op value .)
    COMA            reduce using rule 178 (comparison -> value op value .)


state 176

    (189) logic_recu -> logic_op logic_value .
    (190) logic_recu -> logic_op logic_value . logic_recu
    (189) logic_recu -> . logic_op logic_value
    (190) logic_recu -> . logic_op logic_value logic_recu
    (196) logic_op -> . AND
    (197) logic_op -> . OR

    PRINT           reduce using rule 189 (logic_recu -> logic_op logic_value .)
    SCAN            reduce using rule 189 (logic_recu -> logic_op logic_value .)
    FOR             reduce using rule 189 (logic_recu -> logic_op logic_value .)
    CONST           reduce using rule 189 (logic_recu -> logic_op logic_value .)
    ID              reduce using rule 189 (logic_recu -> logic_op logic_value .)
    APPEND          reduce using rule 189 (logic_recu -> logic_op logic_value .)
    LEN             reduce using rule 189 (logic_recu -> logic_op logic_value .)
    COPY            reduce using rule 189 (logic_recu -> logic_op logic_value .)
    DELETE          reduce using rule 189 (logic_recu -> logic_op logic_value .)
    IF              reduce using rule 189 (logic_recu -> logic_op logic_value .)
    ELSE            reduce using rule 189 (logic_recu -> logic_op logic_value .)
    TYPE            reduce using rule 189 (logic_recu -> logic_op logic_value .)
    SWITCH          reduce using rule 189 (logic_recu -> logic_op logic_value .)
    VAR             reduce using rule 189 (logic_recu -> logic_op logic_value .)
    FUNC            reduce using rule 189 (logic_recu -> logic_op logic_value .)
    INTEGER         reduce using rule 189 (logic_recu -> logic_op logic_value .)
    FLOAT           reduce using rule 189 (logic_recu -> logic_op logic_value .)
    NOT             reduce using rule 189 (logic_recu -> logic_op logic_value .)
    $end            reduce using rule 189 (logic_recu -> logic_op logic_value .)
    RLLAVE          reduce using rule 189 (logic_recu -> logic_op logic_value .)
    INT32           reduce using rule 189 (logic_recu -> logic_op logic_value .)
    INT64           reduce using rule 189 (logic_recu -> logic_op logic_value .)
    FLOAT32         reduce using rule 189 (logic_recu -> logic_op logic_value .)
    FLOAT64         reduce using rule 189 (logic_recu -> logic_op logic_value .)
    BYTE            reduce using rule 189 (logic_recu -> logic_op logic_value .)
    WFLOAT          reduce using rule 189 (logic_recu -> logic_op logic_value .)
    WSTRING         reduce using rule 189 (logic_recu -> logic_op logic_value .)
    WINT            reduce using rule 189 (logic_recu -> logic_op logic_value .)
    BOOL            reduce using rule 189 (logic_recu -> logic_op logic_value .)
    DEFAULT         reduce using rule 189 (logic_recu -> logic_op logic_value .)
    CASE            reduce using rule 189 (logic_recu -> logic_op logic_value .)
    RETURN          reduce using rule 189 (logic_recu -> logic_op logic_value .)
    STRING          reduce using rule 189 (logic_recu -> logic_op logic_value .)
    TRUE            reduce using rule 189 (logic_recu -> logic_op logic_value .)
    FALSE           reduce using rule 189 (logic_recu -> logic_op logic_value .)
    LLLAVE          reduce using rule 189 (logic_recu -> logic_op logic_value .)
    COLON           reduce using rule 189 (logic_recu -> logic_op logic_value .)
    RPAREN          reduce using rule 189 (logic_recu -> logic_op logic_value .)
    RCORCHE         reduce using rule 189 (logic_recu -> logic_op logic_value .)
    COMA            reduce using rule 189 (logic_recu -> logic_op logic_value .)
    AND             shift and go to state 106
    OR              shift and go to state 107

    logic_op                       shift and go to state 105
    logic_recu                     shift and go to state 255

state 177

    (191) logic_value -> negation .

    AND             reduce using rule 191 (logic_value -> negation .)
    OR              reduce using rule 191 (logic_value -> negation .)
    PRINT           reduce using rule 191 (logic_value -> negation .)
    SCAN            reduce using rule 191 (logic_value -> negation .)
    FOR             reduce using rule 191 (logic_value -> negation .)
    CONST           reduce using rule 191 (logic_value -> negation .)
    ID              reduce using rule 191 (logic_value -> negation .)
    APPEND          reduce using rule 191 (logic_value -> negation .)
    LEN             reduce using rule 191 (logic_value -> negation .)
    COPY            reduce using rule 191 (logic_value -> negation .)
    DELETE          reduce using rule 191 (logic_value -> negation .)
    IF              reduce using rule 191 (logic_value -> negation .)
    ELSE            reduce using rule 191 (logic_value -> negation .)
    TYPE            reduce using rule 191 (logic_value -> negation .)
    SWITCH          reduce using rule 191 (logic_value -> negation .)
    VAR             reduce using rule 191 (logic_value -> negation .)
    FUNC            reduce using rule 191 (logic_value -> negation .)
    INTEGER         reduce using rule 191 (logic_value -> negation .)
    FLOAT           reduce using rule 191 (logic_value -> negation .)
    NOT             reduce using rule 191 (logic_value -> negation .)
    $end            reduce using rule 191 (logic_value -> negation .)
    RLLAVE          reduce using rule 191 (logic_value -> negation .)
    INT32           reduce using rule 191 (logic_value -> negation .)
    INT64           reduce using rule 191 (logic_value -> negation .)
    FLOAT32         reduce using rule 191 (logic_value -> negation .)
    FLOAT64         reduce using rule 191 (logic_value -> negation .)
    BYTE            reduce using rule 191 (logic_value -> negation .)
    WFLOAT          reduce using rule 191 (logic_value -> negation .)
    WSTRING         reduce using rule 191 (logic_value -> negation .)
    WINT            reduce using rule 191 (logic_value -> negation .)
    BOOL            reduce using rule 191 (logic_value -> negation .)
    DEFAULT         reduce using rule 191 (logic_value -> negation .)
    CASE            reduce using rule 191 (logic_value -> negation .)
    RETURN          reduce using rule 191 (logic_value -> negation .)
    STRING          reduce using rule 191 (logic_value -> negation .)
    TRUE            reduce using rule 191 (logic_value -> negation .)
    FALSE           reduce using rule 191 (logic_value -> negation .)
    LLLAVE          reduce using rule 191 (logic_value -> negation .)
    COLON           reduce using rule 191 (logic_value -> negation .)
    RPAREN          reduce using rule 191 (logic_value -> negation .)
    RCORCHE         reduce using rule 191 (logic_value -> negation .)
    COMA            reduce using rule 191 (logic_value -> negation .)


state 178

    (192) logic_value -> comparison .

    AND             reduce using rule 192 (logic_value -> comparison .)
    OR              reduce using rule 192 (logic_value -> comparison .)
    PRINT           reduce using rule 192 (logic_value -> comparison .)
    SCAN            reduce using rule 192 (logic_value -> comparison .)
    FOR             reduce using rule 192 (logic_value -> comparison .)
    CONST           reduce using rule 192 (logic_value -> comparison .)
    ID              reduce using rule 192 (logic_value -> comparison .)
    APPEND          reduce using rule 192 (logic_value -> comparison .)
    LEN             reduce using rule 192 (logic_value -> comparison .)
    COPY            reduce using rule 192 (logic_value -> comparison .)
    DELETE          reduce using rule 192 (logic_value -> comparison .)
    IF              reduce using rule 192 (logic_value -> comparison .)
    ELSE            reduce using rule 192 (logic_value -> comparison .)
    TYPE            reduce using rule 192 (logic_value -> comparison .)
    SWITCH          reduce using rule 192 (logic_value -> comparison .)
    VAR             reduce using rule 192 (logic_value -> comparison .)
    FUNC            reduce using rule 192 (logic_value -> comparison .)
    INTEGER         reduce using rule 192 (logic_value -> comparison .)
    FLOAT           reduce using rule 192 (logic_value -> comparison .)
    NOT             reduce using rule 192 (logic_value -> comparison .)
    $end            reduce using rule 192 (logic_value -> comparison .)
    RLLAVE          reduce using rule 192 (logic_value -> comparison .)
    INT32           reduce using rule 192 (logic_value -> comparison .)
    INT64           reduce using rule 192 (logic_value -> comparison .)
    FLOAT32         reduce using rule 192 (logic_value -> comparison .)
    FLOAT64         reduce using rule 192 (logic_value -> comparison .)
    BYTE            reduce using rule 192 (logic_value -> comparison .)
    WFLOAT          reduce using rule 192 (logic_value -> comparison .)
    WSTRING         reduce using rule 192 (logic_value -> comparison .)
    WINT            reduce using rule 192 (logic_value -> comparison .)
    BOOL            reduce using rule 192 (logic_value -> comparison .)
    DEFAULT         reduce using rule 192 (logic_value -> comparison .)
    CASE            reduce using rule 192 (logic_value -> comparison .)
    RETURN          reduce using rule 192 (logic_value -> comparison .)
    STRING          reduce using rule 192 (logic_value -> comparison .)
    TRUE            reduce using rule 192 (logic_value -> comparison .)
    FALSE           reduce using rule 192 (logic_value -> comparison .)
    LLLAVE          reduce using rule 192 (logic_value -> comparison .)
    COLON           reduce using rule 192 (logic_value -> comparison .)
    RPAREN          reduce using rule 192 (logic_value -> comparison .)
    RCORCHE         reduce using rule 192 (logic_value -> comparison .)
    COMA            reduce using rule 192 (logic_value -> comparison .)


state 179

    (193) logic_value -> ID .
    (179) value -> ID .
    (242) something_ex -> ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 179 (value -> ID .)
    AND             reduce using rule 193 (logic_value -> ID .)
    OR              reduce using rule 193 (logic_value -> ID .)
    PRINT           reduce using rule 193 (logic_value -> ID .)
    SCAN            reduce using rule 193 (logic_value -> ID .)
    FOR             reduce using rule 193 (logic_value -> ID .)
    CONST           reduce using rule 193 (logic_value -> ID .)
    ID              reduce using rule 193 (logic_value -> ID .)
    APPEND          reduce using rule 193 (logic_value -> ID .)
    LEN             reduce using rule 193 (logic_value -> ID .)
    COPY            reduce using rule 193 (logic_value -> ID .)
    DELETE          reduce using rule 193 (logic_value -> ID .)
    IF              reduce using rule 193 (logic_value -> ID .)
    ELSE            reduce using rule 193 (logic_value -> ID .)
    TYPE            reduce using rule 193 (logic_value -> ID .)
    SWITCH          reduce using rule 193 (logic_value -> ID .)
    VAR             reduce using rule 193 (logic_value -> ID .)
    FUNC            reduce using rule 193 (logic_value -> ID .)
    INTEGER         reduce using rule 193 (logic_value -> ID .)
    FLOAT           reduce using rule 193 (logic_value -> ID .)
    NOT             reduce using rule 193 (logic_value -> ID .)
    $end            reduce using rule 193 (logic_value -> ID .)
    RLLAVE          reduce using rule 193 (logic_value -> ID .)
    INT32           reduce using rule 193 (logic_value -> ID .)
    INT64           reduce using rule 193 (logic_value -> ID .)
    FLOAT32         reduce using rule 193 (logic_value -> ID .)
    FLOAT64         reduce using rule 193 (logic_value -> ID .)
    BYTE            reduce using rule 193 (logic_value -> ID .)
    WFLOAT          reduce using rule 193 (logic_value -> ID .)
    WSTRING         reduce using rule 193 (logic_value -> ID .)
    WINT            reduce using rule 193 (logic_value -> ID .)
    BOOL            reduce using rule 193 (logic_value -> ID .)
    DEFAULT         reduce using rule 193 (logic_value -> ID .)
    CASE            reduce using rule 193 (logic_value -> ID .)
    RETURN          reduce using rule 193 (logic_value -> ID .)
    STRING          reduce using rule 193 (logic_value -> ID .)
    TRUE            reduce using rule 193 (logic_value -> ID .)
    FALSE           reduce using rule 193 (logic_value -> ID .)
    LLLAVE          reduce using rule 193 (logic_value -> ID .)
    COLON           reduce using rule 193 (logic_value -> ID .)
    RPAREN          reduce using rule 193 (logic_value -> ID .)
    RCORCHE         reduce using rule 193 (logic_value -> ID .)
    COMA            reduce using rule 193 (logic_value -> ID .)
    GREATER         reduce using rule 179 (value -> ID .)
    SMALLER         reduce using rule 179 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 179 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 179 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 179 (value -> ID .)
    NOT_EQUAL       reduce using rule 179 (value -> ID .)
    PLUS            reduce using rule 179 (value -> ID .)
    TIMES           reduce using rule 179 (value -> ID .)
    DIVIDE          reduce using rule 179 (value -> ID .)
    MINUS           reduce using rule 179 (value -> ID .)
    MOD             reduce using rule 179 (value -> ID .)
    LCORCHE         shift and go to state 174
    LPAREN          shift and go to state 112

  ! GREATER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 242 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 242 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 242 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 242 (something_ex -> ID .) ]


state 180

    (111) decConst -> CONST ID data_type_and_value .

    COLON           reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    PRINT           reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    SCAN            reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    FOR             reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    CONST           reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    ID              reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    APPEND          reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    LEN             reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    COPY            reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    DELETE          reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    IF              reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    ELSE            reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    TYPE            reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    SWITCH          reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    VAR             reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    FUNC            reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    INTEGER         reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    FLOAT           reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    NOT             reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    $end            reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    RLLAVE          reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    INT32           reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    INT64           reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    FLOAT32         reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    FLOAT64         reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    BYTE            reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    WFLOAT          reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    WSTRING         reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    WINT            reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    BOOL            reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    DEFAULT         reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    CASE            reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    RETURN          reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    STRING          reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    TRUE            reduce using rule 111 (decConst -> CONST ID data_type_and_value .)
    FALSE           reduce using rule 111 (decConst -> CONST ID data_type_and_value .)


state 181

    (112) decConst -> CONST ID EQUAL . ID
    (113) decConst -> CONST ID EQUAL . data_structure
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE

    ID              shift and go to state 256

    data_structure                 shift and go to state 257
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102

state 182

    (95) data_type_and_value -> WSTRING . EQUAL STRING

    EQUAL           shift and go to state 258


state 183

    (96) data_type_and_value -> WINT . EQUAL int_value

    EQUAL           shift and go to state 259


state 184

    (97) data_type_and_value -> INT32 . EQUAL int_value

    EQUAL           shift and go to state 260


state 185

    (98) data_type_and_value -> INT64 . EQUAL int_value

    EQUAL           shift and go to state 261


state 186

    (99) data_type_and_value -> WFLOAT . EQUAL float_value

    EQUAL           shift and go to state 262


state 187

    (100) data_type_and_value -> FLOAT32 . EQUAL float_value

    EQUAL           shift and go to state 263


state 188

    (101) data_type_and_value -> FLOAT64 . EQUAL float_value

    EQUAL           shift and go to state 264


state 189

    (102) data_type_and_value -> BOOL . EQUAL bool_value

    EQUAL           shift and go to state 265


state 190

    (68) any -> ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN
    (242) something_ex -> ID .
    (179) value -> ID .
    (193) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for CONST resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for INT32 resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for INT64 resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for BYTE resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for WSTRING resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for WINT resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for STRING resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for TRUE resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for FALSE resolved using rule 68 (any -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 179 (value -> ID .)
    COLON           reduce using rule 68 (any -> ID .)
    PRINT           reduce using rule 68 (any -> ID .)
    SCAN            reduce using rule 68 (any -> ID .)
    FOR             reduce using rule 68 (any -> ID .)
    CONST           reduce using rule 68 (any -> ID .)
    ID              reduce using rule 68 (any -> ID .)
    APPEND          reduce using rule 68 (any -> ID .)
    LEN             reduce using rule 68 (any -> ID .)
    COPY            reduce using rule 68 (any -> ID .)
    DELETE          reduce using rule 68 (any -> ID .)
    IF              reduce using rule 68 (any -> ID .)
    ELSE            reduce using rule 68 (any -> ID .)
    TYPE            reduce using rule 68 (any -> ID .)
    SWITCH          reduce using rule 68 (any -> ID .)
    VAR             reduce using rule 68 (any -> ID .)
    FUNC            reduce using rule 68 (any -> ID .)
    INTEGER         reduce using rule 68 (any -> ID .)
    FLOAT           reduce using rule 68 (any -> ID .)
    NOT             reduce using rule 68 (any -> ID .)
    $end            reduce using rule 68 (any -> ID .)
    RLLAVE          reduce using rule 68 (any -> ID .)
    INT32           reduce using rule 68 (any -> ID .)
    INT64           reduce using rule 68 (any -> ID .)
    FLOAT32         reduce using rule 68 (any -> ID .)
    FLOAT64         reduce using rule 68 (any -> ID .)
    BYTE            reduce using rule 68 (any -> ID .)
    WFLOAT          reduce using rule 68 (any -> ID .)
    WSTRING         reduce using rule 68 (any -> ID .)
    WINT            reduce using rule 68 (any -> ID .)
    BOOL            reduce using rule 68 (any -> ID .)
    DEFAULT         reduce using rule 68 (any -> ID .)
    CASE            reduce using rule 68 (any -> ID .)
    RETURN          reduce using rule 68 (any -> ID .)
    STRING          reduce using rule 68 (any -> ID .)
    TRUE            reduce using rule 68 (any -> ID .)
    FALSE           reduce using rule 68 (any -> ID .)
    LCORCHE         shift and go to state 174
    LPAREN          shift and go to state 112
    GREATER         reduce using rule 179 (value -> ID .)
    SMALLER         reduce using rule 179 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 179 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 179 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 179 (value -> ID .)
    NOT_EQUAL       reduce using rule 179 (value -> ID .)
    PLUS            reduce using rule 179 (value -> ID .)
    TIMES           reduce using rule 179 (value -> ID .)
    DIVIDE          reduce using rule 179 (value -> ID .)
    MINUS           reduce using rule 179 (value -> ID .)
    MOD             reduce using rule 179 (value -> ID .)
    AND             reduce using rule 193 (logic_value -> ID .)
    OR              reduce using rule 193 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 242 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 242 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 242 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 242 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 242 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 242 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 242 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 242 (something_ex -> ID .) ]
  ! CONST           [ reduce using rule 242 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 242 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 242 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 242 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 242 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 242 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 242 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 242 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 242 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 242 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 242 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! INT32           [ reduce using rule 242 (something_ex -> ID .) ]
  ! INT64           [ reduce using rule 242 (something_ex -> ID .) ]
  ! FLOAT32         [ reduce using rule 242 (something_ex -> ID .) ]
  ! FLOAT64         [ reduce using rule 242 (something_ex -> ID .) ]
  ! BYTE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! WFLOAT          [ reduce using rule 242 (something_ex -> ID .) ]
  ! WSTRING         [ reduce using rule 242 (something_ex -> ID .) ]
  ! WINT            [ reduce using rule 242 (something_ex -> ID .) ]
  ! BOOL            [ reduce using rule 242 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 242 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 242 (something_ex -> ID .) ]
  ! STRING          [ reduce using rule 242 (something_ex -> ID .) ]
  ! TRUE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! FALSE           [ reduce using rule 242 (something_ex -> ID .) ]


state 191

    (65) var_asignation -> ID EQUAL any .

    COLON           reduce using rule 65 (var_asignation -> ID EQUAL any .)
    PRINT           reduce using rule 65 (var_asignation -> ID EQUAL any .)
    SCAN            reduce using rule 65 (var_asignation -> ID EQUAL any .)
    FOR             reduce using rule 65 (var_asignation -> ID EQUAL any .)
    CONST           reduce using rule 65 (var_asignation -> ID EQUAL any .)
    ID              reduce using rule 65 (var_asignation -> ID EQUAL any .)
    APPEND          reduce using rule 65 (var_asignation -> ID EQUAL any .)
    LEN             reduce using rule 65 (var_asignation -> ID EQUAL any .)
    COPY            reduce using rule 65 (var_asignation -> ID EQUAL any .)
    DELETE          reduce using rule 65 (var_asignation -> ID EQUAL any .)
    IF              reduce using rule 65 (var_asignation -> ID EQUAL any .)
    ELSE            reduce using rule 65 (var_asignation -> ID EQUAL any .)
    TYPE            reduce using rule 65 (var_asignation -> ID EQUAL any .)
    SWITCH          reduce using rule 65 (var_asignation -> ID EQUAL any .)
    VAR             reduce using rule 65 (var_asignation -> ID EQUAL any .)
    FUNC            reduce using rule 65 (var_asignation -> ID EQUAL any .)
    INTEGER         reduce using rule 65 (var_asignation -> ID EQUAL any .)
    FLOAT           reduce using rule 65 (var_asignation -> ID EQUAL any .)
    NOT             reduce using rule 65 (var_asignation -> ID EQUAL any .)
    $end            reduce using rule 65 (var_asignation -> ID EQUAL any .)
    RLLAVE          reduce using rule 65 (var_asignation -> ID EQUAL any .)
    INT32           reduce using rule 65 (var_asignation -> ID EQUAL any .)
    INT64           reduce using rule 65 (var_asignation -> ID EQUAL any .)
    FLOAT32         reduce using rule 65 (var_asignation -> ID EQUAL any .)
    FLOAT64         reduce using rule 65 (var_asignation -> ID EQUAL any .)
    BYTE            reduce using rule 65 (var_asignation -> ID EQUAL any .)
    WFLOAT          reduce using rule 65 (var_asignation -> ID EQUAL any .)
    WSTRING         reduce using rule 65 (var_asignation -> ID EQUAL any .)
    WINT            reduce using rule 65 (var_asignation -> ID EQUAL any .)
    BOOL            reduce using rule 65 (var_asignation -> ID EQUAL any .)
    DEFAULT         reduce using rule 65 (var_asignation -> ID EQUAL any .)
    CASE            reduce using rule 65 (var_asignation -> ID EQUAL any .)
    RETURN          reduce using rule 65 (var_asignation -> ID EQUAL any .)
    STRING          reduce using rule 65 (var_asignation -> ID EQUAL any .)
    TRUE            reduce using rule 65 (var_asignation -> ID EQUAL any .)
    FALSE           reduce using rule 65 (var_asignation -> ID EQUAL any .)


state 192

    (66) any -> values .

    COLON           reduce using rule 66 (any -> values .)
    PRINT           reduce using rule 66 (any -> values .)
    SCAN            reduce using rule 66 (any -> values .)
    FOR             reduce using rule 66 (any -> values .)
    CONST           reduce using rule 66 (any -> values .)
    ID              reduce using rule 66 (any -> values .)
    APPEND          reduce using rule 66 (any -> values .)
    LEN             reduce using rule 66 (any -> values .)
    COPY            reduce using rule 66 (any -> values .)
    DELETE          reduce using rule 66 (any -> values .)
    IF              reduce using rule 66 (any -> values .)
    ELSE            reduce using rule 66 (any -> values .)
    TYPE            reduce using rule 66 (any -> values .)
    SWITCH          reduce using rule 66 (any -> values .)
    VAR             reduce using rule 66 (any -> values .)
    FUNC            reduce using rule 66 (any -> values .)
    INTEGER         reduce using rule 66 (any -> values .)
    FLOAT           reduce using rule 66 (any -> values .)
    NOT             reduce using rule 66 (any -> values .)
    $end            reduce using rule 66 (any -> values .)
    RLLAVE          reduce using rule 66 (any -> values .)
    INT32           reduce using rule 66 (any -> values .)
    INT64           reduce using rule 66 (any -> values .)
    FLOAT32         reduce using rule 66 (any -> values .)
    FLOAT64         reduce using rule 66 (any -> values .)
    BYTE            reduce using rule 66 (any -> values .)
    WFLOAT          reduce using rule 66 (any -> values .)
    WSTRING         reduce using rule 66 (any -> values .)
    WINT            reduce using rule 66 (any -> values .)
    BOOL            reduce using rule 66 (any -> values .)
    DEFAULT         reduce using rule 66 (any -> values .)
    CASE            reduce using rule 66 (any -> values .)
    RETURN          reduce using rule 66 (any -> values .)
    STRING          reduce using rule 66 (any -> values .)
    TRUE            reduce using rule 66 (any -> values .)
    FALSE           reduce using rule 66 (any -> values .)


state 193

    (67) any -> operations .

    COLON           reduce using rule 67 (any -> operations .)
    PRINT           reduce using rule 67 (any -> operations .)
    SCAN            reduce using rule 67 (any -> operations .)
    FOR             reduce using rule 67 (any -> operations .)
    CONST           reduce using rule 67 (any -> operations .)
    ID              reduce using rule 67 (any -> operations .)
    APPEND          reduce using rule 67 (any -> operations .)
    LEN             reduce using rule 67 (any -> operations .)
    COPY            reduce using rule 67 (any -> operations .)
    DELETE          reduce using rule 67 (any -> operations .)
    IF              reduce using rule 67 (any -> operations .)
    ELSE            reduce using rule 67 (any -> operations .)
    TYPE            reduce using rule 67 (any -> operations .)
    SWITCH          reduce using rule 67 (any -> operations .)
    VAR             reduce using rule 67 (any -> operations .)
    FUNC            reduce using rule 67 (any -> operations .)
    INTEGER         reduce using rule 67 (any -> operations .)
    FLOAT           reduce using rule 67 (any -> operations .)
    NOT             reduce using rule 67 (any -> operations .)
    $end            reduce using rule 67 (any -> operations .)
    RLLAVE          reduce using rule 67 (any -> operations .)
    INT32           reduce using rule 67 (any -> operations .)
    INT64           reduce using rule 67 (any -> operations .)
    FLOAT32         reduce using rule 67 (any -> operations .)
    FLOAT64         reduce using rule 67 (any -> operations .)
    BYTE            reduce using rule 67 (any -> operations .)
    WFLOAT          reduce using rule 67 (any -> operations .)
    WSTRING         reduce using rule 67 (any -> operations .)
    WINT            reduce using rule 67 (any -> operations .)
    BOOL            reduce using rule 67 (any -> operations .)
    DEFAULT         reduce using rule 67 (any -> operations .)
    CASE            reduce using rule 67 (any -> operations .)
    RETURN          reduce using rule 67 (any -> operations .)
    STRING          reduce using rule 67 (any -> operations .)
    TRUE            reduce using rule 67 (any -> operations .)
    FALSE           reduce using rule 67 (any -> operations .)


state 194

    (69) any -> data_structure .
    (245) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for PRINT resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for SCAN resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for FOR resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for CONST resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for ID resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for APPEND resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for LEN resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for COPY resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for DELETE resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for IF resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for ELSE resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for TYPE resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for SWITCH resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for VAR resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for FUNC resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for INTEGER resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for FLOAT resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for NOT resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for $end resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for INT32 resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for INT64 resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for BYTE resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for WSTRING resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for WINT resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for BOOL resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for CASE resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for RETURN resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for STRING resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for TRUE resolved using rule 69 (any -> data_structure .)
  ! reduce/reduce conflict for FALSE resolved using rule 69 (any -> data_structure .)
    COLON           reduce using rule 69 (any -> data_structure .)
    PRINT           reduce using rule 69 (any -> data_structure .)
    SCAN            reduce using rule 69 (any -> data_structure .)
    FOR             reduce using rule 69 (any -> data_structure .)
    CONST           reduce using rule 69 (any -> data_structure .)
    ID              reduce using rule 69 (any -> data_structure .)
    APPEND          reduce using rule 69 (any -> data_structure .)
    LEN             reduce using rule 69 (any -> data_structure .)
    COPY            reduce using rule 69 (any -> data_structure .)
    DELETE          reduce using rule 69 (any -> data_structure .)
    IF              reduce using rule 69 (any -> data_structure .)
    ELSE            reduce using rule 69 (any -> data_structure .)
    TYPE            reduce using rule 69 (any -> data_structure .)
    SWITCH          reduce using rule 69 (any -> data_structure .)
    VAR             reduce using rule 69 (any -> data_structure .)
    FUNC            reduce using rule 69 (any -> data_structure .)
    INTEGER         reduce using rule 69 (any -> data_structure .)
    FLOAT           reduce using rule 69 (any -> data_structure .)
    NOT             reduce using rule 69 (any -> data_structure .)
    $end            reduce using rule 69 (any -> data_structure .)
    RLLAVE          reduce using rule 69 (any -> data_structure .)
    INT32           reduce using rule 69 (any -> data_structure .)
    INT64           reduce using rule 69 (any -> data_structure .)
    FLOAT32         reduce using rule 69 (any -> data_structure .)
    FLOAT64         reduce using rule 69 (any -> data_structure .)
    BYTE            reduce using rule 69 (any -> data_structure .)
    WFLOAT          reduce using rule 69 (any -> data_structure .)
    WSTRING         reduce using rule 69 (any -> data_structure .)
    WINT            reduce using rule 69 (any -> data_structure .)
    BOOL            reduce using rule 69 (any -> data_structure .)
    DEFAULT         reduce using rule 69 (any -> data_structure .)
    CASE            reduce using rule 69 (any -> data_structure .)
    RETURN          reduce using rule 69 (any -> data_structure .)
    STRING          reduce using rule 69 (any -> data_structure .)
    TRUE            reduce using rule 69 (any -> data_structure .)
    FALSE           reduce using rule 69 (any -> data_structure .)
    GREATER         reduce using rule 245 (something_ex -> data_structure .)
    SMALLER         reduce using rule 245 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 245 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 245 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 245 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 245 (something_ex -> data_structure .)
    PLUS            reduce using rule 245 (something_ex -> data_structure .)
    TIMES           reduce using rule 245 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 245 (something_ex -> data_structure .)
    MINUS           reduce using rule 245 (something_ex -> data_structure .)
    MOD             reduce using rule 245 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! PRINT           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! SCAN            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FOR             [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! CONST           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! ID              [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! APPEND          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! LEN             [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! COPY            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! DELETE          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! IF              [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! ELSE            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! TYPE            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! SWITCH          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! VAR             [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FUNC            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! INTEGER         [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FLOAT           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! NOT             [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! $end            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! INT32           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! INT64           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FLOAT32         [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FLOAT64         [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! BYTE            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! WFLOAT          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! WSTRING         [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! WINT            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! BOOL            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! DEFAULT         [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! CASE            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! RETURN          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! STRING          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! TRUE            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FALSE           [ reduce using rule 245 (something_ex -> data_structure .) ]


state 195

    (70) any -> funciones .
    (246) something_ex -> funciones .

  ! reduce/reduce conflict for COLON resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for PRINT resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for SCAN resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for FOR resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for CONST resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for ID resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for APPEND resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for LEN resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for COPY resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for DELETE resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for IF resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for ELSE resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for TYPE resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for SWITCH resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for VAR resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for FUNC resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for INTEGER resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for FLOAT resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for NOT resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for $end resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for INT32 resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for INT64 resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for BYTE resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for WSTRING resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for WINT resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for BOOL resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for CASE resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for RETURN resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for STRING resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for TRUE resolved using rule 70 (any -> funciones .)
  ! reduce/reduce conflict for FALSE resolved using rule 70 (any -> funciones .)
    COLON           reduce using rule 70 (any -> funciones .)
    PRINT           reduce using rule 70 (any -> funciones .)
    SCAN            reduce using rule 70 (any -> funciones .)
    FOR             reduce using rule 70 (any -> funciones .)
    CONST           reduce using rule 70 (any -> funciones .)
    ID              reduce using rule 70 (any -> funciones .)
    APPEND          reduce using rule 70 (any -> funciones .)
    LEN             reduce using rule 70 (any -> funciones .)
    COPY            reduce using rule 70 (any -> funciones .)
    DELETE          reduce using rule 70 (any -> funciones .)
    IF              reduce using rule 70 (any -> funciones .)
    ELSE            reduce using rule 70 (any -> funciones .)
    TYPE            reduce using rule 70 (any -> funciones .)
    SWITCH          reduce using rule 70 (any -> funciones .)
    VAR             reduce using rule 70 (any -> funciones .)
    FUNC            reduce using rule 70 (any -> funciones .)
    INTEGER         reduce using rule 70 (any -> funciones .)
    FLOAT           reduce using rule 70 (any -> funciones .)
    NOT             reduce using rule 70 (any -> funciones .)
    $end            reduce using rule 70 (any -> funciones .)
    RLLAVE          reduce using rule 70 (any -> funciones .)
    INT32           reduce using rule 70 (any -> funciones .)
    INT64           reduce using rule 70 (any -> funciones .)
    FLOAT32         reduce using rule 70 (any -> funciones .)
    FLOAT64         reduce using rule 70 (any -> funciones .)
    BYTE            reduce using rule 70 (any -> funciones .)
    WFLOAT          reduce using rule 70 (any -> funciones .)
    WSTRING         reduce using rule 70 (any -> funciones .)
    WINT            reduce using rule 70 (any -> funciones .)
    BOOL            reduce using rule 70 (any -> funciones .)
    DEFAULT         reduce using rule 70 (any -> funciones .)
    CASE            reduce using rule 70 (any -> funciones .)
    RETURN          reduce using rule 70 (any -> funciones .)
    STRING          reduce using rule 70 (any -> funciones .)
    TRUE            reduce using rule 70 (any -> funciones .)
    FALSE           reduce using rule 70 (any -> funciones .)
    GREATER         reduce using rule 246 (something_ex -> funciones .)
    SMALLER         reduce using rule 246 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 246 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 246 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 246 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 246 (something_ex -> funciones .)
    PLUS            reduce using rule 246 (something_ex -> funciones .)
    TIMES           reduce using rule 246 (something_ex -> funciones .)
    DIVIDE          reduce using rule 246 (something_ex -> funciones .)
    MINUS           reduce using rule 246 (something_ex -> funciones .)
    MOD             reduce using rule 246 (something_ex -> funciones .)

  ! COLON           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! PRINT           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! SCAN            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FOR             [ reduce using rule 246 (something_ex -> funciones .) ]
  ! CONST           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! ID              [ reduce using rule 246 (something_ex -> funciones .) ]
  ! APPEND          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! LEN             [ reduce using rule 246 (something_ex -> funciones .) ]
  ! COPY            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! DELETE          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! IF              [ reduce using rule 246 (something_ex -> funciones .) ]
  ! ELSE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! TYPE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! SWITCH          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! VAR             [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FUNC            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! INTEGER         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FLOAT           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! NOT             [ reduce using rule 246 (something_ex -> funciones .) ]
  ! $end            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! RLLAVE          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! INT32           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! INT64           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FLOAT32         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FLOAT64         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! BYTE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! WFLOAT          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! WSTRING         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! WINT            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! BOOL            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! DEFAULT         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! CASE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! RETURN          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! STRING          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! TRUE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FALSE           [ reduce using rule 246 (something_ex -> funciones .) ]


state 196

    (171) cStruct -> ID DEQUAL ID . LLLAVE asignaciones RLLAVE
    (130) algo -> ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN
    (242) something_ex -> ID .
    (179) value -> ID .
    (193) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for CONST resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for INT32 resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for INT64 resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for BYTE resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for WSTRING resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for WINT resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for STRING resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for TRUE resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for FALSE resolved using rule 130 (algo -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 179 (value -> ID .)
    LLLAVE          shift and go to state 266
    COLON           reduce using rule 130 (algo -> ID .)
    PRINT           reduce using rule 130 (algo -> ID .)
    SCAN            reduce using rule 130 (algo -> ID .)
    FOR             reduce using rule 130 (algo -> ID .)
    CONST           reduce using rule 130 (algo -> ID .)
    ID              reduce using rule 130 (algo -> ID .)
    APPEND          reduce using rule 130 (algo -> ID .)
    LEN             reduce using rule 130 (algo -> ID .)
    COPY            reduce using rule 130 (algo -> ID .)
    DELETE          reduce using rule 130 (algo -> ID .)
    IF              reduce using rule 130 (algo -> ID .)
    ELSE            reduce using rule 130 (algo -> ID .)
    TYPE            reduce using rule 130 (algo -> ID .)
    SWITCH          reduce using rule 130 (algo -> ID .)
    VAR             reduce using rule 130 (algo -> ID .)
    FUNC            reduce using rule 130 (algo -> ID .)
    INTEGER         reduce using rule 130 (algo -> ID .)
    FLOAT           reduce using rule 130 (algo -> ID .)
    NOT             reduce using rule 130 (algo -> ID .)
    $end            reduce using rule 130 (algo -> ID .)
    RLLAVE          reduce using rule 130 (algo -> ID .)
    INT32           reduce using rule 130 (algo -> ID .)
    INT64           reduce using rule 130 (algo -> ID .)
    FLOAT32         reduce using rule 130 (algo -> ID .)
    FLOAT64         reduce using rule 130 (algo -> ID .)
    BYTE            reduce using rule 130 (algo -> ID .)
    WFLOAT          reduce using rule 130 (algo -> ID .)
    WSTRING         reduce using rule 130 (algo -> ID .)
    WINT            reduce using rule 130 (algo -> ID .)
    BOOL            reduce using rule 130 (algo -> ID .)
    DEFAULT         reduce using rule 130 (algo -> ID .)
    CASE            reduce using rule 130 (algo -> ID .)
    RETURN          reduce using rule 130 (algo -> ID .)
    STRING          reduce using rule 130 (algo -> ID .)
    TRUE            reduce using rule 130 (algo -> ID .)
    FALSE           reduce using rule 130 (algo -> ID .)
    LCORCHE         shift and go to state 174
    LPAREN          shift and go to state 112
    GREATER         reduce using rule 179 (value -> ID .)
    SMALLER         reduce using rule 179 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 179 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 179 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 179 (value -> ID .)
    NOT_EQUAL       reduce using rule 179 (value -> ID .)
    PLUS            reduce using rule 179 (value -> ID .)
    TIMES           reduce using rule 179 (value -> ID .)
    DIVIDE          reduce using rule 179 (value -> ID .)
    MINUS           reduce using rule 179 (value -> ID .)
    MOD             reduce using rule 179 (value -> ID .)
    AND             reduce using rule 193 (logic_value -> ID .)
    OR              reduce using rule 193 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 242 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 242 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 242 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 242 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 242 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 242 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 242 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 242 (something_ex -> ID .) ]
  ! CONST           [ reduce using rule 242 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 242 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 242 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 242 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 242 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 242 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 242 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 242 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 242 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 242 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 242 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! INT32           [ reduce using rule 242 (something_ex -> ID .) ]
  ! INT64           [ reduce using rule 242 (something_ex -> ID .) ]
  ! FLOAT32         [ reduce using rule 242 (something_ex -> ID .) ]
  ! FLOAT64         [ reduce using rule 242 (something_ex -> ID .) ]
  ! BYTE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! WFLOAT          [ reduce using rule 242 (something_ex -> ID .) ]
  ! WSTRING         [ reduce using rule 242 (something_ex -> ID .) ]
  ! WINT            [ reduce using rule 242 (something_ex -> ID .) ]
  ! BOOL            [ reduce using rule 242 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 242 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 242 (something_ex -> ID .) ]
  ! STRING          [ reduce using rule 242 (something_ex -> ID .) ]
  ! TRUE            [ reduce using rule 242 (something_ex -> ID .) ]
  ! FALSE           [ reduce using rule 242 (something_ex -> ID .) ]


state 197

    (136) slice_declaration -> ID DEQUAL funM .

    COLON           reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    PRINT           reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    SCAN            reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    FOR             reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    CONST           reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    ID              reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    APPEND          reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    LEN             reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    COPY            reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    DELETE          reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    IF              reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    ELSE            reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    TYPE            reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    SWITCH          reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    VAR             reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    FUNC            reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    INTEGER         reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    FLOAT           reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    NOT             reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    $end            reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    RLLAVE          reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    INT32           reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    INT64           reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    FLOAT32         reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    FLOAT64         reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    BYTE            reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    WFLOAT          reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    WSTRING         reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    WINT            reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    BOOL            reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    DEFAULT         reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    CASE            reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    RETURN          reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    STRING          reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    TRUE            reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)
    FALSE           reduce using rule 136 (slice_declaration -> ID DEQUAL funM .)


state 198

    (137) slice_declaration -> ID DEQUAL LCORCHE . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 267


state 199

    (127) dynamic -> ID DEQUAL algo .

    COLON           reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    PRINT           reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    SCAN            reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    FOR             reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    CONST           reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    ID              reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    APPEND          reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    LEN             reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    COPY            reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    DELETE          reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    IF              reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    ELSE            reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    TYPE            reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    SWITCH          reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    VAR             reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    FUNC            reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    INTEGER         reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    FLOAT           reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    NOT             reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    $end            reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    RLLAVE          reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    INT32           reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    INT64           reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    FLOAT32         reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    FLOAT64         reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    BYTE            reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    WFLOAT          reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    WSTRING         reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    WINT            reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    BOOL            reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    DEFAULT         reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    CASE            reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    RETURN          reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    STRING          reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    TRUE            reduce using rule 127 (dynamic -> ID DEQUAL algo .)
    FALSE           reduce using rule 127 (dynamic -> ID DEQUAL algo .)


state 200

    (138) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (139) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LPAREN          shift and go to state 268


state 201

    (128) algo -> values .

    COLON           reduce using rule 128 (algo -> values .)
    PRINT           reduce using rule 128 (algo -> values .)
    SCAN            reduce using rule 128 (algo -> values .)
    FOR             reduce using rule 128 (algo -> values .)
    CONST           reduce using rule 128 (algo -> values .)
    ID              reduce using rule 128 (algo -> values .)
    APPEND          reduce using rule 128 (algo -> values .)
    LEN             reduce using rule 128 (algo -> values .)
    COPY            reduce using rule 128 (algo -> values .)
    DELETE          reduce using rule 128 (algo -> values .)
    IF              reduce using rule 128 (algo -> values .)
    ELSE            reduce using rule 128 (algo -> values .)
    TYPE            reduce using rule 128 (algo -> values .)
    SWITCH          reduce using rule 128 (algo -> values .)
    VAR             reduce using rule 128 (algo -> values .)
    FUNC            reduce using rule 128 (algo -> values .)
    INTEGER         reduce using rule 128 (algo -> values .)
    FLOAT           reduce using rule 128 (algo -> values .)
    NOT             reduce using rule 128 (algo -> values .)
    $end            reduce using rule 128 (algo -> values .)
    RLLAVE          reduce using rule 128 (algo -> values .)
    INT32           reduce using rule 128 (algo -> values .)
    INT64           reduce using rule 128 (algo -> values .)
    FLOAT32         reduce using rule 128 (algo -> values .)
    FLOAT64         reduce using rule 128 (algo -> values .)
    BYTE            reduce using rule 128 (algo -> values .)
    WFLOAT          reduce using rule 128 (algo -> values .)
    WSTRING         reduce using rule 128 (algo -> values .)
    WINT            reduce using rule 128 (algo -> values .)
    BOOL            reduce using rule 128 (algo -> values .)
    DEFAULT         reduce using rule 128 (algo -> values .)
    CASE            reduce using rule 128 (algo -> values .)
    RETURN          reduce using rule 128 (algo -> values .)
    STRING          reduce using rule 128 (algo -> values .)
    TRUE            reduce using rule 128 (algo -> values .)
    FALSE           reduce using rule 128 (algo -> values .)


state 202

    (129) algo -> operations .

    COLON           reduce using rule 129 (algo -> operations .)
    PRINT           reduce using rule 129 (algo -> operations .)
    SCAN            reduce using rule 129 (algo -> operations .)
    FOR             reduce using rule 129 (algo -> operations .)
    CONST           reduce using rule 129 (algo -> operations .)
    ID              reduce using rule 129 (algo -> operations .)
    APPEND          reduce using rule 129 (algo -> operations .)
    LEN             reduce using rule 129 (algo -> operations .)
    COPY            reduce using rule 129 (algo -> operations .)
    DELETE          reduce using rule 129 (algo -> operations .)
    IF              reduce using rule 129 (algo -> operations .)
    ELSE            reduce using rule 129 (algo -> operations .)
    TYPE            reduce using rule 129 (algo -> operations .)
    SWITCH          reduce using rule 129 (algo -> operations .)
    VAR             reduce using rule 129 (algo -> operations .)
    FUNC            reduce using rule 129 (algo -> operations .)
    INTEGER         reduce using rule 129 (algo -> operations .)
    FLOAT           reduce using rule 129 (algo -> operations .)
    NOT             reduce using rule 129 (algo -> operations .)
    $end            reduce using rule 129 (algo -> operations .)
    RLLAVE          reduce using rule 129 (algo -> operations .)
    INT32           reduce using rule 129 (algo -> operations .)
    INT64           reduce using rule 129 (algo -> operations .)
    FLOAT32         reduce using rule 129 (algo -> operations .)
    FLOAT64         reduce using rule 129 (algo -> operations .)
    BYTE            reduce using rule 129 (algo -> operations .)
    WFLOAT          reduce using rule 129 (algo -> operations .)
    WSTRING         reduce using rule 129 (algo -> operations .)
    WINT            reduce using rule 129 (algo -> operations .)
    BOOL            reduce using rule 129 (algo -> operations .)
    DEFAULT         reduce using rule 129 (algo -> operations .)
    CASE            reduce using rule 129 (algo -> operations .)
    RETURN          reduce using rule 129 (algo -> operations .)
    STRING          reduce using rule 129 (algo -> operations .)
    TRUE            reduce using rule 129 (algo -> operations .)
    FALSE           reduce using rule 129 (algo -> operations .)


state 203

    (131) algo -> data_structure .
    (245) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for PRINT resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for SCAN resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for FOR resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for CONST resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for ID resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for APPEND resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for LEN resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for COPY resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for DELETE resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for IF resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for ELSE resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for TYPE resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for SWITCH resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for VAR resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for FUNC resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for INTEGER resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for FLOAT resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for NOT resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for $end resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for INT32 resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for INT64 resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for BYTE resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for WSTRING resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for WINT resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for BOOL resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for CASE resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for RETURN resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for STRING resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for TRUE resolved using rule 131 (algo -> data_structure .)
  ! reduce/reduce conflict for FALSE resolved using rule 131 (algo -> data_structure .)
    COLON           reduce using rule 131 (algo -> data_structure .)
    PRINT           reduce using rule 131 (algo -> data_structure .)
    SCAN            reduce using rule 131 (algo -> data_structure .)
    FOR             reduce using rule 131 (algo -> data_structure .)
    CONST           reduce using rule 131 (algo -> data_structure .)
    ID              reduce using rule 131 (algo -> data_structure .)
    APPEND          reduce using rule 131 (algo -> data_structure .)
    LEN             reduce using rule 131 (algo -> data_structure .)
    COPY            reduce using rule 131 (algo -> data_structure .)
    DELETE          reduce using rule 131 (algo -> data_structure .)
    IF              reduce using rule 131 (algo -> data_structure .)
    ELSE            reduce using rule 131 (algo -> data_structure .)
    TYPE            reduce using rule 131 (algo -> data_structure .)
    SWITCH          reduce using rule 131 (algo -> data_structure .)
    VAR             reduce using rule 131 (algo -> data_structure .)
    FUNC            reduce using rule 131 (algo -> data_structure .)
    INTEGER         reduce using rule 131 (algo -> data_structure .)
    FLOAT           reduce using rule 131 (algo -> data_structure .)
    NOT             reduce using rule 131 (algo -> data_structure .)
    $end            reduce using rule 131 (algo -> data_structure .)
    RLLAVE          reduce using rule 131 (algo -> data_structure .)
    INT32           reduce using rule 131 (algo -> data_structure .)
    INT64           reduce using rule 131 (algo -> data_structure .)
    FLOAT32         reduce using rule 131 (algo -> data_structure .)
    FLOAT64         reduce using rule 131 (algo -> data_structure .)
    BYTE            reduce using rule 131 (algo -> data_structure .)
    WFLOAT          reduce using rule 131 (algo -> data_structure .)
    WSTRING         reduce using rule 131 (algo -> data_structure .)
    WINT            reduce using rule 131 (algo -> data_structure .)
    BOOL            reduce using rule 131 (algo -> data_structure .)
    DEFAULT         reduce using rule 131 (algo -> data_structure .)
    CASE            reduce using rule 131 (algo -> data_structure .)
    RETURN          reduce using rule 131 (algo -> data_structure .)
    STRING          reduce using rule 131 (algo -> data_structure .)
    TRUE            reduce using rule 131 (algo -> data_structure .)
    FALSE           reduce using rule 131 (algo -> data_structure .)
    GREATER         reduce using rule 245 (something_ex -> data_structure .)
    SMALLER         reduce using rule 245 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 245 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 245 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 245 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 245 (something_ex -> data_structure .)
    PLUS            reduce using rule 245 (something_ex -> data_structure .)
    TIMES           reduce using rule 245 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 245 (something_ex -> data_structure .)
    MINUS           reduce using rule 245 (something_ex -> data_structure .)
    MOD             reduce using rule 245 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! PRINT           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! SCAN            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FOR             [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! CONST           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! ID              [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! APPEND          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! LEN             [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! COPY            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! DELETE          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! IF              [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! ELSE            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! TYPE            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! SWITCH          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! VAR             [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FUNC            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! INTEGER         [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FLOAT           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! NOT             [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! $end            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! INT32           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! INT64           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FLOAT32         [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FLOAT64         [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! BYTE            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! WFLOAT          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! WSTRING         [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! WINT            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! BOOL            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! DEFAULT         [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! CASE            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! RETURN          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! STRING          [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! TRUE            [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! FALSE           [ reduce using rule 245 (something_ex -> data_structure .) ]


state 204

    (132) algo -> funciones .
    (246) something_ex -> funciones .

  ! reduce/reduce conflict for COLON resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for PRINT resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for SCAN resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for FOR resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for CONST resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for ID resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for APPEND resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for LEN resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for COPY resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for DELETE resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for IF resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for ELSE resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for TYPE resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for SWITCH resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for VAR resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for FUNC resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for INTEGER resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for FLOAT resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for NOT resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for $end resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for INT32 resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for INT64 resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for BYTE resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for WSTRING resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for WINT resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for BOOL resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for CASE resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for RETURN resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for STRING resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for TRUE resolved using rule 132 (algo -> funciones .)
  ! reduce/reduce conflict for FALSE resolved using rule 132 (algo -> funciones .)
    COLON           reduce using rule 132 (algo -> funciones .)
    PRINT           reduce using rule 132 (algo -> funciones .)
    SCAN            reduce using rule 132 (algo -> funciones .)
    FOR             reduce using rule 132 (algo -> funciones .)
    CONST           reduce using rule 132 (algo -> funciones .)
    ID              reduce using rule 132 (algo -> funciones .)
    APPEND          reduce using rule 132 (algo -> funciones .)
    LEN             reduce using rule 132 (algo -> funciones .)
    COPY            reduce using rule 132 (algo -> funciones .)
    DELETE          reduce using rule 132 (algo -> funciones .)
    IF              reduce using rule 132 (algo -> funciones .)
    ELSE            reduce using rule 132 (algo -> funciones .)
    TYPE            reduce using rule 132 (algo -> funciones .)
    SWITCH          reduce using rule 132 (algo -> funciones .)
    VAR             reduce using rule 132 (algo -> funciones .)
    FUNC            reduce using rule 132 (algo -> funciones .)
    INTEGER         reduce using rule 132 (algo -> funciones .)
    FLOAT           reduce using rule 132 (algo -> funciones .)
    NOT             reduce using rule 132 (algo -> funciones .)
    $end            reduce using rule 132 (algo -> funciones .)
    RLLAVE          reduce using rule 132 (algo -> funciones .)
    INT32           reduce using rule 132 (algo -> funciones .)
    INT64           reduce using rule 132 (algo -> funciones .)
    FLOAT32         reduce using rule 132 (algo -> funciones .)
    FLOAT64         reduce using rule 132 (algo -> funciones .)
    BYTE            reduce using rule 132 (algo -> funciones .)
    WFLOAT          reduce using rule 132 (algo -> funciones .)
    WSTRING         reduce using rule 132 (algo -> funciones .)
    WINT            reduce using rule 132 (algo -> funciones .)
    BOOL            reduce using rule 132 (algo -> funciones .)
    DEFAULT         reduce using rule 132 (algo -> funciones .)
    CASE            reduce using rule 132 (algo -> funciones .)
    RETURN          reduce using rule 132 (algo -> funciones .)
    STRING          reduce using rule 132 (algo -> funciones .)
    TRUE            reduce using rule 132 (algo -> funciones .)
    FALSE           reduce using rule 132 (algo -> funciones .)
    GREATER         reduce using rule 246 (something_ex -> funciones .)
    SMALLER         reduce using rule 246 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 246 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 246 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 246 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 246 (something_ex -> funciones .)
    PLUS            reduce using rule 246 (something_ex -> funciones .)
    TIMES           reduce using rule 246 (something_ex -> funciones .)
    DIVIDE          reduce using rule 246 (something_ex -> funciones .)
    MINUS           reduce using rule 246 (something_ex -> funciones .)
    MOD             reduce using rule 246 (something_ex -> funciones .)

  ! COLON           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! PRINT           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! SCAN            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FOR             [ reduce using rule 246 (something_ex -> funciones .) ]
  ! CONST           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! ID              [ reduce using rule 246 (something_ex -> funciones .) ]
  ! APPEND          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! LEN             [ reduce using rule 246 (something_ex -> funciones .) ]
  ! COPY            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! DELETE          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! IF              [ reduce using rule 246 (something_ex -> funciones .) ]
  ! ELSE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! TYPE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! SWITCH          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! VAR             [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FUNC            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! INTEGER         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FLOAT           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! NOT             [ reduce using rule 246 (something_ex -> funciones .) ]
  ! $end            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! RLLAVE          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! INT32           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! INT64           [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FLOAT32         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FLOAT64         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! BYTE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! WFLOAT          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! WSTRING         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! WINT            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! BOOL            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! DEFAULT         [ reduce using rule 246 (something_ex -> funciones .) ]
  ! CASE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! RETURN          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! STRING          [ reduce using rule 246 (something_ex -> funciones .) ]
  ! TRUE            [ reduce using rule 246 (something_ex -> funciones .) ]
  ! FALSE           [ reduce using rule 246 (something_ex -> funciones .) ]


state 205

    (209) index -> ID .
    (144) index_s -> ID .
    (215) key -> ID .
    (242) something_ex -> ID .
    (179) value -> ID .
    (193) logic_value -> ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for RCORCHE resolved using rule 144 (index_s -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 144 (index_s -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 144 (index_s -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 179 (value -> ID .)
    RCORCHE         reduce using rule 144 (index_s -> ID .)
    GREATER         reduce using rule 179 (value -> ID .)
    SMALLER         reduce using rule 179 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 179 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 179 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 179 (value -> ID .)
    NOT_EQUAL       reduce using rule 179 (value -> ID .)
    PLUS            reduce using rule 179 (value -> ID .)
    TIMES           reduce using rule 179 (value -> ID .)
    DIVIDE          reduce using rule 179 (value -> ID .)
    MINUS           reduce using rule 179 (value -> ID .)
    MOD             reduce using rule 179 (value -> ID .)
    AND             reduce using rule 193 (logic_value -> ID .)
    OR              reduce using rule 193 (logic_value -> ID .)
    LCORCHE         shift and go to state 174
    LPAREN          shift and go to state 112

  ! RCORCHE         [ reduce using rule 209 (index -> ID .) ]
  ! RCORCHE         [ reduce using rule 215 (key -> ID .) ]
  ! GREATER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 242 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 242 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 242 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 242 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 242 (something_ex -> ID .) ]


state 206

    (208) array_var -> ID LCORCHE index . RCORCHE

    RCORCHE         shift and go to state 269


state 207

    (143) slice_var -> ID LCORCHE index_s . RCORCHE

    RCORCHE         shift and go to state 270


state 208

    (214) map_var -> ID LCORCHE key . RCORCHE

    RCORCHE         shift and go to state 271


state 209

    (210) index -> INTEGER .
    (145) index_s -> INTEGER .
    (46) values -> INTEGER .
    (243) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 145 (index_s -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 46 (values -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 46 (values -> INTEGER .)
    RCORCHE         reduce using rule 46 (values -> INTEGER .)
    GREATER         reduce using rule 243 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 243 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 243 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 243 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 243 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 243 (something_ex -> INTEGER .)
    PLUS            reduce using rule 243 (something_ex -> INTEGER .)
    TIMES           reduce using rule 243 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 243 (something_ex -> INTEGER .)
    MINUS           reduce using rule 243 (something_ex -> INTEGER .)
    MOD             reduce using rule 243 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 210 (index -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 145 (index_s -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 243 (something_ex -> INTEGER .) ]


state 210

    (211) index -> expression .
    (146) index_s -> expression .
    (59) operations -> expression .
    (180) value -> expression .

  ! reduce/reduce conflict for RCORCHE resolved using rule 146 (index_s -> expression .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 59 (operations -> expression .)
    RCORCHE         reduce using rule 59 (operations -> expression .)
    GREATER         reduce using rule 180 (value -> expression .)
    SMALLER         reduce using rule 180 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 180 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 180 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 180 (value -> expression .)
    NOT_EQUAL       reduce using rule 180 (value -> expression .)
    PLUS            reduce using rule 180 (value -> expression .)
    TIMES           reduce using rule 180 (value -> expression .)
    DIVIDE          reduce using rule 180 (value -> expression .)
    MINUS           reduce using rule 180 (value -> expression .)
    MOD             reduce using rule 180 (value -> expression .)

  ! RCORCHE         [ reduce using rule 211 (index -> expression .) ]
  ! RCORCHE         [ reduce using rule 146 (index_s -> expression .) ]


state 211

    (216) key -> values .

    RCORCHE         reduce using rule 216 (key -> values .)


state 212

    (217) key -> operations .

    RCORCHE         reduce using rule 217 (key -> operations .)


state 213

    (86) list_params -> ID .
    (87) list_params -> ID . COMA more_p

    RPAREN          reduce using rule 86 (list_params -> ID .)
    COMA            shift and go to state 272


state 214

    (84) call_func -> ID LPAREN list_params . RPAREN

    RPAREN          shift and go to state 273


state 215

    (85) call_func -> ID LPAREN RPAREN .

    COLON           reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    PRINT           reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    SCAN            reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    FOR             reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    CONST           reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    ID              reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    APPEND          reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    LEN             reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    COPY            reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    DELETE          reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    IF              reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    ELSE            reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    TYPE            reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    SWITCH          reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    VAR             reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    FUNC            reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    INTEGER         reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    FLOAT           reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    NOT             reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    $end            reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    GREATER         reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    SMALLER         reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    GREATER_OR_EQUAL reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    EQUAL_COMPARE   reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    NOT_EQUAL       reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    TIMES           reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    MOD             reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    RLLAVE          reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    INT32           reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    INT64           reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    FLOAT32         reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    FLOAT64         reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    BYTE            reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    WFLOAT          reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    WSTRING         reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    WINT            reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    BOOL            reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    DEFAULT         reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    CASE            reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    RETURN          reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    STRING          reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    TRUE            reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    FALSE           reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    AND             reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    OR              reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    LLLAVE          reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    RCORCHE         reduce using rule 85 (call_func -> ID LPAREN RPAREN .)
    COMA            reduce using rule 85 (call_func -> ID LPAREN RPAREN .)


state 216

    (152) funciones -> APPEND LPAREN ID . COMA values RPAREN
    (153) funciones -> APPEND LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 274


state 217

    (154) funciones -> LEN LPAREN ID . RPAREN

    RPAREN          shift and go to state 275


state 218

    (155) funciones -> COPY LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 276


state 219

    (156) funciones -> DELETE LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 277


state 220

    (160) SenIF -> IF comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    comparison                     shift and go to state 8
    codigo                         shift and go to state 278
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 221

    (161) SenIF -> IF TRUE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 279
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 222

    (162) SenIF -> IF FALSE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 280
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 223

    (163) SenElseIF -> ELSE IF comparison . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 281


state 224

    (164) SenElseIF -> ELSE IF TRUE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 282


state 225

    (165) SenElseIF -> ELSE IF FALSE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 283


state 226

    (166) SenElse -> ELSE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 284


state 227

    (167) SenStruct -> TYPE ID STRUCT . LLLAVE declaration RLLAVE

    LLLAVE          shift and go to state 285


state 228

    (198) switch_statement -> SWITCH ID LLLAVE . cases RLLAVE
    (199) cases -> . CASE values POINTS codigo
    (200) cases -> . CASE values POINTS codigo more

    CASE            shift and go to state 287

    cases                          shift and go to state 286

state 229

    (203) array_declaration -> VAR ID LCORCHE . capacity RCORCHE data_types
    (133) slice_declaration -> VAR ID LCORCHE . RCORCHE data_types
    (213) map_declaration -> VAR ID LCORCHE . data_types RCORCHE data_types
    (205) capacity -> . INTEGER
    (206) capacity -> . ID
    (207) capacity -> . expression
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WFLOAT
    (56) data_types -> . WSTRING
    (57) data_types -> . WINT
    (58) data_types -> . BOOL
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    RCORCHE         shift and go to state 290
    INTEGER         shift and go to state 292
    ID              shift and go to state 288
    INT32           shift and go to state 132
    INT64           shift and go to state 133
    FLOAT32         shift and go to state 134
    FLOAT64         shift and go to state 135
    BYTE            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    WINT            shift and go to state 139
    BOOL            shift and go to state 140
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    capacity                       shift and go to state 289
    data_types                     shift and go to state 291
    expression                     shift and go to state 293
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 230

    (122) single -> VAR ID data_types .
    (123) single -> VAR ID data_types . EQUAL funciones
    (124) single -> VAR ID data_types . EQUAL ID
    (125) single -> VAR ID data_types . EQUAL data_structure

    COLON           reduce using rule 122 (single -> VAR ID data_types .)
    PRINT           reduce using rule 122 (single -> VAR ID data_types .)
    SCAN            reduce using rule 122 (single -> VAR ID data_types .)
    FOR             reduce using rule 122 (single -> VAR ID data_types .)
    CONST           reduce using rule 122 (single -> VAR ID data_types .)
    ID              reduce using rule 122 (single -> VAR ID data_types .)
    APPEND          reduce using rule 122 (single -> VAR ID data_types .)
    LEN             reduce using rule 122 (single -> VAR ID data_types .)
    COPY            reduce using rule 122 (single -> VAR ID data_types .)
    DELETE          reduce using rule 122 (single -> VAR ID data_types .)
    IF              reduce using rule 122 (single -> VAR ID data_types .)
    ELSE            reduce using rule 122 (single -> VAR ID data_types .)
    TYPE            reduce using rule 122 (single -> VAR ID data_types .)
    SWITCH          reduce using rule 122 (single -> VAR ID data_types .)
    VAR             reduce using rule 122 (single -> VAR ID data_types .)
    FUNC            reduce using rule 122 (single -> VAR ID data_types .)
    INTEGER         reduce using rule 122 (single -> VAR ID data_types .)
    FLOAT           reduce using rule 122 (single -> VAR ID data_types .)
    NOT             reduce using rule 122 (single -> VAR ID data_types .)
    $end            reduce using rule 122 (single -> VAR ID data_types .)
    RLLAVE          reduce using rule 122 (single -> VAR ID data_types .)
    INT32           reduce using rule 122 (single -> VAR ID data_types .)
    INT64           reduce using rule 122 (single -> VAR ID data_types .)
    FLOAT32         reduce using rule 122 (single -> VAR ID data_types .)
    FLOAT64         reduce using rule 122 (single -> VAR ID data_types .)
    BYTE            reduce using rule 122 (single -> VAR ID data_types .)
    WFLOAT          reduce using rule 122 (single -> VAR ID data_types .)
    WSTRING         reduce using rule 122 (single -> VAR ID data_types .)
    WINT            reduce using rule 122 (single -> VAR ID data_types .)
    BOOL            reduce using rule 122 (single -> VAR ID data_types .)
    DEFAULT         reduce using rule 122 (single -> VAR ID data_types .)
    CASE            reduce using rule 122 (single -> VAR ID data_types .)
    RETURN          reduce using rule 122 (single -> VAR ID data_types .)
    STRING          reduce using rule 122 (single -> VAR ID data_types .)
    TRUE            reduce using rule 122 (single -> VAR ID data_types .)
    FALSE           reduce using rule 122 (single -> VAR ID data_types .)
    EQUAL           shift and go to state 294


state 231

    (204) array_declaration -> VAR ID EQUAL . LCORCHE capacity RCORCHE data_types arr_content
    (134) slice_declaration -> VAR ID EQUAL . LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> VAR ID EQUAL . funM
    (138) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (139) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LCORCHE         shift and go to state 295
    MAKE            shift and go to state 200

    funM                           shift and go to state 296

state 232

    (126) single -> VAR ID data_type_and_value .

    COLON           reduce using rule 126 (single -> VAR ID data_type_and_value .)
    PRINT           reduce using rule 126 (single -> VAR ID data_type_and_value .)
    SCAN            reduce using rule 126 (single -> VAR ID data_type_and_value .)
    FOR             reduce using rule 126 (single -> VAR ID data_type_and_value .)
    CONST           reduce using rule 126 (single -> VAR ID data_type_and_value .)
    ID              reduce using rule 126 (single -> VAR ID data_type_and_value .)
    APPEND          reduce using rule 126 (single -> VAR ID data_type_and_value .)
    LEN             reduce using rule 126 (single -> VAR ID data_type_and_value .)
    COPY            reduce using rule 126 (single -> VAR ID data_type_and_value .)
    DELETE          reduce using rule 126 (single -> VAR ID data_type_and_value .)
    IF              reduce using rule 126 (single -> VAR ID data_type_and_value .)
    ELSE            reduce using rule 126 (single -> VAR ID data_type_and_value .)
    TYPE            reduce using rule 126 (single -> VAR ID data_type_and_value .)
    SWITCH          reduce using rule 126 (single -> VAR ID data_type_and_value .)
    VAR             reduce using rule 126 (single -> VAR ID data_type_and_value .)
    FUNC            reduce using rule 126 (single -> VAR ID data_type_and_value .)
    INTEGER         reduce using rule 126 (single -> VAR ID data_type_and_value .)
    FLOAT           reduce using rule 126 (single -> VAR ID data_type_and_value .)
    NOT             reduce using rule 126 (single -> VAR ID data_type_and_value .)
    $end            reduce using rule 126 (single -> VAR ID data_type_and_value .)
    RLLAVE          reduce using rule 126 (single -> VAR ID data_type_and_value .)
    INT32           reduce using rule 126 (single -> VAR ID data_type_and_value .)
    INT64           reduce using rule 126 (single -> VAR ID data_type_and_value .)
    FLOAT32         reduce using rule 126 (single -> VAR ID data_type_and_value .)
    FLOAT64         reduce using rule 126 (single -> VAR ID data_type_and_value .)
    BYTE            reduce using rule 126 (single -> VAR ID data_type_and_value .)
    WFLOAT          reduce using rule 126 (single -> VAR ID data_type_and_value .)
    WSTRING         reduce using rule 126 (single -> VAR ID data_type_and_value .)
    WINT            reduce using rule 126 (single -> VAR ID data_type_and_value .)
    BOOL            reduce using rule 126 (single -> VAR ID data_type_and_value .)
    DEFAULT         reduce using rule 126 (single -> VAR ID data_type_and_value .)
    CASE            reduce using rule 126 (single -> VAR ID data_type_and_value .)
    RETURN          reduce using rule 126 (single -> VAR ID data_type_and_value .)
    STRING          reduce using rule 126 (single -> VAR ID data_type_and_value .)
    TRUE            reduce using rule 126 (single -> VAR ID data_type_and_value .)
    FALSE           reduce using rule 126 (single -> VAR ID data_type_and_value .)


state 233

    (119) list_var -> VAR ID COMA . more
    (120) more -> . ID
    (121) more -> . ID COMA more
    (201) more -> . cases
    (202) more -> . DEFAULT POINTS codigo
    (199) cases -> . CASE values POINTS codigo
    (200) cases -> . CASE values POINTS codigo more

    ID              shift and go to state 297
    DEFAULT         shift and go to state 300
    CASE            shift and go to state 287

    more                           shift and go to state 298
    cases                          shift and go to state 299

state 234

    (50) data_types -> INT32 .
    (97) data_type_and_value -> INT32 . EQUAL int_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 50 (data_types -> INT32 .)
    PRINT           reduce using rule 50 (data_types -> INT32 .)
    SCAN            reduce using rule 50 (data_types -> INT32 .)
    FOR             reduce using rule 50 (data_types -> INT32 .)
    CONST           reduce using rule 50 (data_types -> INT32 .)
    ID              reduce using rule 50 (data_types -> INT32 .)
    APPEND          reduce using rule 50 (data_types -> INT32 .)
    LEN             reduce using rule 50 (data_types -> INT32 .)
    COPY            reduce using rule 50 (data_types -> INT32 .)
    DELETE          reduce using rule 50 (data_types -> INT32 .)
    IF              reduce using rule 50 (data_types -> INT32 .)
    ELSE            reduce using rule 50 (data_types -> INT32 .)
    TYPE            reduce using rule 50 (data_types -> INT32 .)
    SWITCH          reduce using rule 50 (data_types -> INT32 .)
    VAR             reduce using rule 50 (data_types -> INT32 .)
    FUNC            reduce using rule 50 (data_types -> INT32 .)
    INTEGER         reduce using rule 50 (data_types -> INT32 .)
    FLOAT           reduce using rule 50 (data_types -> INT32 .)
    NOT             reduce using rule 50 (data_types -> INT32 .)
    $end            reduce using rule 50 (data_types -> INT32 .)
    RLLAVE          reduce using rule 50 (data_types -> INT32 .)
    INT32           reduce using rule 50 (data_types -> INT32 .)
    INT64           reduce using rule 50 (data_types -> INT32 .)
    FLOAT32         reduce using rule 50 (data_types -> INT32 .)
    FLOAT64         reduce using rule 50 (data_types -> INT32 .)
    BYTE            reduce using rule 50 (data_types -> INT32 .)
    WFLOAT          reduce using rule 50 (data_types -> INT32 .)
    WSTRING         reduce using rule 50 (data_types -> INT32 .)
    WINT            reduce using rule 50 (data_types -> INT32 .)
    BOOL            reduce using rule 50 (data_types -> INT32 .)
    DEFAULT         reduce using rule 50 (data_types -> INT32 .)
    CASE            reduce using rule 50 (data_types -> INT32 .)
    RETURN          reduce using rule 50 (data_types -> INT32 .)
    STRING          reduce using rule 50 (data_types -> INT32 .)
    TRUE            reduce using rule 50 (data_types -> INT32 .)
    FALSE           reduce using rule 50 (data_types -> INT32 .)
    EQUAL           shift and go to state 260

  ! EQUAL           [ reduce using rule 50 (data_types -> INT32 .) ]


state 235

    (51) data_types -> INT64 .
    (98) data_type_and_value -> INT64 . EQUAL int_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 51 (data_types -> INT64 .)
    PRINT           reduce using rule 51 (data_types -> INT64 .)
    SCAN            reduce using rule 51 (data_types -> INT64 .)
    FOR             reduce using rule 51 (data_types -> INT64 .)
    CONST           reduce using rule 51 (data_types -> INT64 .)
    ID              reduce using rule 51 (data_types -> INT64 .)
    APPEND          reduce using rule 51 (data_types -> INT64 .)
    LEN             reduce using rule 51 (data_types -> INT64 .)
    COPY            reduce using rule 51 (data_types -> INT64 .)
    DELETE          reduce using rule 51 (data_types -> INT64 .)
    IF              reduce using rule 51 (data_types -> INT64 .)
    ELSE            reduce using rule 51 (data_types -> INT64 .)
    TYPE            reduce using rule 51 (data_types -> INT64 .)
    SWITCH          reduce using rule 51 (data_types -> INT64 .)
    VAR             reduce using rule 51 (data_types -> INT64 .)
    FUNC            reduce using rule 51 (data_types -> INT64 .)
    INTEGER         reduce using rule 51 (data_types -> INT64 .)
    FLOAT           reduce using rule 51 (data_types -> INT64 .)
    NOT             reduce using rule 51 (data_types -> INT64 .)
    $end            reduce using rule 51 (data_types -> INT64 .)
    RLLAVE          reduce using rule 51 (data_types -> INT64 .)
    INT32           reduce using rule 51 (data_types -> INT64 .)
    INT64           reduce using rule 51 (data_types -> INT64 .)
    FLOAT32         reduce using rule 51 (data_types -> INT64 .)
    FLOAT64         reduce using rule 51 (data_types -> INT64 .)
    BYTE            reduce using rule 51 (data_types -> INT64 .)
    WFLOAT          reduce using rule 51 (data_types -> INT64 .)
    WSTRING         reduce using rule 51 (data_types -> INT64 .)
    WINT            reduce using rule 51 (data_types -> INT64 .)
    BOOL            reduce using rule 51 (data_types -> INT64 .)
    DEFAULT         reduce using rule 51 (data_types -> INT64 .)
    CASE            reduce using rule 51 (data_types -> INT64 .)
    RETURN          reduce using rule 51 (data_types -> INT64 .)
    STRING          reduce using rule 51 (data_types -> INT64 .)
    TRUE            reduce using rule 51 (data_types -> INT64 .)
    FALSE           reduce using rule 51 (data_types -> INT64 .)
    EQUAL           shift and go to state 261

  ! EQUAL           [ reduce using rule 51 (data_types -> INT64 .) ]


state 236

    (52) data_types -> FLOAT32 .
    (100) data_type_and_value -> FLOAT32 . EQUAL float_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 52 (data_types -> FLOAT32 .)
    PRINT           reduce using rule 52 (data_types -> FLOAT32 .)
    SCAN            reduce using rule 52 (data_types -> FLOAT32 .)
    FOR             reduce using rule 52 (data_types -> FLOAT32 .)
    CONST           reduce using rule 52 (data_types -> FLOAT32 .)
    ID              reduce using rule 52 (data_types -> FLOAT32 .)
    APPEND          reduce using rule 52 (data_types -> FLOAT32 .)
    LEN             reduce using rule 52 (data_types -> FLOAT32 .)
    COPY            reduce using rule 52 (data_types -> FLOAT32 .)
    DELETE          reduce using rule 52 (data_types -> FLOAT32 .)
    IF              reduce using rule 52 (data_types -> FLOAT32 .)
    ELSE            reduce using rule 52 (data_types -> FLOAT32 .)
    TYPE            reduce using rule 52 (data_types -> FLOAT32 .)
    SWITCH          reduce using rule 52 (data_types -> FLOAT32 .)
    VAR             reduce using rule 52 (data_types -> FLOAT32 .)
    FUNC            reduce using rule 52 (data_types -> FLOAT32 .)
    INTEGER         reduce using rule 52 (data_types -> FLOAT32 .)
    FLOAT           reduce using rule 52 (data_types -> FLOAT32 .)
    NOT             reduce using rule 52 (data_types -> FLOAT32 .)
    $end            reduce using rule 52 (data_types -> FLOAT32 .)
    RLLAVE          reduce using rule 52 (data_types -> FLOAT32 .)
    INT32           reduce using rule 52 (data_types -> FLOAT32 .)
    INT64           reduce using rule 52 (data_types -> FLOAT32 .)
    FLOAT32         reduce using rule 52 (data_types -> FLOAT32 .)
    FLOAT64         reduce using rule 52 (data_types -> FLOAT32 .)
    BYTE            reduce using rule 52 (data_types -> FLOAT32 .)
    WFLOAT          reduce using rule 52 (data_types -> FLOAT32 .)
    WSTRING         reduce using rule 52 (data_types -> FLOAT32 .)
    WINT            reduce using rule 52 (data_types -> FLOAT32 .)
    BOOL            reduce using rule 52 (data_types -> FLOAT32 .)
    DEFAULT         reduce using rule 52 (data_types -> FLOAT32 .)
    CASE            reduce using rule 52 (data_types -> FLOAT32 .)
    RETURN          reduce using rule 52 (data_types -> FLOAT32 .)
    STRING          reduce using rule 52 (data_types -> FLOAT32 .)
    TRUE            reduce using rule 52 (data_types -> FLOAT32 .)
    FALSE           reduce using rule 52 (data_types -> FLOAT32 .)
    EQUAL           shift and go to state 263

  ! EQUAL           [ reduce using rule 52 (data_types -> FLOAT32 .) ]


state 237

    (53) data_types -> FLOAT64 .
    (101) data_type_and_value -> FLOAT64 . EQUAL float_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 53 (data_types -> FLOAT64 .)
    PRINT           reduce using rule 53 (data_types -> FLOAT64 .)
    SCAN            reduce using rule 53 (data_types -> FLOAT64 .)
    FOR             reduce using rule 53 (data_types -> FLOAT64 .)
    CONST           reduce using rule 53 (data_types -> FLOAT64 .)
    ID              reduce using rule 53 (data_types -> FLOAT64 .)
    APPEND          reduce using rule 53 (data_types -> FLOAT64 .)
    LEN             reduce using rule 53 (data_types -> FLOAT64 .)
    COPY            reduce using rule 53 (data_types -> FLOAT64 .)
    DELETE          reduce using rule 53 (data_types -> FLOAT64 .)
    IF              reduce using rule 53 (data_types -> FLOAT64 .)
    ELSE            reduce using rule 53 (data_types -> FLOAT64 .)
    TYPE            reduce using rule 53 (data_types -> FLOAT64 .)
    SWITCH          reduce using rule 53 (data_types -> FLOAT64 .)
    VAR             reduce using rule 53 (data_types -> FLOAT64 .)
    FUNC            reduce using rule 53 (data_types -> FLOAT64 .)
    INTEGER         reduce using rule 53 (data_types -> FLOAT64 .)
    FLOAT           reduce using rule 53 (data_types -> FLOAT64 .)
    NOT             reduce using rule 53 (data_types -> FLOAT64 .)
    $end            reduce using rule 53 (data_types -> FLOAT64 .)
    RLLAVE          reduce using rule 53 (data_types -> FLOAT64 .)
    INT32           reduce using rule 53 (data_types -> FLOAT64 .)
    INT64           reduce using rule 53 (data_types -> FLOAT64 .)
    FLOAT32         reduce using rule 53 (data_types -> FLOAT64 .)
    FLOAT64         reduce using rule 53 (data_types -> FLOAT64 .)
    BYTE            reduce using rule 53 (data_types -> FLOAT64 .)
    WFLOAT          reduce using rule 53 (data_types -> FLOAT64 .)
    WSTRING         reduce using rule 53 (data_types -> FLOAT64 .)
    WINT            reduce using rule 53 (data_types -> FLOAT64 .)
    BOOL            reduce using rule 53 (data_types -> FLOAT64 .)
    DEFAULT         reduce using rule 53 (data_types -> FLOAT64 .)
    CASE            reduce using rule 53 (data_types -> FLOAT64 .)
    RETURN          reduce using rule 53 (data_types -> FLOAT64 .)
    STRING          reduce using rule 53 (data_types -> FLOAT64 .)
    TRUE            reduce using rule 53 (data_types -> FLOAT64 .)
    FALSE           reduce using rule 53 (data_types -> FLOAT64 .)
    EQUAL           shift and go to state 264

  ! EQUAL           [ reduce using rule 53 (data_types -> FLOAT64 .) ]


state 238

    (55) data_types -> WFLOAT .
    (99) data_type_and_value -> WFLOAT . EQUAL float_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 55 (data_types -> WFLOAT .)
    PRINT           reduce using rule 55 (data_types -> WFLOAT .)
    SCAN            reduce using rule 55 (data_types -> WFLOAT .)
    FOR             reduce using rule 55 (data_types -> WFLOAT .)
    CONST           reduce using rule 55 (data_types -> WFLOAT .)
    ID              reduce using rule 55 (data_types -> WFLOAT .)
    APPEND          reduce using rule 55 (data_types -> WFLOAT .)
    LEN             reduce using rule 55 (data_types -> WFLOAT .)
    COPY            reduce using rule 55 (data_types -> WFLOAT .)
    DELETE          reduce using rule 55 (data_types -> WFLOAT .)
    IF              reduce using rule 55 (data_types -> WFLOAT .)
    ELSE            reduce using rule 55 (data_types -> WFLOAT .)
    TYPE            reduce using rule 55 (data_types -> WFLOAT .)
    SWITCH          reduce using rule 55 (data_types -> WFLOAT .)
    VAR             reduce using rule 55 (data_types -> WFLOAT .)
    FUNC            reduce using rule 55 (data_types -> WFLOAT .)
    INTEGER         reduce using rule 55 (data_types -> WFLOAT .)
    FLOAT           reduce using rule 55 (data_types -> WFLOAT .)
    NOT             reduce using rule 55 (data_types -> WFLOAT .)
    $end            reduce using rule 55 (data_types -> WFLOAT .)
    RLLAVE          reduce using rule 55 (data_types -> WFLOAT .)
    INT32           reduce using rule 55 (data_types -> WFLOAT .)
    INT64           reduce using rule 55 (data_types -> WFLOAT .)
    FLOAT32         reduce using rule 55 (data_types -> WFLOAT .)
    FLOAT64         reduce using rule 55 (data_types -> WFLOAT .)
    BYTE            reduce using rule 55 (data_types -> WFLOAT .)
    WFLOAT          reduce using rule 55 (data_types -> WFLOAT .)
    WSTRING         reduce using rule 55 (data_types -> WFLOAT .)
    WINT            reduce using rule 55 (data_types -> WFLOAT .)
    BOOL            reduce using rule 55 (data_types -> WFLOAT .)
    DEFAULT         reduce using rule 55 (data_types -> WFLOAT .)
    CASE            reduce using rule 55 (data_types -> WFLOAT .)
    RETURN          reduce using rule 55 (data_types -> WFLOAT .)
    STRING          reduce using rule 55 (data_types -> WFLOAT .)
    TRUE            reduce using rule 55 (data_types -> WFLOAT .)
    FALSE           reduce using rule 55 (data_types -> WFLOAT .)
    EQUAL           shift and go to state 262

  ! EQUAL           [ reduce using rule 55 (data_types -> WFLOAT .) ]


state 239

    (56) data_types -> WSTRING .
    (95) data_type_and_value -> WSTRING . EQUAL STRING

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 56 (data_types -> WSTRING .)
    PRINT           reduce using rule 56 (data_types -> WSTRING .)
    SCAN            reduce using rule 56 (data_types -> WSTRING .)
    FOR             reduce using rule 56 (data_types -> WSTRING .)
    CONST           reduce using rule 56 (data_types -> WSTRING .)
    ID              reduce using rule 56 (data_types -> WSTRING .)
    APPEND          reduce using rule 56 (data_types -> WSTRING .)
    LEN             reduce using rule 56 (data_types -> WSTRING .)
    COPY            reduce using rule 56 (data_types -> WSTRING .)
    DELETE          reduce using rule 56 (data_types -> WSTRING .)
    IF              reduce using rule 56 (data_types -> WSTRING .)
    ELSE            reduce using rule 56 (data_types -> WSTRING .)
    TYPE            reduce using rule 56 (data_types -> WSTRING .)
    SWITCH          reduce using rule 56 (data_types -> WSTRING .)
    VAR             reduce using rule 56 (data_types -> WSTRING .)
    FUNC            reduce using rule 56 (data_types -> WSTRING .)
    INTEGER         reduce using rule 56 (data_types -> WSTRING .)
    FLOAT           reduce using rule 56 (data_types -> WSTRING .)
    NOT             reduce using rule 56 (data_types -> WSTRING .)
    $end            reduce using rule 56 (data_types -> WSTRING .)
    RLLAVE          reduce using rule 56 (data_types -> WSTRING .)
    INT32           reduce using rule 56 (data_types -> WSTRING .)
    INT64           reduce using rule 56 (data_types -> WSTRING .)
    FLOAT32         reduce using rule 56 (data_types -> WSTRING .)
    FLOAT64         reduce using rule 56 (data_types -> WSTRING .)
    BYTE            reduce using rule 56 (data_types -> WSTRING .)
    WFLOAT          reduce using rule 56 (data_types -> WSTRING .)
    WSTRING         reduce using rule 56 (data_types -> WSTRING .)
    WINT            reduce using rule 56 (data_types -> WSTRING .)
    BOOL            reduce using rule 56 (data_types -> WSTRING .)
    DEFAULT         reduce using rule 56 (data_types -> WSTRING .)
    CASE            reduce using rule 56 (data_types -> WSTRING .)
    RETURN          reduce using rule 56 (data_types -> WSTRING .)
    STRING          reduce using rule 56 (data_types -> WSTRING .)
    TRUE            reduce using rule 56 (data_types -> WSTRING .)
    FALSE           reduce using rule 56 (data_types -> WSTRING .)
    EQUAL           shift and go to state 258

  ! EQUAL           [ reduce using rule 56 (data_types -> WSTRING .) ]


state 240

    (57) data_types -> WINT .
    (96) data_type_and_value -> WINT . EQUAL int_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 57 (data_types -> WINT .)
    PRINT           reduce using rule 57 (data_types -> WINT .)
    SCAN            reduce using rule 57 (data_types -> WINT .)
    FOR             reduce using rule 57 (data_types -> WINT .)
    CONST           reduce using rule 57 (data_types -> WINT .)
    ID              reduce using rule 57 (data_types -> WINT .)
    APPEND          reduce using rule 57 (data_types -> WINT .)
    LEN             reduce using rule 57 (data_types -> WINT .)
    COPY            reduce using rule 57 (data_types -> WINT .)
    DELETE          reduce using rule 57 (data_types -> WINT .)
    IF              reduce using rule 57 (data_types -> WINT .)
    ELSE            reduce using rule 57 (data_types -> WINT .)
    TYPE            reduce using rule 57 (data_types -> WINT .)
    SWITCH          reduce using rule 57 (data_types -> WINT .)
    VAR             reduce using rule 57 (data_types -> WINT .)
    FUNC            reduce using rule 57 (data_types -> WINT .)
    INTEGER         reduce using rule 57 (data_types -> WINT .)
    FLOAT           reduce using rule 57 (data_types -> WINT .)
    NOT             reduce using rule 57 (data_types -> WINT .)
    $end            reduce using rule 57 (data_types -> WINT .)
    RLLAVE          reduce using rule 57 (data_types -> WINT .)
    INT32           reduce using rule 57 (data_types -> WINT .)
    INT64           reduce using rule 57 (data_types -> WINT .)
    FLOAT32         reduce using rule 57 (data_types -> WINT .)
    FLOAT64         reduce using rule 57 (data_types -> WINT .)
    BYTE            reduce using rule 57 (data_types -> WINT .)
    WFLOAT          reduce using rule 57 (data_types -> WINT .)
    WSTRING         reduce using rule 57 (data_types -> WINT .)
    WINT            reduce using rule 57 (data_types -> WINT .)
    BOOL            reduce using rule 57 (data_types -> WINT .)
    DEFAULT         reduce using rule 57 (data_types -> WINT .)
    CASE            reduce using rule 57 (data_types -> WINT .)
    RETURN          reduce using rule 57 (data_types -> WINT .)
    STRING          reduce using rule 57 (data_types -> WINT .)
    TRUE            reduce using rule 57 (data_types -> WINT .)
    FALSE           reduce using rule 57 (data_types -> WINT .)
    EQUAL           shift and go to state 259

  ! EQUAL           [ reduce using rule 57 (data_types -> WINT .) ]


state 241

    (58) data_types -> BOOL .
    (102) data_type_and_value -> BOOL . EQUAL bool_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 58 (data_types -> BOOL .)
    PRINT           reduce using rule 58 (data_types -> BOOL .)
    SCAN            reduce using rule 58 (data_types -> BOOL .)
    FOR             reduce using rule 58 (data_types -> BOOL .)
    CONST           reduce using rule 58 (data_types -> BOOL .)
    ID              reduce using rule 58 (data_types -> BOOL .)
    APPEND          reduce using rule 58 (data_types -> BOOL .)
    LEN             reduce using rule 58 (data_types -> BOOL .)
    COPY            reduce using rule 58 (data_types -> BOOL .)
    DELETE          reduce using rule 58 (data_types -> BOOL .)
    IF              reduce using rule 58 (data_types -> BOOL .)
    ELSE            reduce using rule 58 (data_types -> BOOL .)
    TYPE            reduce using rule 58 (data_types -> BOOL .)
    SWITCH          reduce using rule 58 (data_types -> BOOL .)
    VAR             reduce using rule 58 (data_types -> BOOL .)
    FUNC            reduce using rule 58 (data_types -> BOOL .)
    INTEGER         reduce using rule 58 (data_types -> BOOL .)
    FLOAT           reduce using rule 58 (data_types -> BOOL .)
    NOT             reduce using rule 58 (data_types -> BOOL .)
    $end            reduce using rule 58 (data_types -> BOOL .)
    RLLAVE          reduce using rule 58 (data_types -> BOOL .)
    INT32           reduce using rule 58 (data_types -> BOOL .)
    INT64           reduce using rule 58 (data_types -> BOOL .)
    FLOAT32         reduce using rule 58 (data_types -> BOOL .)
    FLOAT64         reduce using rule 58 (data_types -> BOOL .)
    BYTE            reduce using rule 58 (data_types -> BOOL .)
    WFLOAT          reduce using rule 58 (data_types -> BOOL .)
    WSTRING         reduce using rule 58 (data_types -> BOOL .)
    WINT            reduce using rule 58 (data_types -> BOOL .)
    BOOL            reduce using rule 58 (data_types -> BOOL .)
    DEFAULT         reduce using rule 58 (data_types -> BOOL .)
    CASE            reduce using rule 58 (data_types -> BOOL .)
    RETURN          reduce using rule 58 (data_types -> BOOL .)
    STRING          reduce using rule 58 (data_types -> BOOL .)
    TRUE            reduce using rule 58 (data_types -> BOOL .)
    FALSE           reduce using rule 58 (data_types -> BOOL .)
    EQUAL           shift and go to state 265

  ! EQUAL           [ reduce using rule 58 (data_types -> BOOL .) ]


state 242

    (218) map_assignment -> map_var EQUAL something .

    COLON           reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    PRINT           reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    SCAN            reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    FOR             reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    CONST           reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    ID              reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    APPEND          reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    LEN             reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    COPY            reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    DELETE          reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    IF              reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    ELSE            reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    TYPE            reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    SWITCH          reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    VAR             reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    FUNC            reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    INTEGER         reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    FLOAT           reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    NOT             reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    $end            reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    RLLAVE          reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    INT32           reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    INT64           reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    FLOAT32         reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    FLOAT64         reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    BYTE            reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    WFLOAT          reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    WSTRING         reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    WINT            reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    BOOL            reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    DEFAULT         reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    CASE            reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    RETURN          reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    STRING          reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    TRUE            reduce using rule 218 (map_assignment -> map_var EQUAL something .)
    FALSE           reduce using rule 218 (map_assignment -> map_var EQUAL something .)


state 243

    (219) func_declaration -> FUNC ID LPAREN . params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> FUNC ID LPAREN . params RPAREN data_types LLLAVE RETURN body RLLAVE
    (229) params -> . ID data_types
    (230) params -> . more_params
    (231) more_params -> . ID data_types COMA params

    ID              shift and go to state 301

    params                         shift and go to state 302
    more_params                    shift and go to state 303

state 244

    (82) main_func -> FUNC MAIN LPAREN . RPAREN LLLAVE codigo RLLAVE

    RPAREN          shift and go to state 304


state 245

    (232) impresion -> PRINT LPAREN content RPAREN .

    COLON           reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    PRINT           reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    SCAN            reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    FOR             reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    CONST           reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    ID              reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    APPEND          reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    LEN             reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    COPY            reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    DELETE          reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    IF              reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    ELSE            reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    TYPE            reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    SWITCH          reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    VAR             reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    FUNC            reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    INTEGER         reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    FLOAT           reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    NOT             reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    $end            reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    RLLAVE          reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    INT32           reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    INT64           reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    FLOAT32         reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    FLOAT64         reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    BYTE            reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    WFLOAT          reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    WSTRING         reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    WINT            reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    BOOL            reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    DEFAULT         reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    CASE            reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    RETURN          reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    STRING          reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    TRUE            reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)
    FALSE           reduce using rule 232 (impresion -> PRINT LPAREN content RPAREN .)


state 246

    (83) scan_func -> SCAN LPAREN POINTER RPAREN .

    COLON           reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    PRINT           reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    SCAN            reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FOR             reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    CONST           reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    ID              reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    APPEND          reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    LEN             reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    COPY            reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    DELETE          reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    IF              reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    ELSE            reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    TYPE            reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    SWITCH          reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    VAR             reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FUNC            reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    INTEGER         reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FLOAT           reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    NOT             reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    $end            reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    RLLAVE          reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    INT32           reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    INT64           reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FLOAT32         reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FLOAT64         reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    BYTE            reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    WFLOAT          reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    WSTRING         reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    WINT            reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    BOOL            reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    DEFAULT         reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    CASE            reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    RETURN          reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    STRING          reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    TRUE            reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FALSE           reduce using rule 83 (scan_func -> SCAN LPAREN POINTER RPAREN .)


state 247

    (241) adicionaEx -> op something_ex adicionaEx .

    COLON           reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    PRINT           reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    SCAN            reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    FOR             reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    CONST           reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    ID              reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    APPEND          reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    LEN             reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    COPY            reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    DELETE          reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    IF              reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    ELSE            reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    TYPE            reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    SWITCH          reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    VAR             reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    FUNC            reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    INTEGER         reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    FLOAT           reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    NOT             reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    $end            reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    GREATER         reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    SMALLER         reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    GREATER_OR_EQUAL reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    SMALLER_OR_EQUAL reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    EQUAL_COMPARE   reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    NOT_EQUAL       reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    PLUS            reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    TIMES           reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    DIVIDE          reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    MINUS           reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    MOD             reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    RLLAVE          reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    INT32           reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    INT64           reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    FLOAT32         reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    FLOAT64         reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    BYTE            reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    WFLOAT          reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    WSTRING         reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    WINT            reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    BOOL            reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    DEFAULT         reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    CASE            reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    RETURN          reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    STRING          reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    TRUE            reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    FALSE           reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    RPAREN          reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    AND             reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    OR              reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    LLLAVE          reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    RCORCHE         reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)
    COMA            reduce using rule 241 (adicionaEx -> op something_ex adicionaEx .)


state 248

    (89) cicloFor -> FOR LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    ID              reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    IF              reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    $end            reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    STRING          reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    TRUE            reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FALSE           reduce using rule 89 (cicloFor -> FOR LLLAVE codigo RLLAVE .)


state 249

    (90) cicloFor -> FOR comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 305


state 250

    (91) cicloFor -> FOR logic_operation LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 306


state 251

    (92) cicloFor -> FOR decVarOne COLON comparison . COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 307


state 252

    (158) decVarOne -> ID DEQUAL ID .

    COLON           reduce using rule 158 (decVarOne -> ID DEQUAL ID .)


state 253

    (159) decVarOne -> ID DEQUAL INTEGER .

    COLON           reduce using rule 159 (decVarOne -> ID DEQUAL INTEGER .)


state 254

    (209) index -> ID .
    (215) key -> ID .
    (144) index_s -> ID .
    (242) something_ex -> ID .
    (179) value -> ID .
    (193) logic_value -> ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for RCORCHE resolved using rule 209 (index -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 144 (index_s -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 144 (index_s -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 179 (value -> ID .)
    RCORCHE         reduce using rule 144 (index_s -> ID .)
    GREATER         reduce using rule 179 (value -> ID .)
    SMALLER         reduce using rule 179 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 179 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 179 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 179 (value -> ID .)
    NOT_EQUAL       reduce using rule 179 (value -> ID .)
    PLUS            reduce using rule 179 (value -> ID .)
    TIMES           reduce using rule 179 (value -> ID .)
    DIVIDE          reduce using rule 179 (value -> ID .)
    MINUS           reduce using rule 179 (value -> ID .)
    MOD             reduce using rule 179 (value -> ID .)
    AND             reduce using rule 193 (logic_value -> ID .)
    OR              reduce using rule 193 (logic_value -> ID .)
    LCORCHE         shift and go to state 174
    LPAREN          shift and go to state 112

  ! RCORCHE         [ reduce using rule 209 (index -> ID .) ]
  ! RCORCHE         [ reduce using rule 215 (key -> ID .) ]
  ! GREATER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 242 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 242 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 242 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 242 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 242 (something_ex -> ID .) ]


state 255

    (190) logic_recu -> logic_op logic_value logic_recu .

    PRINT           reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    SCAN            reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    FOR             reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    CONST           reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    ID              reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    APPEND          reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    LEN             reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    COPY            reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    DELETE          reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    IF              reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    ELSE            reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    TYPE            reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    SWITCH          reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    VAR             reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    FUNC            reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    INTEGER         reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    FLOAT           reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    NOT             reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    $end            reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    RLLAVE          reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    INT32           reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    INT64           reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    FLOAT32         reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    FLOAT64         reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    BYTE            reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    WFLOAT          reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    WSTRING         reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    WINT            reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    BOOL            reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    DEFAULT         reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    CASE            reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    RETURN          reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    STRING          reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    TRUE            reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    FALSE           reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    LLLAVE          reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    COLON           reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    RPAREN          reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    RCORCHE         reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)
    COMA            reduce using rule 190 (logic_recu -> logic_op logic_value logic_recu .)


state 256

    (112) decConst -> CONST ID EQUAL ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE

    COLON           reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    PRINT           reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    SCAN            reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    FOR             reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    CONST           reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    ID              reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    APPEND          reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    LEN             reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    COPY            reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    DELETE          reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    IF              reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    ELSE            reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    TYPE            reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    SWITCH          reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    VAR             reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    FUNC            reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    INTEGER         reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    FLOAT           reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    NOT             reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    $end            reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    RLLAVE          reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    INT32           reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    INT64           reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    FLOAT32         reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    FLOAT64         reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    BYTE            reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    WFLOAT          reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    WSTRING         reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    WINT            reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    BOOL            reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    DEFAULT         reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    CASE            reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    RETURN          reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    STRING          reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    TRUE            reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    FALSE           reduce using rule 112 (decConst -> CONST ID EQUAL ID .)
    LCORCHE         shift and go to state 174


state 257

    (113) decConst -> CONST ID EQUAL data_structure .

    COLON           reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    PRINT           reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    SCAN            reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    FOR             reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    CONST           reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    ID              reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    APPEND          reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    LEN             reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    COPY            reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    DELETE          reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    IF              reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    ELSE            reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    TYPE            reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    SWITCH          reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    VAR             reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    FUNC            reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    INTEGER         reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    FLOAT           reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    NOT             reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    $end            reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    RLLAVE          reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    INT32           reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    INT64           reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    FLOAT32         reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    FLOAT64         reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    BYTE            reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    WFLOAT          reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    WSTRING         reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    WINT            reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    BOOL            reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    DEFAULT         reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    CASE            reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    RETURN          reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    STRING          reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    TRUE            reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)
    FALSE           reduce using rule 113 (decConst -> CONST ID EQUAL data_structure .)


state 258

    (95) data_type_and_value -> WSTRING EQUAL . STRING

    STRING          shift and go to state 308


state 259

    (96) data_type_and_value -> WINT EQUAL . int_value
    (103) int_value -> . INTEGER
    (104) int_value -> . expression
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 310
    ID              shift and go to state 168
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    int_value                      shift and go to state 309
    expression                     shift and go to state 311
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 260

    (97) data_type_and_value -> INT32 EQUAL . int_value
    (103) int_value -> . INTEGER
    (104) int_value -> . expression
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 310
    ID              shift and go to state 168
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    int_value                      shift and go to state 312
    expression                     shift and go to state 311
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 261

    (98) data_type_and_value -> INT64 EQUAL . int_value
    (103) int_value -> . INTEGER
    (104) int_value -> . expression
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 310
    ID              shift and go to state 168
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    int_value                      shift and go to state 313
    expression                     shift and go to state 311
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 262

    (99) data_type_and_value -> WFLOAT EQUAL . float_value
    (109) float_value -> . FLOAT
    (110) float_value -> . expression
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    FLOAT           shift and go to state 315
    ID              shift and go to state 168
    INTEGER         shift and go to state 54
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    float_value                    shift and go to state 314
    expression                     shift and go to state 316
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 263

    (100) data_type_and_value -> FLOAT32 EQUAL . float_value
    (109) float_value -> . FLOAT
    (110) float_value -> . expression
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    FLOAT           shift and go to state 315
    ID              shift and go to state 168
    INTEGER         shift and go to state 54
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    float_value                    shift and go to state 317
    expression                     shift and go to state 316
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 264

    (101) data_type_and_value -> FLOAT64 EQUAL . float_value
    (109) float_value -> . FLOAT
    (110) float_value -> . expression
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    FLOAT           shift and go to state 315
    ID              shift and go to state 168
    INTEGER         shift and go to state 54
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    float_value                    shift and go to state 318
    expression                     shift and go to state 316
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 265

    (102) data_type_and_value -> BOOL EQUAL . bool_value
    (105) bool_value -> . TRUE
    (106) bool_value -> . FALSE
    (107) bool_value -> . comparison
    (108) bool_value -> . logic_operation
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    TRUE            shift and go to state 320
    FALSE           shift and go to state 321
    ID              shift and go to state 324
    NOT             shift and go to state 56
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    bool_value                     shift and go to state 319
    comparison                     shift and go to state 322
    logic_operation                shift and go to state 323
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    expression                     shift and go to state 98
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 266

    (171) cStruct -> ID DEQUAL ID LLLAVE . asignaciones RLLAVE
    (172) asignaciones -> . ID POINTS valor
    (173) asignaciones -> . ID POINTS valor COMA asignaciones

    ID              shift and go to state 325

    asignaciones                   shift and go to state 326

state 267

    (137) slice_declaration -> ID DEQUAL LCORCHE RCORCHE . data_types arr_content
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WFLOAT
    (56) data_types -> . WSTRING
    (57) data_types -> . WINT
    (58) data_types -> . BOOL

    INT32           shift and go to state 132
    INT64           shift and go to state 133
    FLOAT32         shift and go to state 134
    FLOAT64         shift and go to state 135
    BYTE            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    WINT            shift and go to state 139
    BOOL            shift and go to state 140

    data_types                     shift and go to state 327

state 268

    (138) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap RPAREN
    (139) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LCORCHE         shift and go to state 328


state 269

    (208) array_var -> ID LCORCHE index RCORCHE .

    COLON           reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    EQUAL           reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    PRINT           reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    SCAN            reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    FOR             reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    CONST           reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    ID              reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    APPEND          reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    LEN             reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    COPY            reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    DELETE          reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    IF              reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    ELSE            reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    TYPE            reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    SWITCH          reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    VAR             reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    FUNC            reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    INTEGER         reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    FLOAT           reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    NOT             reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    $end            reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    GREATER         reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    SMALLER         reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    GREATER_OR_EQUAL reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    SMALLER_OR_EQUAL reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    EQUAL_COMPARE   reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    NOT_EQUAL       reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    PLUS            reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    TIMES           reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    DIVIDE          reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    MINUS           reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    MOD             reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    RLLAVE          reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    INT32           reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    INT64           reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    FLOAT32         reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    FLOAT64         reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    BYTE            reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    WFLOAT          reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    WSTRING         reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    WINT            reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    BOOL            reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    DEFAULT         reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    CASE            reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    RETURN          reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    STRING          reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    TRUE            reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    FALSE           reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    RPAREN          reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    AND             reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    OR              reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    LLLAVE          reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    RCORCHE         reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)
    COMA            reduce using rule 208 (array_var -> ID LCORCHE index RCORCHE .)


state 270

    (143) slice_var -> ID LCORCHE index_s RCORCHE .

    COLON           reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    EQUAL           reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    PRINT           reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    SCAN            reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FOR             reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    CONST           reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    ID              reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    APPEND          reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    LEN             reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    COPY            reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    DELETE          reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    IF              reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    ELSE            reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    TYPE            reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    SWITCH          reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    VAR             reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FUNC            reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    INTEGER         reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FLOAT           reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    NOT             reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    $end            reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    GREATER         reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    SMALLER         reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    GREATER_OR_EQUAL reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    SMALLER_OR_EQUAL reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    EQUAL_COMPARE   reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    NOT_EQUAL       reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    PLUS            reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    TIMES           reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    DIVIDE          reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    MINUS           reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    MOD             reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    RLLAVE          reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    INT32           reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    INT64           reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FLOAT32         reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FLOAT64         reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    BYTE            reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    WFLOAT          reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    WSTRING         reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    WINT            reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    BOOL            reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    DEFAULT         reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    CASE            reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    RETURN          reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    STRING          reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    TRUE            reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FALSE           reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    RPAREN          reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    AND             reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    OR              reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    LLLAVE          reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    RCORCHE         reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)
    COMA            reduce using rule 143 (slice_var -> ID LCORCHE index_s RCORCHE .)


state 271

    (214) map_var -> ID LCORCHE key RCORCHE .

    EQUAL           reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    GREATER         reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    SMALLER         reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    GREATER_OR_EQUAL reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    SMALLER_OR_EQUAL reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    EQUAL_COMPARE   reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    NOT_EQUAL       reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    PLUS            reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    TIMES           reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    DIVIDE          reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    MINUS           reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    MOD             reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    COLON           reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    PRINT           reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    SCAN            reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    FOR             reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    CONST           reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    ID              reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    APPEND          reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    LEN             reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    COPY            reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    DELETE          reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    IF              reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    ELSE            reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    TYPE            reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    SWITCH          reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    VAR             reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    FUNC            reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    INTEGER         reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    FLOAT           reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    NOT             reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    $end            reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    RLLAVE          reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    INT32           reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    INT64           reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    FLOAT32         reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    FLOAT64         reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    BYTE            reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    WFLOAT          reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    WSTRING         reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    WINT            reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    BOOL            reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    DEFAULT         reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    CASE            reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    RETURN          reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    STRING          reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    TRUE            reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    FALSE           reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    RPAREN          reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    AND             reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    OR              reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    LLLAVE          reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    RCORCHE         reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)
    COMA            reduce using rule 214 (map_var -> ID LCORCHE key RCORCHE .)


state 272

    (87) list_params -> ID COMA . more_p
    (88) more_p -> . list_params
    (86) list_params -> . ID
    (87) list_params -> . ID COMA more_p

    ID              shift and go to state 213

    more_p                         shift and go to state 329
    list_params                    shift and go to state 330

state 273

    (84) call_func -> ID LPAREN list_params RPAREN .

    COLON           reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    PRINT           reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    SCAN            reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    FOR             reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    CONST           reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    ID              reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    APPEND          reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    LEN             reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    COPY            reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    DELETE          reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    IF              reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    ELSE            reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    TYPE            reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    SWITCH          reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    VAR             reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    FUNC            reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    INTEGER         reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    FLOAT           reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    NOT             reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    $end            reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    GREATER         reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    SMALLER         reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    GREATER_OR_EQUAL reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    EQUAL_COMPARE   reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    NOT_EQUAL       reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    PLUS            reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    TIMES           reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    DIVIDE          reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    MINUS           reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    MOD             reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    RLLAVE          reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    INT32           reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    INT64           reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    FLOAT32         reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    FLOAT64         reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    BYTE            reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    WFLOAT          reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    WSTRING         reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    WINT            reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    BOOL            reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    DEFAULT         reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    CASE            reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    RETURN          reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    STRING          reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    TRUE            reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    FALSE           reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    RPAREN          reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    AND             reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    OR              reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    LLLAVE          reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    RCORCHE         reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)
    COMA            reduce using rule 84 (call_func -> ID LPAREN list_params RPAREN .)


state 274

    (152) funciones -> APPEND LPAREN ID COMA . values RPAREN
    (153) funciones -> APPEND LPAREN ID COMA . ID RPAREN
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE

    ID              shift and go to state 331
    STRING          shift and go to state 147
    INTEGER         shift and go to state 333
    FLOAT           shift and go to state 334
    TRUE            shift and go to state 150
    FALSE           shift and go to state 151

    values                         shift and go to state 332

state 275

    (154) funciones -> LEN LPAREN ID RPAREN .

    COLON           reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    PRINT           reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    SCAN            reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    FOR             reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    CONST           reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    ID              reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    APPEND          reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    LEN             reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    COPY            reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    DELETE          reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    IF              reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    ELSE            reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    TYPE            reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    SWITCH          reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    VAR             reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    FUNC            reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    INTEGER         reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    FLOAT           reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    NOT             reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    $end            reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    GREATER         reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    SMALLER         reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    NOT_EQUAL       reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    PLUS            reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    TIMES           reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    DIVIDE          reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    MINUS           reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    MOD             reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    RLLAVE          reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    INT32           reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    INT64           reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    FLOAT32         reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    FLOAT64         reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    BYTE            reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    WFLOAT          reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    WSTRING         reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    WINT            reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    BOOL            reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    DEFAULT         reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    CASE            reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    RETURN          reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    STRING          reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    TRUE            reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    FALSE           reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    RPAREN          reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    AND             reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    OR              reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    LLLAVE          reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    RCORCHE         reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)
    COMA            reduce using rule 154 (funciones -> LEN LPAREN ID RPAREN .)


state 276

    (155) funciones -> COPY LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 335


state 277

    (156) funciones -> DELETE LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 336


state 278

    (160) SenIF -> IF comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 337


state 279

    (161) SenIF -> IF TRUE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 338


state 280

    (162) SenIF -> IF FALSE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 339


state 281

    (163) SenElseIF -> ELSE IF comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    comparison                     shift and go to state 8
    codigo                         shift and go to state 340
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 282

    (164) SenElseIF -> ELSE IF TRUE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 341
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 283

    (165) SenElseIF -> ELSE IF FALSE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 342
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 284

    (166) SenElse -> ELSE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    STRING          reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    TRUE            reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FALSE           reduce using rule 166 (SenElse -> ELSE LLLAVE codigo RLLAVE .)


state 285

    (167) SenStruct -> TYPE ID STRUCT LLLAVE . declaration RLLAVE
    (168) declaration -> . variable data_types
    (169) declaration -> . declaration variable data_types
    (170) variable -> . ID

    ID              shift and go to state 343

    declaration                    shift and go to state 344
    variable                       shift and go to state 345

state 286

    (198) switch_statement -> SWITCH ID LLLAVE cases . RLLAVE

    RLLAVE          shift and go to state 346


state 287

    (199) cases -> CASE . values POINTS codigo
    (200) cases -> CASE . values POINTS codigo more
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE

    STRING          shift and go to state 147
    INTEGER         shift and go to state 333
    FLOAT           shift and go to state 334
    TRUE            shift and go to state 150
    FALSE           shift and go to state 151

    values                         shift and go to state 347

state 288

    (206) capacity -> ID .
    (242) something_ex -> ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for RCORCHE resolved using rule 206 (capacity -> ID .)
    RCORCHE         reduce using rule 206 (capacity -> ID .)
    GREATER         reduce using rule 242 (something_ex -> ID .)
    SMALLER         reduce using rule 242 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 242 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 242 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 242 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 242 (something_ex -> ID .)
    PLUS            reduce using rule 242 (something_ex -> ID .)
    TIMES           reduce using rule 242 (something_ex -> ID .)
    DIVIDE          reduce using rule 242 (something_ex -> ID .)
    MINUS           reduce using rule 242 (something_ex -> ID .)
    MOD             reduce using rule 242 (something_ex -> ID .)
    LCORCHE         shift and go to state 174
    LPAREN          shift and go to state 112

  ! RCORCHE         [ reduce using rule 242 (something_ex -> ID .) ]


state 289

    (203) array_declaration -> VAR ID LCORCHE capacity . RCORCHE data_types

    RCORCHE         shift and go to state 348


state 290

    (133) slice_declaration -> VAR ID LCORCHE RCORCHE . data_types
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WFLOAT
    (56) data_types -> . WSTRING
    (57) data_types -> . WINT
    (58) data_types -> . BOOL

    INT32           shift and go to state 132
    INT64           shift and go to state 133
    FLOAT32         shift and go to state 134
    FLOAT64         shift and go to state 135
    BYTE            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    WINT            shift and go to state 139
    BOOL            shift and go to state 140

    data_types                     shift and go to state 349

state 291

    (213) map_declaration -> VAR ID LCORCHE data_types . RCORCHE data_types

    RCORCHE         shift and go to state 350


state 292

    (205) capacity -> INTEGER .
    (243) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 205 (capacity -> INTEGER .)
    RCORCHE         reduce using rule 205 (capacity -> INTEGER .)
    GREATER         reduce using rule 243 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 243 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 243 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 243 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 243 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 243 (something_ex -> INTEGER .)
    PLUS            reduce using rule 243 (something_ex -> INTEGER .)
    TIMES           reduce using rule 243 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 243 (something_ex -> INTEGER .)
    MINUS           reduce using rule 243 (something_ex -> INTEGER .)
    MOD             reduce using rule 243 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 243 (something_ex -> INTEGER .) ]


state 293

    (207) capacity -> expression .

    RCORCHE         reduce using rule 207 (capacity -> expression .)


state 294

    (123) single -> VAR ID data_types EQUAL . funciones
    (124) single -> VAR ID data_types EQUAL . ID
    (125) single -> VAR ID data_types EQUAL . data_structure
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE

    ID              shift and go to state 351
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    funciones                      shift and go to state 352
    data_structure                 shift and go to state 353
    call_func                      shift and go to state 46
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102

state 295

    (204) array_declaration -> VAR ID EQUAL LCORCHE . capacity RCORCHE data_types arr_content
    (134) slice_declaration -> VAR ID EQUAL LCORCHE . RCORCHE data_types arr_content
    (205) capacity -> . INTEGER
    (206) capacity -> . ID
    (207) capacity -> . expression
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    RCORCHE         shift and go to state 355
    INTEGER         shift and go to state 292
    ID              shift and go to state 288
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    capacity                       shift and go to state 354
    expression                     shift and go to state 293
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 296

    (135) slice_declaration -> VAR ID EQUAL funM .

    COLON           reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    PRINT           reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    SCAN            reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    FOR             reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    CONST           reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    ID              reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    APPEND          reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    LEN             reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    COPY            reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    DELETE          reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    IF              reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    ELSE            reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    TYPE            reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    SWITCH          reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    VAR             reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    FUNC            reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    INTEGER         reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    FLOAT           reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    NOT             reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    $end            reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    RLLAVE          reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    INT32           reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    INT64           reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    FLOAT32         reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    FLOAT64         reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    BYTE            reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    WFLOAT          reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    WSTRING         reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    WINT            reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    BOOL            reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    DEFAULT         reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    CASE            reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    RETURN          reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    STRING          reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    TRUE            reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)
    FALSE           reduce using rule 135 (slice_declaration -> VAR ID EQUAL funM .)


state 297

    (120) more -> ID .
    (121) more -> ID . COMA more

    INT32           reduce using rule 120 (more -> ID .)
    INT64           reduce using rule 120 (more -> ID .)
    FLOAT32         reduce using rule 120 (more -> ID .)
    FLOAT64         reduce using rule 120 (more -> ID .)
    BYTE            reduce using rule 120 (more -> ID .)
    WFLOAT          reduce using rule 120 (more -> ID .)
    WSTRING         reduce using rule 120 (more -> ID .)
    WINT            reduce using rule 120 (more -> ID .)
    BOOL            reduce using rule 120 (more -> ID .)
    RLLAVE          reduce using rule 120 (more -> ID .)
    COMA            shift and go to state 356


state 298

    (119) list_var -> VAR ID COMA more .

    INT32           reduce using rule 119 (list_var -> VAR ID COMA more .)
    INT64           reduce using rule 119 (list_var -> VAR ID COMA more .)
    FLOAT32         reduce using rule 119 (list_var -> VAR ID COMA more .)
    FLOAT64         reduce using rule 119 (list_var -> VAR ID COMA more .)
    BYTE            reduce using rule 119 (list_var -> VAR ID COMA more .)
    WFLOAT          reduce using rule 119 (list_var -> VAR ID COMA more .)
    WSTRING         reduce using rule 119 (list_var -> VAR ID COMA more .)
    WINT            reduce using rule 119 (list_var -> VAR ID COMA more .)
    BOOL            reduce using rule 119 (list_var -> VAR ID COMA more .)


state 299

    (201) more -> cases .

    INT32           reduce using rule 201 (more -> cases .)
    INT64           reduce using rule 201 (more -> cases .)
    FLOAT32         reduce using rule 201 (more -> cases .)
    FLOAT64         reduce using rule 201 (more -> cases .)
    BYTE            reduce using rule 201 (more -> cases .)
    WFLOAT          reduce using rule 201 (more -> cases .)
    WSTRING         reduce using rule 201 (more -> cases .)
    WINT            reduce using rule 201 (more -> cases .)
    BOOL            reduce using rule 201 (more -> cases .)
    RLLAVE          reduce using rule 201 (more -> cases .)


state 300

    (202) more -> DEFAULT . POINTS codigo

    POINTS          shift and go to state 357


state 301

    (229) params -> ID . data_types
    (231) more_params -> ID . data_types COMA params
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WFLOAT
    (56) data_types -> . WSTRING
    (57) data_types -> . WINT
    (58) data_types -> . BOOL

    INT32           shift and go to state 132
    INT64           shift and go to state 133
    FLOAT32         shift and go to state 134
    FLOAT64         shift and go to state 135
    BYTE            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    WINT            shift and go to state 139
    BOOL            shift and go to state 140

    data_types                     shift and go to state 358

state 302

    (219) func_declaration -> FUNC ID LPAREN params . RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> FUNC ID LPAREN params . RPAREN data_types LLLAVE RETURN body RLLAVE

    RPAREN          shift and go to state 359


state 303

    (230) params -> more_params .

    RPAREN          reduce using rule 230 (params -> more_params .)


state 304

    (82) main_func -> FUNC MAIN LPAREN RPAREN . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 360


state 305

    (90) cicloFor -> FOR comparison LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    ID              reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    IF              reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    $end            reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    STRING          reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    TRUE            reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FALSE           reduce using rule 90 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)


state 306

    (91) cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    ID              reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    IF              reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    $end            reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    STRING          reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    TRUE            reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FALSE           reduce using rule 91 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)


state 307

    (92) cicloFor -> FOR decVarOne COLON comparison COLON . incre LLLAVE codigo RLLAVE
    (93) incre -> . ID INCREASE
    (94) incre -> . ID DECREASE

    ID              shift and go to state 362

    incre                          shift and go to state 361

state 308

    (95) data_type_and_value -> WSTRING EQUAL STRING .

    COLON           reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    PRINT           reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    SCAN            reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    FOR             reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    CONST           reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    ID              reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    APPEND          reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    LEN             reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    COPY            reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    DELETE          reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    IF              reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    ELSE            reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    TYPE            reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    SWITCH          reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    VAR             reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    FUNC            reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    INTEGER         reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    FLOAT           reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    NOT             reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    $end            reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    RLLAVE          reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    INT32           reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    INT64           reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    FLOAT32         reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    FLOAT64         reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    BYTE            reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    WFLOAT          reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    WSTRING         reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    WINT            reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    BOOL            reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    DEFAULT         reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    CASE            reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    RETURN          reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    STRING          reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    TRUE            reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)
    FALSE           reduce using rule 95 (data_type_and_value -> WSTRING EQUAL STRING .)


state 309

    (96) data_type_and_value -> WINT EQUAL int_value .

    COLON           reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    PRINT           reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    SCAN            reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    FOR             reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    CONST           reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    ID              reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    APPEND          reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    LEN             reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    COPY            reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    DELETE          reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    IF              reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    ELSE            reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    TYPE            reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    SWITCH          reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    VAR             reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    FUNC            reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    INTEGER         reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    FLOAT           reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    NOT             reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    $end            reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    RLLAVE          reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    INT32           reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    INT64           reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    FLOAT32         reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    FLOAT64         reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    BYTE            reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    WFLOAT          reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    WSTRING         reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    WINT            reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    BOOL            reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    DEFAULT         reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    CASE            reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    RETURN          reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    STRING          reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    TRUE            reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)
    FALSE           reduce using rule 96 (data_type_and_value -> WINT EQUAL int_value .)


state 310

    (103) int_value -> INTEGER .
    (243) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for PRINT resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for SCAN resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for FOR resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for CONST resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for ID resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for APPEND resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for LEN resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for COPY resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for DELETE resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for IF resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for ELSE resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for TYPE resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for SWITCH resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for VAR resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for FUNC resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for INTEGER resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for FLOAT resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for NOT resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for INT32 resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for INT64 resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for BYTE resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for WSTRING resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for WINT resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for BOOL resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for STRING resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for TRUE resolved using rule 103 (int_value -> INTEGER .)
  ! reduce/reduce conflict for FALSE resolved using rule 103 (int_value -> INTEGER .)
    COLON           reduce using rule 103 (int_value -> INTEGER .)
    PRINT           reduce using rule 103 (int_value -> INTEGER .)
    SCAN            reduce using rule 103 (int_value -> INTEGER .)
    FOR             reduce using rule 103 (int_value -> INTEGER .)
    CONST           reduce using rule 103 (int_value -> INTEGER .)
    ID              reduce using rule 103 (int_value -> INTEGER .)
    APPEND          reduce using rule 103 (int_value -> INTEGER .)
    LEN             reduce using rule 103 (int_value -> INTEGER .)
    COPY            reduce using rule 103 (int_value -> INTEGER .)
    DELETE          reduce using rule 103 (int_value -> INTEGER .)
    IF              reduce using rule 103 (int_value -> INTEGER .)
    ELSE            reduce using rule 103 (int_value -> INTEGER .)
    TYPE            reduce using rule 103 (int_value -> INTEGER .)
    SWITCH          reduce using rule 103 (int_value -> INTEGER .)
    VAR             reduce using rule 103 (int_value -> INTEGER .)
    FUNC            reduce using rule 103 (int_value -> INTEGER .)
    INTEGER         reduce using rule 103 (int_value -> INTEGER .)
    FLOAT           reduce using rule 103 (int_value -> INTEGER .)
    NOT             reduce using rule 103 (int_value -> INTEGER .)
    $end            reduce using rule 103 (int_value -> INTEGER .)
    RLLAVE          reduce using rule 103 (int_value -> INTEGER .)
    INT32           reduce using rule 103 (int_value -> INTEGER .)
    INT64           reduce using rule 103 (int_value -> INTEGER .)
    FLOAT32         reduce using rule 103 (int_value -> INTEGER .)
    FLOAT64         reduce using rule 103 (int_value -> INTEGER .)
    BYTE            reduce using rule 103 (int_value -> INTEGER .)
    WFLOAT          reduce using rule 103 (int_value -> INTEGER .)
    WSTRING         reduce using rule 103 (int_value -> INTEGER .)
    WINT            reduce using rule 103 (int_value -> INTEGER .)
    BOOL            reduce using rule 103 (int_value -> INTEGER .)
    DEFAULT         reduce using rule 103 (int_value -> INTEGER .)
    CASE            reduce using rule 103 (int_value -> INTEGER .)
    RETURN          reduce using rule 103 (int_value -> INTEGER .)
    STRING          reduce using rule 103 (int_value -> INTEGER .)
    TRUE            reduce using rule 103 (int_value -> INTEGER .)
    FALSE           reduce using rule 103 (int_value -> INTEGER .)
    GREATER         reduce using rule 243 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 243 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 243 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 243 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 243 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 243 (something_ex -> INTEGER .)
    PLUS            reduce using rule 243 (something_ex -> INTEGER .)
    TIMES           reduce using rule 243 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 243 (something_ex -> INTEGER .)
    MINUS           reduce using rule 243 (something_ex -> INTEGER .)
    MOD             reduce using rule 243 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! PRINT           [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! SCAN            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! FOR             [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! CONST           [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! ID              [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! APPEND          [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! LEN             [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! COPY            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! DELETE          [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! IF              [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! ELSE            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! TYPE            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! SWITCH          [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! VAR             [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! FUNC            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! INTEGER         [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! FLOAT           [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! NOT             [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! INT32           [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! INT64           [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! FLOAT32         [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! FLOAT64         [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! BYTE            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! WFLOAT          [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! WSTRING         [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! WINT            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! BOOL            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! STRING          [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! TRUE            [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! FALSE           [ reduce using rule 243 (something_ex -> INTEGER .) ]


state 311

    (104) int_value -> expression .

    COLON           reduce using rule 104 (int_value -> expression .)
    PRINT           reduce using rule 104 (int_value -> expression .)
    SCAN            reduce using rule 104 (int_value -> expression .)
    FOR             reduce using rule 104 (int_value -> expression .)
    CONST           reduce using rule 104 (int_value -> expression .)
    ID              reduce using rule 104 (int_value -> expression .)
    APPEND          reduce using rule 104 (int_value -> expression .)
    LEN             reduce using rule 104 (int_value -> expression .)
    COPY            reduce using rule 104 (int_value -> expression .)
    DELETE          reduce using rule 104 (int_value -> expression .)
    IF              reduce using rule 104 (int_value -> expression .)
    ELSE            reduce using rule 104 (int_value -> expression .)
    TYPE            reduce using rule 104 (int_value -> expression .)
    SWITCH          reduce using rule 104 (int_value -> expression .)
    VAR             reduce using rule 104 (int_value -> expression .)
    FUNC            reduce using rule 104 (int_value -> expression .)
    INTEGER         reduce using rule 104 (int_value -> expression .)
    FLOAT           reduce using rule 104 (int_value -> expression .)
    NOT             reduce using rule 104 (int_value -> expression .)
    $end            reduce using rule 104 (int_value -> expression .)
    RLLAVE          reduce using rule 104 (int_value -> expression .)
    INT32           reduce using rule 104 (int_value -> expression .)
    INT64           reduce using rule 104 (int_value -> expression .)
    FLOAT32         reduce using rule 104 (int_value -> expression .)
    FLOAT64         reduce using rule 104 (int_value -> expression .)
    BYTE            reduce using rule 104 (int_value -> expression .)
    WFLOAT          reduce using rule 104 (int_value -> expression .)
    WSTRING         reduce using rule 104 (int_value -> expression .)
    WINT            reduce using rule 104 (int_value -> expression .)
    BOOL            reduce using rule 104 (int_value -> expression .)
    DEFAULT         reduce using rule 104 (int_value -> expression .)
    CASE            reduce using rule 104 (int_value -> expression .)
    RETURN          reduce using rule 104 (int_value -> expression .)
    STRING          reduce using rule 104 (int_value -> expression .)
    TRUE            reduce using rule 104 (int_value -> expression .)
    FALSE           reduce using rule 104 (int_value -> expression .)


state 312

    (97) data_type_and_value -> INT32 EQUAL int_value .

    COLON           reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    PRINT           reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    SCAN            reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    FOR             reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    CONST           reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    ID              reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    APPEND          reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    LEN             reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    COPY            reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    DELETE          reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    IF              reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    ELSE            reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    TYPE            reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    SWITCH          reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    VAR             reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    FUNC            reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    INTEGER         reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    FLOAT           reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    NOT             reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    $end            reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    RLLAVE          reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    INT32           reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    INT64           reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    FLOAT32         reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    FLOAT64         reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    BYTE            reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    WFLOAT          reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    WSTRING         reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    WINT            reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    BOOL            reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    DEFAULT         reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    CASE            reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    RETURN          reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    STRING          reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    TRUE            reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)
    FALSE           reduce using rule 97 (data_type_and_value -> INT32 EQUAL int_value .)


state 313

    (98) data_type_and_value -> INT64 EQUAL int_value .

    COLON           reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    PRINT           reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    SCAN            reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    FOR             reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    CONST           reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    ID              reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    APPEND          reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    LEN             reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    COPY            reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    DELETE          reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    IF              reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    ELSE            reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    TYPE            reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    SWITCH          reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    VAR             reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    FUNC            reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    INTEGER         reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    FLOAT           reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    NOT             reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    $end            reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    RLLAVE          reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    INT32           reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    INT64           reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    FLOAT32         reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    FLOAT64         reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    BYTE            reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    WFLOAT          reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    WSTRING         reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    WINT            reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    BOOL            reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    DEFAULT         reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    CASE            reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    RETURN          reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    STRING          reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    TRUE            reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)
    FALSE           reduce using rule 98 (data_type_and_value -> INT64 EQUAL int_value .)


state 314

    (99) data_type_and_value -> WFLOAT EQUAL float_value .

    COLON           reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    PRINT           reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    SCAN            reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    FOR             reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    CONST           reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    ID              reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    APPEND          reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    LEN             reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    COPY            reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    DELETE          reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    IF              reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    ELSE            reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    TYPE            reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    SWITCH          reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    VAR             reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    FUNC            reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    INTEGER         reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    FLOAT           reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    NOT             reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    $end            reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    RLLAVE          reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    INT32           reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    INT64           reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    FLOAT32         reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    FLOAT64         reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    BYTE            reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    WFLOAT          reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    WSTRING         reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    WINT            reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    BOOL            reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    DEFAULT         reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    CASE            reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    RETURN          reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    STRING          reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    TRUE            reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)
    FALSE           reduce using rule 99 (data_type_and_value -> WFLOAT EQUAL float_value .)


state 315

    (109) float_value -> FLOAT .
    (244) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for PRINT resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for SCAN resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for FOR resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for CONST resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for ID resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for APPEND resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for LEN resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for COPY resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for DELETE resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for IF resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for ELSE resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for TYPE resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for SWITCH resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for VAR resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for FUNC resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for INTEGER resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for FLOAT resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for NOT resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for INT32 resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for INT64 resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for BYTE resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for WSTRING resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for WINT resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for BOOL resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for STRING resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for TRUE resolved using rule 109 (float_value -> FLOAT .)
  ! reduce/reduce conflict for FALSE resolved using rule 109 (float_value -> FLOAT .)
    COLON           reduce using rule 109 (float_value -> FLOAT .)
    PRINT           reduce using rule 109 (float_value -> FLOAT .)
    SCAN            reduce using rule 109 (float_value -> FLOAT .)
    FOR             reduce using rule 109 (float_value -> FLOAT .)
    CONST           reduce using rule 109 (float_value -> FLOAT .)
    ID              reduce using rule 109 (float_value -> FLOAT .)
    APPEND          reduce using rule 109 (float_value -> FLOAT .)
    LEN             reduce using rule 109 (float_value -> FLOAT .)
    COPY            reduce using rule 109 (float_value -> FLOAT .)
    DELETE          reduce using rule 109 (float_value -> FLOAT .)
    IF              reduce using rule 109 (float_value -> FLOAT .)
    ELSE            reduce using rule 109 (float_value -> FLOAT .)
    TYPE            reduce using rule 109 (float_value -> FLOAT .)
    SWITCH          reduce using rule 109 (float_value -> FLOAT .)
    VAR             reduce using rule 109 (float_value -> FLOAT .)
    FUNC            reduce using rule 109 (float_value -> FLOAT .)
    INTEGER         reduce using rule 109 (float_value -> FLOAT .)
    FLOAT           reduce using rule 109 (float_value -> FLOAT .)
    NOT             reduce using rule 109 (float_value -> FLOAT .)
    $end            reduce using rule 109 (float_value -> FLOAT .)
    RLLAVE          reduce using rule 109 (float_value -> FLOAT .)
    INT32           reduce using rule 109 (float_value -> FLOAT .)
    INT64           reduce using rule 109 (float_value -> FLOAT .)
    FLOAT32         reduce using rule 109 (float_value -> FLOAT .)
    FLOAT64         reduce using rule 109 (float_value -> FLOAT .)
    BYTE            reduce using rule 109 (float_value -> FLOAT .)
    WFLOAT          reduce using rule 109 (float_value -> FLOAT .)
    WSTRING         reduce using rule 109 (float_value -> FLOAT .)
    WINT            reduce using rule 109 (float_value -> FLOAT .)
    BOOL            reduce using rule 109 (float_value -> FLOAT .)
    DEFAULT         reduce using rule 109 (float_value -> FLOAT .)
    CASE            reduce using rule 109 (float_value -> FLOAT .)
    RETURN          reduce using rule 109 (float_value -> FLOAT .)
    STRING          reduce using rule 109 (float_value -> FLOAT .)
    TRUE            reduce using rule 109 (float_value -> FLOAT .)
    FALSE           reduce using rule 109 (float_value -> FLOAT .)
    GREATER         reduce using rule 244 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 244 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 244 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 244 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 244 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 244 (something_ex -> FLOAT .)
    PLUS            reduce using rule 244 (something_ex -> FLOAT .)
    TIMES           reduce using rule 244 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 244 (something_ex -> FLOAT .)
    MINUS           reduce using rule 244 (something_ex -> FLOAT .)
    MOD             reduce using rule 244 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! PRINT           [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! SCAN            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! FOR             [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! CONST           [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! ID              [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! APPEND          [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! LEN             [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! COPY            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! DELETE          [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! IF              [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! ELSE            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! TYPE            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! SWITCH          [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! VAR             [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! FUNC            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! INTEGER         [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! FLOAT           [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! NOT             [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! INT32           [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! INT64           [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! FLOAT32         [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! FLOAT64         [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! BYTE            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! WFLOAT          [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! WSTRING         [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! WINT            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! BOOL            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! STRING          [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! TRUE            [ reduce using rule 244 (something_ex -> FLOAT .) ]
  ! FALSE           [ reduce using rule 244 (something_ex -> FLOAT .) ]


state 316

    (110) float_value -> expression .

    COLON           reduce using rule 110 (float_value -> expression .)
    PRINT           reduce using rule 110 (float_value -> expression .)
    SCAN            reduce using rule 110 (float_value -> expression .)
    FOR             reduce using rule 110 (float_value -> expression .)
    CONST           reduce using rule 110 (float_value -> expression .)
    ID              reduce using rule 110 (float_value -> expression .)
    APPEND          reduce using rule 110 (float_value -> expression .)
    LEN             reduce using rule 110 (float_value -> expression .)
    COPY            reduce using rule 110 (float_value -> expression .)
    DELETE          reduce using rule 110 (float_value -> expression .)
    IF              reduce using rule 110 (float_value -> expression .)
    ELSE            reduce using rule 110 (float_value -> expression .)
    TYPE            reduce using rule 110 (float_value -> expression .)
    SWITCH          reduce using rule 110 (float_value -> expression .)
    VAR             reduce using rule 110 (float_value -> expression .)
    FUNC            reduce using rule 110 (float_value -> expression .)
    INTEGER         reduce using rule 110 (float_value -> expression .)
    FLOAT           reduce using rule 110 (float_value -> expression .)
    NOT             reduce using rule 110 (float_value -> expression .)
    $end            reduce using rule 110 (float_value -> expression .)
    RLLAVE          reduce using rule 110 (float_value -> expression .)
    INT32           reduce using rule 110 (float_value -> expression .)
    INT64           reduce using rule 110 (float_value -> expression .)
    FLOAT32         reduce using rule 110 (float_value -> expression .)
    FLOAT64         reduce using rule 110 (float_value -> expression .)
    BYTE            reduce using rule 110 (float_value -> expression .)
    WFLOAT          reduce using rule 110 (float_value -> expression .)
    WSTRING         reduce using rule 110 (float_value -> expression .)
    WINT            reduce using rule 110 (float_value -> expression .)
    BOOL            reduce using rule 110 (float_value -> expression .)
    DEFAULT         reduce using rule 110 (float_value -> expression .)
    CASE            reduce using rule 110 (float_value -> expression .)
    RETURN          reduce using rule 110 (float_value -> expression .)
    STRING          reduce using rule 110 (float_value -> expression .)
    TRUE            reduce using rule 110 (float_value -> expression .)
    FALSE           reduce using rule 110 (float_value -> expression .)


state 317

    (100) data_type_and_value -> FLOAT32 EQUAL float_value .

    COLON           reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    PRINT           reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    SCAN            reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    FOR             reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    CONST           reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    ID              reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    APPEND          reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    LEN             reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    COPY            reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    DELETE          reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    IF              reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    ELSE            reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    TYPE            reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    SWITCH          reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    VAR             reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    FUNC            reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    INTEGER         reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    FLOAT           reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    NOT             reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    $end            reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    RLLAVE          reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    INT32           reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    INT64           reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    FLOAT32         reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    FLOAT64         reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    BYTE            reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    WFLOAT          reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    WSTRING         reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    WINT            reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    BOOL            reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    DEFAULT         reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    CASE            reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    RETURN          reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    STRING          reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    TRUE            reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    FALSE           reduce using rule 100 (data_type_and_value -> FLOAT32 EQUAL float_value .)


state 318

    (101) data_type_and_value -> FLOAT64 EQUAL float_value .

    COLON           reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    PRINT           reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    SCAN            reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    FOR             reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    CONST           reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    ID              reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    APPEND          reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    LEN             reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    COPY            reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    DELETE          reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    IF              reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    ELSE            reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    TYPE            reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    SWITCH          reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    VAR             reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    FUNC            reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    INTEGER         reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    FLOAT           reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    NOT             reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    $end            reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    RLLAVE          reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    INT32           reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    INT64           reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    FLOAT32         reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    FLOAT64         reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    BYTE            reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    WFLOAT          reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    WSTRING         reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    WINT            reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    BOOL            reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    DEFAULT         reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    CASE            reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    RETURN          reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    STRING          reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    TRUE            reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    FALSE           reduce using rule 101 (data_type_and_value -> FLOAT64 EQUAL float_value .)


state 319

    (102) data_type_and_value -> BOOL EQUAL bool_value .

    COLON           reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    PRINT           reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    SCAN            reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    FOR             reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    CONST           reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    ID              reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    APPEND          reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    LEN             reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    COPY            reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    DELETE          reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    IF              reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    ELSE            reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    TYPE            reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    SWITCH          reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    VAR             reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    FUNC            reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    INTEGER         reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    FLOAT           reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    NOT             reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    $end            reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    RLLAVE          reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    INT32           reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    INT64           reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    FLOAT32         reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    FLOAT64         reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    BYTE            reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    WFLOAT          reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    WSTRING         reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    WINT            reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    BOOL            reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    DEFAULT         reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    CASE            reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    RETURN          reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    STRING          reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    TRUE            reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)
    FALSE           reduce using rule 102 (data_type_and_value -> BOOL EQUAL bool_value .)


state 320

    (105) bool_value -> TRUE .

    COLON           reduce using rule 105 (bool_value -> TRUE .)
    PRINT           reduce using rule 105 (bool_value -> TRUE .)
    SCAN            reduce using rule 105 (bool_value -> TRUE .)
    FOR             reduce using rule 105 (bool_value -> TRUE .)
    CONST           reduce using rule 105 (bool_value -> TRUE .)
    ID              reduce using rule 105 (bool_value -> TRUE .)
    APPEND          reduce using rule 105 (bool_value -> TRUE .)
    LEN             reduce using rule 105 (bool_value -> TRUE .)
    COPY            reduce using rule 105 (bool_value -> TRUE .)
    DELETE          reduce using rule 105 (bool_value -> TRUE .)
    IF              reduce using rule 105 (bool_value -> TRUE .)
    ELSE            reduce using rule 105 (bool_value -> TRUE .)
    TYPE            reduce using rule 105 (bool_value -> TRUE .)
    SWITCH          reduce using rule 105 (bool_value -> TRUE .)
    VAR             reduce using rule 105 (bool_value -> TRUE .)
    FUNC            reduce using rule 105 (bool_value -> TRUE .)
    INTEGER         reduce using rule 105 (bool_value -> TRUE .)
    FLOAT           reduce using rule 105 (bool_value -> TRUE .)
    NOT             reduce using rule 105 (bool_value -> TRUE .)
    $end            reduce using rule 105 (bool_value -> TRUE .)
    RLLAVE          reduce using rule 105 (bool_value -> TRUE .)
    INT32           reduce using rule 105 (bool_value -> TRUE .)
    INT64           reduce using rule 105 (bool_value -> TRUE .)
    FLOAT32         reduce using rule 105 (bool_value -> TRUE .)
    FLOAT64         reduce using rule 105 (bool_value -> TRUE .)
    BYTE            reduce using rule 105 (bool_value -> TRUE .)
    WFLOAT          reduce using rule 105 (bool_value -> TRUE .)
    WSTRING         reduce using rule 105 (bool_value -> TRUE .)
    WINT            reduce using rule 105 (bool_value -> TRUE .)
    BOOL            reduce using rule 105 (bool_value -> TRUE .)
    DEFAULT         reduce using rule 105 (bool_value -> TRUE .)
    CASE            reduce using rule 105 (bool_value -> TRUE .)
    RETURN          reduce using rule 105 (bool_value -> TRUE .)
    STRING          reduce using rule 105 (bool_value -> TRUE .)
    TRUE            reduce using rule 105 (bool_value -> TRUE .)
    FALSE           reduce using rule 105 (bool_value -> TRUE .)


state 321

    (106) bool_value -> FALSE .

    COLON           reduce using rule 106 (bool_value -> FALSE .)
    PRINT           reduce using rule 106 (bool_value -> FALSE .)
    SCAN            reduce using rule 106 (bool_value -> FALSE .)
    FOR             reduce using rule 106 (bool_value -> FALSE .)
    CONST           reduce using rule 106 (bool_value -> FALSE .)
    ID              reduce using rule 106 (bool_value -> FALSE .)
    APPEND          reduce using rule 106 (bool_value -> FALSE .)
    LEN             reduce using rule 106 (bool_value -> FALSE .)
    COPY            reduce using rule 106 (bool_value -> FALSE .)
    DELETE          reduce using rule 106 (bool_value -> FALSE .)
    IF              reduce using rule 106 (bool_value -> FALSE .)
    ELSE            reduce using rule 106 (bool_value -> FALSE .)
    TYPE            reduce using rule 106 (bool_value -> FALSE .)
    SWITCH          reduce using rule 106 (bool_value -> FALSE .)
    VAR             reduce using rule 106 (bool_value -> FALSE .)
    FUNC            reduce using rule 106 (bool_value -> FALSE .)
    INTEGER         reduce using rule 106 (bool_value -> FALSE .)
    FLOAT           reduce using rule 106 (bool_value -> FALSE .)
    NOT             reduce using rule 106 (bool_value -> FALSE .)
    $end            reduce using rule 106 (bool_value -> FALSE .)
    RLLAVE          reduce using rule 106 (bool_value -> FALSE .)
    INT32           reduce using rule 106 (bool_value -> FALSE .)
    INT64           reduce using rule 106 (bool_value -> FALSE .)
    FLOAT32         reduce using rule 106 (bool_value -> FALSE .)
    FLOAT64         reduce using rule 106 (bool_value -> FALSE .)
    BYTE            reduce using rule 106 (bool_value -> FALSE .)
    WFLOAT          reduce using rule 106 (bool_value -> FALSE .)
    WSTRING         reduce using rule 106 (bool_value -> FALSE .)
    WINT            reduce using rule 106 (bool_value -> FALSE .)
    BOOL            reduce using rule 106 (bool_value -> FALSE .)
    DEFAULT         reduce using rule 106 (bool_value -> FALSE .)
    CASE            reduce using rule 106 (bool_value -> FALSE .)
    RETURN          reduce using rule 106 (bool_value -> FALSE .)
    STRING          reduce using rule 106 (bool_value -> FALSE .)
    TRUE            reduce using rule 106 (bool_value -> FALSE .)
    FALSE           reduce using rule 106 (bool_value -> FALSE .)


state 322

    (107) bool_value -> comparison .
    (192) logic_value -> comparison .

    COLON           reduce using rule 107 (bool_value -> comparison .)
    PRINT           reduce using rule 107 (bool_value -> comparison .)
    SCAN            reduce using rule 107 (bool_value -> comparison .)
    FOR             reduce using rule 107 (bool_value -> comparison .)
    CONST           reduce using rule 107 (bool_value -> comparison .)
    ID              reduce using rule 107 (bool_value -> comparison .)
    APPEND          reduce using rule 107 (bool_value -> comparison .)
    LEN             reduce using rule 107 (bool_value -> comparison .)
    COPY            reduce using rule 107 (bool_value -> comparison .)
    DELETE          reduce using rule 107 (bool_value -> comparison .)
    IF              reduce using rule 107 (bool_value -> comparison .)
    ELSE            reduce using rule 107 (bool_value -> comparison .)
    TYPE            reduce using rule 107 (bool_value -> comparison .)
    SWITCH          reduce using rule 107 (bool_value -> comparison .)
    VAR             reduce using rule 107 (bool_value -> comparison .)
    FUNC            reduce using rule 107 (bool_value -> comparison .)
    INTEGER         reduce using rule 107 (bool_value -> comparison .)
    FLOAT           reduce using rule 107 (bool_value -> comparison .)
    NOT             reduce using rule 107 (bool_value -> comparison .)
    $end            reduce using rule 107 (bool_value -> comparison .)
    RLLAVE          reduce using rule 107 (bool_value -> comparison .)
    INT32           reduce using rule 107 (bool_value -> comparison .)
    INT64           reduce using rule 107 (bool_value -> comparison .)
    FLOAT32         reduce using rule 107 (bool_value -> comparison .)
    FLOAT64         reduce using rule 107 (bool_value -> comparison .)
    BYTE            reduce using rule 107 (bool_value -> comparison .)
    WFLOAT          reduce using rule 107 (bool_value -> comparison .)
    WSTRING         reduce using rule 107 (bool_value -> comparison .)
    WINT            reduce using rule 107 (bool_value -> comparison .)
    BOOL            reduce using rule 107 (bool_value -> comparison .)
    DEFAULT         reduce using rule 107 (bool_value -> comparison .)
    CASE            reduce using rule 107 (bool_value -> comparison .)
    RETURN          reduce using rule 107 (bool_value -> comparison .)
    STRING          reduce using rule 107 (bool_value -> comparison .)
    TRUE            reduce using rule 107 (bool_value -> comparison .)
    FALSE           reduce using rule 107 (bool_value -> comparison .)
    AND             reduce using rule 192 (logic_value -> comparison .)
    OR              reduce using rule 192 (logic_value -> comparison .)


state 323

    (108) bool_value -> logic_operation .

    COLON           reduce using rule 108 (bool_value -> logic_operation .)
    PRINT           reduce using rule 108 (bool_value -> logic_operation .)
    SCAN            reduce using rule 108 (bool_value -> logic_operation .)
    FOR             reduce using rule 108 (bool_value -> logic_operation .)
    CONST           reduce using rule 108 (bool_value -> logic_operation .)
    ID              reduce using rule 108 (bool_value -> logic_operation .)
    APPEND          reduce using rule 108 (bool_value -> logic_operation .)
    LEN             reduce using rule 108 (bool_value -> logic_operation .)
    COPY            reduce using rule 108 (bool_value -> logic_operation .)
    DELETE          reduce using rule 108 (bool_value -> logic_operation .)
    IF              reduce using rule 108 (bool_value -> logic_operation .)
    ELSE            reduce using rule 108 (bool_value -> logic_operation .)
    TYPE            reduce using rule 108 (bool_value -> logic_operation .)
    SWITCH          reduce using rule 108 (bool_value -> logic_operation .)
    VAR             reduce using rule 108 (bool_value -> logic_operation .)
    FUNC            reduce using rule 108 (bool_value -> logic_operation .)
    INTEGER         reduce using rule 108 (bool_value -> logic_operation .)
    FLOAT           reduce using rule 108 (bool_value -> logic_operation .)
    NOT             reduce using rule 108 (bool_value -> logic_operation .)
    $end            reduce using rule 108 (bool_value -> logic_operation .)
    RLLAVE          reduce using rule 108 (bool_value -> logic_operation .)
    INT32           reduce using rule 108 (bool_value -> logic_operation .)
    INT64           reduce using rule 108 (bool_value -> logic_operation .)
    FLOAT32         reduce using rule 108 (bool_value -> logic_operation .)
    FLOAT64         reduce using rule 108 (bool_value -> logic_operation .)
    BYTE            reduce using rule 108 (bool_value -> logic_operation .)
    WFLOAT          reduce using rule 108 (bool_value -> logic_operation .)
    WSTRING         reduce using rule 108 (bool_value -> logic_operation .)
    WINT            reduce using rule 108 (bool_value -> logic_operation .)
    BOOL            reduce using rule 108 (bool_value -> logic_operation .)
    DEFAULT         reduce using rule 108 (bool_value -> logic_operation .)
    CASE            reduce using rule 108 (bool_value -> logic_operation .)
    RETURN          reduce using rule 108 (bool_value -> logic_operation .)
    STRING          reduce using rule 108 (bool_value -> logic_operation .)
    TRUE            reduce using rule 108 (bool_value -> logic_operation .)
    FALSE           reduce using rule 108 (bool_value -> logic_operation .)


state 324

    (179) value -> ID .
    (193) logic_value -> ID .
    (242) something_ex -> ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 179 (value -> ID .)
    GREATER         reduce using rule 179 (value -> ID .)
    SMALLER         reduce using rule 179 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 179 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 179 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 179 (value -> ID .)
    NOT_EQUAL       reduce using rule 179 (value -> ID .)
    PLUS            reduce using rule 179 (value -> ID .)
    TIMES           reduce using rule 179 (value -> ID .)
    DIVIDE          reduce using rule 179 (value -> ID .)
    MINUS           reduce using rule 179 (value -> ID .)
    MOD             reduce using rule 179 (value -> ID .)
    AND             reduce using rule 193 (logic_value -> ID .)
    OR              reduce using rule 193 (logic_value -> ID .)
    LCORCHE         shift and go to state 174
    LPAREN          shift and go to state 112

  ! GREATER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 242 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 242 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 242 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 242 (something_ex -> ID .) ]


state 325

    (172) asignaciones -> ID . POINTS valor
    (173) asignaciones -> ID . POINTS valor COMA asignaciones

    POINTS          shift and go to state 363


state 326

    (171) cStruct -> ID DEQUAL ID LLLAVE asignaciones . RLLAVE

    RLLAVE          shift and go to state 364


state 327

    (137) slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types . arr_content
    (71) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (72) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 366

    arr_content                    shift and go to state 365

state 328

    (138) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap RPAREN
    (139) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap COMA cap RPAREN

    RCORCHE         shift and go to state 367


state 329

    (87) list_params -> ID COMA more_p .

    RPAREN          reduce using rule 87 (list_params -> ID COMA more_p .)


state 330

    (88) more_p -> list_params .

    RPAREN          reduce using rule 88 (more_p -> list_params .)


state 331

    (153) funciones -> APPEND LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 368


state 332

    (152) funciones -> APPEND LPAREN ID COMA values . RPAREN

    RPAREN          shift and go to state 369


state 333

    (46) values -> INTEGER .

    RPAREN          reduce using rule 46 (values -> INTEGER .)
    POINTS          reduce using rule 46 (values -> INTEGER .)


state 334

    (47) values -> FLOAT .

    RPAREN          reduce using rule 47 (values -> FLOAT .)
    POINTS          reduce using rule 47 (values -> FLOAT .)


state 335

    (155) funciones -> COPY LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 370


state 336

    (156) funciones -> DELETE LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 371


state 337

    (160) SenIF -> IF comparison LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    ID              reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    IF              reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    $end            reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    STRING          reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    TRUE            reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FALSE           reduce using rule 160 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)


state 338

    (161) SenIF -> IF TRUE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    STRING          reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    TRUE            reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FALSE           reduce using rule 161 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)


state 339

    (162) SenIF -> IF FALSE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    STRING          reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    TRUE            reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FALSE           reduce using rule 162 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)


state 340

    (163) SenElseIF -> ELSE IF comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 372


state 341

    (164) SenElseIF -> ELSE IF TRUE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 373


state 342

    (165) SenElseIF -> ELSE IF FALSE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 374


state 343

    (170) variable -> ID .

    INT32           reduce using rule 170 (variable -> ID .)
    INT64           reduce using rule 170 (variable -> ID .)
    FLOAT32         reduce using rule 170 (variable -> ID .)
    FLOAT64         reduce using rule 170 (variable -> ID .)
    BYTE            reduce using rule 170 (variable -> ID .)
    WFLOAT          reduce using rule 170 (variable -> ID .)
    WSTRING         reduce using rule 170 (variable -> ID .)
    WINT            reduce using rule 170 (variable -> ID .)
    BOOL            reduce using rule 170 (variable -> ID .)


state 344

    (167) SenStruct -> TYPE ID STRUCT LLLAVE declaration . RLLAVE
    (169) declaration -> declaration . variable data_types
    (170) variable -> . ID

    RLLAVE          shift and go to state 375
    ID              shift and go to state 343

    variable                       shift and go to state 376

state 345

    (168) declaration -> variable . data_types
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WFLOAT
    (56) data_types -> . WSTRING
    (57) data_types -> . WINT
    (58) data_types -> . BOOL

    INT32           shift and go to state 132
    INT64           shift and go to state 133
    FLOAT32         shift and go to state 134
    FLOAT64         shift and go to state 135
    BYTE            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    WINT            shift and go to state 139
    BOOL            shift and go to state 140

    data_types                     shift and go to state 377

state 346

    (198) switch_statement -> SWITCH ID LLLAVE cases RLLAVE .

    PRINT           reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    SCAN            reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FOR             reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    CONST           reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    ID              reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    APPEND          reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    LEN             reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    COPY            reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    DELETE          reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    IF              reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    ELSE            reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    TYPE            reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    SWITCH          reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    VAR             reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FUNC            reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    INTEGER         reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FLOAT           reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    NOT             reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    $end            reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RLLAVE          reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    INT32           reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    INT64           reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FLOAT32         reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FLOAT64         reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    BYTE            reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    WFLOAT          reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    WSTRING         reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    WINT            reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    BOOL            reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    DEFAULT         reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    CASE            reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RETURN          reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    STRING          reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    TRUE            reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FALSE           reduce using rule 198 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)


state 347

    (199) cases -> CASE values . POINTS codigo
    (200) cases -> CASE values . POINTS codigo more

    POINTS          shift and go to state 378


state 348

    (203) array_declaration -> VAR ID LCORCHE capacity RCORCHE . data_types
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WFLOAT
    (56) data_types -> . WSTRING
    (57) data_types -> . WINT
    (58) data_types -> . BOOL

    INT32           shift and go to state 132
    INT64           shift and go to state 133
    FLOAT32         shift and go to state 134
    FLOAT64         shift and go to state 135
    BYTE            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    WINT            shift and go to state 139
    BOOL            shift and go to state 140

    data_types                     shift and go to state 379

state 349

    (133) slice_declaration -> VAR ID LCORCHE RCORCHE data_types .

    COLON           reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    PRINT           reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    SCAN            reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FOR             reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    CONST           reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    ID              reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    APPEND          reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    LEN             reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    COPY            reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    DELETE          reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    IF              reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    ELSE            reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    TYPE            reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    SWITCH          reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    VAR             reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FUNC            reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    INTEGER         reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FLOAT           reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    NOT             reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    $end            reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    RLLAVE          reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    INT32           reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    INT64           reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FLOAT32         reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FLOAT64         reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    BYTE            reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    WFLOAT          reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    WSTRING         reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    WINT            reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    BOOL            reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    DEFAULT         reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    CASE            reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    RETURN          reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    STRING          reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    TRUE            reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FALSE           reduce using rule 133 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)


state 350

    (213) map_declaration -> VAR ID LCORCHE data_types RCORCHE . data_types
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WFLOAT
    (56) data_types -> . WSTRING
    (57) data_types -> . WINT
    (58) data_types -> . BOOL

    INT32           shift and go to state 132
    INT64           shift and go to state 133
    FLOAT32         shift and go to state 134
    FLOAT64         shift and go to state 135
    BYTE            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    WINT            shift and go to state 139
    BOOL            shift and go to state 140

    data_types                     shift and go to state 380

state 351

    (124) single -> VAR ID data_types EQUAL ID .
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE

    COLON           reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    PRINT           reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    SCAN            reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    FOR             reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    CONST           reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    ID              reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    APPEND          reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    LEN             reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    COPY            reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    DELETE          reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    IF              reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    ELSE            reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    TYPE            reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    SWITCH          reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    VAR             reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    FUNC            reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    INTEGER         reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    FLOAT           reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    NOT             reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    $end            reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    RLLAVE          reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    INT32           reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    INT64           reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    FLOAT32         reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    FLOAT64         reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    BYTE            reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    WFLOAT          reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    WSTRING         reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    WINT            reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    BOOL            reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    DEFAULT         reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    CASE            reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    RETURN          reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    STRING          reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    TRUE            reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    FALSE           reduce using rule 124 (single -> VAR ID data_types EQUAL ID .)
    LPAREN          shift and go to state 112
    LCORCHE         shift and go to state 174


state 352

    (123) single -> VAR ID data_types EQUAL funciones .

    COLON           reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    PRINT           reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    SCAN            reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    FOR             reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    CONST           reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    ID              reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    APPEND          reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    LEN             reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    COPY            reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    DELETE          reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    IF              reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    ELSE            reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    TYPE            reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    SWITCH          reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    VAR             reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    FUNC            reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    INTEGER         reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    FLOAT           reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    NOT             reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    $end            reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    RLLAVE          reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    INT32           reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    INT64           reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    FLOAT32         reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    FLOAT64         reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    BYTE            reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    WFLOAT          reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    WSTRING         reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    WINT            reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    BOOL            reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    DEFAULT         reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    CASE            reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    RETURN          reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    STRING          reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    TRUE            reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)
    FALSE           reduce using rule 123 (single -> VAR ID data_types EQUAL funciones .)


state 353

    (125) single -> VAR ID data_types EQUAL data_structure .

    COLON           reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    PRINT           reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    SCAN            reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    FOR             reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    CONST           reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    ID              reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    APPEND          reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    LEN             reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    COPY            reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    DELETE          reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    IF              reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    ELSE            reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    TYPE            reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    SWITCH          reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    VAR             reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    FUNC            reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    INTEGER         reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    FLOAT           reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    NOT             reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    $end            reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    RLLAVE          reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    INT32           reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    INT64           reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    FLOAT32         reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    FLOAT64         reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    BYTE            reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    WFLOAT          reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    WSTRING         reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    WINT            reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    BOOL            reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    DEFAULT         reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    CASE            reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    RETURN          reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    STRING          reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    TRUE            reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)
    FALSE           reduce using rule 125 (single -> VAR ID data_types EQUAL data_structure .)


state 354

    (204) array_declaration -> VAR ID EQUAL LCORCHE capacity . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 381


state 355

    (134) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE . data_types arr_content
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WFLOAT
    (56) data_types -> . WSTRING
    (57) data_types -> . WINT
    (58) data_types -> . BOOL

    INT32           shift and go to state 132
    INT64           shift and go to state 133
    FLOAT32         shift and go to state 134
    FLOAT64         shift and go to state 135
    BYTE            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    WINT            shift and go to state 139
    BOOL            shift and go to state 140

    data_types                     shift and go to state 382

state 356

    (121) more -> ID COMA . more
    (120) more -> . ID
    (121) more -> . ID COMA more
    (201) more -> . cases
    (202) more -> . DEFAULT POINTS codigo
    (199) cases -> . CASE values POINTS codigo
    (200) cases -> . CASE values POINTS codigo more

    ID              shift and go to state 297
    DEFAULT         shift and go to state 300
    CASE            shift and go to state 287

    more                           shift and go to state 383
    cases                          shift and go to state 299

state 357

    (202) more -> DEFAULT POINTS . codigo
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 384
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 358

    (229) params -> ID data_types .
    (231) more_params -> ID data_types . COMA params

    RPAREN          reduce using rule 229 (params -> ID data_types .)
    COMA            shift and go to state 385


state 359

    (219) func_declaration -> FUNC ID LPAREN params RPAREN . data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> FUNC ID LPAREN params RPAREN . data_types LLLAVE RETURN body RLLAVE
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WFLOAT
    (56) data_types -> . WSTRING
    (57) data_types -> . WINT
    (58) data_types -> . BOOL

    INT32           shift and go to state 132
    INT64           shift and go to state 133
    FLOAT32         shift and go to state 134
    FLOAT64         shift and go to state 135
    BYTE            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    WINT            shift and go to state 139
    BOOL            shift and go to state 140

    data_types                     shift and go to state 386

state 360

    (82) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 387
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 361

    (92) cicloFor -> FOR decVarOne COLON comparison COLON incre . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 388


state 362

    (93) incre -> ID . INCREASE
    (94) incre -> ID . DECREASE

    INCREASE        shift and go to state 389
    DECREASE        shift and go to state 390


state 363

    (172) asignaciones -> ID POINTS . valor
    (173) asignaciones -> ID POINTS . valor COMA asignaciones
    (174) valor -> . ID
    (175) valor -> . INTEGER
    (176) valor -> . TRUE
    (177) valor -> . FALSE

    ID              shift and go to state 391
    INTEGER         shift and go to state 393
    TRUE            shift and go to state 394
    FALSE           shift and go to state 395

    valor                          shift and go to state 392

state 364

    (171) cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .

    PRINT           reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    SCAN            reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FOR             reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    CONST           reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    ID              reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    APPEND          reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    LEN             reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    COPY            reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    DELETE          reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    IF              reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    ELSE            reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    TYPE            reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    SWITCH          reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    VAR             reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FUNC            reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    INTEGER         reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FLOAT           reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    NOT             reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    $end            reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    RLLAVE          reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    INT32           reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    INT64           reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FLOAT32         reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FLOAT64         reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    BYTE            reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    WFLOAT          reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    WSTRING         reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    WINT            reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    BOOL            reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    DEFAULT         reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    CASE            reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    RETURN          reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    STRING          reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    TRUE            reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FALSE           reduce using rule 171 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)


state 365

    (137) slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .

    COLON           reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    PRINT           reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    SCAN            reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FOR             reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    CONST           reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    ID              reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    APPEND          reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    LEN             reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    COPY            reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    DELETE          reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    IF              reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    ELSE            reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    TYPE            reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    SWITCH          reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    VAR             reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FUNC            reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    INTEGER         reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT           reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    NOT             reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    $end            reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    INT32           reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    INT64           reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT32         reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT64         reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    BYTE            reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    WFLOAT          reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    WSTRING         reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    WINT            reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    BOOL            reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    CASE            reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RETURN          reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    STRING          reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    TRUE            reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FALSE           reduce using rule 137 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)


state 366

    (71) arr_content -> LLLAVE . items COMA more_items RLLAVE
    (72) arr_content -> LLLAVE . items RLLAVE
    (75) items -> . values
    (76) items -> . operations
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    STRING          shift and go to state 147
    INTEGER         shift and go to state 148
    FLOAT           shift and go to state 149
    TRUE            shift and go to state 150
    FALSE           shift and go to state 151
    ID              shift and go to state 399
    NOT             shift and go to state 56
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    items                          shift and go to state 396
    values                         shift and go to state 397
    operations                     shift and go to state 398
    expression                     shift and go to state 152
    comparison                     shift and go to state 153
    logic_operation                shift and go to state 154
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 367

    (138) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap RPAREN
    (139) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap COMA cap RPAREN
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WFLOAT
    (56) data_types -> . WSTRING
    (57) data_types -> . WINT
    (58) data_types -> . BOOL

    INT32           shift and go to state 132
    INT64           shift and go to state 133
    FLOAT32         shift and go to state 134
    FLOAT64         shift and go to state 135
    BYTE            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    WINT            shift and go to state 139
    BOOL            shift and go to state 140

    data_types                     shift and go to state 400

state 368

    (153) funciones -> APPEND LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    PRINT           reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SCAN            reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FOR             reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    CONST           reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    ID              reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    APPEND          reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    LEN             reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    COPY            reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DELETE          reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    IF              reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    ELSE            reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    TYPE            reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SWITCH          reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    VAR             reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FUNC            reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    INTEGER         reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FLOAT           reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    NOT             reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    MOD             reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    INT32           reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    INT64           reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FLOAT32         reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FLOAT64         reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    BYTE            reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    WFLOAT          reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    WSTRING         reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    WINT            reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    BOOL            reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    STRING          reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    TRUE            reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FALSE           reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 153 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)


state 369

    (152) funciones -> APPEND LPAREN ID COMA values RPAREN .

    COLON           reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    PRINT           reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SCAN            reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FOR             reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    CONST           reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    ID              reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    APPEND          reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    LEN             reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    COPY            reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DELETE          reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    IF              reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    ELSE            reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    TYPE            reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SWITCH          reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    VAR             reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FUNC            reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    INTEGER         reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FLOAT           reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    NOT             reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    $end            reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    GREATER         reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SMALLER         reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    GREATER_OR_EQUAL reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    EQUAL_COMPARE   reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    NOT_EQUAL       reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    PLUS            reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    TIMES           reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DIVIDE          reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    MINUS           reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    MOD             reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RLLAVE          reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    INT32           reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    INT64           reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FLOAT32         reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FLOAT64         reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    BYTE            reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    WFLOAT          reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    WSTRING         reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    WINT            reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    BOOL            reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DEFAULT         reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    CASE            reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RETURN          reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    STRING          reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    TRUE            reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FALSE           reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RPAREN          reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    AND             reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    OR              reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    LLLAVE          reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RCORCHE         reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    COMA            reduce using rule 152 (funciones -> APPEND LPAREN ID COMA values RPAREN .)


state 370

    (155) funciones -> COPY LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    PRINT           reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SCAN            reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FOR             reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    CONST           reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    ID              reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    APPEND          reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    LEN             reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    COPY            reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DELETE          reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    IF              reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    ELSE            reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    TYPE            reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SWITCH          reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    VAR             reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FUNC            reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    INTEGER         reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FLOAT           reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    NOT             reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    MOD             reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    INT32           reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    INT64           reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FLOAT32         reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FLOAT64         reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    BYTE            reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    WFLOAT          reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    WSTRING         reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    WINT            reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    BOOL            reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    STRING          reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    TRUE            reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FALSE           reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 155 (funciones -> COPY LPAREN ID COMA ID RPAREN .)


state 371

    (156) funciones -> DELETE LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    PRINT           reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SCAN            reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FOR             reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    CONST           reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    ID              reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    APPEND          reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    LEN             reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    COPY            reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DELETE          reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    IF              reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    ELSE            reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    TYPE            reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SWITCH          reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    VAR             reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FUNC            reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    INTEGER         reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FLOAT           reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    NOT             reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    MOD             reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    INT32           reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    INT64           reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FLOAT32         reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FLOAT64         reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    BYTE            reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    WFLOAT          reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    WSTRING         reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    WINT            reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    BOOL            reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    STRING          reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    TRUE            reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FALSE           reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 156 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)


state 372

    (163) SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    ID              reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    IF              reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    $end            reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    STRING          reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    TRUE            reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FALSE           reduce using rule 163 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)


state 373

    (164) SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    STRING          reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    TRUE            reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FALSE           reduce using rule 164 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)


state 374

    (165) SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    STRING          reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    TRUE            reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FALSE           reduce using rule 165 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)


state 375

    (167) SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .

    PRINT           reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    SCAN            reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FOR             reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    CONST           reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    ID              reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    APPEND          reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    LEN             reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    COPY            reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    DELETE          reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    IF              reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    ELSE            reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    TYPE            reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    SWITCH          reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    VAR             reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FUNC            reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    INTEGER         reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FLOAT           reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    NOT             reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    $end            reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RLLAVE          reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    INT32           reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    INT64           reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FLOAT32         reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FLOAT64         reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    BYTE            reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    WFLOAT          reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    WSTRING         reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    WINT            reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    BOOL            reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    DEFAULT         reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    CASE            reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RETURN          reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    STRING          reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    TRUE            reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FALSE           reduce using rule 167 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)


state 376

    (169) declaration -> declaration variable . data_types
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WFLOAT
    (56) data_types -> . WSTRING
    (57) data_types -> . WINT
    (58) data_types -> . BOOL

    INT32           shift and go to state 132
    INT64           shift and go to state 133
    FLOAT32         shift and go to state 134
    FLOAT64         shift and go to state 135
    BYTE            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    WINT            shift and go to state 139
    BOOL            shift and go to state 140

    data_types                     shift and go to state 401

state 377

    (168) declaration -> variable data_types .

    RLLAVE          reduce using rule 168 (declaration -> variable data_types .)
    ID              reduce using rule 168 (declaration -> variable data_types .)


state 378

    (199) cases -> CASE values POINTS . codigo
    (200) cases -> CASE values POINTS . codigo more
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 402
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 379

    (203) array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .

    COLON           reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    PRINT           reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    SCAN            reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FOR             reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    CONST           reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    ID              reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    APPEND          reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    LEN             reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    COPY            reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    DELETE          reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    IF              reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    ELSE            reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    TYPE            reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    SWITCH          reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    VAR             reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FUNC            reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    INTEGER         reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FLOAT           reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    NOT             reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    $end            reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RLLAVE          reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    INT32           reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    INT64           reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FLOAT32         reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FLOAT64         reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    BYTE            reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    WFLOAT          reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    WSTRING         reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    WINT            reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    BOOL            reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    DEFAULT         reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    CASE            reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RETURN          reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    STRING          reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    TRUE            reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FALSE           reduce using rule 203 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)


state 380

    (213) map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .

    COLON           reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    PRINT           reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    SCAN            reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FOR             reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    CONST           reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    ID              reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    APPEND          reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    LEN             reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    COPY            reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    DELETE          reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    IF              reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    ELSE            reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    TYPE            reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    SWITCH          reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    VAR             reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FUNC            reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    INTEGER         reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FLOAT           reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    NOT             reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    $end            reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    RLLAVE          reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    INT32           reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    INT64           reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FLOAT32         reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FLOAT64         reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    BYTE            reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    WFLOAT          reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    WSTRING         reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    WINT            reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    BOOL            reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    DEFAULT         reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    CASE            reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    RETURN          reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    STRING          reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    TRUE            reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FALSE           reduce using rule 213 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)


state 381

    (204) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE . data_types arr_content
    (50) data_types -> . INT32
    (51) data_types -> . INT64
    (52) data_types -> . FLOAT32
    (53) data_types -> . FLOAT64
    (54) data_types -> . BYTE
    (55) data_types -> . WFLOAT
    (56) data_types -> . WSTRING
    (57) data_types -> . WINT
    (58) data_types -> . BOOL

    INT32           shift and go to state 132
    INT64           shift and go to state 133
    FLOAT32         shift and go to state 134
    FLOAT64         shift and go to state 135
    BYTE            shift and go to state 136
    WFLOAT          shift and go to state 137
    WSTRING         shift and go to state 138
    WINT            shift and go to state 139
    BOOL            shift and go to state 140

    data_types                     shift and go to state 403

state 382

    (134) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types . arr_content
    (71) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (72) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 366

    arr_content                    shift and go to state 404

state 383

    (121) more -> ID COMA more .

    INT32           reduce using rule 121 (more -> ID COMA more .)
    INT64           reduce using rule 121 (more -> ID COMA more .)
    FLOAT32         reduce using rule 121 (more -> ID COMA more .)
    FLOAT64         reduce using rule 121 (more -> ID COMA more .)
    BYTE            reduce using rule 121 (more -> ID COMA more .)
    WFLOAT          reduce using rule 121 (more -> ID COMA more .)
    WSTRING         reduce using rule 121 (more -> ID COMA more .)
    WINT            reduce using rule 121 (more -> ID COMA more .)
    BOOL            reduce using rule 121 (more -> ID COMA more .)
    RLLAVE          reduce using rule 121 (more -> ID COMA more .)


state 384

    (202) more -> DEFAULT POINTS codigo .

    INT32           reduce using rule 202 (more -> DEFAULT POINTS codigo .)
    INT64           reduce using rule 202 (more -> DEFAULT POINTS codigo .)
    FLOAT32         reduce using rule 202 (more -> DEFAULT POINTS codigo .)
    FLOAT64         reduce using rule 202 (more -> DEFAULT POINTS codigo .)
    BYTE            reduce using rule 202 (more -> DEFAULT POINTS codigo .)
    WFLOAT          reduce using rule 202 (more -> DEFAULT POINTS codigo .)
    WSTRING         reduce using rule 202 (more -> DEFAULT POINTS codigo .)
    WINT            reduce using rule 202 (more -> DEFAULT POINTS codigo .)
    BOOL            reduce using rule 202 (more -> DEFAULT POINTS codigo .)
    RLLAVE          reduce using rule 202 (more -> DEFAULT POINTS codigo .)


state 385

    (231) more_params -> ID data_types COMA . params
    (229) params -> . ID data_types
    (230) params -> . more_params
    (231) more_params -> . ID data_types COMA params

    ID              shift and go to state 301

    params                         shift and go to state 405
    more_params                    shift and go to state 303

state 386

    (219) func_declaration -> FUNC ID LPAREN params RPAREN data_types . LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> FUNC ID LPAREN params RPAREN data_types . LLLAVE RETURN body RLLAVE

    LLLAVE          shift and go to state 406


state 387

    (82) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 407


state 388

    (92) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    comparison                     shift and go to state 8
    codigo                         shift and go to state 408
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 389

    (93) incre -> ID INCREASE .

    LLLAVE          reduce using rule 93 (incre -> ID INCREASE .)


state 390

    (94) incre -> ID DECREASE .

    LLLAVE          reduce using rule 94 (incre -> ID DECREASE .)


state 391

    (174) valor -> ID .

    COMA            reduce using rule 174 (valor -> ID .)
    RLLAVE          reduce using rule 174 (valor -> ID .)


state 392

    (172) asignaciones -> ID POINTS valor .
    (173) asignaciones -> ID POINTS valor . COMA asignaciones

    RLLAVE          reduce using rule 172 (asignaciones -> ID POINTS valor .)
    COMA            shift and go to state 409


state 393

    (175) valor -> INTEGER .

    COMA            reduce using rule 175 (valor -> INTEGER .)
    RLLAVE          reduce using rule 175 (valor -> INTEGER .)


state 394

    (176) valor -> TRUE .

    COMA            reduce using rule 176 (valor -> TRUE .)
    RLLAVE          reduce using rule 176 (valor -> TRUE .)


state 395

    (177) valor -> FALSE .

    COMA            reduce using rule 177 (valor -> FALSE .)
    RLLAVE          reduce using rule 177 (valor -> FALSE .)


state 396

    (71) arr_content -> LLLAVE items . COMA more_items RLLAVE
    (72) arr_content -> LLLAVE items . RLLAVE

    COMA            shift and go to state 410
    RLLAVE          shift and go to state 411


state 397

    (75) items -> values .

    COMA            reduce using rule 75 (items -> values .)
    RLLAVE          reduce using rule 75 (items -> values .)


state 398

    (76) items -> operations .

    COMA            reduce using rule 76 (items -> operations .)
    RLLAVE          reduce using rule 76 (items -> operations .)


state 399

    (242) something_ex -> ID .
    (179) value -> ID .
    (193) logic_value -> ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 179 (value -> ID .)
    COMA            reduce using rule 242 (something_ex -> ID .)
    RLLAVE          reduce using rule 242 (something_ex -> ID .)
    GREATER         reduce using rule 179 (value -> ID .)
    SMALLER         reduce using rule 179 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 179 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 179 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 179 (value -> ID .)
    NOT_EQUAL       reduce using rule 179 (value -> ID .)
    PLUS            reduce using rule 179 (value -> ID .)
    TIMES           reduce using rule 179 (value -> ID .)
    DIVIDE          reduce using rule 179 (value -> ID .)
    MINUS           reduce using rule 179 (value -> ID .)
    MOD             reduce using rule 179 (value -> ID .)
    AND             reduce using rule 193 (logic_value -> ID .)
    OR              reduce using rule 193 (logic_value -> ID .)
    LCORCHE         shift and go to state 174
    LPAREN          shift and go to state 112

  ! GREATER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 242 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 242 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 242 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 242 (something_ex -> ID .) ]


state 400

    (138) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap RPAREN
    (139) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap COMA cap RPAREN

    COMA            shift and go to state 412


state 401

    (169) declaration -> declaration variable data_types .

    RLLAVE          reduce using rule 169 (declaration -> declaration variable data_types .)
    ID              reduce using rule 169 (declaration -> declaration variable data_types .)


state 402

    (199) cases -> CASE values POINTS codigo .
    (200) cases -> CASE values POINTS codigo . more
    (120) more -> . ID
    (121) more -> . ID COMA more
    (201) more -> . cases
    (202) more -> . DEFAULT POINTS codigo
    (199) cases -> . CASE values POINTS codigo
    (200) cases -> . CASE values POINTS codigo more

    RLLAVE          reduce using rule 199 (cases -> CASE values POINTS codigo .)
    INT32           reduce using rule 199 (cases -> CASE values POINTS codigo .)
    INT64           reduce using rule 199 (cases -> CASE values POINTS codigo .)
    FLOAT32         reduce using rule 199 (cases -> CASE values POINTS codigo .)
    FLOAT64         reduce using rule 199 (cases -> CASE values POINTS codigo .)
    BYTE            reduce using rule 199 (cases -> CASE values POINTS codigo .)
    WFLOAT          reduce using rule 199 (cases -> CASE values POINTS codigo .)
    WSTRING         reduce using rule 199 (cases -> CASE values POINTS codigo .)
    WINT            reduce using rule 199 (cases -> CASE values POINTS codigo .)
    BOOL            reduce using rule 199 (cases -> CASE values POINTS codigo .)
    ID              shift and go to state 297
    DEFAULT         shift and go to state 300
    CASE            shift and go to state 287

    more                           shift and go to state 413
    cases                          shift and go to state 299

state 403

    (204) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types . arr_content
    (71) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (72) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 366

    arr_content                    shift and go to state 414

state 404

    (134) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .

    COLON           reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    PRINT           reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    SCAN            reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FOR             reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    CONST           reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    ID              reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    APPEND          reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    LEN             reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    COPY            reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    DELETE          reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    IF              reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    ELSE            reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    TYPE            reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    SWITCH          reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    VAR             reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FUNC            reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    INTEGER         reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT           reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    NOT             reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    $end            reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    INT32           reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    INT64           reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT32         reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT64         reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    BYTE            reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    WFLOAT          reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    WSTRING         reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    WINT            reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    BOOL            reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    CASE            reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    RETURN          reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    STRING          reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    TRUE            reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FALSE           reduce using rule 134 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)


state 405

    (231) more_params -> ID data_types COMA params .

    RPAREN          reduce using rule 231 (more_params -> ID data_types COMA params .)


state 406

    (219) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE . codigo RETURN retorno RLLAVE
    (220) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE . RETURN body RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    RETURN          shift and go to state 416
    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    ID              shift and go to state 40
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    INTEGER         shift and go to state 54
    FLOAT           shift and go to state 55
    NOT             shift and go to state 56

    codigo                         shift and go to state 415
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    data_structure                 shift and go to state 41
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 407

    (82) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    ID              reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    IF              reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    $end            reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    STRING          reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    TRUE            reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FALSE           reduce using rule 82 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)


state 408

    (92) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 417


state 409

    (173) asignaciones -> ID POINTS valor COMA . asignaciones
    (172) asignaciones -> . ID POINTS valor
    (173) asignaciones -> . ID POINTS valor COMA asignaciones

    ID              shift and go to state 325

    asignaciones                   shift and go to state 418

state 410

    (71) arr_content -> LLLAVE items COMA . more_items RLLAVE
    (73) more_items -> . items COMA more_items
    (74) more_items -> . items
    (75) items -> . values
    (76) items -> . operations
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    STRING          shift and go to state 147
    INTEGER         shift and go to state 148
    FLOAT           shift and go to state 149
    TRUE            shift and go to state 150
    FALSE           shift and go to state 151
    ID              shift and go to state 399
    NOT             shift and go to state 56
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    items                          shift and go to state 419
    more_items                     shift and go to state 420
    values                         shift and go to state 397
    operations                     shift and go to state 398
    expression                     shift and go to state 152
    comparison                     shift and go to state 153
    logic_operation                shift and go to state 154
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 411

    (72) arr_content -> LLLAVE items RLLAVE .

    COLON           reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    PRINT           reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    SCAN            reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    FOR             reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    CONST           reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    ID              reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    APPEND          reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    LEN             reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    COPY            reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    DELETE          reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    IF              reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    ELSE            reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    TYPE            reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    SWITCH          reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    VAR             reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    FUNC            reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    INTEGER         reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    FLOAT           reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    NOT             reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    $end            reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    RLLAVE          reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    INT32           reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    INT64           reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    FLOAT32         reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    FLOAT64         reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    BYTE            reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    WFLOAT          reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    WSTRING         reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    WINT            reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    BOOL            reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    DEFAULT         reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    CASE            reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    RETURN          reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    STRING          reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    TRUE            reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)
    FALSE           reduce using rule 72 (arr_content -> LLLAVE items RLLAVE .)


state 412

    (138) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap RPAREN
    (139) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap COMA cap RPAREN
    (140) cap -> . INTEGER
    (141) cap -> . ID
    (142) cap -> . expression
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 422
    ID              shift and go to state 423
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    cap                            shift and go to state 421
    expression                     shift and go to state 424
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 413

    (200) cases -> CASE values POINTS codigo more .

    RLLAVE          reduce using rule 200 (cases -> CASE values POINTS codigo more .)
    INT32           reduce using rule 200 (cases -> CASE values POINTS codigo more .)
    INT64           reduce using rule 200 (cases -> CASE values POINTS codigo more .)
    FLOAT32         reduce using rule 200 (cases -> CASE values POINTS codigo more .)
    FLOAT64         reduce using rule 200 (cases -> CASE values POINTS codigo more .)
    BYTE            reduce using rule 200 (cases -> CASE values POINTS codigo more .)
    WFLOAT          reduce using rule 200 (cases -> CASE values POINTS codigo more .)
    WSTRING         reduce using rule 200 (cases -> CASE values POINTS codigo more .)
    WINT            reduce using rule 200 (cases -> CASE values POINTS codigo more .)
    BOOL            reduce using rule 200 (cases -> CASE values POINTS codigo more .)


state 414

    (204) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .

    COLON           reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    PRINT           reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    SCAN            reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FOR             reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    CONST           reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    ID              reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    APPEND          reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    LEN             reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    COPY            reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    DELETE          reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    IF              reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    ELSE            reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    TYPE            reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    SWITCH          reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    VAR             reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FUNC            reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    INTEGER         reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FLOAT           reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    NOT             reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    $end            reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    INT32           reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    INT64           reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FLOAT32         reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FLOAT64         reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    BYTE            reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    WFLOAT          reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    WSTRING         reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    WINT            reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    BOOL            reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    CASE            reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RETURN          reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    STRING          reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    TRUE            reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FALSE           reduce using rule 204 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)


state 415

    (219) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo . RETURN retorno RLLAVE

    RETURN          shift and go to state 425


state 416

    (220) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN . body RLLAVE
    (221) body -> . codigo return_value
    (222) body -> . return_value
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (223) return_value -> . retorno COLON
    (224) return_value -> . retorno
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . decConst COLON
    (16) rule -> . decConst
    (17) rule -> . var_asignation
    (18) rule -> . var_asignation COLON
    (19) rule -> . funciones
    (20) rule -> . funciones COLON
    (21) rule -> . SenIF
    (22) rule -> . SenElseIF
    (23) rule -> . SenElse
    (24) rule -> . SenStruct
    (25) rule -> . cStruct
    (26) rule -> . switch_statement
    (27) rule -> . array_declaration COLON
    (28) rule -> . array_declaration
    (29) rule -> . array_var COLON
    (30) rule -> . array_var
    (31) rule -> . array_assignment COLON
    (32) rule -> . array_assignment
    (33) rule -> . slice_declaration COLON
    (34) rule -> . slice_declaration
    (35) rule -> . slice_var COLON
    (36) rule -> . slice_var
    (37) rule -> . slice_assignment COLON
    (38) rule -> . slice_assignment
    (39) rule -> . map_declaration COLON
    (40) rule -> . map_declaration
    (41) rule -> . map_assignment COLON
    (42) rule -> . map_assignment
    (43) rule -> . func_declaration
    (44) rule -> . main_func
    (3) more_rules -> . rule codigo
    (225) retorno -> . ID
    (226) retorno -> . values
    (227) retorno -> . operations
    (228) retorno -> . data_structure
    (232) impresion -> . PRINT LPAREN content RPAREN
    (83) scan_func -> . SCAN LPAREN POINTER RPAREN
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (89) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (90) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (91) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (92) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (114) decVar -> . static
    (115) decVar -> . dynamic
    (111) decConst -> . CONST ID data_type_and_value
    (112) decConst -> . CONST ID EQUAL ID
    (113) decConst -> . CONST ID EQUAL data_structure
    (65) var_asignation -> . ID EQUAL any
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (160) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (161) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (162) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (163) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (164) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (165) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (166) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (167) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (171) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (198) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (203) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (204) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (208) array_var -> . ID LCORCHE index RCORCHE
    (212) array_assignment -> . array_var EQUAL something
    (133) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (134) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (135) slice_declaration -> . VAR ID EQUAL funM
    (136) slice_declaration -> . ID DEQUAL funM
    (137) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (147) slice_assignment -> . slice_var EQUAL something_s
    (213) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (218) map_assignment -> . map_var EQUAL something
    (219) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (220) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE
    (82) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (116) static -> . single
    (117) static -> . multiple
    (127) dynamic -> . ID DEQUAL algo
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN
    (214) map_var -> . ID LCORCHE key RCORCHE
    (122) single -> . VAR ID data_types
    (123) single -> . VAR ID data_types EQUAL funciones
    (124) single -> . VAR ID data_types EQUAL ID
    (125) single -> . VAR ID data_types EQUAL data_structure
    (126) single -> . VAR ID data_type_and_value
    (118) multiple -> . list_var data_types
    (119) list_var -> . VAR ID COMA more

    ID              shift and go to state 426
    PRINT           shift and go to state 30
    SCAN            shift and go to state 31
    FOR             shift and go to state 33
    CONST           shift and go to state 39
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45
    IF              shift and go to state 47
    ELSE            shift and go to state 48
    TYPE            shift and go to state 49
    SWITCH          shift and go to state 50
    VAR             shift and go to state 51
    FUNC            shift and go to state 53
    STRING          shift and go to state 147
    INTEGER         shift and go to state 148
    FLOAT           shift and go to state 149
    TRUE            shift and go to state 150
    FALSE           shift and go to state 151
    NOT             shift and go to state 56

    body                           shift and go to state 427
    codigo                         shift and go to state 428
    return_value                   shift and go to state 429
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    retorno                        shift and go to state 430
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 431
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 432
    logic_operation                shift and go to state 433
    decVar                         shift and go to state 10
    decConst                       shift and go to state 11
    var_asignation                 shift and go to state 12
    funciones                      shift and go to state 13
    SenIF                          shift and go to state 14
    SenElseIF                      shift and go to state 15
    SenElse                        shift and go to state 16
    SenStruct                      shift and go to state 17
    cStruct                        shift and go to state 18
    switch_statement               shift and go to state 19
    array_declaration              shift and go to state 20
    array_var                      shift and go to state 21
    array_assignment               shift and go to state 22
    slice_declaration              shift and go to state 23
    slice_var                      shift and go to state 24
    slice_assignment               shift and go to state 25
    map_declaration                shift and go to state 26
    map_assignment                 shift and go to state 27
    func_declaration               shift and go to state 28
    main_func                      shift and go to state 29
    values                         shift and go to state 434
    operations                     shift and go to state 435
    data_structure                 shift and go to state 436
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    static                         shift and go to state 37
    dynamic                        shift and go to state 38
    call_func                      shift and go to state 46
    map_var                        shift and go to state 52
    single                         shift and go to state 57
    multiple                       shift and go to state 58
    list_var                       shift and go to state 59

state 417

    (92) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    CONST           reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    ID              reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    IF              reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    $end            reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    STRING          reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    TRUE            reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FALSE           reduce using rule 92 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)


state 418

    (173) asignaciones -> ID POINTS valor COMA asignaciones .

    RLLAVE          reduce using rule 173 (asignaciones -> ID POINTS valor COMA asignaciones .)


state 419

    (73) more_items -> items . COMA more_items
    (74) more_items -> items .

    COMA            shift and go to state 437
    RLLAVE          reduce using rule 74 (more_items -> items .)


state 420

    (71) arr_content -> LLLAVE items COMA more_items . RLLAVE

    RLLAVE          shift and go to state 438


state 421

    (138) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . RPAREN
    (139) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . COMA cap RPAREN

    RPAREN          shift and go to state 440
    COMA            shift and go to state 439


state 422

    (140) cap -> INTEGER .
    (243) something_ex -> INTEGER .

  ! reduce/reduce conflict for RPAREN resolved using rule 140 (cap -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 140 (cap -> INTEGER .)
    RPAREN          reduce using rule 140 (cap -> INTEGER .)
    COMA            reduce using rule 140 (cap -> INTEGER .)
    GREATER         reduce using rule 243 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 243 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 243 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 243 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 243 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 243 (something_ex -> INTEGER .)
    PLUS            reduce using rule 243 (something_ex -> INTEGER .)
    TIMES           reduce using rule 243 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 243 (something_ex -> INTEGER .)
    MINUS           reduce using rule 243 (something_ex -> INTEGER .)
    MOD             reduce using rule 243 (something_ex -> INTEGER .)

  ! RPAREN          [ reduce using rule 243 (something_ex -> INTEGER .) ]
  ! COMA            [ reduce using rule 243 (something_ex -> INTEGER .) ]


state 423

    (141) cap -> ID .
    (242) something_ex -> ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for RPAREN resolved using rule 141 (cap -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 141 (cap -> ID .)
    RPAREN          reduce using rule 141 (cap -> ID .)
    COMA            reduce using rule 141 (cap -> ID .)
    GREATER         reduce using rule 242 (something_ex -> ID .)
    SMALLER         reduce using rule 242 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 242 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 242 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 242 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 242 (something_ex -> ID .)
    PLUS            reduce using rule 242 (something_ex -> ID .)
    TIMES           reduce using rule 242 (something_ex -> ID .)
    DIVIDE          reduce using rule 242 (something_ex -> ID .)
    MINUS           reduce using rule 242 (something_ex -> ID .)
    MOD             reduce using rule 242 (something_ex -> ID .)
    LCORCHE         shift and go to state 174
    LPAREN          shift and go to state 112

  ! RPAREN          [ reduce using rule 242 (something_ex -> ID .) ]
  ! COMA            [ reduce using rule 242 (something_ex -> ID .) ]


state 424

    (142) cap -> expression .

    RPAREN          reduce using rule 142 (cap -> expression .)
    COMA            reduce using rule 142 (cap -> expression .)


state 425

    (219) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN . retorno RLLAVE
    (225) retorno -> . ID
    (226) retorno -> . values
    (227) retorno -> . operations
    (228) retorno -> . data_structure
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 441
    STRING          shift and go to state 147
    INTEGER         shift and go to state 148
    FLOAT           shift and go to state 149
    TRUE            shift and go to state 150
    FALSE           shift and go to state 151
    NOT             shift and go to state 56
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    retorno                        shift and go to state 442
    values                         shift and go to state 434
    operations                     shift and go to state 435
    data_structure                 shift and go to state 436
    expression                     shift and go to state 152
    comparison                     shift and go to state 153
    logic_operation                shift and go to state 154
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    funciones                      shift and go to state 99
    call_func                      shift and go to state 46

state 426

    (225) retorno -> ID .
    (65) var_asignation -> ID . EQUAL any
    (171) cStruct -> ID . DEQUAL ID LLLAVE asignaciones RLLAVE
    (208) array_var -> ID . LCORCHE index RCORCHE
    (136) slice_declaration -> ID . DEQUAL funM
    (137) slice_declaration -> ID . DEQUAL LCORCHE RCORCHE data_types arr_content
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (242) something_ex -> ID .
    (179) value -> ID .
    (193) logic_value -> ID .
    (127) dynamic -> ID . DEQUAL algo
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN
    (214) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for COLON resolved using rule 225 (retorno -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 225 (retorno -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 179 (value -> ID .)
    COLON           reduce using rule 225 (retorno -> ID .)
    RLLAVE          reduce using rule 225 (retorno -> ID .)
    EQUAL           shift and go to state 109
    DEQUAL          shift and go to state 110
    LCORCHE         shift and go to state 111
    PRINT           reduce using rule 242 (something_ex -> ID .)
    SCAN            reduce using rule 242 (something_ex -> ID .)
    FOR             reduce using rule 242 (something_ex -> ID .)
    CONST           reduce using rule 242 (something_ex -> ID .)
    ID              reduce using rule 242 (something_ex -> ID .)
    APPEND          reduce using rule 242 (something_ex -> ID .)
    LEN             reduce using rule 242 (something_ex -> ID .)
    COPY            reduce using rule 242 (something_ex -> ID .)
    DELETE          reduce using rule 242 (something_ex -> ID .)
    IF              reduce using rule 242 (something_ex -> ID .)
    ELSE            reduce using rule 242 (something_ex -> ID .)
    TYPE            reduce using rule 242 (something_ex -> ID .)
    SWITCH          reduce using rule 242 (something_ex -> ID .)
    VAR             reduce using rule 242 (something_ex -> ID .)
    FUNC            reduce using rule 242 (something_ex -> ID .)
    INTEGER         reduce using rule 242 (something_ex -> ID .)
    FLOAT           reduce using rule 242 (something_ex -> ID .)
    NOT             reduce using rule 242 (something_ex -> ID .)
    STRING          reduce using rule 242 (something_ex -> ID .)
    TRUE            reduce using rule 242 (something_ex -> ID .)
    FALSE           reduce using rule 242 (something_ex -> ID .)
    GREATER         reduce using rule 179 (value -> ID .)
    SMALLER         reduce using rule 179 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 179 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 179 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 179 (value -> ID .)
    NOT_EQUAL       reduce using rule 179 (value -> ID .)
    PLUS            reduce using rule 179 (value -> ID .)
    TIMES           reduce using rule 179 (value -> ID .)
    DIVIDE          reduce using rule 179 (value -> ID .)
    MINUS           reduce using rule 179 (value -> ID .)
    MOD             reduce using rule 179 (value -> ID .)
    AND             reduce using rule 193 (logic_value -> ID .)
    OR              reduce using rule 193 (logic_value -> ID .)
    LPAREN          shift and go to state 112

  ! GREATER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 242 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 242 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 242 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 242 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 242 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 242 (something_ex -> ID .) ]


state 427

    (220) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body . RLLAVE

    RLLAVE          shift and go to state 443


state 428

    (221) body -> codigo . return_value
    (223) return_value -> . retorno COLON
    (224) return_value -> . retorno
    (225) retorno -> . ID
    (226) retorno -> . values
    (227) retorno -> . operations
    (228) retorno -> . data_structure
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 441
    STRING          shift and go to state 147
    INTEGER         shift and go to state 148
    FLOAT           shift and go to state 149
    TRUE            shift and go to state 150
    FALSE           shift and go to state 151
    NOT             shift and go to state 56
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    return_value                   shift and go to state 444
    retorno                        shift and go to state 430
    values                         shift and go to state 434
    operations                     shift and go to state 435
    data_structure                 shift and go to state 436
    expression                     shift and go to state 152
    comparison                     shift and go to state 153
    logic_operation                shift and go to state 154
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    funciones                      shift and go to state 99
    call_func                      shift and go to state 46

state 429

    (222) body -> return_value .

    RLLAVE          reduce using rule 222 (body -> return_value .)


state 430

    (223) return_value -> retorno . COLON
    (224) return_value -> retorno .

    COLON           shift and go to state 445
    RLLAVE          reduce using rule 224 (return_value -> retorno .)


state 431

    (8) rule -> expression . COLON
    (9) rule -> expression .
    (59) operations -> expression .
    (180) value -> expression .

  ! shift/reduce conflict for COLON resolved as shift
    COLON           shift and go to state 63
    PRINT           reduce using rule 9 (rule -> expression .)
    SCAN            reduce using rule 9 (rule -> expression .)
    FOR             reduce using rule 9 (rule -> expression .)
    CONST           reduce using rule 9 (rule -> expression .)
    ID              reduce using rule 9 (rule -> expression .)
    APPEND          reduce using rule 9 (rule -> expression .)
    LEN             reduce using rule 9 (rule -> expression .)
    COPY            reduce using rule 9 (rule -> expression .)
    DELETE          reduce using rule 9 (rule -> expression .)
    IF              reduce using rule 9 (rule -> expression .)
    ELSE            reduce using rule 9 (rule -> expression .)
    TYPE            reduce using rule 9 (rule -> expression .)
    SWITCH          reduce using rule 9 (rule -> expression .)
    VAR             reduce using rule 9 (rule -> expression .)
    FUNC            reduce using rule 9 (rule -> expression .)
    INTEGER         reduce using rule 9 (rule -> expression .)
    FLOAT           reduce using rule 9 (rule -> expression .)
    NOT             reduce using rule 9 (rule -> expression .)
    STRING          reduce using rule 9 (rule -> expression .)
    TRUE            reduce using rule 9 (rule -> expression .)
    FALSE           reduce using rule 9 (rule -> expression .)
    RLLAVE          reduce using rule 59 (operations -> expression .)
    GREATER         reduce using rule 180 (value -> expression .)
    SMALLER         reduce using rule 180 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 180 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 180 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 180 (value -> expression .)
    NOT_EQUAL       reduce using rule 180 (value -> expression .)
    PLUS            reduce using rule 180 (value -> expression .)
    TIMES           reduce using rule 180 (value -> expression .)
    DIVIDE          reduce using rule 180 (value -> expression .)
    MINUS           reduce using rule 180 (value -> expression .)
    MOD             reduce using rule 180 (value -> expression .)

  ! COLON           [ reduce using rule 59 (operations -> expression .) ]


state 432

    (11) rule -> comparison .
    (60) operations -> comparison .
    (192) logic_value -> comparison .

    PRINT           reduce using rule 11 (rule -> comparison .)
    SCAN            reduce using rule 11 (rule -> comparison .)
    FOR             reduce using rule 11 (rule -> comparison .)
    CONST           reduce using rule 11 (rule -> comparison .)
    ID              reduce using rule 11 (rule -> comparison .)
    APPEND          reduce using rule 11 (rule -> comparison .)
    LEN             reduce using rule 11 (rule -> comparison .)
    COPY            reduce using rule 11 (rule -> comparison .)
    DELETE          reduce using rule 11 (rule -> comparison .)
    IF              reduce using rule 11 (rule -> comparison .)
    ELSE            reduce using rule 11 (rule -> comparison .)
    TYPE            reduce using rule 11 (rule -> comparison .)
    SWITCH          reduce using rule 11 (rule -> comparison .)
    VAR             reduce using rule 11 (rule -> comparison .)
    FUNC            reduce using rule 11 (rule -> comparison .)
    INTEGER         reduce using rule 11 (rule -> comparison .)
    FLOAT           reduce using rule 11 (rule -> comparison .)
    NOT             reduce using rule 11 (rule -> comparison .)
    STRING          reduce using rule 11 (rule -> comparison .)
    TRUE            reduce using rule 11 (rule -> comparison .)
    FALSE           reduce using rule 11 (rule -> comparison .)
    COLON           reduce using rule 60 (operations -> comparison .)
    RLLAVE          reduce using rule 60 (operations -> comparison .)
    AND             reduce using rule 192 (logic_value -> comparison .)
    OR              reduce using rule 192 (logic_value -> comparison .)


state 433

    (12) rule -> logic_operation .
    (61) operations -> logic_operation .

    PRINT           reduce using rule 12 (rule -> logic_operation .)
    SCAN            reduce using rule 12 (rule -> logic_operation .)
    FOR             reduce using rule 12 (rule -> logic_operation .)
    CONST           reduce using rule 12 (rule -> logic_operation .)
    ID              reduce using rule 12 (rule -> logic_operation .)
    APPEND          reduce using rule 12 (rule -> logic_operation .)
    LEN             reduce using rule 12 (rule -> logic_operation .)
    COPY            reduce using rule 12 (rule -> logic_operation .)
    DELETE          reduce using rule 12 (rule -> logic_operation .)
    IF              reduce using rule 12 (rule -> logic_operation .)
    ELSE            reduce using rule 12 (rule -> logic_operation .)
    TYPE            reduce using rule 12 (rule -> logic_operation .)
    SWITCH          reduce using rule 12 (rule -> logic_operation .)
    VAR             reduce using rule 12 (rule -> logic_operation .)
    FUNC            reduce using rule 12 (rule -> logic_operation .)
    INTEGER         reduce using rule 12 (rule -> logic_operation .)
    FLOAT           reduce using rule 12 (rule -> logic_operation .)
    NOT             reduce using rule 12 (rule -> logic_operation .)
    STRING          reduce using rule 12 (rule -> logic_operation .)
    TRUE            reduce using rule 12 (rule -> logic_operation .)
    FALSE           reduce using rule 12 (rule -> logic_operation .)
    COLON           reduce using rule 61 (operations -> logic_operation .)
    RLLAVE          reduce using rule 61 (operations -> logic_operation .)


state 434

    (226) retorno -> values .

    COLON           reduce using rule 226 (retorno -> values .)
    RLLAVE          reduce using rule 226 (retorno -> values .)


state 435

    (227) retorno -> operations .

    COLON           reduce using rule 227 (retorno -> operations .)
    RLLAVE          reduce using rule 227 (retorno -> operations .)


state 436

    (228) retorno -> data_structure .
    (245) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 228 (retorno -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 228 (retorno -> data_structure .)
    COLON           reduce using rule 228 (retorno -> data_structure .)
    RLLAVE          reduce using rule 228 (retorno -> data_structure .)
    GREATER         reduce using rule 245 (something_ex -> data_structure .)
    SMALLER         reduce using rule 245 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 245 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 245 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 245 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 245 (something_ex -> data_structure .)
    PLUS            reduce using rule 245 (something_ex -> data_structure .)
    TIMES           reduce using rule 245 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 245 (something_ex -> data_structure .)
    MINUS           reduce using rule 245 (something_ex -> data_structure .)
    MOD             reduce using rule 245 (something_ex -> data_structure .)
    PRINT           reduce using rule 245 (something_ex -> data_structure .)
    SCAN            reduce using rule 245 (something_ex -> data_structure .)
    FOR             reduce using rule 245 (something_ex -> data_structure .)
    CONST           reduce using rule 245 (something_ex -> data_structure .)
    ID              reduce using rule 245 (something_ex -> data_structure .)
    APPEND          reduce using rule 245 (something_ex -> data_structure .)
    LEN             reduce using rule 245 (something_ex -> data_structure .)
    COPY            reduce using rule 245 (something_ex -> data_structure .)
    DELETE          reduce using rule 245 (something_ex -> data_structure .)
    IF              reduce using rule 245 (something_ex -> data_structure .)
    ELSE            reduce using rule 245 (something_ex -> data_structure .)
    TYPE            reduce using rule 245 (something_ex -> data_structure .)
    SWITCH          reduce using rule 245 (something_ex -> data_structure .)
    VAR             reduce using rule 245 (something_ex -> data_structure .)
    FUNC            reduce using rule 245 (something_ex -> data_structure .)
    INTEGER         reduce using rule 245 (something_ex -> data_structure .)
    FLOAT           reduce using rule 245 (something_ex -> data_structure .)
    NOT             reduce using rule 245 (something_ex -> data_structure .)
    STRING          reduce using rule 245 (something_ex -> data_structure .)
    TRUE            reduce using rule 245 (something_ex -> data_structure .)
    FALSE           reduce using rule 245 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 245 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 245 (something_ex -> data_structure .) ]


state 437

    (73) more_items -> items COMA . more_items
    (73) more_items -> . items COMA more_items
    (74) more_items -> . items
    (75) items -> . values
    (76) items -> . operations
    (45) values -> . STRING
    (46) values -> . INTEGER
    (47) values -> . FLOAT
    (48) values -> . TRUE
    (49) values -> . FALSE
    (59) operations -> . expression
    (60) operations -> . comparison
    (61) operations -> . logic_operation
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (178) comparison -> . value op value
    (187) logic_operation -> . logic_value logic_recu
    (188) logic_operation -> . negation
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (179) value -> . ID
    (180) value -> . expression
    (191) logic_value -> . negation
    (192) logic_value -> . comparison
    (193) logic_value -> . ID
    (194) negation -> . NOT comparison
    (195) negation -> . NOT ID
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    STRING          shift and go to state 147
    INTEGER         shift and go to state 148
    FLOAT           shift and go to state 149
    TRUE            shift and go to state 150
    FALSE           shift and go to state 151
    ID              shift and go to state 399
    NOT             shift and go to state 56
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    items                          shift and go to state 419
    more_items                     shift and go to state 446
    values                         shift and go to state 397
    operations                     shift and go to state 398
    expression                     shift and go to state 152
    comparison                     shift and go to state 153
    logic_operation                shift and go to state 154
    something_ex                   shift and go to state 32
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 438

    (71) arr_content -> LLLAVE items COMA more_items RLLAVE .

    COLON           reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    PRINT           reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    SCAN            reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FOR             reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    CONST           reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    ID              reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    APPEND          reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    LEN             reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    COPY            reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    DELETE          reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    IF              reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    ELSE            reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    TYPE            reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    SWITCH          reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    VAR             reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FUNC            reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    INTEGER         reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FLOAT           reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    NOT             reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    $end            reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RLLAVE          reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    INT32           reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    INT64           reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FLOAT32         reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FLOAT64         reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    BYTE            reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    WFLOAT          reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    WSTRING         reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    WINT            reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    BOOL            reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    DEFAULT         reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    CASE            reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RETURN          reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    STRING          reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    TRUE            reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FALSE           reduce using rule 71 (arr_content -> LLLAVE items COMA more_items RLLAVE .)


state 439

    (139) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA . cap RPAREN
    (140) cap -> . INTEGER
    (141) cap -> . ID
    (142) cap -> . expression
    (238) expression -> . something_ex
    (239) expression -> . something_ex adicionaEx
    (242) something_ex -> . ID
    (243) something_ex -> . INTEGER
    (244) something_ex -> . FLOAT
    (245) something_ex -> . data_structure
    (246) something_ex -> . funciones
    (62) data_structure -> . array_var
    (63) data_structure -> . map_var
    (64) data_structure -> . slice_var
    (152) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (153) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (154) funciones -> . LEN LPAREN ID RPAREN
    (155) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (156) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (157) funciones -> . call_func
    (208) array_var -> . ID LCORCHE index RCORCHE
    (214) map_var -> . ID LCORCHE key RCORCHE
    (143) slice_var -> . ID LCORCHE index_s RCORCHE
    (84) call_func -> . ID LPAREN list_params RPAREN
    (85) call_func -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 422
    ID              shift and go to state 423
    FLOAT           shift and go to state 55
    APPEND          shift and go to state 42
    LEN             shift and go to state 43
    COPY            shift and go to state 44
    DELETE          shift and go to state 45

    cap                            shift and go to state 447
    expression                     shift and go to state 424
    something_ex                   shift and go to state 32
    data_structure                 shift and go to state 41
    funciones                      shift and go to state 99
    array_var                      shift and go to state 100
    map_var                        shift and go to state 101
    slice_var                      shift and go to state 102
    call_func                      shift and go to state 46

state 440

    (138) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .

    COLON           reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    PRINT           reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    SCAN            reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FOR             reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    CONST           reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    ID              reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    APPEND          reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    LEN             reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    COPY            reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    DELETE          reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    IF              reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    ELSE            reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    TYPE            reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    SWITCH          reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    VAR             reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FUNC            reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    INTEGER         reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FLOAT           reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    NOT             reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    $end            reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RLLAVE          reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    INT32           reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    INT64           reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FLOAT32         reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FLOAT64         reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    BYTE            reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    WFLOAT          reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    WSTRING         reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    WINT            reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    BOOL            reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    DEFAULT         reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    CASE            reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RETURN          reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    STRING          reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    TRUE            reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FALSE           reduce using rule 138 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)


state 441

    (225) retorno -> ID .
    (208) array_var -> ID . LCORCHE index RCORCHE
    (214) map_var -> ID . LCORCHE key RCORCHE
    (143) slice_var -> ID . LCORCHE index_s RCORCHE
    (242) something_ex -> ID .
    (179) value -> ID .
    (193) logic_value -> ID .
    (84) call_func -> ID . LPAREN list_params RPAREN
    (85) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for RLLAVE resolved using rule 225 (retorno -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 225 (retorno -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 179 (value -> ID .)
  ! reduce/reduce conflict for MOD resolved using rule 179 (value -> ID .)
    RLLAVE          reduce using rule 225 (retorno -> ID .)
    COLON           reduce using rule 225 (retorno -> ID .)
    LCORCHE         shift and go to state 174
    GREATER         reduce using rule 179 (value -> ID .)
    SMALLER         reduce using rule 179 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 179 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 179 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 179 (value -> ID .)
    NOT_EQUAL       reduce using rule 179 (value -> ID .)
    PLUS            reduce using rule 179 (value -> ID .)
    TIMES           reduce using rule 179 (value -> ID .)
    DIVIDE          reduce using rule 179 (value -> ID .)
    MINUS           reduce using rule 179 (value -> ID .)
    MOD             reduce using rule 179 (value -> ID .)
    AND             reduce using rule 193 (logic_value -> ID .)
    OR              reduce using rule 193 (logic_value -> ID .)
    LPAREN          shift and go to state 112

  ! GREATER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 242 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 242 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 242 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 242 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 242 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 242 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 242 (something_ex -> ID .) ]
  ! MOD             [ reduce using rule 242 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 242 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 242 (something_ex -> ID .) ]


state 442

    (219) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno . RLLAVE

    RLLAVE          shift and go to state 448


state 443

    (220) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .

    PRINT           reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    SCAN            reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    FOR             reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    CONST           reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    ID              reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    APPEND          reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    LEN             reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    COPY            reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    DELETE          reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    IF              reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    ELSE            reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    TYPE            reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    SWITCH          reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    VAR             reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    FUNC            reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    INTEGER         reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    FLOAT           reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    NOT             reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    $end            reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    RLLAVE          reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    INT32           reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    INT64           reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    FLOAT32         reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    FLOAT64         reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    BYTE            reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    WFLOAT          reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    WSTRING         reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    WINT            reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    BOOL            reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    DEFAULT         reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    CASE            reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    RETURN          reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    STRING          reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    TRUE            reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)
    FALSE           reduce using rule 220 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN body RLLAVE .)


state 444

    (221) body -> codigo return_value .

    RLLAVE          reduce using rule 221 (body -> codigo return_value .)


state 445

    (223) return_value -> retorno COLON .

    RLLAVE          reduce using rule 223 (return_value -> retorno COLON .)


state 446

    (73) more_items -> items COMA more_items .

    RLLAVE          reduce using rule 73 (more_items -> items COMA more_items .)


state 447

    (139) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap . RPAREN

    RPAREN          shift and go to state 449


state 448

    (219) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .

    PRINT           reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    SCAN            reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FOR             reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    CONST           reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    ID              reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    APPEND          reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    LEN             reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    COPY            reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    DELETE          reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    IF              reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    ELSE            reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    TYPE            reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    SWITCH          reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    VAR             reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FUNC            reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    INTEGER         reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FLOAT           reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    NOT             reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    $end            reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    RLLAVE          reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    INT32           reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    INT64           reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FLOAT32         reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FLOAT64         reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    BYTE            reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    WFLOAT          reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    WSTRING         reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    WINT            reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    BOOL            reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    DEFAULT         reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    CASE            reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    RETURN          reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    STRING          reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    TRUE            reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FALSE           reduce using rule 219 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)


state 449

    (139) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .

    COLON           reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    PRINT           reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    SCAN            reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FOR             reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    CONST           reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    ID              reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    APPEND          reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    LEN             reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    COPY            reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    DELETE          reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    IF              reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    ELSE            reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    TYPE            reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    SWITCH          reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    VAR             reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FUNC            reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    INTEGER         reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FLOAT           reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    NOT             reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    $end            reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RLLAVE          reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    INT32           reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    INT64           reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FLOAT32         reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FLOAT64         reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    BYTE            reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    WFLOAT          reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    WSTRING         reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    WINT            reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    BOOL            reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    DEFAULT         reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    CASE            reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RETURN          reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    STRING          reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    TRUE            reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FALSE           reduce using rule 139 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 2 resolved as shift
WARNING: shift/reduce conflict for APPEND in state 2 resolved as shift
WARNING: shift/reduce conflict for LEN in state 2 resolved as shift
WARNING: shift/reduce conflict for COPY in state 2 resolved as shift
WARNING: shift/reduce conflict for DELETE in state 2 resolved as shift
WARNING: shift/reduce conflict for INTEGER in state 2 resolved as shift
WARNING: shift/reduce conflict for FLOAT in state 2 resolved as shift
WARNING: shift/reduce conflict for NOT in state 2 resolved as shift
WARNING: shift/reduce conflict for COLON in state 13 resolved as shift
WARNING: shift/reduce conflict for COLON in state 21 resolved as shift
WARNING: shift/reduce conflict for COLON in state 24 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 32 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 32 resolved as shift
WARNING: shift/reduce conflict for GREATER_OR_EQUAL in state 32 resolved as shift
WARNING: shift/reduce conflict for SMALLER_OR_EQUAL in state 32 resolved as shift
WARNING: shift/reduce conflict for EQUAL_COMPARE in state 32 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 32 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 32 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 32 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 32 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 32 resolved as shift
WARNING: shift/reduce conflict for MOD in state 32 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 167 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 167 resolved as shift
WARNING: shift/reduce conflict for GREATER_OR_EQUAL in state 167 resolved as shift
WARNING: shift/reduce conflict for SMALLER_OR_EQUAL in state 167 resolved as shift
WARNING: shift/reduce conflict for EQUAL_COMPARE in state 167 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 167 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 167 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 167 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 167 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 167 resolved as shift
WARNING: shift/reduce conflict for MOD in state 167 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 234 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 235 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 236 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 237 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 238 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 239 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 240 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 241 resolved as shift
WARNING: shift/reduce conflict for COLON in state 431 resolved as shift
WARNING: reduce/reduce conflict in state 13 resolved using rule (rule -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 13
WARNING: reduce/reduce conflict in state 21 resolved using rule (rule -> array_var)
WARNING: rejected rule (data_structure -> array_var) in state 21
WARNING: reduce/reduce conflict in state 24 resolved using rule (rule -> slice_var)
WARNING: rejected rule (data_structure -> slice_var) in state 24
WARNING: reduce/reduce conflict in state 40 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 40
WARNING: reduce/reduce conflict in state 97 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 97
WARNING: reduce/reduce conflict in state 120 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 120
WARNING: reduce/reduce conflict in state 130 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 130
WARNING: reduce/reduce conflict in state 142 resolved using rule (something -> ID)
WARNING: rejected rule (something_ex -> ID) in state 142
WARNING: reduce/reduce conflict in state 142 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 142
WARNING: reduce/reduce conflict in state 143 resolved using rule (something -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 143
WARNING: reduce/reduce conflict in state 146 resolved using rule (something -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 146
WARNING: reduce/reduce conflict in state 148 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 148
WARNING: reduce/reduce conflict in state 149 resolved using rule (values -> FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 149
WARNING: reduce/reduce conflict in state 156 resolved using rule (something_s -> ID)
WARNING: rejected rule (something_ex -> ID) in state 156
WARNING: reduce/reduce conflict in state 156 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 156
WARNING: reduce/reduce conflict in state 157 resolved using rule (data_structure -> array_var)
WARNING: rejected rule (something_s -> array_var) in state 157
WARNING: reduce/reduce conflict in state 163 resolved using rule (content -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 163
WARNING: reduce/reduce conflict in state 164 resolved using rule (content -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 164
WARNING: reduce/reduce conflict in state 165 resolved using rule (content -> ID)
WARNING: rejected rule (something_ex -> ID) in state 165
WARNING: reduce/reduce conflict in state 165 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 165
WARNING: reduce/reduce conflict in state 179 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 179
WARNING: reduce/reduce conflict in state 190 resolved using rule (any -> ID)
WARNING: rejected rule (something_ex -> ID) in state 190
WARNING: reduce/reduce conflict in state 190 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 190
WARNING: reduce/reduce conflict in state 194 resolved using rule (any -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 194
WARNING: reduce/reduce conflict in state 195 resolved using rule (any -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 195
WARNING: reduce/reduce conflict in state 196 resolved using rule (algo -> ID)
WARNING: rejected rule (something_ex -> ID) in state 196
WARNING: reduce/reduce conflict in state 196 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 196
WARNING: reduce/reduce conflict in state 203 resolved using rule (algo -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 203
WARNING: reduce/reduce conflict in state 204 resolved using rule (algo -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 204
WARNING: reduce/reduce conflict in state 205 resolved using rule (index_s -> ID)
WARNING: rejected rule (index -> ID) in state 205
WARNING: reduce/reduce conflict in state 205 resolved using rule (index_s -> ID)
WARNING: rejected rule (key -> ID) in state 205
WARNING: reduce/reduce conflict in state 205 resolved using rule (index_s -> ID)
WARNING: rejected rule (something_ex -> ID) in state 205
WARNING: reduce/reduce conflict in state 205 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 205
WARNING: reduce/reduce conflict in state 209 resolved using rule (index_s -> INTEGER)
WARNING: rejected rule (index -> INTEGER) in state 209
WARNING: reduce/reduce conflict in state 209 resolved using rule (values -> INTEGER)
WARNING: rejected rule (index_s -> INTEGER) in state 209
WARNING: reduce/reduce conflict in state 209 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 209
WARNING: reduce/reduce conflict in state 210 resolved using rule (index_s -> expression)
WARNING: rejected rule (index -> expression) in state 210
WARNING: reduce/reduce conflict in state 210 resolved using rule (operations -> expression)
WARNING: rejected rule (index_s -> expression) in state 210
WARNING: reduce/reduce conflict in state 254 resolved using rule (index -> ID)
WARNING: rejected rule (key -> ID) in state 254
WARNING: reduce/reduce conflict in state 254 resolved using rule (index_s -> ID)
WARNING: rejected rule (index -> ID) in state 254
WARNING: reduce/reduce conflict in state 254 resolved using rule (index_s -> ID)
WARNING: rejected rule (something_ex -> ID) in state 254
WARNING: reduce/reduce conflict in state 254 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 254
WARNING: reduce/reduce conflict in state 288 resolved using rule (capacity -> ID)
WARNING: rejected rule (something_ex -> ID) in state 288
WARNING: reduce/reduce conflict in state 292 resolved using rule (capacity -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 292
WARNING: reduce/reduce conflict in state 310 resolved using rule (int_value -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 310
WARNING: reduce/reduce conflict in state 315 resolved using rule (float_value -> FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 315
WARNING: reduce/reduce conflict in state 324 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 324
WARNING: reduce/reduce conflict in state 399 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 399
WARNING: reduce/reduce conflict in state 422 resolved using rule (cap -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 422
WARNING: reduce/reduce conflict in state 423 resolved using rule (cap -> ID)
WARNING: rejected rule (something_ex -> ID) in state 423
WARNING: reduce/reduce conflict in state 426 resolved using rule (retorno -> ID)
WARNING: rejected rule (something_ex -> ID) in state 426
WARNING: reduce/reduce conflict in state 426 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 426
WARNING: reduce/reduce conflict in state 436 resolved using rule (retorno -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 436
WARNING: reduce/reduce conflict in state 441 resolved using rule (retorno -> ID)
WARNING: rejected rule (something_ex -> ID) in state 441
WARNING: reduce/reduce conflict in state 441 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 441
WARNING: Rule (something_s -> array_var) is never reduced
WARNING: Rule (index -> ID) is never reduced
WARNING: Rule (key -> ID) is never reduced
WARNING: Rule (index -> INTEGER) is never reduced
WARNING: Rule (index_s -> INTEGER) is never reduced
WARNING: Rule (index -> expression) is never reduced
WARNING: Rule (index_s -> expression) is never reduced
