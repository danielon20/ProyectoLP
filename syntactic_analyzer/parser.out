Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    CAP
    COMMENT
    CONST
    INTERFACE
    JOIN
    MAP
    MOD
    MULTI_COMMENT
    PACKAGE

Grammar

Rule 0     S' -> codigo
Rule 1     codigo -> rule
Rule 2     codigo -> more_rules
Rule 3     more_rules -> rule codigo
Rule 4     rule -> impresion COLON
Rule 5     rule -> impresion
Rule 6     rule -> scan_func COLON
Rule 7     rule -> scan_func
Rule 8     rule -> expression COLON
Rule 9     rule -> expression
Rule 10    rule -> cicloFor
Rule 11    rule -> comparison
Rule 12    rule -> logic_operation
Rule 13    rule -> decVar COLON
Rule 14    rule -> decVar
Rule 15    rule -> var_asignation
Rule 16    rule -> var_asignation COLON
Rule 17    rule -> funciones
Rule 18    rule -> funciones COLON
Rule 19    rule -> SenIF
Rule 20    rule -> SenElseIF
Rule 21    rule -> SenElse
Rule 22    rule -> SenStruct
Rule 23    rule -> cStruct
Rule 24    rule -> switch_statement
Rule 25    rule -> array_declaration COLON
Rule 26    rule -> array_declaration
Rule 27    rule -> array_var COLON
Rule 28    rule -> array_var
Rule 29    rule -> array_assignment COLON
Rule 30    rule -> array_assignment
Rule 31    rule -> slice_declaration COLON
Rule 32    rule -> slice_declaration
Rule 33    rule -> slice_var COLON
Rule 34    rule -> slice_var
Rule 35    rule -> slice_assignment COLON
Rule 36    rule -> slice_assignment
Rule 37    rule -> map_declaration COLON
Rule 38    rule -> map_declaration
Rule 39    rule -> map_assignment COLON
Rule 40    rule -> map_assignment
Rule 41    rule -> func_declaration
Rule 42    rule -> main_func
Rule 43    values -> STRING
Rule 44    values -> INTEGER
Rule 45    values -> FLOAT
Rule 46    values -> TRUE
Rule 47    values -> FALSE
Rule 48    data_types -> INT32
Rule 49    data_types -> INT64
Rule 50    data_types -> FLOAT32
Rule 51    data_types -> FLOAT64
Rule 52    data_types -> BYTE
Rule 53    data_types -> WINT
Rule 54    data_types -> WFLOAT
Rule 55    data_types -> WSTRING
Rule 56    data_types -> BOOL
Rule 57    operations -> expression
Rule 58    operations -> comparison
Rule 59    operations -> logic_operation
Rule 60    data_structure -> array_var
Rule 61    data_structure -> map_var
Rule 62    var_asignation -> ID EQUAL any
Rule 63    any -> values
Rule 64    any -> operations
Rule 65    any -> ID
Rule 66    any -> data_structure
Rule 67    any -> funciones
Rule 68    arr_content -> LLLAVE items COMA more_items RLLAVE
Rule 69    arr_content -> LLLAVE items RLLAVE
Rule 70    more_items -> items COMA more_items
Rule 71    more_items -> items
Rule 72    items -> values
Rule 73    items -> operations
Rule 74    something -> ID
Rule 75    something -> data_structure
Rule 76    something -> values
Rule 77    something -> operations
Rule 78    main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
Rule 79    scan_func -> SCAN LPAREN POINTER RPAREN
Rule 80    cicloFor -> FOR LLLAVE codigo RLLAVE
Rule 81    cicloFor -> FOR comparison LLLAVE codigo RLLAVE
Rule 82    cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE
Rule 83    cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
Rule 84    incre -> ID INCREASE
Rule 85    incre -> ID DECREASE
Rule 86    decVar -> decVarOne
Rule 87    decVar -> VAR ID EQUAL INTEGER
Rule 88    decVar -> VAR ID EQUAL ID
Rule 89    decVar -> VAR ID EQUAL FLOAT
Rule 90    decVar -> VAR ID EQUAL expression
Rule 91    decVar -> VAR ID EQUAL logic_operation
Rule 92    decVar -> VAR ID EQUAL comparison
Rule 93    decVar -> VAR ID EQUAL STRING
Rule 94    decVar -> ID DEQUAL STRING
Rule 95    decVar -> ID DEQUAL FLOAT
Rule 96    decVar -> ID DEQUAL expression
Rule 97    decVar -> ID DEQUAL logic_operation
Rule 98    decVar -> ID DEQUAL comparison
Rule 99    slice_declaration -> VAR ID LCORCHE RCORCHE data_types
Rule 100   slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
Rule 101   slice_declaration -> VAR ID EQUAL funM
Rule 102   slice_declaration -> ID DEQUAL funM
Rule 103   slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content
Rule 104   funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
Rule 105   funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
Rule 106   cap -> INTEGER
Rule 107   cap -> ID
Rule 108   cap -> expression
Rule 109   slice_var -> ID LCORCHE index_s RCORCHE
Rule 110   index_s -> ID
Rule 111   index_s -> INTEGER
Rule 112   index_s -> expression
Rule 113   slice_assignment -> slice_var EQUAL something_s
Rule 114   something_s -> ID
Rule 115   something_s -> array_var
Rule 116   something_s -> values
Rule 117   something_s -> operations
Rule 118   funciones -> APPEND LPAREN ID COMA values RPAREN
Rule 119   funciones -> APPEND LPAREN ID COMA ID RPAREN
Rule 120   funciones -> LEN LPAREN ID RPAREN
Rule 121   funciones -> COPY LPAREN ID COMA ID RPAREN
Rule 122   funciones -> DELETE LPAREN ID COMA ID RPAREN
Rule 123   decVarOne -> ID DEQUAL ID
Rule 124   decVarOne -> ID DEQUAL INTEGER
Rule 125   SenIF -> IF comparison LLLAVE codigo RLLAVE
Rule 126   SenIF -> IF TRUE LLLAVE codigo RLLAVE
Rule 127   SenIF -> IF FALSE LLLAVE codigo RLLAVE
Rule 128   SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE
Rule 129   SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE
Rule 130   SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE
Rule 131   SenElse -> ELSE LLLAVE codigo RLLAVE
Rule 132   SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE
Rule 133   declaration -> variable data_types
Rule 134   declaration -> declaration variable data_types
Rule 135   variable -> ID
Rule 136   cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE
Rule 137   asignaciones -> ID POINTS valor
Rule 138   asignaciones -> ID POINTS valor COMA asignaciones
Rule 139   valor -> ID
Rule 140   valor -> INTEGER
Rule 141   valor -> TRUE
Rule 142   valor -> FALSE
Rule 143   comparison -> value op value
Rule 144   value -> ID
Rule 145   value -> expression
Rule 146   op -> GREATER
Rule 147   op -> SMALLER
Rule 148   op -> GREATER_OR_EQUAL
Rule 149   op -> SMALLER_OR_EQUAL
Rule 150   op -> EQUAL_COMPARE
Rule 151   op -> NOT_EQUAL
Rule 152   logic_operation -> logic_value logic_recu
Rule 153   logic_operation -> negation
Rule 154   logic_recu -> logic_op logic_value
Rule 155   logic_recu -> logic_op logic_value logic_recu
Rule 156   logic_value -> negation
Rule 157   logic_value -> comparison
Rule 158   logic_value -> ID
Rule 159   negation -> NOT comparison
Rule 160   negation -> NOT ID
Rule 161   logic_op -> AND
Rule 162   logic_op -> OR
Rule 163   switch_statement -> SWITCH ID LLLAVE cases RLLAVE
Rule 164   cases -> CASE values POINTS codigo
Rule 165   cases -> CASE values POINTS codigo more
Rule 166   more -> cases
Rule 167   more -> DEFAULT POINTS codigo
Rule 168   array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types
Rule 169   array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
Rule 170   capacity -> INTEGER
Rule 171   capacity -> ID
Rule 172   capacity -> expression
Rule 173   array_var -> ID LCORCHE index RCORCHE
Rule 174   index -> ID
Rule 175   index -> INTEGER
Rule 176   index -> expression
Rule 177   array_assignment -> array_var EQUAL something
Rule 178   map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types
Rule 179   map_var -> ID LCORCHE key RCORCHE
Rule 180   key -> ID
Rule 181   key -> values
Rule 182   key -> operations
Rule 183   map_assignment -> array_var EQUAL something
Rule 184   func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
Rule 185   func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
Rule 186   return_value -> retorno COLON
Rule 187   return_value -> retorno
Rule 188   retorno -> ID
Rule 189   retorno -> values
Rule 190   retorno -> operations
Rule 191   retorno -> data_structure
Rule 192   params -> ID data_types
Rule 193   params -> more_params
Rule 194   more_params -> ID data_types COMA params
Rule 195   impresion -> PRINT LPAREN content RPAREN
Rule 196   content -> values
Rule 197   content -> operations
Rule 198   content -> funciones
Rule 199   content -> data_structure
Rule 200   content -> ID
Rule 201   expression -> something_ex
Rule 202   expression -> something_ex adicionaEx
Rule 203   adicionaEx -> op something_ex
Rule 204   adicionaEx -> op something_ex adicionaEx
Rule 205   something_ex -> ID
Rule 206   something_ex -> INTEGER
Rule 207   something_ex -> FLOAT
Rule 208   something_ex -> data_structure
Rule 209   something_ex -> funciones
Rule 210   op -> PLUS
Rule 211   op -> TIMES
Rule 212   op -> DIVIDE
Rule 213   op -> MINUS

Terminals, with rules where they appear

AND                  : 161
APPEND               : 118 119
ARRAY                : 
BOOL                 : 56
BYTE                 : 52
CAP                  : 
CASE                 : 164 165
COLON                : 4 6 8 13 16 18 25 27 29 31 33 35 37 39 83 83 186
COMA                 : 68 70 104 105 105 118 119 121 122 138 194
COMMENT              : 
CONST                : 
COPY                 : 121
DECREASE             : 85
DEFAULT              : 167
DELETE               : 122
DEQUAL               : 94 95 96 97 98 102 103 123 124 136
DIVIDE               : 212
ELSE                 : 128 129 130 131
EQUAL                : 62 87 88 89 90 91 92 93 100 101 113 169 177 183
EQUAL_COMPARE        : 150
FALSE                : 47 127 130 142
FLOAT                : 45 89 95 207
FLOAT32              : 50
FLOAT64              : 51
FOR                  : 80 81 82 83
FUNC                 : 78 184 185
GREATER              : 146
GREATER_OR_EQUAL     : 148
ID                   : 62 65 74 84 85 87 88 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 107 109 110 114 118 119 119 120 121 121 122 122 123 123 124 132 135 136 136 137 138 139 144 158 160 163 168 169 171 173 174 178 179 180 184 185 188 192 194 200 205
IF                   : 125 126 127 128 129 130
INCREASE             : 84
INT32                : 48
INT64                : 49
INTEGER              : 44 87 106 111 124 140 170 175 206
INTERFACE            : 
JOIN                 : 
LCORCHE              : 99 100 103 104 105 109 168 169 173 178 179
LEN                  : 120
LLLAVE               : 68 69 78 80 81 82 83 125 126 127 128 129 130 131 132 136 163 184 185
LPAREN               : 78 79 104 105 118 119 120 121 122 184 185 195
MAIN                 : 78
MAKE                 : 104 105
MAP                  : 
MINUS                : 213
MOD                  : 
MULTI_COMMENT        : 
NOT                  : 159 160
NOT_EQUAL            : 151
OR                   : 162
PACKAGE              : 
PLUS                 : 210
POINTER              : 79
POINTS               : 137 138 164 165 167
PRINT                : 195
RCORCHE              : 99 100 103 104 105 109 168 169 173 178 179
RETURN               : 184 185
RLLAVE               : 68 69 78 80 81 82 83 125 126 127 128 129 130 131 132 136 163 184 185
RPAREN               : 78 79 104 105 118 119 120 121 122 184 185 195
SCAN                 : 79
SMALLER              : 147
SMALLER_OR_EQUAL     : 149
STRING               : 43 93 94
STRUCT               : 132
SWITCH               : 163
TIMES                : 211
TRUE                 : 46 126 129 141
TYPE                 : 132
VAR                  : 87 88 89 90 91 92 93 99 100 101 168 169 178
WFLOAT               : 54
WINT                 : 53
WSTRING              : 55
error                : 

Nonterminals, with rules where they appear

SenElse              : 21
SenElseIF            : 20
SenIF                : 19
SenStruct            : 22
adicionaEx           : 202 204
any                  : 62
arr_content          : 100 103 169
array_assignment     : 29 30
array_declaration    : 25 26
array_var            : 27 28 60 115 177 183
asignaciones         : 136 138
cStruct              : 23
cap                  : 104 105 105
capacity             : 168 169
cases                : 163 166
cicloFor             : 10
codigo               : 3 78 80 81 82 83 125 126 127 128 129 130 131 164 165 167 184 0
comparison           : 11 58 81 83 92 98 125 128 157 159
content              : 195
data_structure       : 66 75 191 199 208
data_types           : 99 100 103 104 105 133 134 168 169 178 178 184 185 192 194
decVar               : 13 14
decVarOne            : 83 86
declaration          : 132 134
expression           : 8 9 57 90 96 108 112 145 172 176
funM                 : 101 102
func_declaration     : 41
funciones            : 17 18 67 198 209
impresion            : 4 5
incre                : 83
index                : 173
index_s              : 109
items                : 68 69 70 71
key                  : 179
logic_op             : 154 155
logic_operation      : 12 59 82 91 97
logic_recu           : 152 155
logic_value          : 152 154 155
main_func            : 42
map_assignment       : 39 40
map_declaration      : 37 38
map_var              : 61
more                 : 165
more_items           : 68 70
more_params          : 193
more_rules           : 2
negation             : 153 156
op                   : 143 203 204
operations           : 64 73 77 117 182 190 197
params               : 184 185 194
retorno              : 184 186 187
return_value         : 185
rule                 : 1 3
scan_func            : 6 7
slice_assignment     : 35 36
slice_declaration    : 31 32
slice_var            : 33 34 113
something            : 177 183
something_ex         : 201 202 203 204
something_s          : 113
switch_statement     : 24
valor                : 137 138
value                : 143 143
values               : 63 72 76 116 118 164 165 181 189 196
var_asignation       : 15 16
variable             : 133 134

Parsing method: LALR

state 0

    (0) S' -> . codigo
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    codigo                         shift and go to state 1
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    decVarOne                      shift and go to state 33
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 1

    (0) S' -> codigo .



state 2

    (1) codigo -> rule .
    (3) more_rules -> rule . codigo
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    $end            reduce using rule 1 (codigo -> rule .)
    RLLAVE          reduce using rule 1 (codigo -> rule .)
    DEFAULT         reduce using rule 1 (codigo -> rule .)
    CASE            reduce using rule 1 (codigo -> rule .)
    RETURN          reduce using rule 1 (codigo -> rule .)
    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    rule                           shift and go to state 2
    codigo                         shift and go to state 53
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    decVarOne                      shift and go to state 33
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 3

    (2) codigo -> more_rules .

    $end            reduce using rule 2 (codigo -> more_rules .)
    RLLAVE          reduce using rule 2 (codigo -> more_rules .)
    DEFAULT         reduce using rule 2 (codigo -> more_rules .)
    CASE            reduce using rule 2 (codigo -> more_rules .)
    RETURN          reduce using rule 2 (codigo -> more_rules .)


state 4

    (4) rule -> impresion . COLON
    (5) rule -> impresion .

    COLON           shift and go to state 54
    PRINT           reduce using rule 5 (rule -> impresion .)
    SCAN            reduce using rule 5 (rule -> impresion .)
    FOR             reduce using rule 5 (rule -> impresion .)
    VAR             reduce using rule 5 (rule -> impresion .)
    ID              reduce using rule 5 (rule -> impresion .)
    APPEND          reduce using rule 5 (rule -> impresion .)
    LEN             reduce using rule 5 (rule -> impresion .)
    COPY            reduce using rule 5 (rule -> impresion .)
    DELETE          reduce using rule 5 (rule -> impresion .)
    IF              reduce using rule 5 (rule -> impresion .)
    ELSE            reduce using rule 5 (rule -> impresion .)
    TYPE            reduce using rule 5 (rule -> impresion .)
    SWITCH          reduce using rule 5 (rule -> impresion .)
    FUNC            reduce using rule 5 (rule -> impresion .)
    INTEGER         reduce using rule 5 (rule -> impresion .)
    FLOAT           reduce using rule 5 (rule -> impresion .)
    NOT             reduce using rule 5 (rule -> impresion .)
    $end            reduce using rule 5 (rule -> impresion .)
    RLLAVE          reduce using rule 5 (rule -> impresion .)
    DEFAULT         reduce using rule 5 (rule -> impresion .)
    CASE            reduce using rule 5 (rule -> impresion .)
    RETURN          reduce using rule 5 (rule -> impresion .)


state 5

    (6) rule -> scan_func . COLON
    (7) rule -> scan_func .

    COLON           shift and go to state 55
    PRINT           reduce using rule 7 (rule -> scan_func .)
    SCAN            reduce using rule 7 (rule -> scan_func .)
    FOR             reduce using rule 7 (rule -> scan_func .)
    VAR             reduce using rule 7 (rule -> scan_func .)
    ID              reduce using rule 7 (rule -> scan_func .)
    APPEND          reduce using rule 7 (rule -> scan_func .)
    LEN             reduce using rule 7 (rule -> scan_func .)
    COPY            reduce using rule 7 (rule -> scan_func .)
    DELETE          reduce using rule 7 (rule -> scan_func .)
    IF              reduce using rule 7 (rule -> scan_func .)
    ELSE            reduce using rule 7 (rule -> scan_func .)
    TYPE            reduce using rule 7 (rule -> scan_func .)
    SWITCH          reduce using rule 7 (rule -> scan_func .)
    FUNC            reduce using rule 7 (rule -> scan_func .)
    INTEGER         reduce using rule 7 (rule -> scan_func .)
    FLOAT           reduce using rule 7 (rule -> scan_func .)
    NOT             reduce using rule 7 (rule -> scan_func .)
    $end            reduce using rule 7 (rule -> scan_func .)
    RLLAVE          reduce using rule 7 (rule -> scan_func .)
    DEFAULT         reduce using rule 7 (rule -> scan_func .)
    CASE            reduce using rule 7 (rule -> scan_func .)
    RETURN          reduce using rule 7 (rule -> scan_func .)


state 6

    (8) rule -> expression . COLON
    (9) rule -> expression .
    (145) value -> expression .

    COLON           shift and go to state 56
    PRINT           reduce using rule 9 (rule -> expression .)
    SCAN            reduce using rule 9 (rule -> expression .)
    FOR             reduce using rule 9 (rule -> expression .)
    VAR             reduce using rule 9 (rule -> expression .)
    ID              reduce using rule 9 (rule -> expression .)
    APPEND          reduce using rule 9 (rule -> expression .)
    LEN             reduce using rule 9 (rule -> expression .)
    COPY            reduce using rule 9 (rule -> expression .)
    DELETE          reduce using rule 9 (rule -> expression .)
    IF              reduce using rule 9 (rule -> expression .)
    ELSE            reduce using rule 9 (rule -> expression .)
    TYPE            reduce using rule 9 (rule -> expression .)
    SWITCH          reduce using rule 9 (rule -> expression .)
    FUNC            reduce using rule 9 (rule -> expression .)
    INTEGER         reduce using rule 9 (rule -> expression .)
    FLOAT           reduce using rule 9 (rule -> expression .)
    NOT             reduce using rule 9 (rule -> expression .)
    $end            reduce using rule 9 (rule -> expression .)
    RLLAVE          reduce using rule 9 (rule -> expression .)
    DEFAULT         reduce using rule 9 (rule -> expression .)
    CASE            reduce using rule 9 (rule -> expression .)
    RETURN          reduce using rule 9 (rule -> expression .)
    GREATER         reduce using rule 145 (value -> expression .)
    SMALLER         reduce using rule 145 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 145 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 145 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 145 (value -> expression .)
    NOT_EQUAL       reduce using rule 145 (value -> expression .)
    PLUS            reduce using rule 145 (value -> expression .)
    TIMES           reduce using rule 145 (value -> expression .)
    DIVIDE          reduce using rule 145 (value -> expression .)
    MINUS           reduce using rule 145 (value -> expression .)


state 7

    (10) rule -> cicloFor .

    PRINT           reduce using rule 10 (rule -> cicloFor .)
    SCAN            reduce using rule 10 (rule -> cicloFor .)
    FOR             reduce using rule 10 (rule -> cicloFor .)
    VAR             reduce using rule 10 (rule -> cicloFor .)
    ID              reduce using rule 10 (rule -> cicloFor .)
    APPEND          reduce using rule 10 (rule -> cicloFor .)
    LEN             reduce using rule 10 (rule -> cicloFor .)
    COPY            reduce using rule 10 (rule -> cicloFor .)
    DELETE          reduce using rule 10 (rule -> cicloFor .)
    IF              reduce using rule 10 (rule -> cicloFor .)
    ELSE            reduce using rule 10 (rule -> cicloFor .)
    TYPE            reduce using rule 10 (rule -> cicloFor .)
    SWITCH          reduce using rule 10 (rule -> cicloFor .)
    FUNC            reduce using rule 10 (rule -> cicloFor .)
    INTEGER         reduce using rule 10 (rule -> cicloFor .)
    FLOAT           reduce using rule 10 (rule -> cicloFor .)
    NOT             reduce using rule 10 (rule -> cicloFor .)
    $end            reduce using rule 10 (rule -> cicloFor .)
    RLLAVE          reduce using rule 10 (rule -> cicloFor .)
    DEFAULT         reduce using rule 10 (rule -> cicloFor .)
    CASE            reduce using rule 10 (rule -> cicloFor .)
    RETURN          reduce using rule 10 (rule -> cicloFor .)


state 8

    (11) rule -> comparison .
    (157) logic_value -> comparison .

    PRINT           reduce using rule 11 (rule -> comparison .)
    SCAN            reduce using rule 11 (rule -> comparison .)
    FOR             reduce using rule 11 (rule -> comparison .)
    VAR             reduce using rule 11 (rule -> comparison .)
    ID              reduce using rule 11 (rule -> comparison .)
    APPEND          reduce using rule 11 (rule -> comparison .)
    LEN             reduce using rule 11 (rule -> comparison .)
    COPY            reduce using rule 11 (rule -> comparison .)
    DELETE          reduce using rule 11 (rule -> comparison .)
    IF              reduce using rule 11 (rule -> comparison .)
    ELSE            reduce using rule 11 (rule -> comparison .)
    TYPE            reduce using rule 11 (rule -> comparison .)
    SWITCH          reduce using rule 11 (rule -> comparison .)
    FUNC            reduce using rule 11 (rule -> comparison .)
    INTEGER         reduce using rule 11 (rule -> comparison .)
    FLOAT           reduce using rule 11 (rule -> comparison .)
    NOT             reduce using rule 11 (rule -> comparison .)
    $end            reduce using rule 11 (rule -> comparison .)
    RLLAVE          reduce using rule 11 (rule -> comparison .)
    DEFAULT         reduce using rule 11 (rule -> comparison .)
    CASE            reduce using rule 11 (rule -> comparison .)
    RETURN          reduce using rule 11 (rule -> comparison .)
    AND             reduce using rule 157 (logic_value -> comparison .)
    OR              reduce using rule 157 (logic_value -> comparison .)


state 9

    (12) rule -> logic_operation .

    PRINT           reduce using rule 12 (rule -> logic_operation .)
    SCAN            reduce using rule 12 (rule -> logic_operation .)
    FOR             reduce using rule 12 (rule -> logic_operation .)
    VAR             reduce using rule 12 (rule -> logic_operation .)
    ID              reduce using rule 12 (rule -> logic_operation .)
    APPEND          reduce using rule 12 (rule -> logic_operation .)
    LEN             reduce using rule 12 (rule -> logic_operation .)
    COPY            reduce using rule 12 (rule -> logic_operation .)
    DELETE          reduce using rule 12 (rule -> logic_operation .)
    IF              reduce using rule 12 (rule -> logic_operation .)
    ELSE            reduce using rule 12 (rule -> logic_operation .)
    TYPE            reduce using rule 12 (rule -> logic_operation .)
    SWITCH          reduce using rule 12 (rule -> logic_operation .)
    FUNC            reduce using rule 12 (rule -> logic_operation .)
    INTEGER         reduce using rule 12 (rule -> logic_operation .)
    FLOAT           reduce using rule 12 (rule -> logic_operation .)
    NOT             reduce using rule 12 (rule -> logic_operation .)
    $end            reduce using rule 12 (rule -> logic_operation .)
    RLLAVE          reduce using rule 12 (rule -> logic_operation .)
    DEFAULT         reduce using rule 12 (rule -> logic_operation .)
    CASE            reduce using rule 12 (rule -> logic_operation .)
    RETURN          reduce using rule 12 (rule -> logic_operation .)


state 10

    (13) rule -> decVar . COLON
    (14) rule -> decVar .

    COLON           shift and go to state 57
    PRINT           reduce using rule 14 (rule -> decVar .)
    SCAN            reduce using rule 14 (rule -> decVar .)
    FOR             reduce using rule 14 (rule -> decVar .)
    VAR             reduce using rule 14 (rule -> decVar .)
    ID              reduce using rule 14 (rule -> decVar .)
    APPEND          reduce using rule 14 (rule -> decVar .)
    LEN             reduce using rule 14 (rule -> decVar .)
    COPY            reduce using rule 14 (rule -> decVar .)
    DELETE          reduce using rule 14 (rule -> decVar .)
    IF              reduce using rule 14 (rule -> decVar .)
    ELSE            reduce using rule 14 (rule -> decVar .)
    TYPE            reduce using rule 14 (rule -> decVar .)
    SWITCH          reduce using rule 14 (rule -> decVar .)
    FUNC            reduce using rule 14 (rule -> decVar .)
    INTEGER         reduce using rule 14 (rule -> decVar .)
    FLOAT           reduce using rule 14 (rule -> decVar .)
    NOT             reduce using rule 14 (rule -> decVar .)
    $end            reduce using rule 14 (rule -> decVar .)
    RLLAVE          reduce using rule 14 (rule -> decVar .)
    DEFAULT         reduce using rule 14 (rule -> decVar .)
    CASE            reduce using rule 14 (rule -> decVar .)
    RETURN          reduce using rule 14 (rule -> decVar .)


state 11

    (15) rule -> var_asignation .
    (16) rule -> var_asignation . COLON

    PRINT           reduce using rule 15 (rule -> var_asignation .)
    SCAN            reduce using rule 15 (rule -> var_asignation .)
    FOR             reduce using rule 15 (rule -> var_asignation .)
    VAR             reduce using rule 15 (rule -> var_asignation .)
    ID              reduce using rule 15 (rule -> var_asignation .)
    APPEND          reduce using rule 15 (rule -> var_asignation .)
    LEN             reduce using rule 15 (rule -> var_asignation .)
    COPY            reduce using rule 15 (rule -> var_asignation .)
    DELETE          reduce using rule 15 (rule -> var_asignation .)
    IF              reduce using rule 15 (rule -> var_asignation .)
    ELSE            reduce using rule 15 (rule -> var_asignation .)
    TYPE            reduce using rule 15 (rule -> var_asignation .)
    SWITCH          reduce using rule 15 (rule -> var_asignation .)
    FUNC            reduce using rule 15 (rule -> var_asignation .)
    INTEGER         reduce using rule 15 (rule -> var_asignation .)
    FLOAT           reduce using rule 15 (rule -> var_asignation .)
    NOT             reduce using rule 15 (rule -> var_asignation .)
    $end            reduce using rule 15 (rule -> var_asignation .)
    RLLAVE          reduce using rule 15 (rule -> var_asignation .)
    DEFAULT         reduce using rule 15 (rule -> var_asignation .)
    CASE            reduce using rule 15 (rule -> var_asignation .)
    RETURN          reduce using rule 15 (rule -> var_asignation .)
    COLON           shift and go to state 58


state 12

    (17) rule -> funciones .
    (18) rule -> funciones . COLON
    (209) something_ex -> funciones .

  ! shift/reduce conflict for COLON resolved as shift
  ! reduce/reduce conflict for PRINT resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for SCAN resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for FOR resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for VAR resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for ID resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for APPEND resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for LEN resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for COPY resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for DELETE resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for IF resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for ELSE resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for TYPE resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for SWITCH resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for FUNC resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for INTEGER resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for FLOAT resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for NOT resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for $end resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for CASE resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for RETURN resolved using rule 17 (rule -> funciones .)
    PRINT           reduce using rule 17 (rule -> funciones .)
    SCAN            reduce using rule 17 (rule -> funciones .)
    FOR             reduce using rule 17 (rule -> funciones .)
    VAR             reduce using rule 17 (rule -> funciones .)
    ID              reduce using rule 17 (rule -> funciones .)
    APPEND          reduce using rule 17 (rule -> funciones .)
    LEN             reduce using rule 17 (rule -> funciones .)
    COPY            reduce using rule 17 (rule -> funciones .)
    DELETE          reduce using rule 17 (rule -> funciones .)
    IF              reduce using rule 17 (rule -> funciones .)
    ELSE            reduce using rule 17 (rule -> funciones .)
    TYPE            reduce using rule 17 (rule -> funciones .)
    SWITCH          reduce using rule 17 (rule -> funciones .)
    FUNC            reduce using rule 17 (rule -> funciones .)
    INTEGER         reduce using rule 17 (rule -> funciones .)
    FLOAT           reduce using rule 17 (rule -> funciones .)
    NOT             reduce using rule 17 (rule -> funciones .)
    $end            reduce using rule 17 (rule -> funciones .)
    RLLAVE          reduce using rule 17 (rule -> funciones .)
    DEFAULT         reduce using rule 17 (rule -> funciones .)
    CASE            reduce using rule 17 (rule -> funciones .)
    RETURN          reduce using rule 17 (rule -> funciones .)
    COLON           shift and go to state 59
    GREATER         reduce using rule 209 (something_ex -> funciones .)
    SMALLER         reduce using rule 209 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 209 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 209 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 209 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 209 (something_ex -> funciones .)
    PLUS            reduce using rule 209 (something_ex -> funciones .)
    TIMES           reduce using rule 209 (something_ex -> funciones .)
    DIVIDE          reduce using rule 209 (something_ex -> funciones .)
    MINUS           reduce using rule 209 (something_ex -> funciones .)

  ! COLON           [ reduce using rule 209 (something_ex -> funciones .) ]
  ! PRINT           [ reduce using rule 209 (something_ex -> funciones .) ]
  ! SCAN            [ reduce using rule 209 (something_ex -> funciones .) ]
  ! FOR             [ reduce using rule 209 (something_ex -> funciones .) ]
  ! VAR             [ reduce using rule 209 (something_ex -> funciones .) ]
  ! ID              [ reduce using rule 209 (something_ex -> funciones .) ]
  ! APPEND          [ reduce using rule 209 (something_ex -> funciones .) ]
  ! LEN             [ reduce using rule 209 (something_ex -> funciones .) ]
  ! COPY            [ reduce using rule 209 (something_ex -> funciones .) ]
  ! DELETE          [ reduce using rule 209 (something_ex -> funciones .) ]
  ! IF              [ reduce using rule 209 (something_ex -> funciones .) ]
  ! ELSE            [ reduce using rule 209 (something_ex -> funciones .) ]
  ! TYPE            [ reduce using rule 209 (something_ex -> funciones .) ]
  ! SWITCH          [ reduce using rule 209 (something_ex -> funciones .) ]
  ! FUNC            [ reduce using rule 209 (something_ex -> funciones .) ]
  ! INTEGER         [ reduce using rule 209 (something_ex -> funciones .) ]
  ! FLOAT           [ reduce using rule 209 (something_ex -> funciones .) ]
  ! NOT             [ reduce using rule 209 (something_ex -> funciones .) ]
  ! $end            [ reduce using rule 209 (something_ex -> funciones .) ]
  ! RLLAVE          [ reduce using rule 209 (something_ex -> funciones .) ]
  ! DEFAULT         [ reduce using rule 209 (something_ex -> funciones .) ]
  ! CASE            [ reduce using rule 209 (something_ex -> funciones .) ]
  ! RETURN          [ reduce using rule 209 (something_ex -> funciones .) ]


state 13

    (19) rule -> SenIF .

    PRINT           reduce using rule 19 (rule -> SenIF .)
    SCAN            reduce using rule 19 (rule -> SenIF .)
    FOR             reduce using rule 19 (rule -> SenIF .)
    VAR             reduce using rule 19 (rule -> SenIF .)
    ID              reduce using rule 19 (rule -> SenIF .)
    APPEND          reduce using rule 19 (rule -> SenIF .)
    LEN             reduce using rule 19 (rule -> SenIF .)
    COPY            reduce using rule 19 (rule -> SenIF .)
    DELETE          reduce using rule 19 (rule -> SenIF .)
    IF              reduce using rule 19 (rule -> SenIF .)
    ELSE            reduce using rule 19 (rule -> SenIF .)
    TYPE            reduce using rule 19 (rule -> SenIF .)
    SWITCH          reduce using rule 19 (rule -> SenIF .)
    FUNC            reduce using rule 19 (rule -> SenIF .)
    INTEGER         reduce using rule 19 (rule -> SenIF .)
    FLOAT           reduce using rule 19 (rule -> SenIF .)
    NOT             reduce using rule 19 (rule -> SenIF .)
    $end            reduce using rule 19 (rule -> SenIF .)
    RLLAVE          reduce using rule 19 (rule -> SenIF .)
    DEFAULT         reduce using rule 19 (rule -> SenIF .)
    CASE            reduce using rule 19 (rule -> SenIF .)
    RETURN          reduce using rule 19 (rule -> SenIF .)


state 14

    (20) rule -> SenElseIF .

    PRINT           reduce using rule 20 (rule -> SenElseIF .)
    SCAN            reduce using rule 20 (rule -> SenElseIF .)
    FOR             reduce using rule 20 (rule -> SenElseIF .)
    VAR             reduce using rule 20 (rule -> SenElseIF .)
    ID              reduce using rule 20 (rule -> SenElseIF .)
    APPEND          reduce using rule 20 (rule -> SenElseIF .)
    LEN             reduce using rule 20 (rule -> SenElseIF .)
    COPY            reduce using rule 20 (rule -> SenElseIF .)
    DELETE          reduce using rule 20 (rule -> SenElseIF .)
    IF              reduce using rule 20 (rule -> SenElseIF .)
    ELSE            reduce using rule 20 (rule -> SenElseIF .)
    TYPE            reduce using rule 20 (rule -> SenElseIF .)
    SWITCH          reduce using rule 20 (rule -> SenElseIF .)
    FUNC            reduce using rule 20 (rule -> SenElseIF .)
    INTEGER         reduce using rule 20 (rule -> SenElseIF .)
    FLOAT           reduce using rule 20 (rule -> SenElseIF .)
    NOT             reduce using rule 20 (rule -> SenElseIF .)
    $end            reduce using rule 20 (rule -> SenElseIF .)
    RLLAVE          reduce using rule 20 (rule -> SenElseIF .)
    DEFAULT         reduce using rule 20 (rule -> SenElseIF .)
    CASE            reduce using rule 20 (rule -> SenElseIF .)
    RETURN          reduce using rule 20 (rule -> SenElseIF .)


state 15

    (21) rule -> SenElse .

    PRINT           reduce using rule 21 (rule -> SenElse .)
    SCAN            reduce using rule 21 (rule -> SenElse .)
    FOR             reduce using rule 21 (rule -> SenElse .)
    VAR             reduce using rule 21 (rule -> SenElse .)
    ID              reduce using rule 21 (rule -> SenElse .)
    APPEND          reduce using rule 21 (rule -> SenElse .)
    LEN             reduce using rule 21 (rule -> SenElse .)
    COPY            reduce using rule 21 (rule -> SenElse .)
    DELETE          reduce using rule 21 (rule -> SenElse .)
    IF              reduce using rule 21 (rule -> SenElse .)
    ELSE            reduce using rule 21 (rule -> SenElse .)
    TYPE            reduce using rule 21 (rule -> SenElse .)
    SWITCH          reduce using rule 21 (rule -> SenElse .)
    FUNC            reduce using rule 21 (rule -> SenElse .)
    INTEGER         reduce using rule 21 (rule -> SenElse .)
    FLOAT           reduce using rule 21 (rule -> SenElse .)
    NOT             reduce using rule 21 (rule -> SenElse .)
    $end            reduce using rule 21 (rule -> SenElse .)
    RLLAVE          reduce using rule 21 (rule -> SenElse .)
    DEFAULT         reduce using rule 21 (rule -> SenElse .)
    CASE            reduce using rule 21 (rule -> SenElse .)
    RETURN          reduce using rule 21 (rule -> SenElse .)


state 16

    (22) rule -> SenStruct .

    PRINT           reduce using rule 22 (rule -> SenStruct .)
    SCAN            reduce using rule 22 (rule -> SenStruct .)
    FOR             reduce using rule 22 (rule -> SenStruct .)
    VAR             reduce using rule 22 (rule -> SenStruct .)
    ID              reduce using rule 22 (rule -> SenStruct .)
    APPEND          reduce using rule 22 (rule -> SenStruct .)
    LEN             reduce using rule 22 (rule -> SenStruct .)
    COPY            reduce using rule 22 (rule -> SenStruct .)
    DELETE          reduce using rule 22 (rule -> SenStruct .)
    IF              reduce using rule 22 (rule -> SenStruct .)
    ELSE            reduce using rule 22 (rule -> SenStruct .)
    TYPE            reduce using rule 22 (rule -> SenStruct .)
    SWITCH          reduce using rule 22 (rule -> SenStruct .)
    FUNC            reduce using rule 22 (rule -> SenStruct .)
    INTEGER         reduce using rule 22 (rule -> SenStruct .)
    FLOAT           reduce using rule 22 (rule -> SenStruct .)
    NOT             reduce using rule 22 (rule -> SenStruct .)
    $end            reduce using rule 22 (rule -> SenStruct .)
    RLLAVE          reduce using rule 22 (rule -> SenStruct .)
    DEFAULT         reduce using rule 22 (rule -> SenStruct .)
    CASE            reduce using rule 22 (rule -> SenStruct .)
    RETURN          reduce using rule 22 (rule -> SenStruct .)


state 17

    (23) rule -> cStruct .

    PRINT           reduce using rule 23 (rule -> cStruct .)
    SCAN            reduce using rule 23 (rule -> cStruct .)
    FOR             reduce using rule 23 (rule -> cStruct .)
    VAR             reduce using rule 23 (rule -> cStruct .)
    ID              reduce using rule 23 (rule -> cStruct .)
    APPEND          reduce using rule 23 (rule -> cStruct .)
    LEN             reduce using rule 23 (rule -> cStruct .)
    COPY            reduce using rule 23 (rule -> cStruct .)
    DELETE          reduce using rule 23 (rule -> cStruct .)
    IF              reduce using rule 23 (rule -> cStruct .)
    ELSE            reduce using rule 23 (rule -> cStruct .)
    TYPE            reduce using rule 23 (rule -> cStruct .)
    SWITCH          reduce using rule 23 (rule -> cStruct .)
    FUNC            reduce using rule 23 (rule -> cStruct .)
    INTEGER         reduce using rule 23 (rule -> cStruct .)
    FLOAT           reduce using rule 23 (rule -> cStruct .)
    NOT             reduce using rule 23 (rule -> cStruct .)
    $end            reduce using rule 23 (rule -> cStruct .)
    RLLAVE          reduce using rule 23 (rule -> cStruct .)
    DEFAULT         reduce using rule 23 (rule -> cStruct .)
    CASE            reduce using rule 23 (rule -> cStruct .)
    RETURN          reduce using rule 23 (rule -> cStruct .)


state 18

    (24) rule -> switch_statement .

    PRINT           reduce using rule 24 (rule -> switch_statement .)
    SCAN            reduce using rule 24 (rule -> switch_statement .)
    FOR             reduce using rule 24 (rule -> switch_statement .)
    VAR             reduce using rule 24 (rule -> switch_statement .)
    ID              reduce using rule 24 (rule -> switch_statement .)
    APPEND          reduce using rule 24 (rule -> switch_statement .)
    LEN             reduce using rule 24 (rule -> switch_statement .)
    COPY            reduce using rule 24 (rule -> switch_statement .)
    DELETE          reduce using rule 24 (rule -> switch_statement .)
    IF              reduce using rule 24 (rule -> switch_statement .)
    ELSE            reduce using rule 24 (rule -> switch_statement .)
    TYPE            reduce using rule 24 (rule -> switch_statement .)
    SWITCH          reduce using rule 24 (rule -> switch_statement .)
    FUNC            reduce using rule 24 (rule -> switch_statement .)
    INTEGER         reduce using rule 24 (rule -> switch_statement .)
    FLOAT           reduce using rule 24 (rule -> switch_statement .)
    NOT             reduce using rule 24 (rule -> switch_statement .)
    $end            reduce using rule 24 (rule -> switch_statement .)
    RLLAVE          reduce using rule 24 (rule -> switch_statement .)
    DEFAULT         reduce using rule 24 (rule -> switch_statement .)
    CASE            reduce using rule 24 (rule -> switch_statement .)
    RETURN          reduce using rule 24 (rule -> switch_statement .)


state 19

    (25) rule -> array_declaration . COLON
    (26) rule -> array_declaration .

    COLON           shift and go to state 60
    PRINT           reduce using rule 26 (rule -> array_declaration .)
    SCAN            reduce using rule 26 (rule -> array_declaration .)
    FOR             reduce using rule 26 (rule -> array_declaration .)
    VAR             reduce using rule 26 (rule -> array_declaration .)
    ID              reduce using rule 26 (rule -> array_declaration .)
    APPEND          reduce using rule 26 (rule -> array_declaration .)
    LEN             reduce using rule 26 (rule -> array_declaration .)
    COPY            reduce using rule 26 (rule -> array_declaration .)
    DELETE          reduce using rule 26 (rule -> array_declaration .)
    IF              reduce using rule 26 (rule -> array_declaration .)
    ELSE            reduce using rule 26 (rule -> array_declaration .)
    TYPE            reduce using rule 26 (rule -> array_declaration .)
    SWITCH          reduce using rule 26 (rule -> array_declaration .)
    FUNC            reduce using rule 26 (rule -> array_declaration .)
    INTEGER         reduce using rule 26 (rule -> array_declaration .)
    FLOAT           reduce using rule 26 (rule -> array_declaration .)
    NOT             reduce using rule 26 (rule -> array_declaration .)
    $end            reduce using rule 26 (rule -> array_declaration .)
    RLLAVE          reduce using rule 26 (rule -> array_declaration .)
    DEFAULT         reduce using rule 26 (rule -> array_declaration .)
    CASE            reduce using rule 26 (rule -> array_declaration .)
    RETURN          reduce using rule 26 (rule -> array_declaration .)


state 20

    (27) rule -> array_var . COLON
    (28) rule -> array_var .
    (177) array_assignment -> array_var . EQUAL something
    (183) map_assignment -> array_var . EQUAL something
    (60) data_structure -> array_var .

  ! shift/reduce conflict for COLON resolved as shift
  ! reduce/reduce conflict for PRINT resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for SCAN resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for FOR resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for VAR resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for ID resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for APPEND resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for LEN resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for COPY resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for DELETE resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for IF resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for ELSE resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for TYPE resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for SWITCH resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for FUNC resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for INTEGER resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for FLOAT resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for NOT resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for $end resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for CASE resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for RETURN resolved using rule 28 (rule -> array_var .)
    COLON           shift and go to state 61
    PRINT           reduce using rule 28 (rule -> array_var .)
    SCAN            reduce using rule 28 (rule -> array_var .)
    FOR             reduce using rule 28 (rule -> array_var .)
    VAR             reduce using rule 28 (rule -> array_var .)
    ID              reduce using rule 28 (rule -> array_var .)
    APPEND          reduce using rule 28 (rule -> array_var .)
    LEN             reduce using rule 28 (rule -> array_var .)
    COPY            reduce using rule 28 (rule -> array_var .)
    DELETE          reduce using rule 28 (rule -> array_var .)
    IF              reduce using rule 28 (rule -> array_var .)
    ELSE            reduce using rule 28 (rule -> array_var .)
    TYPE            reduce using rule 28 (rule -> array_var .)
    SWITCH          reduce using rule 28 (rule -> array_var .)
    FUNC            reduce using rule 28 (rule -> array_var .)
    INTEGER         reduce using rule 28 (rule -> array_var .)
    FLOAT           reduce using rule 28 (rule -> array_var .)
    NOT             reduce using rule 28 (rule -> array_var .)
    $end            reduce using rule 28 (rule -> array_var .)
    RLLAVE          reduce using rule 28 (rule -> array_var .)
    DEFAULT         reduce using rule 28 (rule -> array_var .)
    CASE            reduce using rule 28 (rule -> array_var .)
    RETURN          reduce using rule 28 (rule -> array_var .)
    EQUAL           shift and go to state 62
    GREATER         reduce using rule 60 (data_structure -> array_var .)
    SMALLER         reduce using rule 60 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 60 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 60 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 60 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 60 (data_structure -> array_var .)
    PLUS            reduce using rule 60 (data_structure -> array_var .)
    TIMES           reduce using rule 60 (data_structure -> array_var .)
    DIVIDE          reduce using rule 60 (data_structure -> array_var .)
    MINUS           reduce using rule 60 (data_structure -> array_var .)

  ! COLON           [ reduce using rule 60 (data_structure -> array_var .) ]
  ! PRINT           [ reduce using rule 60 (data_structure -> array_var .) ]
  ! SCAN            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! FOR             [ reduce using rule 60 (data_structure -> array_var .) ]
  ! VAR             [ reduce using rule 60 (data_structure -> array_var .) ]
  ! ID              [ reduce using rule 60 (data_structure -> array_var .) ]
  ! APPEND          [ reduce using rule 60 (data_structure -> array_var .) ]
  ! LEN             [ reduce using rule 60 (data_structure -> array_var .) ]
  ! COPY            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! DELETE          [ reduce using rule 60 (data_structure -> array_var .) ]
  ! IF              [ reduce using rule 60 (data_structure -> array_var .) ]
  ! ELSE            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! TYPE            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! SWITCH          [ reduce using rule 60 (data_structure -> array_var .) ]
  ! FUNC            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! INTEGER         [ reduce using rule 60 (data_structure -> array_var .) ]
  ! FLOAT           [ reduce using rule 60 (data_structure -> array_var .) ]
  ! NOT             [ reduce using rule 60 (data_structure -> array_var .) ]
  ! $end            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! RLLAVE          [ reduce using rule 60 (data_structure -> array_var .) ]
  ! DEFAULT         [ reduce using rule 60 (data_structure -> array_var .) ]
  ! CASE            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! RETURN          [ reduce using rule 60 (data_structure -> array_var .) ]


state 21

    (29) rule -> array_assignment . COLON
    (30) rule -> array_assignment .

    COLON           shift and go to state 63
    PRINT           reduce using rule 30 (rule -> array_assignment .)
    SCAN            reduce using rule 30 (rule -> array_assignment .)
    FOR             reduce using rule 30 (rule -> array_assignment .)
    VAR             reduce using rule 30 (rule -> array_assignment .)
    ID              reduce using rule 30 (rule -> array_assignment .)
    APPEND          reduce using rule 30 (rule -> array_assignment .)
    LEN             reduce using rule 30 (rule -> array_assignment .)
    COPY            reduce using rule 30 (rule -> array_assignment .)
    DELETE          reduce using rule 30 (rule -> array_assignment .)
    IF              reduce using rule 30 (rule -> array_assignment .)
    ELSE            reduce using rule 30 (rule -> array_assignment .)
    TYPE            reduce using rule 30 (rule -> array_assignment .)
    SWITCH          reduce using rule 30 (rule -> array_assignment .)
    FUNC            reduce using rule 30 (rule -> array_assignment .)
    INTEGER         reduce using rule 30 (rule -> array_assignment .)
    FLOAT           reduce using rule 30 (rule -> array_assignment .)
    NOT             reduce using rule 30 (rule -> array_assignment .)
    $end            reduce using rule 30 (rule -> array_assignment .)
    RLLAVE          reduce using rule 30 (rule -> array_assignment .)
    DEFAULT         reduce using rule 30 (rule -> array_assignment .)
    CASE            reduce using rule 30 (rule -> array_assignment .)
    RETURN          reduce using rule 30 (rule -> array_assignment .)


state 22

    (31) rule -> slice_declaration . COLON
    (32) rule -> slice_declaration .

    COLON           shift and go to state 64
    PRINT           reduce using rule 32 (rule -> slice_declaration .)
    SCAN            reduce using rule 32 (rule -> slice_declaration .)
    FOR             reduce using rule 32 (rule -> slice_declaration .)
    VAR             reduce using rule 32 (rule -> slice_declaration .)
    ID              reduce using rule 32 (rule -> slice_declaration .)
    APPEND          reduce using rule 32 (rule -> slice_declaration .)
    LEN             reduce using rule 32 (rule -> slice_declaration .)
    COPY            reduce using rule 32 (rule -> slice_declaration .)
    DELETE          reduce using rule 32 (rule -> slice_declaration .)
    IF              reduce using rule 32 (rule -> slice_declaration .)
    ELSE            reduce using rule 32 (rule -> slice_declaration .)
    TYPE            reduce using rule 32 (rule -> slice_declaration .)
    SWITCH          reduce using rule 32 (rule -> slice_declaration .)
    FUNC            reduce using rule 32 (rule -> slice_declaration .)
    INTEGER         reduce using rule 32 (rule -> slice_declaration .)
    FLOAT           reduce using rule 32 (rule -> slice_declaration .)
    NOT             reduce using rule 32 (rule -> slice_declaration .)
    $end            reduce using rule 32 (rule -> slice_declaration .)
    RLLAVE          reduce using rule 32 (rule -> slice_declaration .)
    DEFAULT         reduce using rule 32 (rule -> slice_declaration .)
    CASE            reduce using rule 32 (rule -> slice_declaration .)
    RETURN          reduce using rule 32 (rule -> slice_declaration .)


state 23

    (33) rule -> slice_var . COLON
    (34) rule -> slice_var .
    (113) slice_assignment -> slice_var . EQUAL something_s

    COLON           shift and go to state 65
    PRINT           reduce using rule 34 (rule -> slice_var .)
    SCAN            reduce using rule 34 (rule -> slice_var .)
    FOR             reduce using rule 34 (rule -> slice_var .)
    VAR             reduce using rule 34 (rule -> slice_var .)
    ID              reduce using rule 34 (rule -> slice_var .)
    APPEND          reduce using rule 34 (rule -> slice_var .)
    LEN             reduce using rule 34 (rule -> slice_var .)
    COPY            reduce using rule 34 (rule -> slice_var .)
    DELETE          reduce using rule 34 (rule -> slice_var .)
    IF              reduce using rule 34 (rule -> slice_var .)
    ELSE            reduce using rule 34 (rule -> slice_var .)
    TYPE            reduce using rule 34 (rule -> slice_var .)
    SWITCH          reduce using rule 34 (rule -> slice_var .)
    FUNC            reduce using rule 34 (rule -> slice_var .)
    INTEGER         reduce using rule 34 (rule -> slice_var .)
    FLOAT           reduce using rule 34 (rule -> slice_var .)
    NOT             reduce using rule 34 (rule -> slice_var .)
    $end            reduce using rule 34 (rule -> slice_var .)
    RLLAVE          reduce using rule 34 (rule -> slice_var .)
    DEFAULT         reduce using rule 34 (rule -> slice_var .)
    CASE            reduce using rule 34 (rule -> slice_var .)
    RETURN          reduce using rule 34 (rule -> slice_var .)
    EQUAL           shift and go to state 66


state 24

    (35) rule -> slice_assignment . COLON
    (36) rule -> slice_assignment .

    COLON           shift and go to state 67
    PRINT           reduce using rule 36 (rule -> slice_assignment .)
    SCAN            reduce using rule 36 (rule -> slice_assignment .)
    FOR             reduce using rule 36 (rule -> slice_assignment .)
    VAR             reduce using rule 36 (rule -> slice_assignment .)
    ID              reduce using rule 36 (rule -> slice_assignment .)
    APPEND          reduce using rule 36 (rule -> slice_assignment .)
    LEN             reduce using rule 36 (rule -> slice_assignment .)
    COPY            reduce using rule 36 (rule -> slice_assignment .)
    DELETE          reduce using rule 36 (rule -> slice_assignment .)
    IF              reduce using rule 36 (rule -> slice_assignment .)
    ELSE            reduce using rule 36 (rule -> slice_assignment .)
    TYPE            reduce using rule 36 (rule -> slice_assignment .)
    SWITCH          reduce using rule 36 (rule -> slice_assignment .)
    FUNC            reduce using rule 36 (rule -> slice_assignment .)
    INTEGER         reduce using rule 36 (rule -> slice_assignment .)
    FLOAT           reduce using rule 36 (rule -> slice_assignment .)
    NOT             reduce using rule 36 (rule -> slice_assignment .)
    $end            reduce using rule 36 (rule -> slice_assignment .)
    RLLAVE          reduce using rule 36 (rule -> slice_assignment .)
    DEFAULT         reduce using rule 36 (rule -> slice_assignment .)
    CASE            reduce using rule 36 (rule -> slice_assignment .)
    RETURN          reduce using rule 36 (rule -> slice_assignment .)


state 25

    (37) rule -> map_declaration . COLON
    (38) rule -> map_declaration .

    COLON           shift and go to state 68
    PRINT           reduce using rule 38 (rule -> map_declaration .)
    SCAN            reduce using rule 38 (rule -> map_declaration .)
    FOR             reduce using rule 38 (rule -> map_declaration .)
    VAR             reduce using rule 38 (rule -> map_declaration .)
    ID              reduce using rule 38 (rule -> map_declaration .)
    APPEND          reduce using rule 38 (rule -> map_declaration .)
    LEN             reduce using rule 38 (rule -> map_declaration .)
    COPY            reduce using rule 38 (rule -> map_declaration .)
    DELETE          reduce using rule 38 (rule -> map_declaration .)
    IF              reduce using rule 38 (rule -> map_declaration .)
    ELSE            reduce using rule 38 (rule -> map_declaration .)
    TYPE            reduce using rule 38 (rule -> map_declaration .)
    SWITCH          reduce using rule 38 (rule -> map_declaration .)
    FUNC            reduce using rule 38 (rule -> map_declaration .)
    INTEGER         reduce using rule 38 (rule -> map_declaration .)
    FLOAT           reduce using rule 38 (rule -> map_declaration .)
    NOT             reduce using rule 38 (rule -> map_declaration .)
    $end            reduce using rule 38 (rule -> map_declaration .)
    RLLAVE          reduce using rule 38 (rule -> map_declaration .)
    DEFAULT         reduce using rule 38 (rule -> map_declaration .)
    CASE            reduce using rule 38 (rule -> map_declaration .)
    RETURN          reduce using rule 38 (rule -> map_declaration .)


state 26

    (39) rule -> map_assignment . COLON
    (40) rule -> map_assignment .

    COLON           shift and go to state 69
    PRINT           reduce using rule 40 (rule -> map_assignment .)
    SCAN            reduce using rule 40 (rule -> map_assignment .)
    FOR             reduce using rule 40 (rule -> map_assignment .)
    VAR             reduce using rule 40 (rule -> map_assignment .)
    ID              reduce using rule 40 (rule -> map_assignment .)
    APPEND          reduce using rule 40 (rule -> map_assignment .)
    LEN             reduce using rule 40 (rule -> map_assignment .)
    COPY            reduce using rule 40 (rule -> map_assignment .)
    DELETE          reduce using rule 40 (rule -> map_assignment .)
    IF              reduce using rule 40 (rule -> map_assignment .)
    ELSE            reduce using rule 40 (rule -> map_assignment .)
    TYPE            reduce using rule 40 (rule -> map_assignment .)
    SWITCH          reduce using rule 40 (rule -> map_assignment .)
    FUNC            reduce using rule 40 (rule -> map_assignment .)
    INTEGER         reduce using rule 40 (rule -> map_assignment .)
    FLOAT           reduce using rule 40 (rule -> map_assignment .)
    NOT             reduce using rule 40 (rule -> map_assignment .)
    $end            reduce using rule 40 (rule -> map_assignment .)
    RLLAVE          reduce using rule 40 (rule -> map_assignment .)
    DEFAULT         reduce using rule 40 (rule -> map_assignment .)
    CASE            reduce using rule 40 (rule -> map_assignment .)
    RETURN          reduce using rule 40 (rule -> map_assignment .)


state 27

    (41) rule -> func_declaration .

    PRINT           reduce using rule 41 (rule -> func_declaration .)
    SCAN            reduce using rule 41 (rule -> func_declaration .)
    FOR             reduce using rule 41 (rule -> func_declaration .)
    VAR             reduce using rule 41 (rule -> func_declaration .)
    ID              reduce using rule 41 (rule -> func_declaration .)
    APPEND          reduce using rule 41 (rule -> func_declaration .)
    LEN             reduce using rule 41 (rule -> func_declaration .)
    COPY            reduce using rule 41 (rule -> func_declaration .)
    DELETE          reduce using rule 41 (rule -> func_declaration .)
    IF              reduce using rule 41 (rule -> func_declaration .)
    ELSE            reduce using rule 41 (rule -> func_declaration .)
    TYPE            reduce using rule 41 (rule -> func_declaration .)
    SWITCH          reduce using rule 41 (rule -> func_declaration .)
    FUNC            reduce using rule 41 (rule -> func_declaration .)
    INTEGER         reduce using rule 41 (rule -> func_declaration .)
    FLOAT           reduce using rule 41 (rule -> func_declaration .)
    NOT             reduce using rule 41 (rule -> func_declaration .)
    $end            reduce using rule 41 (rule -> func_declaration .)
    RLLAVE          reduce using rule 41 (rule -> func_declaration .)
    DEFAULT         reduce using rule 41 (rule -> func_declaration .)
    CASE            reduce using rule 41 (rule -> func_declaration .)
    RETURN          reduce using rule 41 (rule -> func_declaration .)


state 28

    (42) rule -> main_func .

    PRINT           reduce using rule 42 (rule -> main_func .)
    SCAN            reduce using rule 42 (rule -> main_func .)
    FOR             reduce using rule 42 (rule -> main_func .)
    VAR             reduce using rule 42 (rule -> main_func .)
    ID              reduce using rule 42 (rule -> main_func .)
    APPEND          reduce using rule 42 (rule -> main_func .)
    LEN             reduce using rule 42 (rule -> main_func .)
    COPY            reduce using rule 42 (rule -> main_func .)
    DELETE          reduce using rule 42 (rule -> main_func .)
    IF              reduce using rule 42 (rule -> main_func .)
    ELSE            reduce using rule 42 (rule -> main_func .)
    TYPE            reduce using rule 42 (rule -> main_func .)
    SWITCH          reduce using rule 42 (rule -> main_func .)
    FUNC            reduce using rule 42 (rule -> main_func .)
    INTEGER         reduce using rule 42 (rule -> main_func .)
    FLOAT           reduce using rule 42 (rule -> main_func .)
    NOT             reduce using rule 42 (rule -> main_func .)
    $end            reduce using rule 42 (rule -> main_func .)
    RLLAVE          reduce using rule 42 (rule -> main_func .)
    DEFAULT         reduce using rule 42 (rule -> main_func .)
    CASE            reduce using rule 42 (rule -> main_func .)
    RETURN          reduce using rule 42 (rule -> main_func .)


state 29

    (195) impresion -> PRINT . LPAREN content RPAREN

    LPAREN          shift and go to state 70


state 30

    (79) scan_func -> SCAN . LPAREN POINTER RPAREN

    LPAREN          shift and go to state 71


state 31

    (201) expression -> something_ex .
    (202) expression -> something_ex . adicionaEx
    (203) adicionaEx -> . op something_ex
    (204) adicionaEx -> . op something_ex adicionaEx
    (146) op -> . GREATER
    (147) op -> . SMALLER
    (148) op -> . GREATER_OR_EQUAL
    (149) op -> . SMALLER_OR_EQUAL
    (150) op -> . EQUAL_COMPARE
    (151) op -> . NOT_EQUAL
    (210) op -> . PLUS
    (211) op -> . TIMES
    (212) op -> . DIVIDE
    (213) op -> . MINUS

  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL_COMPARE resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    COLON           reduce using rule 201 (expression -> something_ex .)
    PRINT           reduce using rule 201 (expression -> something_ex .)
    SCAN            reduce using rule 201 (expression -> something_ex .)
    FOR             reduce using rule 201 (expression -> something_ex .)
    VAR             reduce using rule 201 (expression -> something_ex .)
    ID              reduce using rule 201 (expression -> something_ex .)
    APPEND          reduce using rule 201 (expression -> something_ex .)
    LEN             reduce using rule 201 (expression -> something_ex .)
    COPY            reduce using rule 201 (expression -> something_ex .)
    DELETE          reduce using rule 201 (expression -> something_ex .)
    IF              reduce using rule 201 (expression -> something_ex .)
    ELSE            reduce using rule 201 (expression -> something_ex .)
    TYPE            reduce using rule 201 (expression -> something_ex .)
    SWITCH          reduce using rule 201 (expression -> something_ex .)
    FUNC            reduce using rule 201 (expression -> something_ex .)
    INTEGER         reduce using rule 201 (expression -> something_ex .)
    FLOAT           reduce using rule 201 (expression -> something_ex .)
    NOT             reduce using rule 201 (expression -> something_ex .)
    $end            reduce using rule 201 (expression -> something_ex .)
    RLLAVE          reduce using rule 201 (expression -> something_ex .)
    DEFAULT         reduce using rule 201 (expression -> something_ex .)
    CASE            reduce using rule 201 (expression -> something_ex .)
    RETURN          reduce using rule 201 (expression -> something_ex .)
    RPAREN          reduce using rule 201 (expression -> something_ex .)
    AND             reduce using rule 201 (expression -> something_ex .)
    OR              reduce using rule 201 (expression -> something_ex .)
    LLLAVE          reduce using rule 201 (expression -> something_ex .)
    RCORCHE         reduce using rule 201 (expression -> something_ex .)
    COMA            reduce using rule 201 (expression -> something_ex .)
    GREATER         shift and go to state 74
    SMALLER         shift and go to state 75
    GREATER_OR_EQUAL shift and go to state 76
    SMALLER_OR_EQUAL shift and go to state 77
    EQUAL_COMPARE   shift and go to state 78
    NOT_EQUAL       shift and go to state 79
    PLUS            shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MINUS           shift and go to state 83

  ! GREATER         [ reduce using rule 201 (expression -> something_ex .) ]
  ! SMALLER         [ reduce using rule 201 (expression -> something_ex .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 201 (expression -> something_ex .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 201 (expression -> something_ex .) ]
  ! EQUAL_COMPARE   [ reduce using rule 201 (expression -> something_ex .) ]
  ! NOT_EQUAL       [ reduce using rule 201 (expression -> something_ex .) ]
  ! PLUS            [ reduce using rule 201 (expression -> something_ex .) ]
  ! TIMES           [ reduce using rule 201 (expression -> something_ex .) ]
  ! DIVIDE          [ reduce using rule 201 (expression -> something_ex .) ]
  ! MINUS           [ reduce using rule 201 (expression -> something_ex .) ]

    adicionaEx                     shift and go to state 72
    op                             shift and go to state 73

state 32

    (80) cicloFor -> FOR . LLLAVE codigo RLLAVE
    (81) cicloFor -> FOR . comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> FOR . logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> FOR . decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    LLLAVE          shift and go to state 84
    ID              shift and go to state 88
    NOT             shift and go to state 51
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    comparison                     shift and go to state 85
    logic_operation                shift and go to state 86
    decVarOne                      shift and go to state 87
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    expression                     shift and go to state 89
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 33

    (86) decVar -> decVarOne .

    COLON           reduce using rule 86 (decVar -> decVarOne .)
    PRINT           reduce using rule 86 (decVar -> decVarOne .)
    SCAN            reduce using rule 86 (decVar -> decVarOne .)
    FOR             reduce using rule 86 (decVar -> decVarOne .)
    VAR             reduce using rule 86 (decVar -> decVarOne .)
    ID              reduce using rule 86 (decVar -> decVarOne .)
    APPEND          reduce using rule 86 (decVar -> decVarOne .)
    LEN             reduce using rule 86 (decVar -> decVarOne .)
    COPY            reduce using rule 86 (decVar -> decVarOne .)
    DELETE          reduce using rule 86 (decVar -> decVarOne .)
    IF              reduce using rule 86 (decVar -> decVarOne .)
    ELSE            reduce using rule 86 (decVar -> decVarOne .)
    TYPE            reduce using rule 86 (decVar -> decVarOne .)
    SWITCH          reduce using rule 86 (decVar -> decVarOne .)
    FUNC            reduce using rule 86 (decVar -> decVarOne .)
    INTEGER         reduce using rule 86 (decVar -> decVarOne .)
    FLOAT           reduce using rule 86 (decVar -> decVarOne .)
    NOT             reduce using rule 86 (decVar -> decVarOne .)
    $end            reduce using rule 86 (decVar -> decVarOne .)
    RLLAVE          reduce using rule 86 (decVar -> decVarOne .)
    DEFAULT         reduce using rule 86 (decVar -> decVarOne .)
    CASE            reduce using rule 86 (decVar -> decVarOne .)
    RETURN          reduce using rule 86 (decVar -> decVarOne .)


state 34

    (143) comparison -> value . op value
    (146) op -> . GREATER
    (147) op -> . SMALLER
    (148) op -> . GREATER_OR_EQUAL
    (149) op -> . SMALLER_OR_EQUAL
    (150) op -> . EQUAL_COMPARE
    (151) op -> . NOT_EQUAL
    (210) op -> . PLUS
    (211) op -> . TIMES
    (212) op -> . DIVIDE
    (213) op -> . MINUS

    GREATER         shift and go to state 74
    SMALLER         shift and go to state 75
    GREATER_OR_EQUAL shift and go to state 76
    SMALLER_OR_EQUAL shift and go to state 77
    EQUAL_COMPARE   shift and go to state 78
    NOT_EQUAL       shift and go to state 79
    PLUS            shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MINUS           shift and go to state 83

    op                             shift and go to state 92

state 35

    (152) logic_operation -> logic_value . logic_recu
    (154) logic_recu -> . logic_op logic_value
    (155) logic_recu -> . logic_op logic_value logic_recu
    (161) logic_op -> . AND
    (162) logic_op -> . OR

    AND             shift and go to state 95
    OR              shift and go to state 96

    logic_recu                     shift and go to state 93
    logic_op                       shift and go to state 94

state 36

    (153) logic_operation -> negation .
    (156) logic_value -> negation .

    PRINT           reduce using rule 153 (logic_operation -> negation .)
    SCAN            reduce using rule 153 (logic_operation -> negation .)
    FOR             reduce using rule 153 (logic_operation -> negation .)
    VAR             reduce using rule 153 (logic_operation -> negation .)
    ID              reduce using rule 153 (logic_operation -> negation .)
    APPEND          reduce using rule 153 (logic_operation -> negation .)
    LEN             reduce using rule 153 (logic_operation -> negation .)
    COPY            reduce using rule 153 (logic_operation -> negation .)
    DELETE          reduce using rule 153 (logic_operation -> negation .)
    IF              reduce using rule 153 (logic_operation -> negation .)
    ELSE            reduce using rule 153 (logic_operation -> negation .)
    TYPE            reduce using rule 153 (logic_operation -> negation .)
    SWITCH          reduce using rule 153 (logic_operation -> negation .)
    FUNC            reduce using rule 153 (logic_operation -> negation .)
    INTEGER         reduce using rule 153 (logic_operation -> negation .)
    FLOAT           reduce using rule 153 (logic_operation -> negation .)
    NOT             reduce using rule 153 (logic_operation -> negation .)
    $end            reduce using rule 153 (logic_operation -> negation .)
    RLLAVE          reduce using rule 153 (logic_operation -> negation .)
    DEFAULT         reduce using rule 153 (logic_operation -> negation .)
    CASE            reduce using rule 153 (logic_operation -> negation .)
    RETURN          reduce using rule 153 (logic_operation -> negation .)
    LLLAVE          reduce using rule 153 (logic_operation -> negation .)
    COLON           reduce using rule 153 (logic_operation -> negation .)
    RPAREN          reduce using rule 153 (logic_operation -> negation .)
    RCORCHE         reduce using rule 153 (logic_operation -> negation .)
    COMA            reduce using rule 153 (logic_operation -> negation .)
    AND             reduce using rule 156 (logic_value -> negation .)
    OR              reduce using rule 156 (logic_value -> negation .)


state 37

    (87) decVar -> VAR . ID EQUAL INTEGER
    (88) decVar -> VAR . ID EQUAL ID
    (89) decVar -> VAR . ID EQUAL FLOAT
    (90) decVar -> VAR . ID EQUAL expression
    (91) decVar -> VAR . ID EQUAL logic_operation
    (92) decVar -> VAR . ID EQUAL comparison
    (93) decVar -> VAR . ID EQUAL STRING
    (168) array_declaration -> VAR . ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> VAR . ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (99) slice_declaration -> VAR . ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> VAR . ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> VAR . ID EQUAL funM
    (178) map_declaration -> VAR . ID LCORCHE data_types RCORCHE data_types

    ID              shift and go to state 97


state 38

    (94) decVar -> ID . DEQUAL STRING
    (95) decVar -> ID . DEQUAL FLOAT
    (96) decVar -> ID . DEQUAL expression
    (97) decVar -> ID . DEQUAL logic_operation
    (98) decVar -> ID . DEQUAL comparison
    (62) var_asignation -> ID . EQUAL any
    (136) cStruct -> ID . DEQUAL ID LLLAVE asignaciones RLLAVE
    (173) array_var -> ID . LCORCHE index RCORCHE
    (102) slice_declaration -> ID . DEQUAL funM
    (103) slice_declaration -> ID . DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> ID . LCORCHE index_s RCORCHE
    (205) something_ex -> ID .
    (144) value -> ID .
    (158) logic_value -> ID .
    (123) decVarOne -> ID . DEQUAL ID
    (124) decVarOne -> ID . DEQUAL INTEGER
    (179) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 144 (value -> ID .)
    DEQUAL          shift and go to state 98
    EQUAL           shift and go to state 99
    LCORCHE         shift and go to state 100
    COLON           reduce using rule 205 (something_ex -> ID .)
    PRINT           reduce using rule 205 (something_ex -> ID .)
    SCAN            reduce using rule 205 (something_ex -> ID .)
    FOR             reduce using rule 205 (something_ex -> ID .)
    VAR             reduce using rule 205 (something_ex -> ID .)
    ID              reduce using rule 205 (something_ex -> ID .)
    APPEND          reduce using rule 205 (something_ex -> ID .)
    LEN             reduce using rule 205 (something_ex -> ID .)
    COPY            reduce using rule 205 (something_ex -> ID .)
    DELETE          reduce using rule 205 (something_ex -> ID .)
    IF              reduce using rule 205 (something_ex -> ID .)
    ELSE            reduce using rule 205 (something_ex -> ID .)
    TYPE            reduce using rule 205 (something_ex -> ID .)
    SWITCH          reduce using rule 205 (something_ex -> ID .)
    FUNC            reduce using rule 205 (something_ex -> ID .)
    INTEGER         reduce using rule 205 (something_ex -> ID .)
    FLOAT           reduce using rule 205 (something_ex -> ID .)
    NOT             reduce using rule 205 (something_ex -> ID .)
    $end            reduce using rule 205 (something_ex -> ID .)
    RLLAVE          reduce using rule 205 (something_ex -> ID .)
    DEFAULT         reduce using rule 205 (something_ex -> ID .)
    CASE            reduce using rule 205 (something_ex -> ID .)
    RETURN          reduce using rule 205 (something_ex -> ID .)
    GREATER         reduce using rule 144 (value -> ID .)
    SMALLER         reduce using rule 144 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 144 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 144 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 144 (value -> ID .)
    NOT_EQUAL       reduce using rule 144 (value -> ID .)
    PLUS            reduce using rule 144 (value -> ID .)
    TIMES           reduce using rule 144 (value -> ID .)
    DIVIDE          reduce using rule 144 (value -> ID .)
    MINUS           reduce using rule 144 (value -> ID .)
    AND             reduce using rule 158 (logic_value -> ID .)
    OR              reduce using rule 158 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 205 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 205 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 205 (something_ex -> ID .) ]


state 39

    (206) something_ex -> INTEGER .

    GREATER         reduce using rule 206 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 206 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 206 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 206 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 206 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 206 (something_ex -> INTEGER .)
    PLUS            reduce using rule 206 (something_ex -> INTEGER .)
    TIMES           reduce using rule 206 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 206 (something_ex -> INTEGER .)
    MINUS           reduce using rule 206 (something_ex -> INTEGER .)
    COLON           reduce using rule 206 (something_ex -> INTEGER .)
    PRINT           reduce using rule 206 (something_ex -> INTEGER .)
    SCAN            reduce using rule 206 (something_ex -> INTEGER .)
    FOR             reduce using rule 206 (something_ex -> INTEGER .)
    VAR             reduce using rule 206 (something_ex -> INTEGER .)
    ID              reduce using rule 206 (something_ex -> INTEGER .)
    APPEND          reduce using rule 206 (something_ex -> INTEGER .)
    LEN             reduce using rule 206 (something_ex -> INTEGER .)
    COPY            reduce using rule 206 (something_ex -> INTEGER .)
    DELETE          reduce using rule 206 (something_ex -> INTEGER .)
    IF              reduce using rule 206 (something_ex -> INTEGER .)
    ELSE            reduce using rule 206 (something_ex -> INTEGER .)
    TYPE            reduce using rule 206 (something_ex -> INTEGER .)
    SWITCH          reduce using rule 206 (something_ex -> INTEGER .)
    FUNC            reduce using rule 206 (something_ex -> INTEGER .)
    INTEGER         reduce using rule 206 (something_ex -> INTEGER .)
    FLOAT           reduce using rule 206 (something_ex -> INTEGER .)
    NOT             reduce using rule 206 (something_ex -> INTEGER .)
    $end            reduce using rule 206 (something_ex -> INTEGER .)
    RLLAVE          reduce using rule 206 (something_ex -> INTEGER .)
    DEFAULT         reduce using rule 206 (something_ex -> INTEGER .)
    CASE            reduce using rule 206 (something_ex -> INTEGER .)
    RETURN          reduce using rule 206 (something_ex -> INTEGER .)
    RPAREN          reduce using rule 206 (something_ex -> INTEGER .)
    AND             reduce using rule 206 (something_ex -> INTEGER .)
    OR              reduce using rule 206 (something_ex -> INTEGER .)
    LLLAVE          reduce using rule 206 (something_ex -> INTEGER .)
    RCORCHE         reduce using rule 206 (something_ex -> INTEGER .)
    COMA            reduce using rule 206 (something_ex -> INTEGER .)


state 40

    (207) something_ex -> FLOAT .

    GREATER         reduce using rule 207 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 207 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 207 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 207 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 207 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 207 (something_ex -> FLOAT .)
    PLUS            reduce using rule 207 (something_ex -> FLOAT .)
    TIMES           reduce using rule 207 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 207 (something_ex -> FLOAT .)
    MINUS           reduce using rule 207 (something_ex -> FLOAT .)
    COLON           reduce using rule 207 (something_ex -> FLOAT .)
    PRINT           reduce using rule 207 (something_ex -> FLOAT .)
    SCAN            reduce using rule 207 (something_ex -> FLOAT .)
    FOR             reduce using rule 207 (something_ex -> FLOAT .)
    VAR             reduce using rule 207 (something_ex -> FLOAT .)
    ID              reduce using rule 207 (something_ex -> FLOAT .)
    APPEND          reduce using rule 207 (something_ex -> FLOAT .)
    LEN             reduce using rule 207 (something_ex -> FLOAT .)
    COPY            reduce using rule 207 (something_ex -> FLOAT .)
    DELETE          reduce using rule 207 (something_ex -> FLOAT .)
    IF              reduce using rule 207 (something_ex -> FLOAT .)
    ELSE            reduce using rule 207 (something_ex -> FLOAT .)
    TYPE            reduce using rule 207 (something_ex -> FLOAT .)
    SWITCH          reduce using rule 207 (something_ex -> FLOAT .)
    FUNC            reduce using rule 207 (something_ex -> FLOAT .)
    INTEGER         reduce using rule 207 (something_ex -> FLOAT .)
    FLOAT           reduce using rule 207 (something_ex -> FLOAT .)
    NOT             reduce using rule 207 (something_ex -> FLOAT .)
    $end            reduce using rule 207 (something_ex -> FLOAT .)
    RLLAVE          reduce using rule 207 (something_ex -> FLOAT .)
    DEFAULT         reduce using rule 207 (something_ex -> FLOAT .)
    CASE            reduce using rule 207 (something_ex -> FLOAT .)
    RETURN          reduce using rule 207 (something_ex -> FLOAT .)
    RPAREN          reduce using rule 207 (something_ex -> FLOAT .)
    AND             reduce using rule 207 (something_ex -> FLOAT .)
    OR              reduce using rule 207 (something_ex -> FLOAT .)
    LLLAVE          reduce using rule 207 (something_ex -> FLOAT .)
    RCORCHE         reduce using rule 207 (something_ex -> FLOAT .)
    COMA            reduce using rule 207 (something_ex -> FLOAT .)


state 41

    (118) funciones -> APPEND . LPAREN ID COMA values RPAREN
    (119) funciones -> APPEND . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 101


state 42

    (120) funciones -> LEN . LPAREN ID RPAREN

    LPAREN          shift and go to state 102


state 43

    (121) funciones -> COPY . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 103


state 44

    (122) funciones -> DELETE . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 104


state 45

    (125) SenIF -> IF . comparison LLLAVE codigo RLLAVE
    (126) SenIF -> IF . TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> IF . FALSE LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (144) value -> . ID
    (145) value -> . expression
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    TRUE            shift and go to state 106
    FALSE           shift and go to state 107
    ID              shift and go to state 108
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    comparison                     shift and go to state 105
    value                          shift and go to state 34
    expression                     shift and go to state 89
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 46

    (128) SenElseIF -> ELSE . IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> ELSE . IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> ELSE . IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> ELSE . LLLAVE codigo RLLAVE

    IF              shift and go to state 109
    LLLAVE          shift and go to state 110


state 47

    (132) SenStruct -> TYPE . ID STRUCT LLLAVE declaration RLLAVE

    ID              shift and go to state 111


state 48

    (163) switch_statement -> SWITCH . ID LLLAVE cases RLLAVE

    ID              shift and go to state 112


state 49

    (184) func_declaration -> FUNC . ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> FUNC . ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> FUNC . MAIN LPAREN RPAREN LLLAVE codigo RLLAVE

    ID              shift and go to state 113
    MAIN            shift and go to state 114


state 50

    (208) something_ex -> data_structure .

    GREATER         reduce using rule 208 (something_ex -> data_structure .)
    SMALLER         reduce using rule 208 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 208 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 208 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 208 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 208 (something_ex -> data_structure .)
    PLUS            reduce using rule 208 (something_ex -> data_structure .)
    TIMES           reduce using rule 208 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 208 (something_ex -> data_structure .)
    MINUS           reduce using rule 208 (something_ex -> data_structure .)
    COLON           reduce using rule 208 (something_ex -> data_structure .)
    PRINT           reduce using rule 208 (something_ex -> data_structure .)
    SCAN            reduce using rule 208 (something_ex -> data_structure .)
    FOR             reduce using rule 208 (something_ex -> data_structure .)
    VAR             reduce using rule 208 (something_ex -> data_structure .)
    ID              reduce using rule 208 (something_ex -> data_structure .)
    APPEND          reduce using rule 208 (something_ex -> data_structure .)
    LEN             reduce using rule 208 (something_ex -> data_structure .)
    COPY            reduce using rule 208 (something_ex -> data_structure .)
    DELETE          reduce using rule 208 (something_ex -> data_structure .)
    IF              reduce using rule 208 (something_ex -> data_structure .)
    ELSE            reduce using rule 208 (something_ex -> data_structure .)
    TYPE            reduce using rule 208 (something_ex -> data_structure .)
    SWITCH          reduce using rule 208 (something_ex -> data_structure .)
    FUNC            reduce using rule 208 (something_ex -> data_structure .)
    INTEGER         reduce using rule 208 (something_ex -> data_structure .)
    FLOAT           reduce using rule 208 (something_ex -> data_structure .)
    NOT             reduce using rule 208 (something_ex -> data_structure .)
    $end            reduce using rule 208 (something_ex -> data_structure .)
    RLLAVE          reduce using rule 208 (something_ex -> data_structure .)
    DEFAULT         reduce using rule 208 (something_ex -> data_structure .)
    CASE            reduce using rule 208 (something_ex -> data_structure .)
    RETURN          reduce using rule 208 (something_ex -> data_structure .)
    RPAREN          reduce using rule 208 (something_ex -> data_structure .)
    AND             reduce using rule 208 (something_ex -> data_structure .)
    OR              reduce using rule 208 (something_ex -> data_structure .)
    LLLAVE          reduce using rule 208 (something_ex -> data_structure .)
    RCORCHE         reduce using rule 208 (something_ex -> data_structure .)
    COMA            reduce using rule 208 (something_ex -> data_structure .)


state 51

    (159) negation -> NOT . comparison
    (160) negation -> NOT . ID
    (143) comparison -> . value op value
    (144) value -> . ID
    (145) value -> . expression
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 116
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    comparison                     shift and go to state 115
    value                          shift and go to state 34
    expression                     shift and go to state 89
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 52

    (61) data_structure -> map_var .

    GREATER         reduce using rule 61 (data_structure -> map_var .)
    SMALLER         reduce using rule 61 (data_structure -> map_var .)
    GREATER_OR_EQUAL reduce using rule 61 (data_structure -> map_var .)
    SMALLER_OR_EQUAL reduce using rule 61 (data_structure -> map_var .)
    EQUAL_COMPARE   reduce using rule 61 (data_structure -> map_var .)
    NOT_EQUAL       reduce using rule 61 (data_structure -> map_var .)
    PLUS            reduce using rule 61 (data_structure -> map_var .)
    TIMES           reduce using rule 61 (data_structure -> map_var .)
    DIVIDE          reduce using rule 61 (data_structure -> map_var .)
    MINUS           reduce using rule 61 (data_structure -> map_var .)
    COLON           reduce using rule 61 (data_structure -> map_var .)
    PRINT           reduce using rule 61 (data_structure -> map_var .)
    SCAN            reduce using rule 61 (data_structure -> map_var .)
    FOR             reduce using rule 61 (data_structure -> map_var .)
    VAR             reduce using rule 61 (data_structure -> map_var .)
    ID              reduce using rule 61 (data_structure -> map_var .)
    APPEND          reduce using rule 61 (data_structure -> map_var .)
    LEN             reduce using rule 61 (data_structure -> map_var .)
    COPY            reduce using rule 61 (data_structure -> map_var .)
    DELETE          reduce using rule 61 (data_structure -> map_var .)
    IF              reduce using rule 61 (data_structure -> map_var .)
    ELSE            reduce using rule 61 (data_structure -> map_var .)
    TYPE            reduce using rule 61 (data_structure -> map_var .)
    SWITCH          reduce using rule 61 (data_structure -> map_var .)
    FUNC            reduce using rule 61 (data_structure -> map_var .)
    INTEGER         reduce using rule 61 (data_structure -> map_var .)
    FLOAT           reduce using rule 61 (data_structure -> map_var .)
    NOT             reduce using rule 61 (data_structure -> map_var .)
    $end            reduce using rule 61 (data_structure -> map_var .)
    RLLAVE          reduce using rule 61 (data_structure -> map_var .)
    DEFAULT         reduce using rule 61 (data_structure -> map_var .)
    CASE            reduce using rule 61 (data_structure -> map_var .)
    RETURN          reduce using rule 61 (data_structure -> map_var .)
    RPAREN          reduce using rule 61 (data_structure -> map_var .)
    AND             reduce using rule 61 (data_structure -> map_var .)
    OR              reduce using rule 61 (data_structure -> map_var .)
    LLLAVE          reduce using rule 61 (data_structure -> map_var .)
    RCORCHE         reduce using rule 61 (data_structure -> map_var .)
    COMA            reduce using rule 61 (data_structure -> map_var .)


state 53

    (3) more_rules -> rule codigo .

    $end            reduce using rule 3 (more_rules -> rule codigo .)
    RLLAVE          reduce using rule 3 (more_rules -> rule codigo .)
    DEFAULT         reduce using rule 3 (more_rules -> rule codigo .)
    CASE            reduce using rule 3 (more_rules -> rule codigo .)
    RETURN          reduce using rule 3 (more_rules -> rule codigo .)


state 54

    (4) rule -> impresion COLON .

    PRINT           reduce using rule 4 (rule -> impresion COLON .)
    SCAN            reduce using rule 4 (rule -> impresion COLON .)
    FOR             reduce using rule 4 (rule -> impresion COLON .)
    VAR             reduce using rule 4 (rule -> impresion COLON .)
    ID              reduce using rule 4 (rule -> impresion COLON .)
    APPEND          reduce using rule 4 (rule -> impresion COLON .)
    LEN             reduce using rule 4 (rule -> impresion COLON .)
    COPY            reduce using rule 4 (rule -> impresion COLON .)
    DELETE          reduce using rule 4 (rule -> impresion COLON .)
    IF              reduce using rule 4 (rule -> impresion COLON .)
    ELSE            reduce using rule 4 (rule -> impresion COLON .)
    TYPE            reduce using rule 4 (rule -> impresion COLON .)
    SWITCH          reduce using rule 4 (rule -> impresion COLON .)
    FUNC            reduce using rule 4 (rule -> impresion COLON .)
    INTEGER         reduce using rule 4 (rule -> impresion COLON .)
    FLOAT           reduce using rule 4 (rule -> impresion COLON .)
    NOT             reduce using rule 4 (rule -> impresion COLON .)
    $end            reduce using rule 4 (rule -> impresion COLON .)
    RLLAVE          reduce using rule 4 (rule -> impresion COLON .)
    DEFAULT         reduce using rule 4 (rule -> impresion COLON .)
    CASE            reduce using rule 4 (rule -> impresion COLON .)
    RETURN          reduce using rule 4 (rule -> impresion COLON .)


state 55

    (6) rule -> scan_func COLON .

    PRINT           reduce using rule 6 (rule -> scan_func COLON .)
    SCAN            reduce using rule 6 (rule -> scan_func COLON .)
    FOR             reduce using rule 6 (rule -> scan_func COLON .)
    VAR             reduce using rule 6 (rule -> scan_func COLON .)
    ID              reduce using rule 6 (rule -> scan_func COLON .)
    APPEND          reduce using rule 6 (rule -> scan_func COLON .)
    LEN             reduce using rule 6 (rule -> scan_func COLON .)
    COPY            reduce using rule 6 (rule -> scan_func COLON .)
    DELETE          reduce using rule 6 (rule -> scan_func COLON .)
    IF              reduce using rule 6 (rule -> scan_func COLON .)
    ELSE            reduce using rule 6 (rule -> scan_func COLON .)
    TYPE            reduce using rule 6 (rule -> scan_func COLON .)
    SWITCH          reduce using rule 6 (rule -> scan_func COLON .)
    FUNC            reduce using rule 6 (rule -> scan_func COLON .)
    INTEGER         reduce using rule 6 (rule -> scan_func COLON .)
    FLOAT           reduce using rule 6 (rule -> scan_func COLON .)
    NOT             reduce using rule 6 (rule -> scan_func COLON .)
    $end            reduce using rule 6 (rule -> scan_func COLON .)
    RLLAVE          reduce using rule 6 (rule -> scan_func COLON .)
    DEFAULT         reduce using rule 6 (rule -> scan_func COLON .)
    CASE            reduce using rule 6 (rule -> scan_func COLON .)
    RETURN          reduce using rule 6 (rule -> scan_func COLON .)


state 56

    (8) rule -> expression COLON .

    PRINT           reduce using rule 8 (rule -> expression COLON .)
    SCAN            reduce using rule 8 (rule -> expression COLON .)
    FOR             reduce using rule 8 (rule -> expression COLON .)
    VAR             reduce using rule 8 (rule -> expression COLON .)
    ID              reduce using rule 8 (rule -> expression COLON .)
    APPEND          reduce using rule 8 (rule -> expression COLON .)
    LEN             reduce using rule 8 (rule -> expression COLON .)
    COPY            reduce using rule 8 (rule -> expression COLON .)
    DELETE          reduce using rule 8 (rule -> expression COLON .)
    IF              reduce using rule 8 (rule -> expression COLON .)
    ELSE            reduce using rule 8 (rule -> expression COLON .)
    TYPE            reduce using rule 8 (rule -> expression COLON .)
    SWITCH          reduce using rule 8 (rule -> expression COLON .)
    FUNC            reduce using rule 8 (rule -> expression COLON .)
    INTEGER         reduce using rule 8 (rule -> expression COLON .)
    FLOAT           reduce using rule 8 (rule -> expression COLON .)
    NOT             reduce using rule 8 (rule -> expression COLON .)
    $end            reduce using rule 8 (rule -> expression COLON .)
    RLLAVE          reduce using rule 8 (rule -> expression COLON .)
    DEFAULT         reduce using rule 8 (rule -> expression COLON .)
    CASE            reduce using rule 8 (rule -> expression COLON .)
    RETURN          reduce using rule 8 (rule -> expression COLON .)


state 57

    (13) rule -> decVar COLON .

    PRINT           reduce using rule 13 (rule -> decVar COLON .)
    SCAN            reduce using rule 13 (rule -> decVar COLON .)
    FOR             reduce using rule 13 (rule -> decVar COLON .)
    VAR             reduce using rule 13 (rule -> decVar COLON .)
    ID              reduce using rule 13 (rule -> decVar COLON .)
    APPEND          reduce using rule 13 (rule -> decVar COLON .)
    LEN             reduce using rule 13 (rule -> decVar COLON .)
    COPY            reduce using rule 13 (rule -> decVar COLON .)
    DELETE          reduce using rule 13 (rule -> decVar COLON .)
    IF              reduce using rule 13 (rule -> decVar COLON .)
    ELSE            reduce using rule 13 (rule -> decVar COLON .)
    TYPE            reduce using rule 13 (rule -> decVar COLON .)
    SWITCH          reduce using rule 13 (rule -> decVar COLON .)
    FUNC            reduce using rule 13 (rule -> decVar COLON .)
    INTEGER         reduce using rule 13 (rule -> decVar COLON .)
    FLOAT           reduce using rule 13 (rule -> decVar COLON .)
    NOT             reduce using rule 13 (rule -> decVar COLON .)
    $end            reduce using rule 13 (rule -> decVar COLON .)
    RLLAVE          reduce using rule 13 (rule -> decVar COLON .)
    DEFAULT         reduce using rule 13 (rule -> decVar COLON .)
    CASE            reduce using rule 13 (rule -> decVar COLON .)
    RETURN          reduce using rule 13 (rule -> decVar COLON .)


state 58

    (16) rule -> var_asignation COLON .

    PRINT           reduce using rule 16 (rule -> var_asignation COLON .)
    SCAN            reduce using rule 16 (rule -> var_asignation COLON .)
    FOR             reduce using rule 16 (rule -> var_asignation COLON .)
    VAR             reduce using rule 16 (rule -> var_asignation COLON .)
    ID              reduce using rule 16 (rule -> var_asignation COLON .)
    APPEND          reduce using rule 16 (rule -> var_asignation COLON .)
    LEN             reduce using rule 16 (rule -> var_asignation COLON .)
    COPY            reduce using rule 16 (rule -> var_asignation COLON .)
    DELETE          reduce using rule 16 (rule -> var_asignation COLON .)
    IF              reduce using rule 16 (rule -> var_asignation COLON .)
    ELSE            reduce using rule 16 (rule -> var_asignation COLON .)
    TYPE            reduce using rule 16 (rule -> var_asignation COLON .)
    SWITCH          reduce using rule 16 (rule -> var_asignation COLON .)
    FUNC            reduce using rule 16 (rule -> var_asignation COLON .)
    INTEGER         reduce using rule 16 (rule -> var_asignation COLON .)
    FLOAT           reduce using rule 16 (rule -> var_asignation COLON .)
    NOT             reduce using rule 16 (rule -> var_asignation COLON .)
    $end            reduce using rule 16 (rule -> var_asignation COLON .)
    RLLAVE          reduce using rule 16 (rule -> var_asignation COLON .)
    DEFAULT         reduce using rule 16 (rule -> var_asignation COLON .)
    CASE            reduce using rule 16 (rule -> var_asignation COLON .)
    RETURN          reduce using rule 16 (rule -> var_asignation COLON .)


state 59

    (18) rule -> funciones COLON .

    PRINT           reduce using rule 18 (rule -> funciones COLON .)
    SCAN            reduce using rule 18 (rule -> funciones COLON .)
    FOR             reduce using rule 18 (rule -> funciones COLON .)
    VAR             reduce using rule 18 (rule -> funciones COLON .)
    ID              reduce using rule 18 (rule -> funciones COLON .)
    APPEND          reduce using rule 18 (rule -> funciones COLON .)
    LEN             reduce using rule 18 (rule -> funciones COLON .)
    COPY            reduce using rule 18 (rule -> funciones COLON .)
    DELETE          reduce using rule 18 (rule -> funciones COLON .)
    IF              reduce using rule 18 (rule -> funciones COLON .)
    ELSE            reduce using rule 18 (rule -> funciones COLON .)
    TYPE            reduce using rule 18 (rule -> funciones COLON .)
    SWITCH          reduce using rule 18 (rule -> funciones COLON .)
    FUNC            reduce using rule 18 (rule -> funciones COLON .)
    INTEGER         reduce using rule 18 (rule -> funciones COLON .)
    FLOAT           reduce using rule 18 (rule -> funciones COLON .)
    NOT             reduce using rule 18 (rule -> funciones COLON .)
    $end            reduce using rule 18 (rule -> funciones COLON .)
    RLLAVE          reduce using rule 18 (rule -> funciones COLON .)
    DEFAULT         reduce using rule 18 (rule -> funciones COLON .)
    CASE            reduce using rule 18 (rule -> funciones COLON .)
    RETURN          reduce using rule 18 (rule -> funciones COLON .)


state 60

    (25) rule -> array_declaration COLON .

    PRINT           reduce using rule 25 (rule -> array_declaration COLON .)
    SCAN            reduce using rule 25 (rule -> array_declaration COLON .)
    FOR             reduce using rule 25 (rule -> array_declaration COLON .)
    VAR             reduce using rule 25 (rule -> array_declaration COLON .)
    ID              reduce using rule 25 (rule -> array_declaration COLON .)
    APPEND          reduce using rule 25 (rule -> array_declaration COLON .)
    LEN             reduce using rule 25 (rule -> array_declaration COLON .)
    COPY            reduce using rule 25 (rule -> array_declaration COLON .)
    DELETE          reduce using rule 25 (rule -> array_declaration COLON .)
    IF              reduce using rule 25 (rule -> array_declaration COLON .)
    ELSE            reduce using rule 25 (rule -> array_declaration COLON .)
    TYPE            reduce using rule 25 (rule -> array_declaration COLON .)
    SWITCH          reduce using rule 25 (rule -> array_declaration COLON .)
    FUNC            reduce using rule 25 (rule -> array_declaration COLON .)
    INTEGER         reduce using rule 25 (rule -> array_declaration COLON .)
    FLOAT           reduce using rule 25 (rule -> array_declaration COLON .)
    NOT             reduce using rule 25 (rule -> array_declaration COLON .)
    $end            reduce using rule 25 (rule -> array_declaration COLON .)
    RLLAVE          reduce using rule 25 (rule -> array_declaration COLON .)
    DEFAULT         reduce using rule 25 (rule -> array_declaration COLON .)
    CASE            reduce using rule 25 (rule -> array_declaration COLON .)
    RETURN          reduce using rule 25 (rule -> array_declaration COLON .)


state 61

    (27) rule -> array_var COLON .

    PRINT           reduce using rule 27 (rule -> array_var COLON .)
    SCAN            reduce using rule 27 (rule -> array_var COLON .)
    FOR             reduce using rule 27 (rule -> array_var COLON .)
    VAR             reduce using rule 27 (rule -> array_var COLON .)
    ID              reduce using rule 27 (rule -> array_var COLON .)
    APPEND          reduce using rule 27 (rule -> array_var COLON .)
    LEN             reduce using rule 27 (rule -> array_var COLON .)
    COPY            reduce using rule 27 (rule -> array_var COLON .)
    DELETE          reduce using rule 27 (rule -> array_var COLON .)
    IF              reduce using rule 27 (rule -> array_var COLON .)
    ELSE            reduce using rule 27 (rule -> array_var COLON .)
    TYPE            reduce using rule 27 (rule -> array_var COLON .)
    SWITCH          reduce using rule 27 (rule -> array_var COLON .)
    FUNC            reduce using rule 27 (rule -> array_var COLON .)
    INTEGER         reduce using rule 27 (rule -> array_var COLON .)
    FLOAT           reduce using rule 27 (rule -> array_var COLON .)
    NOT             reduce using rule 27 (rule -> array_var COLON .)
    $end            reduce using rule 27 (rule -> array_var COLON .)
    RLLAVE          reduce using rule 27 (rule -> array_var COLON .)
    DEFAULT         reduce using rule 27 (rule -> array_var COLON .)
    CASE            reduce using rule 27 (rule -> array_var COLON .)
    RETURN          reduce using rule 27 (rule -> array_var COLON .)


state 62

    (177) array_assignment -> array_var EQUAL . something
    (183) map_assignment -> array_var EQUAL . something
    (74) something -> . ID
    (75) something -> . data_structure
    (76) something -> . values
    (77) something -> . operations
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN

    ID              shift and go to state 118
    STRING          shift and go to state 122
    INTEGER         shift and go to state 123
    FLOAT           shift and go to state 124
    TRUE            shift and go to state 125
    FALSE           shift and go to state 126
    NOT             shift and go to state 51
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    array_var                      shift and go to state 91
    something                      shift and go to state 117
    data_structure                 shift and go to state 119
    values                         shift and go to state 120
    operations                     shift and go to state 121
    map_var                        shift and go to state 52
    expression                     shift and go to state 127
    comparison                     shift and go to state 128
    logic_operation                shift and go to state 129
    something_ex                   shift and go to state 31
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    funciones                      shift and go to state 90

state 63

    (29) rule -> array_assignment COLON .

    PRINT           reduce using rule 29 (rule -> array_assignment COLON .)
    SCAN            reduce using rule 29 (rule -> array_assignment COLON .)
    FOR             reduce using rule 29 (rule -> array_assignment COLON .)
    VAR             reduce using rule 29 (rule -> array_assignment COLON .)
    ID              reduce using rule 29 (rule -> array_assignment COLON .)
    APPEND          reduce using rule 29 (rule -> array_assignment COLON .)
    LEN             reduce using rule 29 (rule -> array_assignment COLON .)
    COPY            reduce using rule 29 (rule -> array_assignment COLON .)
    DELETE          reduce using rule 29 (rule -> array_assignment COLON .)
    IF              reduce using rule 29 (rule -> array_assignment COLON .)
    ELSE            reduce using rule 29 (rule -> array_assignment COLON .)
    TYPE            reduce using rule 29 (rule -> array_assignment COLON .)
    SWITCH          reduce using rule 29 (rule -> array_assignment COLON .)
    FUNC            reduce using rule 29 (rule -> array_assignment COLON .)
    INTEGER         reduce using rule 29 (rule -> array_assignment COLON .)
    FLOAT           reduce using rule 29 (rule -> array_assignment COLON .)
    NOT             reduce using rule 29 (rule -> array_assignment COLON .)
    $end            reduce using rule 29 (rule -> array_assignment COLON .)
    RLLAVE          reduce using rule 29 (rule -> array_assignment COLON .)
    DEFAULT         reduce using rule 29 (rule -> array_assignment COLON .)
    CASE            reduce using rule 29 (rule -> array_assignment COLON .)
    RETURN          reduce using rule 29 (rule -> array_assignment COLON .)


state 64

    (31) rule -> slice_declaration COLON .

    PRINT           reduce using rule 31 (rule -> slice_declaration COLON .)
    SCAN            reduce using rule 31 (rule -> slice_declaration COLON .)
    FOR             reduce using rule 31 (rule -> slice_declaration COLON .)
    VAR             reduce using rule 31 (rule -> slice_declaration COLON .)
    ID              reduce using rule 31 (rule -> slice_declaration COLON .)
    APPEND          reduce using rule 31 (rule -> slice_declaration COLON .)
    LEN             reduce using rule 31 (rule -> slice_declaration COLON .)
    COPY            reduce using rule 31 (rule -> slice_declaration COLON .)
    DELETE          reduce using rule 31 (rule -> slice_declaration COLON .)
    IF              reduce using rule 31 (rule -> slice_declaration COLON .)
    ELSE            reduce using rule 31 (rule -> slice_declaration COLON .)
    TYPE            reduce using rule 31 (rule -> slice_declaration COLON .)
    SWITCH          reduce using rule 31 (rule -> slice_declaration COLON .)
    FUNC            reduce using rule 31 (rule -> slice_declaration COLON .)
    INTEGER         reduce using rule 31 (rule -> slice_declaration COLON .)
    FLOAT           reduce using rule 31 (rule -> slice_declaration COLON .)
    NOT             reduce using rule 31 (rule -> slice_declaration COLON .)
    $end            reduce using rule 31 (rule -> slice_declaration COLON .)
    RLLAVE          reduce using rule 31 (rule -> slice_declaration COLON .)
    DEFAULT         reduce using rule 31 (rule -> slice_declaration COLON .)
    CASE            reduce using rule 31 (rule -> slice_declaration COLON .)
    RETURN          reduce using rule 31 (rule -> slice_declaration COLON .)


state 65

    (33) rule -> slice_var COLON .

    PRINT           reduce using rule 33 (rule -> slice_var COLON .)
    SCAN            reduce using rule 33 (rule -> slice_var COLON .)
    FOR             reduce using rule 33 (rule -> slice_var COLON .)
    VAR             reduce using rule 33 (rule -> slice_var COLON .)
    ID              reduce using rule 33 (rule -> slice_var COLON .)
    APPEND          reduce using rule 33 (rule -> slice_var COLON .)
    LEN             reduce using rule 33 (rule -> slice_var COLON .)
    COPY            reduce using rule 33 (rule -> slice_var COLON .)
    DELETE          reduce using rule 33 (rule -> slice_var COLON .)
    IF              reduce using rule 33 (rule -> slice_var COLON .)
    ELSE            reduce using rule 33 (rule -> slice_var COLON .)
    TYPE            reduce using rule 33 (rule -> slice_var COLON .)
    SWITCH          reduce using rule 33 (rule -> slice_var COLON .)
    FUNC            reduce using rule 33 (rule -> slice_var COLON .)
    INTEGER         reduce using rule 33 (rule -> slice_var COLON .)
    FLOAT           reduce using rule 33 (rule -> slice_var COLON .)
    NOT             reduce using rule 33 (rule -> slice_var COLON .)
    $end            reduce using rule 33 (rule -> slice_var COLON .)
    RLLAVE          reduce using rule 33 (rule -> slice_var COLON .)
    DEFAULT         reduce using rule 33 (rule -> slice_var COLON .)
    CASE            reduce using rule 33 (rule -> slice_var COLON .)
    RETURN          reduce using rule 33 (rule -> slice_var COLON .)


state 66

    (113) slice_assignment -> slice_var EQUAL . something_s
    (114) something_s -> . ID
    (115) something_s -> . array_var
    (116) something_s -> . values
    (117) something_s -> . operations
    (173) array_var -> . ID LCORCHE index RCORCHE
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (179) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 131
    STRING          shift and go to state 122
    INTEGER         shift and go to state 123
    FLOAT           shift and go to state 124
    TRUE            shift and go to state 125
    FALSE           shift and go to state 126
    NOT             shift and go to state 51
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    something_s                    shift and go to state 130
    array_var                      shift and go to state 132
    values                         shift and go to state 133
    operations                     shift and go to state 134
    expression                     shift and go to state 127
    comparison                     shift and go to state 128
    logic_operation                shift and go to state 129
    something_ex                   shift and go to state 31
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    map_var                        shift and go to state 52

state 67

    (35) rule -> slice_assignment COLON .

    PRINT           reduce using rule 35 (rule -> slice_assignment COLON .)
    SCAN            reduce using rule 35 (rule -> slice_assignment COLON .)
    FOR             reduce using rule 35 (rule -> slice_assignment COLON .)
    VAR             reduce using rule 35 (rule -> slice_assignment COLON .)
    ID              reduce using rule 35 (rule -> slice_assignment COLON .)
    APPEND          reduce using rule 35 (rule -> slice_assignment COLON .)
    LEN             reduce using rule 35 (rule -> slice_assignment COLON .)
    COPY            reduce using rule 35 (rule -> slice_assignment COLON .)
    DELETE          reduce using rule 35 (rule -> slice_assignment COLON .)
    IF              reduce using rule 35 (rule -> slice_assignment COLON .)
    ELSE            reduce using rule 35 (rule -> slice_assignment COLON .)
    TYPE            reduce using rule 35 (rule -> slice_assignment COLON .)
    SWITCH          reduce using rule 35 (rule -> slice_assignment COLON .)
    FUNC            reduce using rule 35 (rule -> slice_assignment COLON .)
    INTEGER         reduce using rule 35 (rule -> slice_assignment COLON .)
    FLOAT           reduce using rule 35 (rule -> slice_assignment COLON .)
    NOT             reduce using rule 35 (rule -> slice_assignment COLON .)
    $end            reduce using rule 35 (rule -> slice_assignment COLON .)
    RLLAVE          reduce using rule 35 (rule -> slice_assignment COLON .)
    DEFAULT         reduce using rule 35 (rule -> slice_assignment COLON .)
    CASE            reduce using rule 35 (rule -> slice_assignment COLON .)
    RETURN          reduce using rule 35 (rule -> slice_assignment COLON .)


state 68

    (37) rule -> map_declaration COLON .

    PRINT           reduce using rule 37 (rule -> map_declaration COLON .)
    SCAN            reduce using rule 37 (rule -> map_declaration COLON .)
    FOR             reduce using rule 37 (rule -> map_declaration COLON .)
    VAR             reduce using rule 37 (rule -> map_declaration COLON .)
    ID              reduce using rule 37 (rule -> map_declaration COLON .)
    APPEND          reduce using rule 37 (rule -> map_declaration COLON .)
    LEN             reduce using rule 37 (rule -> map_declaration COLON .)
    COPY            reduce using rule 37 (rule -> map_declaration COLON .)
    DELETE          reduce using rule 37 (rule -> map_declaration COLON .)
    IF              reduce using rule 37 (rule -> map_declaration COLON .)
    ELSE            reduce using rule 37 (rule -> map_declaration COLON .)
    TYPE            reduce using rule 37 (rule -> map_declaration COLON .)
    SWITCH          reduce using rule 37 (rule -> map_declaration COLON .)
    FUNC            reduce using rule 37 (rule -> map_declaration COLON .)
    INTEGER         reduce using rule 37 (rule -> map_declaration COLON .)
    FLOAT           reduce using rule 37 (rule -> map_declaration COLON .)
    NOT             reduce using rule 37 (rule -> map_declaration COLON .)
    $end            reduce using rule 37 (rule -> map_declaration COLON .)
    RLLAVE          reduce using rule 37 (rule -> map_declaration COLON .)
    DEFAULT         reduce using rule 37 (rule -> map_declaration COLON .)
    CASE            reduce using rule 37 (rule -> map_declaration COLON .)
    RETURN          reduce using rule 37 (rule -> map_declaration COLON .)


state 69

    (39) rule -> map_assignment COLON .

    PRINT           reduce using rule 39 (rule -> map_assignment COLON .)
    SCAN            reduce using rule 39 (rule -> map_assignment COLON .)
    FOR             reduce using rule 39 (rule -> map_assignment COLON .)
    VAR             reduce using rule 39 (rule -> map_assignment COLON .)
    ID              reduce using rule 39 (rule -> map_assignment COLON .)
    APPEND          reduce using rule 39 (rule -> map_assignment COLON .)
    LEN             reduce using rule 39 (rule -> map_assignment COLON .)
    COPY            reduce using rule 39 (rule -> map_assignment COLON .)
    DELETE          reduce using rule 39 (rule -> map_assignment COLON .)
    IF              reduce using rule 39 (rule -> map_assignment COLON .)
    ELSE            reduce using rule 39 (rule -> map_assignment COLON .)
    TYPE            reduce using rule 39 (rule -> map_assignment COLON .)
    SWITCH          reduce using rule 39 (rule -> map_assignment COLON .)
    FUNC            reduce using rule 39 (rule -> map_assignment COLON .)
    INTEGER         reduce using rule 39 (rule -> map_assignment COLON .)
    FLOAT           reduce using rule 39 (rule -> map_assignment COLON .)
    NOT             reduce using rule 39 (rule -> map_assignment COLON .)
    $end            reduce using rule 39 (rule -> map_assignment COLON .)
    RLLAVE          reduce using rule 39 (rule -> map_assignment COLON .)
    DEFAULT         reduce using rule 39 (rule -> map_assignment COLON .)
    CASE            reduce using rule 39 (rule -> map_assignment COLON .)
    RETURN          reduce using rule 39 (rule -> map_assignment COLON .)


state 70

    (195) impresion -> PRINT LPAREN . content RPAREN
    (196) content -> . values
    (197) content -> . operations
    (198) content -> . funciones
    (199) content -> . data_structure
    (200) content -> . ID
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID

    ID              shift and go to state 140
    STRING          shift and go to state 122
    INTEGER         shift and go to state 123
    FLOAT           shift and go to state 124
    TRUE            shift and go to state 125
    FALSE           shift and go to state 126
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    NOT             shift and go to state 51

    content                        shift and go to state 135
    values                         shift and go to state 136
    operations                     shift and go to state 137
    funciones                      shift and go to state 138
    data_structure                 shift and go to state 139
    expression                     shift and go to state 127
    comparison                     shift and go to state 128
    logic_operation                shift and go to state 129
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52
    something_ex                   shift and go to state 31
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36

state 71

    (79) scan_func -> SCAN LPAREN . POINTER RPAREN

    POINTER         shift and go to state 141


state 72

    (202) expression -> something_ex adicionaEx .

    COLON           reduce using rule 202 (expression -> something_ex adicionaEx .)
    PRINT           reduce using rule 202 (expression -> something_ex adicionaEx .)
    SCAN            reduce using rule 202 (expression -> something_ex adicionaEx .)
    FOR             reduce using rule 202 (expression -> something_ex adicionaEx .)
    VAR             reduce using rule 202 (expression -> something_ex adicionaEx .)
    ID              reduce using rule 202 (expression -> something_ex adicionaEx .)
    APPEND          reduce using rule 202 (expression -> something_ex adicionaEx .)
    LEN             reduce using rule 202 (expression -> something_ex adicionaEx .)
    COPY            reduce using rule 202 (expression -> something_ex adicionaEx .)
    DELETE          reduce using rule 202 (expression -> something_ex adicionaEx .)
    IF              reduce using rule 202 (expression -> something_ex adicionaEx .)
    ELSE            reduce using rule 202 (expression -> something_ex adicionaEx .)
    TYPE            reduce using rule 202 (expression -> something_ex adicionaEx .)
    SWITCH          reduce using rule 202 (expression -> something_ex adicionaEx .)
    FUNC            reduce using rule 202 (expression -> something_ex adicionaEx .)
    INTEGER         reduce using rule 202 (expression -> something_ex adicionaEx .)
    FLOAT           reduce using rule 202 (expression -> something_ex adicionaEx .)
    NOT             reduce using rule 202 (expression -> something_ex adicionaEx .)
    $end            reduce using rule 202 (expression -> something_ex adicionaEx .)
    GREATER         reduce using rule 202 (expression -> something_ex adicionaEx .)
    SMALLER         reduce using rule 202 (expression -> something_ex adicionaEx .)
    GREATER_OR_EQUAL reduce using rule 202 (expression -> something_ex adicionaEx .)
    SMALLER_OR_EQUAL reduce using rule 202 (expression -> something_ex adicionaEx .)
    EQUAL_COMPARE   reduce using rule 202 (expression -> something_ex adicionaEx .)
    NOT_EQUAL       reduce using rule 202 (expression -> something_ex adicionaEx .)
    PLUS            reduce using rule 202 (expression -> something_ex adicionaEx .)
    TIMES           reduce using rule 202 (expression -> something_ex adicionaEx .)
    DIVIDE          reduce using rule 202 (expression -> something_ex adicionaEx .)
    MINUS           reduce using rule 202 (expression -> something_ex adicionaEx .)
    RLLAVE          reduce using rule 202 (expression -> something_ex adicionaEx .)
    DEFAULT         reduce using rule 202 (expression -> something_ex adicionaEx .)
    CASE            reduce using rule 202 (expression -> something_ex adicionaEx .)
    RETURN          reduce using rule 202 (expression -> something_ex adicionaEx .)
    RPAREN          reduce using rule 202 (expression -> something_ex adicionaEx .)
    AND             reduce using rule 202 (expression -> something_ex adicionaEx .)
    OR              reduce using rule 202 (expression -> something_ex adicionaEx .)
    LLLAVE          reduce using rule 202 (expression -> something_ex adicionaEx .)
    RCORCHE         reduce using rule 202 (expression -> something_ex adicionaEx .)
    COMA            reduce using rule 202 (expression -> something_ex adicionaEx .)


state 73

    (203) adicionaEx -> op . something_ex
    (204) adicionaEx -> op . something_ex adicionaEx
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 143
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    something_ex                   shift and go to state 142
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 74

    (146) op -> GREATER .

    ID              reduce using rule 146 (op -> GREATER .)
    INTEGER         reduce using rule 146 (op -> GREATER .)
    FLOAT           reduce using rule 146 (op -> GREATER .)
    APPEND          reduce using rule 146 (op -> GREATER .)
    LEN             reduce using rule 146 (op -> GREATER .)
    COPY            reduce using rule 146 (op -> GREATER .)
    DELETE          reduce using rule 146 (op -> GREATER .)


state 75

    (147) op -> SMALLER .

    ID              reduce using rule 147 (op -> SMALLER .)
    INTEGER         reduce using rule 147 (op -> SMALLER .)
    FLOAT           reduce using rule 147 (op -> SMALLER .)
    APPEND          reduce using rule 147 (op -> SMALLER .)
    LEN             reduce using rule 147 (op -> SMALLER .)
    COPY            reduce using rule 147 (op -> SMALLER .)
    DELETE          reduce using rule 147 (op -> SMALLER .)


state 76

    (148) op -> GREATER_OR_EQUAL .

    ID              reduce using rule 148 (op -> GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 148 (op -> GREATER_OR_EQUAL .)
    FLOAT           reduce using rule 148 (op -> GREATER_OR_EQUAL .)
    APPEND          reduce using rule 148 (op -> GREATER_OR_EQUAL .)
    LEN             reduce using rule 148 (op -> GREATER_OR_EQUAL .)
    COPY            reduce using rule 148 (op -> GREATER_OR_EQUAL .)
    DELETE          reduce using rule 148 (op -> GREATER_OR_EQUAL .)


state 77

    (149) op -> SMALLER_OR_EQUAL .

    ID              reduce using rule 149 (op -> SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 149 (op -> SMALLER_OR_EQUAL .)
    FLOAT           reduce using rule 149 (op -> SMALLER_OR_EQUAL .)
    APPEND          reduce using rule 149 (op -> SMALLER_OR_EQUAL .)
    LEN             reduce using rule 149 (op -> SMALLER_OR_EQUAL .)
    COPY            reduce using rule 149 (op -> SMALLER_OR_EQUAL .)
    DELETE          reduce using rule 149 (op -> SMALLER_OR_EQUAL .)


state 78

    (150) op -> EQUAL_COMPARE .

    ID              reduce using rule 150 (op -> EQUAL_COMPARE .)
    INTEGER         reduce using rule 150 (op -> EQUAL_COMPARE .)
    FLOAT           reduce using rule 150 (op -> EQUAL_COMPARE .)
    APPEND          reduce using rule 150 (op -> EQUAL_COMPARE .)
    LEN             reduce using rule 150 (op -> EQUAL_COMPARE .)
    COPY            reduce using rule 150 (op -> EQUAL_COMPARE .)
    DELETE          reduce using rule 150 (op -> EQUAL_COMPARE .)


state 79

    (151) op -> NOT_EQUAL .

    ID              reduce using rule 151 (op -> NOT_EQUAL .)
    INTEGER         reduce using rule 151 (op -> NOT_EQUAL .)
    FLOAT           reduce using rule 151 (op -> NOT_EQUAL .)
    APPEND          reduce using rule 151 (op -> NOT_EQUAL .)
    LEN             reduce using rule 151 (op -> NOT_EQUAL .)
    COPY            reduce using rule 151 (op -> NOT_EQUAL .)
    DELETE          reduce using rule 151 (op -> NOT_EQUAL .)


state 80

    (210) op -> PLUS .

    ID              reduce using rule 210 (op -> PLUS .)
    INTEGER         reduce using rule 210 (op -> PLUS .)
    FLOAT           reduce using rule 210 (op -> PLUS .)
    APPEND          reduce using rule 210 (op -> PLUS .)
    LEN             reduce using rule 210 (op -> PLUS .)
    COPY            reduce using rule 210 (op -> PLUS .)
    DELETE          reduce using rule 210 (op -> PLUS .)


state 81

    (211) op -> TIMES .

    ID              reduce using rule 211 (op -> TIMES .)
    INTEGER         reduce using rule 211 (op -> TIMES .)
    FLOAT           reduce using rule 211 (op -> TIMES .)
    APPEND          reduce using rule 211 (op -> TIMES .)
    LEN             reduce using rule 211 (op -> TIMES .)
    COPY            reduce using rule 211 (op -> TIMES .)
    DELETE          reduce using rule 211 (op -> TIMES .)


state 82

    (212) op -> DIVIDE .

    ID              reduce using rule 212 (op -> DIVIDE .)
    INTEGER         reduce using rule 212 (op -> DIVIDE .)
    FLOAT           reduce using rule 212 (op -> DIVIDE .)
    APPEND          reduce using rule 212 (op -> DIVIDE .)
    LEN             reduce using rule 212 (op -> DIVIDE .)
    COPY            reduce using rule 212 (op -> DIVIDE .)
    DELETE          reduce using rule 212 (op -> DIVIDE .)


state 83

    (213) op -> MINUS .

    ID              reduce using rule 213 (op -> MINUS .)
    INTEGER         reduce using rule 213 (op -> MINUS .)
    FLOAT           reduce using rule 213 (op -> MINUS .)
    APPEND          reduce using rule 213 (op -> MINUS .)
    LEN             reduce using rule 213 (op -> MINUS .)
    COPY            reduce using rule 213 (op -> MINUS .)
    DELETE          reduce using rule 213 (op -> MINUS .)


state 84

    (80) cicloFor -> FOR LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    codigo                         shift and go to state 144
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    decVarOne                      shift and go to state 33
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 85

    (81) cicloFor -> FOR comparison . LLLAVE codigo RLLAVE
    (157) logic_value -> comparison .

    LLLAVE          shift and go to state 145
    AND             reduce using rule 157 (logic_value -> comparison .)
    OR              reduce using rule 157 (logic_value -> comparison .)


state 86

    (82) cicloFor -> FOR logic_operation . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 146


state 87

    (83) cicloFor -> FOR decVarOne . COLON comparison COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 147


state 88

    (123) decVarOne -> ID . DEQUAL ID
    (124) decVarOne -> ID . DEQUAL INTEGER
    (144) value -> ID .
    (158) logic_value -> ID .
    (205) something_ex -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (179) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 144 (value -> ID .)
    DEQUAL          shift and go to state 148
    GREATER         reduce using rule 144 (value -> ID .)
    SMALLER         reduce using rule 144 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 144 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 144 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 144 (value -> ID .)
    NOT_EQUAL       reduce using rule 144 (value -> ID .)
    PLUS            reduce using rule 144 (value -> ID .)
    TIMES           reduce using rule 144 (value -> ID .)
    DIVIDE          reduce using rule 144 (value -> ID .)
    MINUS           reduce using rule 144 (value -> ID .)
    AND             reduce using rule 158 (logic_value -> ID .)
    OR              reduce using rule 158 (logic_value -> ID .)
    LCORCHE         shift and go to state 149

  ! GREATER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 205 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 205 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 205 (something_ex -> ID .) ]


state 89

    (145) value -> expression .

    GREATER         reduce using rule 145 (value -> expression .)
    SMALLER         reduce using rule 145 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 145 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 145 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 145 (value -> expression .)
    NOT_EQUAL       reduce using rule 145 (value -> expression .)
    PLUS            reduce using rule 145 (value -> expression .)
    TIMES           reduce using rule 145 (value -> expression .)
    DIVIDE          reduce using rule 145 (value -> expression .)
    MINUS           reduce using rule 145 (value -> expression .)
    PRINT           reduce using rule 145 (value -> expression .)
    SCAN            reduce using rule 145 (value -> expression .)
    FOR             reduce using rule 145 (value -> expression .)
    VAR             reduce using rule 145 (value -> expression .)
    ID              reduce using rule 145 (value -> expression .)
    APPEND          reduce using rule 145 (value -> expression .)
    LEN             reduce using rule 145 (value -> expression .)
    COPY            reduce using rule 145 (value -> expression .)
    DELETE          reduce using rule 145 (value -> expression .)
    IF              reduce using rule 145 (value -> expression .)
    ELSE            reduce using rule 145 (value -> expression .)
    TYPE            reduce using rule 145 (value -> expression .)
    SWITCH          reduce using rule 145 (value -> expression .)
    FUNC            reduce using rule 145 (value -> expression .)
    INTEGER         reduce using rule 145 (value -> expression .)
    FLOAT           reduce using rule 145 (value -> expression .)
    NOT             reduce using rule 145 (value -> expression .)
    $end            reduce using rule 145 (value -> expression .)
    AND             reduce using rule 145 (value -> expression .)
    OR              reduce using rule 145 (value -> expression .)
    RLLAVE          reduce using rule 145 (value -> expression .)
    DEFAULT         reduce using rule 145 (value -> expression .)
    CASE            reduce using rule 145 (value -> expression .)
    RETURN          reduce using rule 145 (value -> expression .)
    LLLAVE          reduce using rule 145 (value -> expression .)
    COLON           reduce using rule 145 (value -> expression .)
    RPAREN          reduce using rule 145 (value -> expression .)
    RCORCHE         reduce using rule 145 (value -> expression .)
    COMA            reduce using rule 145 (value -> expression .)


state 90

    (209) something_ex -> funciones .

    GREATER         reduce using rule 209 (something_ex -> funciones .)
    SMALLER         reduce using rule 209 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 209 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 209 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 209 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 209 (something_ex -> funciones .)
    PLUS            reduce using rule 209 (something_ex -> funciones .)
    TIMES           reduce using rule 209 (something_ex -> funciones .)
    DIVIDE          reduce using rule 209 (something_ex -> funciones .)
    MINUS           reduce using rule 209 (something_ex -> funciones .)
    COLON           reduce using rule 209 (something_ex -> funciones .)
    PRINT           reduce using rule 209 (something_ex -> funciones .)
    SCAN            reduce using rule 209 (something_ex -> funciones .)
    FOR             reduce using rule 209 (something_ex -> funciones .)
    VAR             reduce using rule 209 (something_ex -> funciones .)
    ID              reduce using rule 209 (something_ex -> funciones .)
    APPEND          reduce using rule 209 (something_ex -> funciones .)
    LEN             reduce using rule 209 (something_ex -> funciones .)
    COPY            reduce using rule 209 (something_ex -> funciones .)
    DELETE          reduce using rule 209 (something_ex -> funciones .)
    IF              reduce using rule 209 (something_ex -> funciones .)
    ELSE            reduce using rule 209 (something_ex -> funciones .)
    TYPE            reduce using rule 209 (something_ex -> funciones .)
    SWITCH          reduce using rule 209 (something_ex -> funciones .)
    FUNC            reduce using rule 209 (something_ex -> funciones .)
    INTEGER         reduce using rule 209 (something_ex -> funciones .)
    FLOAT           reduce using rule 209 (something_ex -> funciones .)
    NOT             reduce using rule 209 (something_ex -> funciones .)
    $end            reduce using rule 209 (something_ex -> funciones .)
    RLLAVE          reduce using rule 209 (something_ex -> funciones .)
    DEFAULT         reduce using rule 209 (something_ex -> funciones .)
    CASE            reduce using rule 209 (something_ex -> funciones .)
    RETURN          reduce using rule 209 (something_ex -> funciones .)
    RPAREN          reduce using rule 209 (something_ex -> funciones .)
    AND             reduce using rule 209 (something_ex -> funciones .)
    OR              reduce using rule 209 (something_ex -> funciones .)
    LLLAVE          reduce using rule 209 (something_ex -> funciones .)
    RCORCHE         reduce using rule 209 (something_ex -> funciones .)
    COMA            reduce using rule 209 (something_ex -> funciones .)


state 91

    (60) data_structure -> array_var .

    GREATER         reduce using rule 60 (data_structure -> array_var .)
    SMALLER         reduce using rule 60 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 60 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 60 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 60 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 60 (data_structure -> array_var .)
    PLUS            reduce using rule 60 (data_structure -> array_var .)
    TIMES           reduce using rule 60 (data_structure -> array_var .)
    DIVIDE          reduce using rule 60 (data_structure -> array_var .)
    MINUS           reduce using rule 60 (data_structure -> array_var .)
    COLON           reduce using rule 60 (data_structure -> array_var .)
    PRINT           reduce using rule 60 (data_structure -> array_var .)
    SCAN            reduce using rule 60 (data_structure -> array_var .)
    FOR             reduce using rule 60 (data_structure -> array_var .)
    VAR             reduce using rule 60 (data_structure -> array_var .)
    ID              reduce using rule 60 (data_structure -> array_var .)
    APPEND          reduce using rule 60 (data_structure -> array_var .)
    LEN             reduce using rule 60 (data_structure -> array_var .)
    COPY            reduce using rule 60 (data_structure -> array_var .)
    DELETE          reduce using rule 60 (data_structure -> array_var .)
    IF              reduce using rule 60 (data_structure -> array_var .)
    ELSE            reduce using rule 60 (data_structure -> array_var .)
    TYPE            reduce using rule 60 (data_structure -> array_var .)
    SWITCH          reduce using rule 60 (data_structure -> array_var .)
    FUNC            reduce using rule 60 (data_structure -> array_var .)
    INTEGER         reduce using rule 60 (data_structure -> array_var .)
    FLOAT           reduce using rule 60 (data_structure -> array_var .)
    NOT             reduce using rule 60 (data_structure -> array_var .)
    $end            reduce using rule 60 (data_structure -> array_var .)
    RLLAVE          reduce using rule 60 (data_structure -> array_var .)
    DEFAULT         reduce using rule 60 (data_structure -> array_var .)
    CASE            reduce using rule 60 (data_structure -> array_var .)
    RETURN          reduce using rule 60 (data_structure -> array_var .)
    RPAREN          reduce using rule 60 (data_structure -> array_var .)
    AND             reduce using rule 60 (data_structure -> array_var .)
    OR              reduce using rule 60 (data_structure -> array_var .)
    LLLAVE          reduce using rule 60 (data_structure -> array_var .)
    RCORCHE         reduce using rule 60 (data_structure -> array_var .)
    COMA            reduce using rule 60 (data_structure -> array_var .)


state 92

    (143) comparison -> value op . value
    (144) value -> . ID
    (145) value -> . expression
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 108
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    value                          shift and go to state 150
    expression                     shift and go to state 89
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 93

    (152) logic_operation -> logic_value logic_recu .

    PRINT           reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    SCAN            reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    FOR             reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    VAR             reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    ID              reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    APPEND          reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    LEN             reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    COPY            reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    DELETE          reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    IF              reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    ELSE            reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    TYPE            reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    SWITCH          reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    FUNC            reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    INTEGER         reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    FLOAT           reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    NOT             reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    $end            reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    RLLAVE          reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    DEFAULT         reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    CASE            reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    RETURN          reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    LLLAVE          reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    COLON           reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    RPAREN          reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    RCORCHE         reduce using rule 152 (logic_operation -> logic_value logic_recu .)
    COMA            reduce using rule 152 (logic_operation -> logic_value logic_recu .)


state 94

    (154) logic_recu -> logic_op . logic_value
    (155) logic_recu -> logic_op . logic_value logic_recu
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (143) comparison -> . value op value
    (144) value -> . ID
    (145) value -> . expression
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 154
    NOT             shift and go to state 51
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    logic_value                    shift and go to state 151
    negation                       shift and go to state 152
    comparison                     shift and go to state 153
    value                          shift and go to state 34
    expression                     shift and go to state 89
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 95

    (161) logic_op -> AND .

    ID              reduce using rule 161 (logic_op -> AND .)
    NOT             reduce using rule 161 (logic_op -> AND .)
    INTEGER         reduce using rule 161 (logic_op -> AND .)
    FLOAT           reduce using rule 161 (logic_op -> AND .)
    APPEND          reduce using rule 161 (logic_op -> AND .)
    LEN             reduce using rule 161 (logic_op -> AND .)
    COPY            reduce using rule 161 (logic_op -> AND .)
    DELETE          reduce using rule 161 (logic_op -> AND .)


state 96

    (162) logic_op -> OR .

    ID              reduce using rule 162 (logic_op -> OR .)
    NOT             reduce using rule 162 (logic_op -> OR .)
    INTEGER         reduce using rule 162 (logic_op -> OR .)
    FLOAT           reduce using rule 162 (logic_op -> OR .)
    APPEND          reduce using rule 162 (logic_op -> OR .)
    LEN             reduce using rule 162 (logic_op -> OR .)
    COPY            reduce using rule 162 (logic_op -> OR .)
    DELETE          reduce using rule 162 (logic_op -> OR .)


state 97

    (87) decVar -> VAR ID . EQUAL INTEGER
    (88) decVar -> VAR ID . EQUAL ID
    (89) decVar -> VAR ID . EQUAL FLOAT
    (90) decVar -> VAR ID . EQUAL expression
    (91) decVar -> VAR ID . EQUAL logic_operation
    (92) decVar -> VAR ID . EQUAL comparison
    (93) decVar -> VAR ID . EQUAL STRING
    (168) array_declaration -> VAR ID . LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> VAR ID . EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (99) slice_declaration -> VAR ID . LCORCHE RCORCHE data_types
    (100) slice_declaration -> VAR ID . EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> VAR ID . EQUAL funM
    (178) map_declaration -> VAR ID . LCORCHE data_types RCORCHE data_types

    EQUAL           shift and go to state 155
    LCORCHE         shift and go to state 156


state 98

    (94) decVar -> ID DEQUAL . STRING
    (95) decVar -> ID DEQUAL . FLOAT
    (96) decVar -> ID DEQUAL . expression
    (97) decVar -> ID DEQUAL . logic_operation
    (98) decVar -> ID DEQUAL . comparison
    (136) cStruct -> ID DEQUAL . ID LLLAVE asignaciones RLLAVE
    (102) slice_declaration -> ID DEQUAL . funM
    (103) slice_declaration -> ID DEQUAL . LCORCHE RCORCHE data_types arr_content
    (123) decVarOne -> ID DEQUAL . ID
    (124) decVarOne -> ID DEQUAL . INTEGER
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (143) comparison -> . value op value
    (104) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (105) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (144) value -> . ID
    (145) value -> . expression
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    STRING          shift and go to state 158
    FLOAT           shift and go to state 159
    ID              shift and go to state 157
    LCORCHE         shift and go to state 164
    INTEGER         shift and go to state 165
    MAKE            shift and go to state 166
    NOT             shift and go to state 51
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    expression                     shift and go to state 160
    logic_operation                shift and go to state 161
    comparison                     shift and go to state 162
    funM                           shift and go to state 163
    something_ex                   shift and go to state 31
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    value                          shift and go to state 34
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 99

    (62) var_asignation -> ID EQUAL . any
    (63) any -> . values
    (64) any -> . operations
    (65) any -> . ID
    (66) any -> . data_structure
    (67) any -> . funciones
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID

    ID              shift and go to state 167
    STRING          shift and go to state 122
    INTEGER         shift and go to state 123
    FLOAT           shift and go to state 124
    TRUE            shift and go to state 125
    FALSE           shift and go to state 126
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    NOT             shift and go to state 51

    any                            shift and go to state 168
    values                         shift and go to state 169
    operations                     shift and go to state 170
    data_structure                 shift and go to state 171
    funciones                      shift and go to state 172
    expression                     shift and go to state 127
    comparison                     shift and go to state 128
    logic_operation                shift and go to state 129
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52
    something_ex                   shift and go to state 31
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36

state 100

    (173) array_var -> ID LCORCHE . index RCORCHE
    (109) slice_var -> ID LCORCHE . index_s RCORCHE
    (179) map_var -> ID LCORCHE . key RCORCHE
    (174) index -> . ID
    (175) index -> . INTEGER
    (176) index -> . expression
    (110) index_s -> . ID
    (111) index_s -> . INTEGER
    (112) index_s -> . expression
    (180) key -> . ID
    (181) key -> . values
    (182) key -> . operations
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 173
    INTEGER         shift and go to state 177
    STRING          shift and go to state 122
    FLOAT           shift and go to state 124
    TRUE            shift and go to state 125
    FALSE           shift and go to state 126
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    NOT             shift and go to state 51

    index                          shift and go to state 174
    index_s                        shift and go to state 175
    key                            shift and go to state 176
    expression                     shift and go to state 178
    values                         shift and go to state 179
    operations                     shift and go to state 180
    something_ex                   shift and go to state 31
    comparison                     shift and go to state 128
    logic_operation                shift and go to state 129
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 101

    (118) funciones -> APPEND LPAREN . ID COMA values RPAREN
    (119) funciones -> APPEND LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 181


state 102

    (120) funciones -> LEN LPAREN . ID RPAREN

    ID              shift and go to state 182


state 103

    (121) funciones -> COPY LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 183


state 104

    (122) funciones -> DELETE LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 184


state 105

    (125) SenIF -> IF comparison . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 185


state 106

    (126) SenIF -> IF TRUE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 186


state 107

    (127) SenIF -> IF FALSE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 187


state 108

    (144) value -> ID .
    (205) something_ex -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (179) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for LLLAVE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 144 (value -> ID .)
    GREATER         reduce using rule 144 (value -> ID .)
    SMALLER         reduce using rule 144 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 144 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 144 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 144 (value -> ID .)
    NOT_EQUAL       reduce using rule 144 (value -> ID .)
    PLUS            reduce using rule 144 (value -> ID .)
    TIMES           reduce using rule 144 (value -> ID .)
    DIVIDE          reduce using rule 144 (value -> ID .)
    MINUS           reduce using rule 144 (value -> ID .)
    PRINT           reduce using rule 144 (value -> ID .)
    SCAN            reduce using rule 144 (value -> ID .)
    FOR             reduce using rule 144 (value -> ID .)
    VAR             reduce using rule 144 (value -> ID .)
    ID              reduce using rule 144 (value -> ID .)
    APPEND          reduce using rule 144 (value -> ID .)
    LEN             reduce using rule 144 (value -> ID .)
    COPY            reduce using rule 144 (value -> ID .)
    DELETE          reduce using rule 144 (value -> ID .)
    IF              reduce using rule 144 (value -> ID .)
    ELSE            reduce using rule 144 (value -> ID .)
    TYPE            reduce using rule 144 (value -> ID .)
    SWITCH          reduce using rule 144 (value -> ID .)
    FUNC            reduce using rule 144 (value -> ID .)
    INTEGER         reduce using rule 144 (value -> ID .)
    FLOAT           reduce using rule 144 (value -> ID .)
    NOT             reduce using rule 144 (value -> ID .)
    $end            reduce using rule 144 (value -> ID .)
    AND             reduce using rule 144 (value -> ID .)
    OR              reduce using rule 144 (value -> ID .)
    RLLAVE          reduce using rule 144 (value -> ID .)
    DEFAULT         reduce using rule 144 (value -> ID .)
    CASE            reduce using rule 144 (value -> ID .)
    RETURN          reduce using rule 144 (value -> ID .)
    LLLAVE          reduce using rule 144 (value -> ID .)
    COLON           reduce using rule 144 (value -> ID .)
    RPAREN          reduce using rule 144 (value -> ID .)
    RCORCHE         reduce using rule 144 (value -> ID .)
    COMA            reduce using rule 144 (value -> ID .)
    LCORCHE         shift and go to state 149

  ! GREATER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 205 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 205 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 205 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 205 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 205 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 205 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 205 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 205 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 205 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 205 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 205 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 205 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 205 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 205 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 205 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 205 (something_ex -> ID .) ]
  ! AND             [ reduce using rule 205 (something_ex -> ID .) ]
  ! OR              [ reduce using rule 205 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 205 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 205 (something_ex -> ID .) ]
  ! LLLAVE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 205 (something_ex -> ID .) ]
  ! RPAREN          [ reduce using rule 205 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 205 (something_ex -> ID .) ]
  ! COMA            [ reduce using rule 205 (something_ex -> ID .) ]


state 109

    (128) SenElseIF -> ELSE IF . comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> ELSE IF . TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> ELSE IF . FALSE LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (144) value -> . ID
    (145) value -> . expression
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    TRUE            shift and go to state 189
    FALSE           shift and go to state 190
    ID              shift and go to state 108
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    comparison                     shift and go to state 188
    value                          shift and go to state 34
    expression                     shift and go to state 89
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 110

    (131) SenElse -> ELSE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    codigo                         shift and go to state 191
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    decVarOne                      shift and go to state 33
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 111

    (132) SenStruct -> TYPE ID . STRUCT LLLAVE declaration RLLAVE

    STRUCT          shift and go to state 192


state 112

    (163) switch_statement -> SWITCH ID . LLLAVE cases RLLAVE

    LLLAVE          shift and go to state 193


state 113

    (184) func_declaration -> FUNC ID . LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> FUNC ID . LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE

    LPAREN          shift and go to state 194


state 114

    (78) main_func -> FUNC MAIN . LPAREN RPAREN LLLAVE codigo RLLAVE

    LPAREN          shift and go to state 195


state 115

    (159) negation -> NOT comparison .

    PRINT           reduce using rule 159 (negation -> NOT comparison .)
    SCAN            reduce using rule 159 (negation -> NOT comparison .)
    FOR             reduce using rule 159 (negation -> NOT comparison .)
    VAR             reduce using rule 159 (negation -> NOT comparison .)
    ID              reduce using rule 159 (negation -> NOT comparison .)
    APPEND          reduce using rule 159 (negation -> NOT comparison .)
    LEN             reduce using rule 159 (negation -> NOT comparison .)
    COPY            reduce using rule 159 (negation -> NOT comparison .)
    DELETE          reduce using rule 159 (negation -> NOT comparison .)
    IF              reduce using rule 159 (negation -> NOT comparison .)
    ELSE            reduce using rule 159 (negation -> NOT comparison .)
    TYPE            reduce using rule 159 (negation -> NOT comparison .)
    SWITCH          reduce using rule 159 (negation -> NOT comparison .)
    FUNC            reduce using rule 159 (negation -> NOT comparison .)
    INTEGER         reduce using rule 159 (negation -> NOT comparison .)
    FLOAT           reduce using rule 159 (negation -> NOT comparison .)
    NOT             reduce using rule 159 (negation -> NOT comparison .)
    $end            reduce using rule 159 (negation -> NOT comparison .)
    AND             reduce using rule 159 (negation -> NOT comparison .)
    OR              reduce using rule 159 (negation -> NOT comparison .)
    RLLAVE          reduce using rule 159 (negation -> NOT comparison .)
    DEFAULT         reduce using rule 159 (negation -> NOT comparison .)
    CASE            reduce using rule 159 (negation -> NOT comparison .)
    RETURN          reduce using rule 159 (negation -> NOT comparison .)
    LLLAVE          reduce using rule 159 (negation -> NOT comparison .)
    COLON           reduce using rule 159 (negation -> NOT comparison .)
    RPAREN          reduce using rule 159 (negation -> NOT comparison .)
    RCORCHE         reduce using rule 159 (negation -> NOT comparison .)
    COMA            reduce using rule 159 (negation -> NOT comparison .)


state 116

    (160) negation -> NOT ID .
    (144) value -> ID .
    (205) something_ex -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (179) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 144 (value -> ID .)
    PRINT           reduce using rule 160 (negation -> NOT ID .)
    SCAN            reduce using rule 160 (negation -> NOT ID .)
    FOR             reduce using rule 160 (negation -> NOT ID .)
    VAR             reduce using rule 160 (negation -> NOT ID .)
    ID              reduce using rule 160 (negation -> NOT ID .)
    APPEND          reduce using rule 160 (negation -> NOT ID .)
    LEN             reduce using rule 160 (negation -> NOT ID .)
    COPY            reduce using rule 160 (negation -> NOT ID .)
    DELETE          reduce using rule 160 (negation -> NOT ID .)
    IF              reduce using rule 160 (negation -> NOT ID .)
    ELSE            reduce using rule 160 (negation -> NOT ID .)
    TYPE            reduce using rule 160 (negation -> NOT ID .)
    SWITCH          reduce using rule 160 (negation -> NOT ID .)
    FUNC            reduce using rule 160 (negation -> NOT ID .)
    INTEGER         reduce using rule 160 (negation -> NOT ID .)
    FLOAT           reduce using rule 160 (negation -> NOT ID .)
    NOT             reduce using rule 160 (negation -> NOT ID .)
    $end            reduce using rule 160 (negation -> NOT ID .)
    AND             reduce using rule 160 (negation -> NOT ID .)
    OR              reduce using rule 160 (negation -> NOT ID .)
    RLLAVE          reduce using rule 160 (negation -> NOT ID .)
    DEFAULT         reduce using rule 160 (negation -> NOT ID .)
    CASE            reduce using rule 160 (negation -> NOT ID .)
    RETURN          reduce using rule 160 (negation -> NOT ID .)
    LLLAVE          reduce using rule 160 (negation -> NOT ID .)
    COLON           reduce using rule 160 (negation -> NOT ID .)
    RPAREN          reduce using rule 160 (negation -> NOT ID .)
    RCORCHE         reduce using rule 160 (negation -> NOT ID .)
    COMA            reduce using rule 160 (negation -> NOT ID .)
    GREATER         reduce using rule 144 (value -> ID .)
    SMALLER         reduce using rule 144 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 144 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 144 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 144 (value -> ID .)
    NOT_EQUAL       reduce using rule 144 (value -> ID .)
    PLUS            reduce using rule 144 (value -> ID .)
    TIMES           reduce using rule 144 (value -> ID .)
    DIVIDE          reduce using rule 144 (value -> ID .)
    MINUS           reduce using rule 144 (value -> ID .)
    LCORCHE         shift and go to state 149

  ! GREATER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 205 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 205 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 205 (something_ex -> ID .) ]


state 117

    (177) array_assignment -> array_var EQUAL something .
    (183) map_assignment -> array_var EQUAL something .

  ! reduce/reduce conflict for COLON resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for PRINT resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for SCAN resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for FOR resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for VAR resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for ID resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for APPEND resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for LEN resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for COPY resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for DELETE resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for IF resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for ELSE resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for TYPE resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for SWITCH resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for FUNC resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for INTEGER resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for FLOAT resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for NOT resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for $end resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for CASE resolved using rule 177 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for RETURN resolved using rule 177 (array_assignment -> array_var EQUAL something .)
    COLON           reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    PRINT           reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    SCAN            reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    FOR             reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    VAR             reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    ID              reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    APPEND          reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    LEN             reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    COPY            reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    DELETE          reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    IF              reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    ELSE            reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    TYPE            reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    SWITCH          reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    FUNC            reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    INTEGER         reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    FLOAT           reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    NOT             reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    $end            reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    RLLAVE          reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    DEFAULT         reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    CASE            reduce using rule 177 (array_assignment -> array_var EQUAL something .)
    RETURN          reduce using rule 177 (array_assignment -> array_var EQUAL something .)

  ! COLON           [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! PRINT           [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! SCAN            [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! FOR             [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! VAR             [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! ID              [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! APPEND          [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! LEN             [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! COPY            [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! DELETE          [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! IF              [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! ELSE            [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! TYPE            [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! SWITCH          [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! FUNC            [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! INTEGER         [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! FLOAT           [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! NOT             [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! $end            [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! RLLAVE          [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! DEFAULT         [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! CASE            [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]
  ! RETURN          [ reduce using rule 183 (map_assignment -> array_var EQUAL something .) ]


state 118

    (74) something -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (179) map_var -> ID . LCORCHE key RCORCHE
    (205) something_ex -> ID .
    (144) value -> ID .
    (158) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 74 (something -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 144 (value -> ID .)
    COLON           reduce using rule 74 (something -> ID .)
    PRINT           reduce using rule 74 (something -> ID .)
    SCAN            reduce using rule 74 (something -> ID .)
    FOR             reduce using rule 74 (something -> ID .)
    VAR             reduce using rule 74 (something -> ID .)
    ID              reduce using rule 74 (something -> ID .)
    APPEND          reduce using rule 74 (something -> ID .)
    LEN             reduce using rule 74 (something -> ID .)
    COPY            reduce using rule 74 (something -> ID .)
    DELETE          reduce using rule 74 (something -> ID .)
    IF              reduce using rule 74 (something -> ID .)
    ELSE            reduce using rule 74 (something -> ID .)
    TYPE            reduce using rule 74 (something -> ID .)
    SWITCH          reduce using rule 74 (something -> ID .)
    FUNC            reduce using rule 74 (something -> ID .)
    INTEGER         reduce using rule 74 (something -> ID .)
    FLOAT           reduce using rule 74 (something -> ID .)
    NOT             reduce using rule 74 (something -> ID .)
    $end            reduce using rule 74 (something -> ID .)
    RLLAVE          reduce using rule 74 (something -> ID .)
    DEFAULT         reduce using rule 74 (something -> ID .)
    CASE            reduce using rule 74 (something -> ID .)
    RETURN          reduce using rule 74 (something -> ID .)
    LCORCHE         shift and go to state 149
    GREATER         reduce using rule 144 (value -> ID .)
    SMALLER         reduce using rule 144 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 144 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 144 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 144 (value -> ID .)
    NOT_EQUAL       reduce using rule 144 (value -> ID .)
    PLUS            reduce using rule 144 (value -> ID .)
    TIMES           reduce using rule 144 (value -> ID .)
    DIVIDE          reduce using rule 144 (value -> ID .)
    MINUS           reduce using rule 144 (value -> ID .)
    AND             reduce using rule 158 (logic_value -> ID .)
    OR              reduce using rule 158 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 205 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 205 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 205 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 205 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 205 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 205 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 205 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 205 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 205 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 205 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 205 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 205 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 205 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 205 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 205 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 205 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 205 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 205 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 205 (something_ex -> ID .) ]


state 119

    (75) something -> data_structure .
    (208) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for PRINT resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for SCAN resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for FOR resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for VAR resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for ID resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for APPEND resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for LEN resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for COPY resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for DELETE resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for IF resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for ELSE resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for TYPE resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for SWITCH resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for FUNC resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for INTEGER resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for FLOAT resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for NOT resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for $end resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for CASE resolved using rule 75 (something -> data_structure .)
  ! reduce/reduce conflict for RETURN resolved using rule 75 (something -> data_structure .)
    COLON           reduce using rule 75 (something -> data_structure .)
    PRINT           reduce using rule 75 (something -> data_structure .)
    SCAN            reduce using rule 75 (something -> data_structure .)
    FOR             reduce using rule 75 (something -> data_structure .)
    VAR             reduce using rule 75 (something -> data_structure .)
    ID              reduce using rule 75 (something -> data_structure .)
    APPEND          reduce using rule 75 (something -> data_structure .)
    LEN             reduce using rule 75 (something -> data_structure .)
    COPY            reduce using rule 75 (something -> data_structure .)
    DELETE          reduce using rule 75 (something -> data_structure .)
    IF              reduce using rule 75 (something -> data_structure .)
    ELSE            reduce using rule 75 (something -> data_structure .)
    TYPE            reduce using rule 75 (something -> data_structure .)
    SWITCH          reduce using rule 75 (something -> data_structure .)
    FUNC            reduce using rule 75 (something -> data_structure .)
    INTEGER         reduce using rule 75 (something -> data_structure .)
    FLOAT           reduce using rule 75 (something -> data_structure .)
    NOT             reduce using rule 75 (something -> data_structure .)
    $end            reduce using rule 75 (something -> data_structure .)
    RLLAVE          reduce using rule 75 (something -> data_structure .)
    DEFAULT         reduce using rule 75 (something -> data_structure .)
    CASE            reduce using rule 75 (something -> data_structure .)
    RETURN          reduce using rule 75 (something -> data_structure .)
    GREATER         reduce using rule 208 (something_ex -> data_structure .)
    SMALLER         reduce using rule 208 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 208 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 208 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 208 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 208 (something_ex -> data_structure .)
    PLUS            reduce using rule 208 (something_ex -> data_structure .)
    TIMES           reduce using rule 208 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 208 (something_ex -> data_structure .)
    MINUS           reduce using rule 208 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! PRINT           [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! SCAN            [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! FOR             [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! VAR             [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! ID              [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! APPEND          [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! LEN             [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! COPY            [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! DELETE          [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! IF              [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! ELSE            [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! TYPE            [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! SWITCH          [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! FUNC            [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! INTEGER         [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! FLOAT           [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! NOT             [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! $end            [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! DEFAULT         [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! CASE            [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! RETURN          [ reduce using rule 208 (something_ex -> data_structure .) ]


state 120

    (76) something -> values .

    COLON           reduce using rule 76 (something -> values .)
    PRINT           reduce using rule 76 (something -> values .)
    SCAN            reduce using rule 76 (something -> values .)
    FOR             reduce using rule 76 (something -> values .)
    VAR             reduce using rule 76 (something -> values .)
    ID              reduce using rule 76 (something -> values .)
    APPEND          reduce using rule 76 (something -> values .)
    LEN             reduce using rule 76 (something -> values .)
    COPY            reduce using rule 76 (something -> values .)
    DELETE          reduce using rule 76 (something -> values .)
    IF              reduce using rule 76 (something -> values .)
    ELSE            reduce using rule 76 (something -> values .)
    TYPE            reduce using rule 76 (something -> values .)
    SWITCH          reduce using rule 76 (something -> values .)
    FUNC            reduce using rule 76 (something -> values .)
    INTEGER         reduce using rule 76 (something -> values .)
    FLOAT           reduce using rule 76 (something -> values .)
    NOT             reduce using rule 76 (something -> values .)
    $end            reduce using rule 76 (something -> values .)
    RLLAVE          reduce using rule 76 (something -> values .)
    DEFAULT         reduce using rule 76 (something -> values .)
    CASE            reduce using rule 76 (something -> values .)
    RETURN          reduce using rule 76 (something -> values .)


state 121

    (77) something -> operations .

    COLON           reduce using rule 77 (something -> operations .)
    PRINT           reduce using rule 77 (something -> operations .)
    SCAN            reduce using rule 77 (something -> operations .)
    FOR             reduce using rule 77 (something -> operations .)
    VAR             reduce using rule 77 (something -> operations .)
    ID              reduce using rule 77 (something -> operations .)
    APPEND          reduce using rule 77 (something -> operations .)
    LEN             reduce using rule 77 (something -> operations .)
    COPY            reduce using rule 77 (something -> operations .)
    DELETE          reduce using rule 77 (something -> operations .)
    IF              reduce using rule 77 (something -> operations .)
    ELSE            reduce using rule 77 (something -> operations .)
    TYPE            reduce using rule 77 (something -> operations .)
    SWITCH          reduce using rule 77 (something -> operations .)
    FUNC            reduce using rule 77 (something -> operations .)
    INTEGER         reduce using rule 77 (something -> operations .)
    FLOAT           reduce using rule 77 (something -> operations .)
    NOT             reduce using rule 77 (something -> operations .)
    $end            reduce using rule 77 (something -> operations .)
    RLLAVE          reduce using rule 77 (something -> operations .)
    DEFAULT         reduce using rule 77 (something -> operations .)
    CASE            reduce using rule 77 (something -> operations .)
    RETURN          reduce using rule 77 (something -> operations .)


state 122

    (43) values -> STRING .

    COLON           reduce using rule 43 (values -> STRING .)
    PRINT           reduce using rule 43 (values -> STRING .)
    SCAN            reduce using rule 43 (values -> STRING .)
    FOR             reduce using rule 43 (values -> STRING .)
    VAR             reduce using rule 43 (values -> STRING .)
    ID              reduce using rule 43 (values -> STRING .)
    APPEND          reduce using rule 43 (values -> STRING .)
    LEN             reduce using rule 43 (values -> STRING .)
    COPY            reduce using rule 43 (values -> STRING .)
    DELETE          reduce using rule 43 (values -> STRING .)
    IF              reduce using rule 43 (values -> STRING .)
    ELSE            reduce using rule 43 (values -> STRING .)
    TYPE            reduce using rule 43 (values -> STRING .)
    SWITCH          reduce using rule 43 (values -> STRING .)
    FUNC            reduce using rule 43 (values -> STRING .)
    INTEGER         reduce using rule 43 (values -> STRING .)
    FLOAT           reduce using rule 43 (values -> STRING .)
    NOT             reduce using rule 43 (values -> STRING .)
    $end            reduce using rule 43 (values -> STRING .)
    RLLAVE          reduce using rule 43 (values -> STRING .)
    DEFAULT         reduce using rule 43 (values -> STRING .)
    CASE            reduce using rule 43 (values -> STRING .)
    RETURN          reduce using rule 43 (values -> STRING .)
    RPAREN          reduce using rule 43 (values -> STRING .)
    RCORCHE         reduce using rule 43 (values -> STRING .)
    POINTS          reduce using rule 43 (values -> STRING .)
    COMA            reduce using rule 43 (values -> STRING .)


state 123

    (44) values -> INTEGER .
    (206) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for PRINT resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for SCAN resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for FOR resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for VAR resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for ID resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for APPEND resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for LEN resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for COPY resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for DELETE resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for IF resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for ELSE resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for TYPE resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for SWITCH resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for FUNC resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for INTEGER resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for FLOAT resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for NOT resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 44 (values -> INTEGER .)
    COLON           reduce using rule 44 (values -> INTEGER .)
    PRINT           reduce using rule 44 (values -> INTEGER .)
    SCAN            reduce using rule 44 (values -> INTEGER .)
    FOR             reduce using rule 44 (values -> INTEGER .)
    VAR             reduce using rule 44 (values -> INTEGER .)
    ID              reduce using rule 44 (values -> INTEGER .)
    APPEND          reduce using rule 44 (values -> INTEGER .)
    LEN             reduce using rule 44 (values -> INTEGER .)
    COPY            reduce using rule 44 (values -> INTEGER .)
    DELETE          reduce using rule 44 (values -> INTEGER .)
    IF              reduce using rule 44 (values -> INTEGER .)
    ELSE            reduce using rule 44 (values -> INTEGER .)
    TYPE            reduce using rule 44 (values -> INTEGER .)
    SWITCH          reduce using rule 44 (values -> INTEGER .)
    FUNC            reduce using rule 44 (values -> INTEGER .)
    INTEGER         reduce using rule 44 (values -> INTEGER .)
    FLOAT           reduce using rule 44 (values -> INTEGER .)
    NOT             reduce using rule 44 (values -> INTEGER .)
    $end            reduce using rule 44 (values -> INTEGER .)
    RLLAVE          reduce using rule 44 (values -> INTEGER .)
    DEFAULT         reduce using rule 44 (values -> INTEGER .)
    CASE            reduce using rule 44 (values -> INTEGER .)
    RETURN          reduce using rule 44 (values -> INTEGER .)
    RPAREN          reduce using rule 44 (values -> INTEGER .)
    COMA            reduce using rule 44 (values -> INTEGER .)
    GREATER         reduce using rule 206 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 206 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 206 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 206 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 206 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 206 (something_ex -> INTEGER .)
    PLUS            reduce using rule 206 (something_ex -> INTEGER .)
    TIMES           reduce using rule 206 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 206 (something_ex -> INTEGER .)
    MINUS           reduce using rule 206 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! PRINT           [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! SCAN            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! FOR             [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! VAR             [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! ID              [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! APPEND          [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! LEN             [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! COPY            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! DELETE          [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! IF              [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! ELSE            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! TYPE            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! SWITCH          [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! FUNC            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! INTEGER         [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! FLOAT           [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! NOT             [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! RPAREN          [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! COMA            [ reduce using rule 206 (something_ex -> INTEGER .) ]


state 124

    (45) values -> FLOAT .
    (207) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for PRINT resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for SCAN resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for FOR resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for VAR resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for ID resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for APPEND resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for LEN resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for COPY resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for DELETE resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for IF resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for ELSE resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for TYPE resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for SWITCH resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for FUNC resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for INTEGER resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for FLOAT resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for NOT resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for RPAREN resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for COMA resolved using rule 45 (values -> FLOAT .)
    COLON           reduce using rule 45 (values -> FLOAT .)
    PRINT           reduce using rule 45 (values -> FLOAT .)
    SCAN            reduce using rule 45 (values -> FLOAT .)
    FOR             reduce using rule 45 (values -> FLOAT .)
    VAR             reduce using rule 45 (values -> FLOAT .)
    ID              reduce using rule 45 (values -> FLOAT .)
    APPEND          reduce using rule 45 (values -> FLOAT .)
    LEN             reduce using rule 45 (values -> FLOAT .)
    COPY            reduce using rule 45 (values -> FLOAT .)
    DELETE          reduce using rule 45 (values -> FLOAT .)
    IF              reduce using rule 45 (values -> FLOAT .)
    ELSE            reduce using rule 45 (values -> FLOAT .)
    TYPE            reduce using rule 45 (values -> FLOAT .)
    SWITCH          reduce using rule 45 (values -> FLOAT .)
    FUNC            reduce using rule 45 (values -> FLOAT .)
    INTEGER         reduce using rule 45 (values -> FLOAT .)
    FLOAT           reduce using rule 45 (values -> FLOAT .)
    NOT             reduce using rule 45 (values -> FLOAT .)
    $end            reduce using rule 45 (values -> FLOAT .)
    RLLAVE          reduce using rule 45 (values -> FLOAT .)
    DEFAULT         reduce using rule 45 (values -> FLOAT .)
    CASE            reduce using rule 45 (values -> FLOAT .)
    RETURN          reduce using rule 45 (values -> FLOAT .)
    RPAREN          reduce using rule 45 (values -> FLOAT .)
    RCORCHE         reduce using rule 45 (values -> FLOAT .)
    COMA            reduce using rule 45 (values -> FLOAT .)
    GREATER         reduce using rule 207 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 207 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 207 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 207 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 207 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 207 (something_ex -> FLOAT .)
    PLUS            reduce using rule 207 (something_ex -> FLOAT .)
    TIMES           reduce using rule 207 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 207 (something_ex -> FLOAT .)
    MINUS           reduce using rule 207 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! PRINT           [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! SCAN            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! FOR             [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! VAR             [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! ID              [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! APPEND          [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! LEN             [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! COPY            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! DELETE          [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! IF              [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! ELSE            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! TYPE            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! SWITCH          [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! FUNC            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! INTEGER         [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! FLOAT           [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! NOT             [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! RPAREN          [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! RCORCHE         [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! COMA            [ reduce using rule 207 (something_ex -> FLOAT .) ]


state 125

    (46) values -> TRUE .

    COLON           reduce using rule 46 (values -> TRUE .)
    PRINT           reduce using rule 46 (values -> TRUE .)
    SCAN            reduce using rule 46 (values -> TRUE .)
    FOR             reduce using rule 46 (values -> TRUE .)
    VAR             reduce using rule 46 (values -> TRUE .)
    ID              reduce using rule 46 (values -> TRUE .)
    APPEND          reduce using rule 46 (values -> TRUE .)
    LEN             reduce using rule 46 (values -> TRUE .)
    COPY            reduce using rule 46 (values -> TRUE .)
    DELETE          reduce using rule 46 (values -> TRUE .)
    IF              reduce using rule 46 (values -> TRUE .)
    ELSE            reduce using rule 46 (values -> TRUE .)
    TYPE            reduce using rule 46 (values -> TRUE .)
    SWITCH          reduce using rule 46 (values -> TRUE .)
    FUNC            reduce using rule 46 (values -> TRUE .)
    INTEGER         reduce using rule 46 (values -> TRUE .)
    FLOAT           reduce using rule 46 (values -> TRUE .)
    NOT             reduce using rule 46 (values -> TRUE .)
    $end            reduce using rule 46 (values -> TRUE .)
    RLLAVE          reduce using rule 46 (values -> TRUE .)
    DEFAULT         reduce using rule 46 (values -> TRUE .)
    CASE            reduce using rule 46 (values -> TRUE .)
    RETURN          reduce using rule 46 (values -> TRUE .)
    RPAREN          reduce using rule 46 (values -> TRUE .)
    RCORCHE         reduce using rule 46 (values -> TRUE .)
    POINTS          reduce using rule 46 (values -> TRUE .)
    COMA            reduce using rule 46 (values -> TRUE .)


state 126

    (47) values -> FALSE .

    COLON           reduce using rule 47 (values -> FALSE .)
    PRINT           reduce using rule 47 (values -> FALSE .)
    SCAN            reduce using rule 47 (values -> FALSE .)
    FOR             reduce using rule 47 (values -> FALSE .)
    VAR             reduce using rule 47 (values -> FALSE .)
    ID              reduce using rule 47 (values -> FALSE .)
    APPEND          reduce using rule 47 (values -> FALSE .)
    LEN             reduce using rule 47 (values -> FALSE .)
    COPY            reduce using rule 47 (values -> FALSE .)
    DELETE          reduce using rule 47 (values -> FALSE .)
    IF              reduce using rule 47 (values -> FALSE .)
    ELSE            reduce using rule 47 (values -> FALSE .)
    TYPE            reduce using rule 47 (values -> FALSE .)
    SWITCH          reduce using rule 47 (values -> FALSE .)
    FUNC            reduce using rule 47 (values -> FALSE .)
    INTEGER         reduce using rule 47 (values -> FALSE .)
    FLOAT           reduce using rule 47 (values -> FALSE .)
    NOT             reduce using rule 47 (values -> FALSE .)
    $end            reduce using rule 47 (values -> FALSE .)
    RLLAVE          reduce using rule 47 (values -> FALSE .)
    DEFAULT         reduce using rule 47 (values -> FALSE .)
    CASE            reduce using rule 47 (values -> FALSE .)
    RETURN          reduce using rule 47 (values -> FALSE .)
    RPAREN          reduce using rule 47 (values -> FALSE .)
    RCORCHE         reduce using rule 47 (values -> FALSE .)
    POINTS          reduce using rule 47 (values -> FALSE .)
    COMA            reduce using rule 47 (values -> FALSE .)


state 127

    (57) operations -> expression .
    (145) value -> expression .

    COLON           reduce using rule 57 (operations -> expression .)
    PRINT           reduce using rule 57 (operations -> expression .)
    SCAN            reduce using rule 57 (operations -> expression .)
    FOR             reduce using rule 57 (operations -> expression .)
    VAR             reduce using rule 57 (operations -> expression .)
    ID              reduce using rule 57 (operations -> expression .)
    APPEND          reduce using rule 57 (operations -> expression .)
    LEN             reduce using rule 57 (operations -> expression .)
    COPY            reduce using rule 57 (operations -> expression .)
    DELETE          reduce using rule 57 (operations -> expression .)
    IF              reduce using rule 57 (operations -> expression .)
    ELSE            reduce using rule 57 (operations -> expression .)
    TYPE            reduce using rule 57 (operations -> expression .)
    SWITCH          reduce using rule 57 (operations -> expression .)
    FUNC            reduce using rule 57 (operations -> expression .)
    INTEGER         reduce using rule 57 (operations -> expression .)
    FLOAT           reduce using rule 57 (operations -> expression .)
    NOT             reduce using rule 57 (operations -> expression .)
    $end            reduce using rule 57 (operations -> expression .)
    RLLAVE          reduce using rule 57 (operations -> expression .)
    DEFAULT         reduce using rule 57 (operations -> expression .)
    CASE            reduce using rule 57 (operations -> expression .)
    RETURN          reduce using rule 57 (operations -> expression .)
    RPAREN          reduce using rule 57 (operations -> expression .)
    COMA            reduce using rule 57 (operations -> expression .)
    GREATER         reduce using rule 145 (value -> expression .)
    SMALLER         reduce using rule 145 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 145 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 145 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 145 (value -> expression .)
    NOT_EQUAL       reduce using rule 145 (value -> expression .)
    PLUS            reduce using rule 145 (value -> expression .)
    TIMES           reduce using rule 145 (value -> expression .)
    DIVIDE          reduce using rule 145 (value -> expression .)
    MINUS           reduce using rule 145 (value -> expression .)


state 128

    (58) operations -> comparison .
    (157) logic_value -> comparison .

    COLON           reduce using rule 58 (operations -> comparison .)
    PRINT           reduce using rule 58 (operations -> comparison .)
    SCAN            reduce using rule 58 (operations -> comparison .)
    FOR             reduce using rule 58 (operations -> comparison .)
    VAR             reduce using rule 58 (operations -> comparison .)
    ID              reduce using rule 58 (operations -> comparison .)
    APPEND          reduce using rule 58 (operations -> comparison .)
    LEN             reduce using rule 58 (operations -> comparison .)
    COPY            reduce using rule 58 (operations -> comparison .)
    DELETE          reduce using rule 58 (operations -> comparison .)
    IF              reduce using rule 58 (operations -> comparison .)
    ELSE            reduce using rule 58 (operations -> comparison .)
    TYPE            reduce using rule 58 (operations -> comparison .)
    SWITCH          reduce using rule 58 (operations -> comparison .)
    FUNC            reduce using rule 58 (operations -> comparison .)
    INTEGER         reduce using rule 58 (operations -> comparison .)
    FLOAT           reduce using rule 58 (operations -> comparison .)
    NOT             reduce using rule 58 (operations -> comparison .)
    $end            reduce using rule 58 (operations -> comparison .)
    RLLAVE          reduce using rule 58 (operations -> comparison .)
    DEFAULT         reduce using rule 58 (operations -> comparison .)
    CASE            reduce using rule 58 (operations -> comparison .)
    RETURN          reduce using rule 58 (operations -> comparison .)
    RPAREN          reduce using rule 58 (operations -> comparison .)
    RCORCHE         reduce using rule 58 (operations -> comparison .)
    COMA            reduce using rule 58 (operations -> comparison .)
    AND             reduce using rule 157 (logic_value -> comparison .)
    OR              reduce using rule 157 (logic_value -> comparison .)


state 129

    (59) operations -> logic_operation .

    COLON           reduce using rule 59 (operations -> logic_operation .)
    PRINT           reduce using rule 59 (operations -> logic_operation .)
    SCAN            reduce using rule 59 (operations -> logic_operation .)
    FOR             reduce using rule 59 (operations -> logic_operation .)
    VAR             reduce using rule 59 (operations -> logic_operation .)
    ID              reduce using rule 59 (operations -> logic_operation .)
    APPEND          reduce using rule 59 (operations -> logic_operation .)
    LEN             reduce using rule 59 (operations -> logic_operation .)
    COPY            reduce using rule 59 (operations -> logic_operation .)
    DELETE          reduce using rule 59 (operations -> logic_operation .)
    IF              reduce using rule 59 (operations -> logic_operation .)
    ELSE            reduce using rule 59 (operations -> logic_operation .)
    TYPE            reduce using rule 59 (operations -> logic_operation .)
    SWITCH          reduce using rule 59 (operations -> logic_operation .)
    FUNC            reduce using rule 59 (operations -> logic_operation .)
    INTEGER         reduce using rule 59 (operations -> logic_operation .)
    FLOAT           reduce using rule 59 (operations -> logic_operation .)
    NOT             reduce using rule 59 (operations -> logic_operation .)
    $end            reduce using rule 59 (operations -> logic_operation .)
    RLLAVE          reduce using rule 59 (operations -> logic_operation .)
    DEFAULT         reduce using rule 59 (operations -> logic_operation .)
    CASE            reduce using rule 59 (operations -> logic_operation .)
    RETURN          reduce using rule 59 (operations -> logic_operation .)
    RPAREN          reduce using rule 59 (operations -> logic_operation .)
    RCORCHE         reduce using rule 59 (operations -> logic_operation .)
    COMA            reduce using rule 59 (operations -> logic_operation .)


state 130

    (113) slice_assignment -> slice_var EQUAL something_s .

    COLON           reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    PRINT           reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    SCAN            reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    FOR             reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    VAR             reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    ID              reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    APPEND          reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    LEN             reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    COPY            reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    DELETE          reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    IF              reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    ELSE            reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    TYPE            reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    SWITCH          reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    FUNC            reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    INTEGER         reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    FLOAT           reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    NOT             reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    $end            reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    RLLAVE          reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    DEFAULT         reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    CASE            reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)
    RETURN          reduce using rule 113 (slice_assignment -> slice_var EQUAL something_s .)


state 131

    (114) something_s -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (205) something_ex -> ID .
    (144) value -> ID .
    (158) logic_value -> ID .
    (179) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for COLON resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 114 (something_s -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 144 (value -> ID .)
    COLON           reduce using rule 114 (something_s -> ID .)
    PRINT           reduce using rule 114 (something_s -> ID .)
    SCAN            reduce using rule 114 (something_s -> ID .)
    FOR             reduce using rule 114 (something_s -> ID .)
    VAR             reduce using rule 114 (something_s -> ID .)
    ID              reduce using rule 114 (something_s -> ID .)
    APPEND          reduce using rule 114 (something_s -> ID .)
    LEN             reduce using rule 114 (something_s -> ID .)
    COPY            reduce using rule 114 (something_s -> ID .)
    DELETE          reduce using rule 114 (something_s -> ID .)
    IF              reduce using rule 114 (something_s -> ID .)
    ELSE            reduce using rule 114 (something_s -> ID .)
    TYPE            reduce using rule 114 (something_s -> ID .)
    SWITCH          reduce using rule 114 (something_s -> ID .)
    FUNC            reduce using rule 114 (something_s -> ID .)
    INTEGER         reduce using rule 114 (something_s -> ID .)
    FLOAT           reduce using rule 114 (something_s -> ID .)
    NOT             reduce using rule 114 (something_s -> ID .)
    $end            reduce using rule 114 (something_s -> ID .)
    RLLAVE          reduce using rule 114 (something_s -> ID .)
    DEFAULT         reduce using rule 114 (something_s -> ID .)
    CASE            reduce using rule 114 (something_s -> ID .)
    RETURN          reduce using rule 114 (something_s -> ID .)
    LCORCHE         shift and go to state 149
    GREATER         reduce using rule 144 (value -> ID .)
    SMALLER         reduce using rule 144 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 144 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 144 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 144 (value -> ID .)
    NOT_EQUAL       reduce using rule 144 (value -> ID .)
    PLUS            reduce using rule 144 (value -> ID .)
    TIMES           reduce using rule 144 (value -> ID .)
    DIVIDE          reduce using rule 144 (value -> ID .)
    MINUS           reduce using rule 144 (value -> ID .)
    AND             reduce using rule 158 (logic_value -> ID .)
    OR              reduce using rule 158 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 205 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 205 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 205 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 205 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 205 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 205 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 205 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 205 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 205 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 205 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 205 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 205 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 205 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 205 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 205 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 205 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 205 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 205 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 205 (something_ex -> ID .) ]


state 132

    (115) something_s -> array_var .
    (60) data_structure -> array_var .

  ! reduce/reduce conflict for COLON resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for PRINT resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for SCAN resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for FOR resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for VAR resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for ID resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for APPEND resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for LEN resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for COPY resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for DELETE resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for IF resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for ELSE resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for TYPE resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for SWITCH resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for FUNC resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for INTEGER resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for FLOAT resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for NOT resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for $end resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for CASE resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for RETURN resolved using rule 60 (data_structure -> array_var .)
    GREATER         reduce using rule 60 (data_structure -> array_var .)
    SMALLER         reduce using rule 60 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 60 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 60 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 60 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 60 (data_structure -> array_var .)
    PLUS            reduce using rule 60 (data_structure -> array_var .)
    TIMES           reduce using rule 60 (data_structure -> array_var .)
    DIVIDE          reduce using rule 60 (data_structure -> array_var .)
    MINUS           reduce using rule 60 (data_structure -> array_var .)
    COLON           reduce using rule 60 (data_structure -> array_var .)
    PRINT           reduce using rule 60 (data_structure -> array_var .)
    SCAN            reduce using rule 60 (data_structure -> array_var .)
    FOR             reduce using rule 60 (data_structure -> array_var .)
    VAR             reduce using rule 60 (data_structure -> array_var .)
    ID              reduce using rule 60 (data_structure -> array_var .)
    APPEND          reduce using rule 60 (data_structure -> array_var .)
    LEN             reduce using rule 60 (data_structure -> array_var .)
    COPY            reduce using rule 60 (data_structure -> array_var .)
    DELETE          reduce using rule 60 (data_structure -> array_var .)
    IF              reduce using rule 60 (data_structure -> array_var .)
    ELSE            reduce using rule 60 (data_structure -> array_var .)
    TYPE            reduce using rule 60 (data_structure -> array_var .)
    SWITCH          reduce using rule 60 (data_structure -> array_var .)
    FUNC            reduce using rule 60 (data_structure -> array_var .)
    INTEGER         reduce using rule 60 (data_structure -> array_var .)
    FLOAT           reduce using rule 60 (data_structure -> array_var .)
    NOT             reduce using rule 60 (data_structure -> array_var .)
    $end            reduce using rule 60 (data_structure -> array_var .)
    RLLAVE          reduce using rule 60 (data_structure -> array_var .)
    DEFAULT         reduce using rule 60 (data_structure -> array_var .)
    CASE            reduce using rule 60 (data_structure -> array_var .)
    RETURN          reduce using rule 60 (data_structure -> array_var .)

  ! COLON           [ reduce using rule 115 (something_s -> array_var .) ]
  ! PRINT           [ reduce using rule 115 (something_s -> array_var .) ]
  ! SCAN            [ reduce using rule 115 (something_s -> array_var .) ]
  ! FOR             [ reduce using rule 115 (something_s -> array_var .) ]
  ! VAR             [ reduce using rule 115 (something_s -> array_var .) ]
  ! ID              [ reduce using rule 115 (something_s -> array_var .) ]
  ! APPEND          [ reduce using rule 115 (something_s -> array_var .) ]
  ! LEN             [ reduce using rule 115 (something_s -> array_var .) ]
  ! COPY            [ reduce using rule 115 (something_s -> array_var .) ]
  ! DELETE          [ reduce using rule 115 (something_s -> array_var .) ]
  ! IF              [ reduce using rule 115 (something_s -> array_var .) ]
  ! ELSE            [ reduce using rule 115 (something_s -> array_var .) ]
  ! TYPE            [ reduce using rule 115 (something_s -> array_var .) ]
  ! SWITCH          [ reduce using rule 115 (something_s -> array_var .) ]
  ! FUNC            [ reduce using rule 115 (something_s -> array_var .) ]
  ! INTEGER         [ reduce using rule 115 (something_s -> array_var .) ]
  ! FLOAT           [ reduce using rule 115 (something_s -> array_var .) ]
  ! NOT             [ reduce using rule 115 (something_s -> array_var .) ]
  ! $end            [ reduce using rule 115 (something_s -> array_var .) ]
  ! RLLAVE          [ reduce using rule 115 (something_s -> array_var .) ]
  ! DEFAULT         [ reduce using rule 115 (something_s -> array_var .) ]
  ! CASE            [ reduce using rule 115 (something_s -> array_var .) ]
  ! RETURN          [ reduce using rule 115 (something_s -> array_var .) ]


state 133

    (116) something_s -> values .

    COLON           reduce using rule 116 (something_s -> values .)
    PRINT           reduce using rule 116 (something_s -> values .)
    SCAN            reduce using rule 116 (something_s -> values .)
    FOR             reduce using rule 116 (something_s -> values .)
    VAR             reduce using rule 116 (something_s -> values .)
    ID              reduce using rule 116 (something_s -> values .)
    APPEND          reduce using rule 116 (something_s -> values .)
    LEN             reduce using rule 116 (something_s -> values .)
    COPY            reduce using rule 116 (something_s -> values .)
    DELETE          reduce using rule 116 (something_s -> values .)
    IF              reduce using rule 116 (something_s -> values .)
    ELSE            reduce using rule 116 (something_s -> values .)
    TYPE            reduce using rule 116 (something_s -> values .)
    SWITCH          reduce using rule 116 (something_s -> values .)
    FUNC            reduce using rule 116 (something_s -> values .)
    INTEGER         reduce using rule 116 (something_s -> values .)
    FLOAT           reduce using rule 116 (something_s -> values .)
    NOT             reduce using rule 116 (something_s -> values .)
    $end            reduce using rule 116 (something_s -> values .)
    RLLAVE          reduce using rule 116 (something_s -> values .)
    DEFAULT         reduce using rule 116 (something_s -> values .)
    CASE            reduce using rule 116 (something_s -> values .)
    RETURN          reduce using rule 116 (something_s -> values .)


state 134

    (117) something_s -> operations .

    COLON           reduce using rule 117 (something_s -> operations .)
    PRINT           reduce using rule 117 (something_s -> operations .)
    SCAN            reduce using rule 117 (something_s -> operations .)
    FOR             reduce using rule 117 (something_s -> operations .)
    VAR             reduce using rule 117 (something_s -> operations .)
    ID              reduce using rule 117 (something_s -> operations .)
    APPEND          reduce using rule 117 (something_s -> operations .)
    LEN             reduce using rule 117 (something_s -> operations .)
    COPY            reduce using rule 117 (something_s -> operations .)
    DELETE          reduce using rule 117 (something_s -> operations .)
    IF              reduce using rule 117 (something_s -> operations .)
    ELSE            reduce using rule 117 (something_s -> operations .)
    TYPE            reduce using rule 117 (something_s -> operations .)
    SWITCH          reduce using rule 117 (something_s -> operations .)
    FUNC            reduce using rule 117 (something_s -> operations .)
    INTEGER         reduce using rule 117 (something_s -> operations .)
    FLOAT           reduce using rule 117 (something_s -> operations .)
    NOT             reduce using rule 117 (something_s -> operations .)
    $end            reduce using rule 117 (something_s -> operations .)
    RLLAVE          reduce using rule 117 (something_s -> operations .)
    DEFAULT         reduce using rule 117 (something_s -> operations .)
    CASE            reduce using rule 117 (something_s -> operations .)
    RETURN          reduce using rule 117 (something_s -> operations .)


state 135

    (195) impresion -> PRINT LPAREN content . RPAREN

    RPAREN          shift and go to state 196


state 136

    (196) content -> values .

    RPAREN          reduce using rule 196 (content -> values .)


state 137

    (197) content -> operations .

    RPAREN          reduce using rule 197 (content -> operations .)


state 138

    (198) content -> funciones .
    (209) something_ex -> funciones .

  ! reduce/reduce conflict for RPAREN resolved using rule 198 (content -> funciones .)
    RPAREN          reduce using rule 198 (content -> funciones .)
    GREATER         reduce using rule 209 (something_ex -> funciones .)
    SMALLER         reduce using rule 209 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 209 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 209 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 209 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 209 (something_ex -> funciones .)
    PLUS            reduce using rule 209 (something_ex -> funciones .)
    TIMES           reduce using rule 209 (something_ex -> funciones .)
    DIVIDE          reduce using rule 209 (something_ex -> funciones .)
    MINUS           reduce using rule 209 (something_ex -> funciones .)

  ! RPAREN          [ reduce using rule 209 (something_ex -> funciones .) ]


state 139

    (199) content -> data_structure .
    (208) something_ex -> data_structure .

  ! reduce/reduce conflict for RPAREN resolved using rule 199 (content -> data_structure .)
    RPAREN          reduce using rule 199 (content -> data_structure .)
    GREATER         reduce using rule 208 (something_ex -> data_structure .)
    SMALLER         reduce using rule 208 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 208 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 208 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 208 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 208 (something_ex -> data_structure .)
    PLUS            reduce using rule 208 (something_ex -> data_structure .)
    TIMES           reduce using rule 208 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 208 (something_ex -> data_structure .)
    MINUS           reduce using rule 208 (something_ex -> data_structure .)

  ! RPAREN          [ reduce using rule 208 (something_ex -> data_structure .) ]


state 140

    (200) content -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (179) map_var -> ID . LCORCHE key RCORCHE
    (205) something_ex -> ID .
    (144) value -> ID .
    (158) logic_value -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 200 (content -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 144 (value -> ID .)
    RPAREN          reduce using rule 200 (content -> ID .)
    LCORCHE         shift and go to state 149
    GREATER         reduce using rule 144 (value -> ID .)
    SMALLER         reduce using rule 144 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 144 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 144 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 144 (value -> ID .)
    NOT_EQUAL       reduce using rule 144 (value -> ID .)
    PLUS            reduce using rule 144 (value -> ID .)
    TIMES           reduce using rule 144 (value -> ID .)
    DIVIDE          reduce using rule 144 (value -> ID .)
    MINUS           reduce using rule 144 (value -> ID .)
    AND             reduce using rule 158 (logic_value -> ID .)
    OR              reduce using rule 158 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 205 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 205 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 205 (something_ex -> ID .) ]
  ! RPAREN          [ reduce using rule 205 (something_ex -> ID .) ]


state 141

    (79) scan_func -> SCAN LPAREN POINTER . RPAREN

    RPAREN          shift and go to state 197


state 142

    (203) adicionaEx -> op something_ex .
    (204) adicionaEx -> op something_ex . adicionaEx
    (203) adicionaEx -> . op something_ex
    (204) adicionaEx -> . op something_ex adicionaEx
    (146) op -> . GREATER
    (147) op -> . SMALLER
    (148) op -> . GREATER_OR_EQUAL
    (149) op -> . SMALLER_OR_EQUAL
    (150) op -> . EQUAL_COMPARE
    (151) op -> . NOT_EQUAL
    (210) op -> . PLUS
    (211) op -> . TIMES
    (212) op -> . DIVIDE
    (213) op -> . MINUS

  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL_COMPARE resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    COLON           reduce using rule 203 (adicionaEx -> op something_ex .)
    PRINT           reduce using rule 203 (adicionaEx -> op something_ex .)
    SCAN            reduce using rule 203 (adicionaEx -> op something_ex .)
    FOR             reduce using rule 203 (adicionaEx -> op something_ex .)
    VAR             reduce using rule 203 (adicionaEx -> op something_ex .)
    ID              reduce using rule 203 (adicionaEx -> op something_ex .)
    APPEND          reduce using rule 203 (adicionaEx -> op something_ex .)
    LEN             reduce using rule 203 (adicionaEx -> op something_ex .)
    COPY            reduce using rule 203 (adicionaEx -> op something_ex .)
    DELETE          reduce using rule 203 (adicionaEx -> op something_ex .)
    IF              reduce using rule 203 (adicionaEx -> op something_ex .)
    ELSE            reduce using rule 203 (adicionaEx -> op something_ex .)
    TYPE            reduce using rule 203 (adicionaEx -> op something_ex .)
    SWITCH          reduce using rule 203 (adicionaEx -> op something_ex .)
    FUNC            reduce using rule 203 (adicionaEx -> op something_ex .)
    INTEGER         reduce using rule 203 (adicionaEx -> op something_ex .)
    FLOAT           reduce using rule 203 (adicionaEx -> op something_ex .)
    NOT             reduce using rule 203 (adicionaEx -> op something_ex .)
    $end            reduce using rule 203 (adicionaEx -> op something_ex .)
    RLLAVE          reduce using rule 203 (adicionaEx -> op something_ex .)
    DEFAULT         reduce using rule 203 (adicionaEx -> op something_ex .)
    CASE            reduce using rule 203 (adicionaEx -> op something_ex .)
    RETURN          reduce using rule 203 (adicionaEx -> op something_ex .)
    RPAREN          reduce using rule 203 (adicionaEx -> op something_ex .)
    AND             reduce using rule 203 (adicionaEx -> op something_ex .)
    OR              reduce using rule 203 (adicionaEx -> op something_ex .)
    LLLAVE          reduce using rule 203 (adicionaEx -> op something_ex .)
    RCORCHE         reduce using rule 203 (adicionaEx -> op something_ex .)
    COMA            reduce using rule 203 (adicionaEx -> op something_ex .)
    GREATER         shift and go to state 74
    SMALLER         shift and go to state 75
    GREATER_OR_EQUAL shift and go to state 76
    SMALLER_OR_EQUAL shift and go to state 77
    EQUAL_COMPARE   shift and go to state 78
    NOT_EQUAL       shift and go to state 79
    PLUS            shift and go to state 80
    TIMES           shift and go to state 81
    DIVIDE          shift and go to state 82
    MINUS           shift and go to state 83

  ! GREATER         [ reduce using rule 203 (adicionaEx -> op something_ex .) ]
  ! SMALLER         [ reduce using rule 203 (adicionaEx -> op something_ex .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 203 (adicionaEx -> op something_ex .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 203 (adicionaEx -> op something_ex .) ]
  ! EQUAL_COMPARE   [ reduce using rule 203 (adicionaEx -> op something_ex .) ]
  ! NOT_EQUAL       [ reduce using rule 203 (adicionaEx -> op something_ex .) ]
  ! PLUS            [ reduce using rule 203 (adicionaEx -> op something_ex .) ]
  ! TIMES           [ reduce using rule 203 (adicionaEx -> op something_ex .) ]
  ! DIVIDE          [ reduce using rule 203 (adicionaEx -> op something_ex .) ]
  ! MINUS           [ reduce using rule 203 (adicionaEx -> op something_ex .) ]

    op                             shift and go to state 73
    adicionaEx                     shift and go to state 198

state 143

    (205) something_ex -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (179) map_var -> ID . LCORCHE key RCORCHE

    GREATER         reduce using rule 205 (something_ex -> ID .)
    SMALLER         reduce using rule 205 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 205 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 205 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 205 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 205 (something_ex -> ID .)
    PLUS            reduce using rule 205 (something_ex -> ID .)
    TIMES           reduce using rule 205 (something_ex -> ID .)
    DIVIDE          reduce using rule 205 (something_ex -> ID .)
    MINUS           reduce using rule 205 (something_ex -> ID .)
    COLON           reduce using rule 205 (something_ex -> ID .)
    PRINT           reduce using rule 205 (something_ex -> ID .)
    SCAN            reduce using rule 205 (something_ex -> ID .)
    FOR             reduce using rule 205 (something_ex -> ID .)
    VAR             reduce using rule 205 (something_ex -> ID .)
    ID              reduce using rule 205 (something_ex -> ID .)
    APPEND          reduce using rule 205 (something_ex -> ID .)
    LEN             reduce using rule 205 (something_ex -> ID .)
    COPY            reduce using rule 205 (something_ex -> ID .)
    DELETE          reduce using rule 205 (something_ex -> ID .)
    IF              reduce using rule 205 (something_ex -> ID .)
    ELSE            reduce using rule 205 (something_ex -> ID .)
    TYPE            reduce using rule 205 (something_ex -> ID .)
    SWITCH          reduce using rule 205 (something_ex -> ID .)
    FUNC            reduce using rule 205 (something_ex -> ID .)
    INTEGER         reduce using rule 205 (something_ex -> ID .)
    FLOAT           reduce using rule 205 (something_ex -> ID .)
    NOT             reduce using rule 205 (something_ex -> ID .)
    $end            reduce using rule 205 (something_ex -> ID .)
    RLLAVE          reduce using rule 205 (something_ex -> ID .)
    DEFAULT         reduce using rule 205 (something_ex -> ID .)
    CASE            reduce using rule 205 (something_ex -> ID .)
    RETURN          reduce using rule 205 (something_ex -> ID .)
    RPAREN          reduce using rule 205 (something_ex -> ID .)
    AND             reduce using rule 205 (something_ex -> ID .)
    OR              reduce using rule 205 (something_ex -> ID .)
    LLLAVE          reduce using rule 205 (something_ex -> ID .)
    RCORCHE         reduce using rule 205 (something_ex -> ID .)
    COMA            reduce using rule 205 (something_ex -> ID .)
    LCORCHE         shift and go to state 149


state 144

    (80) cicloFor -> FOR LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 199


state 145

    (81) cicloFor -> FOR comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    comparison                     shift and go to state 8
    codigo                         shift and go to state 200
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    decVarOne                      shift and go to state 33
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 146

    (82) cicloFor -> FOR logic_operation LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    logic_operation                shift and go to state 9
    codigo                         shift and go to state 201
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    decVarOne                      shift and go to state 33
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 147

    (83) cicloFor -> FOR decVarOne COLON . comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (144) value -> . ID
    (145) value -> . expression
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 108
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    comparison                     shift and go to state 202
    value                          shift and go to state 34
    expression                     shift and go to state 89
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 148

    (123) decVarOne -> ID DEQUAL . ID
    (124) decVarOne -> ID DEQUAL . INTEGER

    ID              shift and go to state 203
    INTEGER         shift and go to state 204


state 149

    (173) array_var -> ID LCORCHE . index RCORCHE
    (179) map_var -> ID LCORCHE . key RCORCHE
    (174) index -> . ID
    (175) index -> . INTEGER
    (176) index -> . expression
    (180) key -> . ID
    (181) key -> . values
    (182) key -> . operations
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 205
    INTEGER         shift and go to state 206
    STRING          shift and go to state 122
    FLOAT           shift and go to state 124
    TRUE            shift and go to state 125
    FALSE           shift and go to state 126
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    NOT             shift and go to state 51

    index                          shift and go to state 174
    key                            shift and go to state 176
    expression                     shift and go to state 207
    values                         shift and go to state 179
    operations                     shift and go to state 180
    something_ex                   shift and go to state 31
    comparison                     shift and go to state 128
    logic_operation                shift and go to state 129
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 150

    (143) comparison -> value op value .

    PRINT           reduce using rule 143 (comparison -> value op value .)
    SCAN            reduce using rule 143 (comparison -> value op value .)
    FOR             reduce using rule 143 (comparison -> value op value .)
    VAR             reduce using rule 143 (comparison -> value op value .)
    ID              reduce using rule 143 (comparison -> value op value .)
    APPEND          reduce using rule 143 (comparison -> value op value .)
    LEN             reduce using rule 143 (comparison -> value op value .)
    COPY            reduce using rule 143 (comparison -> value op value .)
    DELETE          reduce using rule 143 (comparison -> value op value .)
    IF              reduce using rule 143 (comparison -> value op value .)
    ELSE            reduce using rule 143 (comparison -> value op value .)
    TYPE            reduce using rule 143 (comparison -> value op value .)
    SWITCH          reduce using rule 143 (comparison -> value op value .)
    FUNC            reduce using rule 143 (comparison -> value op value .)
    INTEGER         reduce using rule 143 (comparison -> value op value .)
    FLOAT           reduce using rule 143 (comparison -> value op value .)
    NOT             reduce using rule 143 (comparison -> value op value .)
    $end            reduce using rule 143 (comparison -> value op value .)
    AND             reduce using rule 143 (comparison -> value op value .)
    OR              reduce using rule 143 (comparison -> value op value .)
    RLLAVE          reduce using rule 143 (comparison -> value op value .)
    DEFAULT         reduce using rule 143 (comparison -> value op value .)
    CASE            reduce using rule 143 (comparison -> value op value .)
    RETURN          reduce using rule 143 (comparison -> value op value .)
    LLLAVE          reduce using rule 143 (comparison -> value op value .)
    COLON           reduce using rule 143 (comparison -> value op value .)
    RPAREN          reduce using rule 143 (comparison -> value op value .)
    RCORCHE         reduce using rule 143 (comparison -> value op value .)
    COMA            reduce using rule 143 (comparison -> value op value .)


state 151

    (154) logic_recu -> logic_op logic_value .
    (155) logic_recu -> logic_op logic_value . logic_recu
    (154) logic_recu -> . logic_op logic_value
    (155) logic_recu -> . logic_op logic_value logic_recu
    (161) logic_op -> . AND
    (162) logic_op -> . OR

    PRINT           reduce using rule 154 (logic_recu -> logic_op logic_value .)
    SCAN            reduce using rule 154 (logic_recu -> logic_op logic_value .)
    FOR             reduce using rule 154 (logic_recu -> logic_op logic_value .)
    VAR             reduce using rule 154 (logic_recu -> logic_op logic_value .)
    ID              reduce using rule 154 (logic_recu -> logic_op logic_value .)
    APPEND          reduce using rule 154 (logic_recu -> logic_op logic_value .)
    LEN             reduce using rule 154 (logic_recu -> logic_op logic_value .)
    COPY            reduce using rule 154 (logic_recu -> logic_op logic_value .)
    DELETE          reduce using rule 154 (logic_recu -> logic_op logic_value .)
    IF              reduce using rule 154 (logic_recu -> logic_op logic_value .)
    ELSE            reduce using rule 154 (logic_recu -> logic_op logic_value .)
    TYPE            reduce using rule 154 (logic_recu -> logic_op logic_value .)
    SWITCH          reduce using rule 154 (logic_recu -> logic_op logic_value .)
    FUNC            reduce using rule 154 (logic_recu -> logic_op logic_value .)
    INTEGER         reduce using rule 154 (logic_recu -> logic_op logic_value .)
    FLOAT           reduce using rule 154 (logic_recu -> logic_op logic_value .)
    NOT             reduce using rule 154 (logic_recu -> logic_op logic_value .)
    $end            reduce using rule 154 (logic_recu -> logic_op logic_value .)
    RLLAVE          reduce using rule 154 (logic_recu -> logic_op logic_value .)
    DEFAULT         reduce using rule 154 (logic_recu -> logic_op logic_value .)
    CASE            reduce using rule 154 (logic_recu -> logic_op logic_value .)
    RETURN          reduce using rule 154 (logic_recu -> logic_op logic_value .)
    LLLAVE          reduce using rule 154 (logic_recu -> logic_op logic_value .)
    COLON           reduce using rule 154 (logic_recu -> logic_op logic_value .)
    RPAREN          reduce using rule 154 (logic_recu -> logic_op logic_value .)
    RCORCHE         reduce using rule 154 (logic_recu -> logic_op logic_value .)
    COMA            reduce using rule 154 (logic_recu -> logic_op logic_value .)
    AND             shift and go to state 95
    OR              shift and go to state 96

    logic_op                       shift and go to state 94
    logic_recu                     shift and go to state 208

state 152

    (156) logic_value -> negation .

    AND             reduce using rule 156 (logic_value -> negation .)
    OR              reduce using rule 156 (logic_value -> negation .)
    PRINT           reduce using rule 156 (logic_value -> negation .)
    SCAN            reduce using rule 156 (logic_value -> negation .)
    FOR             reduce using rule 156 (logic_value -> negation .)
    VAR             reduce using rule 156 (logic_value -> negation .)
    ID              reduce using rule 156 (logic_value -> negation .)
    APPEND          reduce using rule 156 (logic_value -> negation .)
    LEN             reduce using rule 156 (logic_value -> negation .)
    COPY            reduce using rule 156 (logic_value -> negation .)
    DELETE          reduce using rule 156 (logic_value -> negation .)
    IF              reduce using rule 156 (logic_value -> negation .)
    ELSE            reduce using rule 156 (logic_value -> negation .)
    TYPE            reduce using rule 156 (logic_value -> negation .)
    SWITCH          reduce using rule 156 (logic_value -> negation .)
    FUNC            reduce using rule 156 (logic_value -> negation .)
    INTEGER         reduce using rule 156 (logic_value -> negation .)
    FLOAT           reduce using rule 156 (logic_value -> negation .)
    NOT             reduce using rule 156 (logic_value -> negation .)
    $end            reduce using rule 156 (logic_value -> negation .)
    RLLAVE          reduce using rule 156 (logic_value -> negation .)
    DEFAULT         reduce using rule 156 (logic_value -> negation .)
    CASE            reduce using rule 156 (logic_value -> negation .)
    RETURN          reduce using rule 156 (logic_value -> negation .)
    LLLAVE          reduce using rule 156 (logic_value -> negation .)
    COLON           reduce using rule 156 (logic_value -> negation .)
    RPAREN          reduce using rule 156 (logic_value -> negation .)
    RCORCHE         reduce using rule 156 (logic_value -> negation .)
    COMA            reduce using rule 156 (logic_value -> negation .)


state 153

    (157) logic_value -> comparison .

    AND             reduce using rule 157 (logic_value -> comparison .)
    OR              reduce using rule 157 (logic_value -> comparison .)
    PRINT           reduce using rule 157 (logic_value -> comparison .)
    SCAN            reduce using rule 157 (logic_value -> comparison .)
    FOR             reduce using rule 157 (logic_value -> comparison .)
    VAR             reduce using rule 157 (logic_value -> comparison .)
    ID              reduce using rule 157 (logic_value -> comparison .)
    APPEND          reduce using rule 157 (logic_value -> comparison .)
    LEN             reduce using rule 157 (logic_value -> comparison .)
    COPY            reduce using rule 157 (logic_value -> comparison .)
    DELETE          reduce using rule 157 (logic_value -> comparison .)
    IF              reduce using rule 157 (logic_value -> comparison .)
    ELSE            reduce using rule 157 (logic_value -> comparison .)
    TYPE            reduce using rule 157 (logic_value -> comparison .)
    SWITCH          reduce using rule 157 (logic_value -> comparison .)
    FUNC            reduce using rule 157 (logic_value -> comparison .)
    INTEGER         reduce using rule 157 (logic_value -> comparison .)
    FLOAT           reduce using rule 157 (logic_value -> comparison .)
    NOT             reduce using rule 157 (logic_value -> comparison .)
    $end            reduce using rule 157 (logic_value -> comparison .)
    RLLAVE          reduce using rule 157 (logic_value -> comparison .)
    DEFAULT         reduce using rule 157 (logic_value -> comparison .)
    CASE            reduce using rule 157 (logic_value -> comparison .)
    RETURN          reduce using rule 157 (logic_value -> comparison .)
    LLLAVE          reduce using rule 157 (logic_value -> comparison .)
    COLON           reduce using rule 157 (logic_value -> comparison .)
    RPAREN          reduce using rule 157 (logic_value -> comparison .)
    RCORCHE         reduce using rule 157 (logic_value -> comparison .)
    COMA            reduce using rule 157 (logic_value -> comparison .)


state 154

    (158) logic_value -> ID .
    (144) value -> ID .
    (205) something_ex -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (179) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 144 (value -> ID .)
    AND             reduce using rule 158 (logic_value -> ID .)
    OR              reduce using rule 158 (logic_value -> ID .)
    PRINT           reduce using rule 158 (logic_value -> ID .)
    SCAN            reduce using rule 158 (logic_value -> ID .)
    FOR             reduce using rule 158 (logic_value -> ID .)
    VAR             reduce using rule 158 (logic_value -> ID .)
    ID              reduce using rule 158 (logic_value -> ID .)
    APPEND          reduce using rule 158 (logic_value -> ID .)
    LEN             reduce using rule 158 (logic_value -> ID .)
    COPY            reduce using rule 158 (logic_value -> ID .)
    DELETE          reduce using rule 158 (logic_value -> ID .)
    IF              reduce using rule 158 (logic_value -> ID .)
    ELSE            reduce using rule 158 (logic_value -> ID .)
    TYPE            reduce using rule 158 (logic_value -> ID .)
    SWITCH          reduce using rule 158 (logic_value -> ID .)
    FUNC            reduce using rule 158 (logic_value -> ID .)
    INTEGER         reduce using rule 158 (logic_value -> ID .)
    FLOAT           reduce using rule 158 (logic_value -> ID .)
    NOT             reduce using rule 158 (logic_value -> ID .)
    $end            reduce using rule 158 (logic_value -> ID .)
    RLLAVE          reduce using rule 158 (logic_value -> ID .)
    DEFAULT         reduce using rule 158 (logic_value -> ID .)
    CASE            reduce using rule 158 (logic_value -> ID .)
    RETURN          reduce using rule 158 (logic_value -> ID .)
    LLLAVE          reduce using rule 158 (logic_value -> ID .)
    COLON           reduce using rule 158 (logic_value -> ID .)
    RPAREN          reduce using rule 158 (logic_value -> ID .)
    RCORCHE         reduce using rule 158 (logic_value -> ID .)
    COMA            reduce using rule 158 (logic_value -> ID .)
    GREATER         reduce using rule 144 (value -> ID .)
    SMALLER         reduce using rule 144 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 144 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 144 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 144 (value -> ID .)
    NOT_EQUAL       reduce using rule 144 (value -> ID .)
    PLUS            reduce using rule 144 (value -> ID .)
    TIMES           reduce using rule 144 (value -> ID .)
    DIVIDE          reduce using rule 144 (value -> ID .)
    MINUS           reduce using rule 144 (value -> ID .)
    LCORCHE         shift and go to state 149

  ! GREATER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 205 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 205 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 205 (something_ex -> ID .) ]


state 155

    (87) decVar -> VAR ID EQUAL . INTEGER
    (88) decVar -> VAR ID EQUAL . ID
    (89) decVar -> VAR ID EQUAL . FLOAT
    (90) decVar -> VAR ID EQUAL . expression
    (91) decVar -> VAR ID EQUAL . logic_operation
    (92) decVar -> VAR ID EQUAL . comparison
    (93) decVar -> VAR ID EQUAL . STRING
    (169) array_declaration -> VAR ID EQUAL . LCORCHE capacity RCORCHE data_types arr_content
    (100) slice_declaration -> VAR ID EQUAL . LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> VAR ID EQUAL . funM
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (143) comparison -> . value op value
    (104) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (105) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (144) value -> . ID
    (145) value -> . expression
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    INTEGER         shift and go to state 210
    ID              shift and go to state 209
    FLOAT           shift and go to state 211
    STRING          shift and go to state 215
    LCORCHE         shift and go to state 216
    MAKE            shift and go to state 166
    NOT             shift and go to state 51
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    expression                     shift and go to state 212
    logic_operation                shift and go to state 213
    comparison                     shift and go to state 214
    funM                           shift and go to state 217
    something_ex                   shift and go to state 31
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    value                          shift and go to state 34
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 156

    (168) array_declaration -> VAR ID LCORCHE . capacity RCORCHE data_types
    (99) slice_declaration -> VAR ID LCORCHE . RCORCHE data_types
    (178) map_declaration -> VAR ID LCORCHE . data_types RCORCHE data_types
    (170) capacity -> . INTEGER
    (171) capacity -> . ID
    (172) capacity -> . expression
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    RCORCHE         shift and go to state 220
    INTEGER         shift and go to state 222
    ID              shift and go to state 218
    INT32           shift and go to state 224
    INT64           shift and go to state 225
    FLOAT32         shift and go to state 226
    FLOAT64         shift and go to state 227
    BYTE            shift and go to state 228
    WINT            shift and go to state 229
    WFLOAT          shift and go to state 230
    WSTRING         shift and go to state 231
    BOOL            shift and go to state 232
    FLOAT           shift and go to state 40
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    capacity                       shift and go to state 219
    data_types                     shift and go to state 221
    expression                     shift and go to state 223
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 157

    (136) cStruct -> ID DEQUAL ID . LLLAVE asignaciones RLLAVE
    (123) decVarOne -> ID DEQUAL ID .
    (205) something_ex -> ID .
    (158) logic_value -> ID .
    (144) value -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (179) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for COLON resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for FOR resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for VAR resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for ID resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for LEN resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for COPY resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for IF resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for NOT resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for $end resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for CASE resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 123 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 144 (value -> ID .)
    LLLAVE          shift and go to state 233
    COLON           reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    PRINT           reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    SCAN            reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    FOR             reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    VAR             reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    ID              reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    APPEND          reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    LEN             reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    COPY            reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    DELETE          reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    IF              reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    ELSE            reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    TYPE            reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    SWITCH          reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    FUNC            reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    INTEGER         reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    FLOAT           reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    NOT             reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    $end            reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    RLLAVE          reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    DEFAULT         reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    CASE            reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    RETURN          reduce using rule 123 (decVarOne -> ID DEQUAL ID .)
    AND             reduce using rule 158 (logic_value -> ID .)
    OR              reduce using rule 158 (logic_value -> ID .)
    GREATER         reduce using rule 144 (value -> ID .)
    SMALLER         reduce using rule 144 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 144 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 144 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 144 (value -> ID .)
    NOT_EQUAL       reduce using rule 144 (value -> ID .)
    PLUS            reduce using rule 144 (value -> ID .)
    TIMES           reduce using rule 144 (value -> ID .)
    DIVIDE          reduce using rule 144 (value -> ID .)
    MINUS           reduce using rule 144 (value -> ID .)
    LCORCHE         shift and go to state 149

  ! GREATER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 205 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 205 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 205 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 205 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 205 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 205 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 205 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 205 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 205 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 205 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 205 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 205 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 205 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 205 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 205 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 205 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 205 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 205 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 205 (something_ex -> ID .) ]


state 158

    (94) decVar -> ID DEQUAL STRING .

    COLON           reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    PRINT           reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    SCAN            reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    FOR             reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    VAR             reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    ID              reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    APPEND          reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    LEN             reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    COPY            reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    DELETE          reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    IF              reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    ELSE            reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    TYPE            reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    SWITCH          reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    FUNC            reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    INTEGER         reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    FLOAT           reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    NOT             reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    $end            reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    RLLAVE          reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    DEFAULT         reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    CASE            reduce using rule 94 (decVar -> ID DEQUAL STRING .)
    RETURN          reduce using rule 94 (decVar -> ID DEQUAL STRING .)


state 159

    (95) decVar -> ID DEQUAL FLOAT .
    (207) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for PRINT resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for SCAN resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for FOR resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for VAR resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for ID resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for APPEND resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for LEN resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for COPY resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for DELETE resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for IF resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for ELSE resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for TYPE resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for SWITCH resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for FUNC resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for INTEGER resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for FLOAT resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for NOT resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 95 (decVar -> ID DEQUAL FLOAT .)
    COLON           reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    PRINT           reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    SCAN            reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    FOR             reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    VAR             reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    ID              reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    APPEND          reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    LEN             reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    COPY            reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    DELETE          reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    IF              reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    ELSE            reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    TYPE            reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    SWITCH          reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    FUNC            reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    INTEGER         reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    FLOAT           reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    NOT             reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    $end            reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    RLLAVE          reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    DEFAULT         reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    CASE            reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    RETURN          reduce using rule 95 (decVar -> ID DEQUAL FLOAT .)
    GREATER         reduce using rule 207 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 207 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 207 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 207 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 207 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 207 (something_ex -> FLOAT .)
    PLUS            reduce using rule 207 (something_ex -> FLOAT .)
    TIMES           reduce using rule 207 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 207 (something_ex -> FLOAT .)
    MINUS           reduce using rule 207 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! PRINT           [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! SCAN            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! FOR             [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! VAR             [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! ID              [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! APPEND          [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! LEN             [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! COPY            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! DELETE          [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! IF              [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! ELSE            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! TYPE            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! SWITCH          [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! FUNC            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! INTEGER         [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! FLOAT           [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! NOT             [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 207 (something_ex -> FLOAT .) ]


state 160

    (96) decVar -> ID DEQUAL expression .
    (145) value -> expression .

    COLON           reduce using rule 96 (decVar -> ID DEQUAL expression .)
    PRINT           reduce using rule 96 (decVar -> ID DEQUAL expression .)
    SCAN            reduce using rule 96 (decVar -> ID DEQUAL expression .)
    FOR             reduce using rule 96 (decVar -> ID DEQUAL expression .)
    VAR             reduce using rule 96 (decVar -> ID DEQUAL expression .)
    ID              reduce using rule 96 (decVar -> ID DEQUAL expression .)
    APPEND          reduce using rule 96 (decVar -> ID DEQUAL expression .)
    LEN             reduce using rule 96 (decVar -> ID DEQUAL expression .)
    COPY            reduce using rule 96 (decVar -> ID DEQUAL expression .)
    DELETE          reduce using rule 96 (decVar -> ID DEQUAL expression .)
    IF              reduce using rule 96 (decVar -> ID DEQUAL expression .)
    ELSE            reduce using rule 96 (decVar -> ID DEQUAL expression .)
    TYPE            reduce using rule 96 (decVar -> ID DEQUAL expression .)
    SWITCH          reduce using rule 96 (decVar -> ID DEQUAL expression .)
    FUNC            reduce using rule 96 (decVar -> ID DEQUAL expression .)
    INTEGER         reduce using rule 96 (decVar -> ID DEQUAL expression .)
    FLOAT           reduce using rule 96 (decVar -> ID DEQUAL expression .)
    NOT             reduce using rule 96 (decVar -> ID DEQUAL expression .)
    $end            reduce using rule 96 (decVar -> ID DEQUAL expression .)
    RLLAVE          reduce using rule 96 (decVar -> ID DEQUAL expression .)
    DEFAULT         reduce using rule 96 (decVar -> ID DEQUAL expression .)
    CASE            reduce using rule 96 (decVar -> ID DEQUAL expression .)
    RETURN          reduce using rule 96 (decVar -> ID DEQUAL expression .)
    GREATER         reduce using rule 145 (value -> expression .)
    SMALLER         reduce using rule 145 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 145 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 145 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 145 (value -> expression .)
    NOT_EQUAL       reduce using rule 145 (value -> expression .)
    PLUS            reduce using rule 145 (value -> expression .)
    TIMES           reduce using rule 145 (value -> expression .)
    DIVIDE          reduce using rule 145 (value -> expression .)
    MINUS           reduce using rule 145 (value -> expression .)


state 161

    (97) decVar -> ID DEQUAL logic_operation .

    COLON           reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    PRINT           reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    SCAN            reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    FOR             reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    VAR             reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    ID              reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    APPEND          reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    LEN             reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    COPY            reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    DELETE          reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    IF              reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    ELSE            reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    TYPE            reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    SWITCH          reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    FUNC            reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    INTEGER         reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    FLOAT           reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    NOT             reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    $end            reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    RLLAVE          reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    DEFAULT         reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    CASE            reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)
    RETURN          reduce using rule 97 (decVar -> ID DEQUAL logic_operation .)


state 162

    (98) decVar -> ID DEQUAL comparison .
    (157) logic_value -> comparison .

    COLON           reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    PRINT           reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    SCAN            reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    FOR             reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    VAR             reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    ID              reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    APPEND          reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    LEN             reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    COPY            reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    DELETE          reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    IF              reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    ELSE            reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    TYPE            reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    SWITCH          reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    FUNC            reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    INTEGER         reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    FLOAT           reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    NOT             reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    $end            reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    RLLAVE          reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    DEFAULT         reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    CASE            reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    RETURN          reduce using rule 98 (decVar -> ID DEQUAL comparison .)
    AND             reduce using rule 157 (logic_value -> comparison .)
    OR              reduce using rule 157 (logic_value -> comparison .)


state 163

    (102) slice_declaration -> ID DEQUAL funM .

    COLON           reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    PRINT           reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    SCAN            reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    FOR             reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    VAR             reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    ID              reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    APPEND          reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    LEN             reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    COPY            reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    DELETE          reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    IF              reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    ELSE            reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    TYPE            reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    SWITCH          reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    FUNC            reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    INTEGER         reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    FLOAT           reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    NOT             reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    $end            reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    RLLAVE          reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    DEFAULT         reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    CASE            reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)
    RETURN          reduce using rule 102 (slice_declaration -> ID DEQUAL funM .)


state 164

    (103) slice_declaration -> ID DEQUAL LCORCHE . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 234


state 165

    (124) decVarOne -> ID DEQUAL INTEGER .
    (206) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for PRINT resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for SCAN resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for FOR resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for VAR resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for ID resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for APPEND resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for LEN resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for COPY resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for DELETE resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for IF resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for ELSE resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for TYPE resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for SWITCH resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for FUNC resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for INTEGER resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for FLOAT resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for NOT resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    COLON           reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    PRINT           reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    SCAN            reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    FOR             reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    VAR             reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    ID              reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    APPEND          reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    LEN             reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    COPY            reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    DELETE          reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    IF              reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    ELSE            reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    TYPE            reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    SWITCH          reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    FUNC            reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    INTEGER         reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    FLOAT           reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    NOT             reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    $end            reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    RLLAVE          reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    DEFAULT         reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    CASE            reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    RETURN          reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)
    GREATER         reduce using rule 206 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 206 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 206 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 206 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 206 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 206 (something_ex -> INTEGER .)
    PLUS            reduce using rule 206 (something_ex -> INTEGER .)
    TIMES           reduce using rule 206 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 206 (something_ex -> INTEGER .)
    MINUS           reduce using rule 206 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! PRINT           [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! SCAN            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! FOR             [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! VAR             [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! ID              [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! APPEND          [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! LEN             [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! COPY            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! DELETE          [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! IF              [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! ELSE            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! TYPE            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! SWITCH          [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! FUNC            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! INTEGER         [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! FLOAT           [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! NOT             [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 206 (something_ex -> INTEGER .) ]


state 166

    (104) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (105) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LPAREN          shift and go to state 235


state 167

    (65) any -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (179) map_var -> ID . LCORCHE key RCORCHE
    (205) something_ex -> ID .
    (144) value -> ID .
    (158) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 144 (value -> ID .)
    COLON           reduce using rule 65 (any -> ID .)
    PRINT           reduce using rule 65 (any -> ID .)
    SCAN            reduce using rule 65 (any -> ID .)
    FOR             reduce using rule 65 (any -> ID .)
    VAR             reduce using rule 65 (any -> ID .)
    ID              reduce using rule 65 (any -> ID .)
    APPEND          reduce using rule 65 (any -> ID .)
    LEN             reduce using rule 65 (any -> ID .)
    COPY            reduce using rule 65 (any -> ID .)
    DELETE          reduce using rule 65 (any -> ID .)
    IF              reduce using rule 65 (any -> ID .)
    ELSE            reduce using rule 65 (any -> ID .)
    TYPE            reduce using rule 65 (any -> ID .)
    SWITCH          reduce using rule 65 (any -> ID .)
    FUNC            reduce using rule 65 (any -> ID .)
    INTEGER         reduce using rule 65 (any -> ID .)
    FLOAT           reduce using rule 65 (any -> ID .)
    NOT             reduce using rule 65 (any -> ID .)
    $end            reduce using rule 65 (any -> ID .)
    RLLAVE          reduce using rule 65 (any -> ID .)
    DEFAULT         reduce using rule 65 (any -> ID .)
    CASE            reduce using rule 65 (any -> ID .)
    RETURN          reduce using rule 65 (any -> ID .)
    LCORCHE         shift and go to state 149
    GREATER         reduce using rule 144 (value -> ID .)
    SMALLER         reduce using rule 144 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 144 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 144 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 144 (value -> ID .)
    NOT_EQUAL       reduce using rule 144 (value -> ID .)
    PLUS            reduce using rule 144 (value -> ID .)
    TIMES           reduce using rule 144 (value -> ID .)
    DIVIDE          reduce using rule 144 (value -> ID .)
    MINUS           reduce using rule 144 (value -> ID .)
    AND             reduce using rule 158 (logic_value -> ID .)
    OR              reduce using rule 158 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 205 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 205 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 205 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 205 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 205 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 205 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 205 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 205 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 205 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 205 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 205 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 205 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 205 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 205 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 205 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 205 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 205 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 205 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 205 (something_ex -> ID .) ]


state 168

    (62) var_asignation -> ID EQUAL any .

    COLON           reduce using rule 62 (var_asignation -> ID EQUAL any .)
    PRINT           reduce using rule 62 (var_asignation -> ID EQUAL any .)
    SCAN            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    FOR             reduce using rule 62 (var_asignation -> ID EQUAL any .)
    VAR             reduce using rule 62 (var_asignation -> ID EQUAL any .)
    ID              reduce using rule 62 (var_asignation -> ID EQUAL any .)
    APPEND          reduce using rule 62 (var_asignation -> ID EQUAL any .)
    LEN             reduce using rule 62 (var_asignation -> ID EQUAL any .)
    COPY            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    DELETE          reduce using rule 62 (var_asignation -> ID EQUAL any .)
    IF              reduce using rule 62 (var_asignation -> ID EQUAL any .)
    ELSE            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    TYPE            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    SWITCH          reduce using rule 62 (var_asignation -> ID EQUAL any .)
    FUNC            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    INTEGER         reduce using rule 62 (var_asignation -> ID EQUAL any .)
    FLOAT           reduce using rule 62 (var_asignation -> ID EQUAL any .)
    NOT             reduce using rule 62 (var_asignation -> ID EQUAL any .)
    $end            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    RLLAVE          reduce using rule 62 (var_asignation -> ID EQUAL any .)
    DEFAULT         reduce using rule 62 (var_asignation -> ID EQUAL any .)
    CASE            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    RETURN          reduce using rule 62 (var_asignation -> ID EQUAL any .)


state 169

    (63) any -> values .

    COLON           reduce using rule 63 (any -> values .)
    PRINT           reduce using rule 63 (any -> values .)
    SCAN            reduce using rule 63 (any -> values .)
    FOR             reduce using rule 63 (any -> values .)
    VAR             reduce using rule 63 (any -> values .)
    ID              reduce using rule 63 (any -> values .)
    APPEND          reduce using rule 63 (any -> values .)
    LEN             reduce using rule 63 (any -> values .)
    COPY            reduce using rule 63 (any -> values .)
    DELETE          reduce using rule 63 (any -> values .)
    IF              reduce using rule 63 (any -> values .)
    ELSE            reduce using rule 63 (any -> values .)
    TYPE            reduce using rule 63 (any -> values .)
    SWITCH          reduce using rule 63 (any -> values .)
    FUNC            reduce using rule 63 (any -> values .)
    INTEGER         reduce using rule 63 (any -> values .)
    FLOAT           reduce using rule 63 (any -> values .)
    NOT             reduce using rule 63 (any -> values .)
    $end            reduce using rule 63 (any -> values .)
    RLLAVE          reduce using rule 63 (any -> values .)
    DEFAULT         reduce using rule 63 (any -> values .)
    CASE            reduce using rule 63 (any -> values .)
    RETURN          reduce using rule 63 (any -> values .)


state 170

    (64) any -> operations .

    COLON           reduce using rule 64 (any -> operations .)
    PRINT           reduce using rule 64 (any -> operations .)
    SCAN            reduce using rule 64 (any -> operations .)
    FOR             reduce using rule 64 (any -> operations .)
    VAR             reduce using rule 64 (any -> operations .)
    ID              reduce using rule 64 (any -> operations .)
    APPEND          reduce using rule 64 (any -> operations .)
    LEN             reduce using rule 64 (any -> operations .)
    COPY            reduce using rule 64 (any -> operations .)
    DELETE          reduce using rule 64 (any -> operations .)
    IF              reduce using rule 64 (any -> operations .)
    ELSE            reduce using rule 64 (any -> operations .)
    TYPE            reduce using rule 64 (any -> operations .)
    SWITCH          reduce using rule 64 (any -> operations .)
    FUNC            reduce using rule 64 (any -> operations .)
    INTEGER         reduce using rule 64 (any -> operations .)
    FLOAT           reduce using rule 64 (any -> operations .)
    NOT             reduce using rule 64 (any -> operations .)
    $end            reduce using rule 64 (any -> operations .)
    RLLAVE          reduce using rule 64 (any -> operations .)
    DEFAULT         reduce using rule 64 (any -> operations .)
    CASE            reduce using rule 64 (any -> operations .)
    RETURN          reduce using rule 64 (any -> operations .)


state 171

    (66) any -> data_structure .
    (208) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for PRINT resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for SCAN resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for FOR resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for VAR resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for ID resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for APPEND resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for LEN resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for COPY resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for DELETE resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for IF resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for ELSE resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for TYPE resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for SWITCH resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for FUNC resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for INTEGER resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for FLOAT resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for NOT resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for $end resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for CASE resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for RETURN resolved using rule 66 (any -> data_structure .)
    COLON           reduce using rule 66 (any -> data_structure .)
    PRINT           reduce using rule 66 (any -> data_structure .)
    SCAN            reduce using rule 66 (any -> data_structure .)
    FOR             reduce using rule 66 (any -> data_structure .)
    VAR             reduce using rule 66 (any -> data_structure .)
    ID              reduce using rule 66 (any -> data_structure .)
    APPEND          reduce using rule 66 (any -> data_structure .)
    LEN             reduce using rule 66 (any -> data_structure .)
    COPY            reduce using rule 66 (any -> data_structure .)
    DELETE          reduce using rule 66 (any -> data_structure .)
    IF              reduce using rule 66 (any -> data_structure .)
    ELSE            reduce using rule 66 (any -> data_structure .)
    TYPE            reduce using rule 66 (any -> data_structure .)
    SWITCH          reduce using rule 66 (any -> data_structure .)
    FUNC            reduce using rule 66 (any -> data_structure .)
    INTEGER         reduce using rule 66 (any -> data_structure .)
    FLOAT           reduce using rule 66 (any -> data_structure .)
    NOT             reduce using rule 66 (any -> data_structure .)
    $end            reduce using rule 66 (any -> data_structure .)
    RLLAVE          reduce using rule 66 (any -> data_structure .)
    DEFAULT         reduce using rule 66 (any -> data_structure .)
    CASE            reduce using rule 66 (any -> data_structure .)
    RETURN          reduce using rule 66 (any -> data_structure .)
    GREATER         reduce using rule 208 (something_ex -> data_structure .)
    SMALLER         reduce using rule 208 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 208 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 208 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 208 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 208 (something_ex -> data_structure .)
    PLUS            reduce using rule 208 (something_ex -> data_structure .)
    TIMES           reduce using rule 208 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 208 (something_ex -> data_structure .)
    MINUS           reduce using rule 208 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! PRINT           [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! SCAN            [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! FOR             [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! VAR             [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! ID              [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! APPEND          [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! LEN             [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! COPY            [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! DELETE          [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! IF              [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! ELSE            [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! TYPE            [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! SWITCH          [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! FUNC            [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! INTEGER         [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! FLOAT           [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! NOT             [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! $end            [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! DEFAULT         [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! CASE            [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! RETURN          [ reduce using rule 208 (something_ex -> data_structure .) ]


state 172

    (67) any -> funciones .
    (209) something_ex -> funciones .

  ! reduce/reduce conflict for COLON resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for PRINT resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for SCAN resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for FOR resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for VAR resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for ID resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for APPEND resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for LEN resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for COPY resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for DELETE resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for IF resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for ELSE resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for TYPE resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for SWITCH resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for FUNC resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for INTEGER resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for FLOAT resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for NOT resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for $end resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for CASE resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for RETURN resolved using rule 67 (any -> funciones .)
    COLON           reduce using rule 67 (any -> funciones .)
    PRINT           reduce using rule 67 (any -> funciones .)
    SCAN            reduce using rule 67 (any -> funciones .)
    FOR             reduce using rule 67 (any -> funciones .)
    VAR             reduce using rule 67 (any -> funciones .)
    ID              reduce using rule 67 (any -> funciones .)
    APPEND          reduce using rule 67 (any -> funciones .)
    LEN             reduce using rule 67 (any -> funciones .)
    COPY            reduce using rule 67 (any -> funciones .)
    DELETE          reduce using rule 67 (any -> funciones .)
    IF              reduce using rule 67 (any -> funciones .)
    ELSE            reduce using rule 67 (any -> funciones .)
    TYPE            reduce using rule 67 (any -> funciones .)
    SWITCH          reduce using rule 67 (any -> funciones .)
    FUNC            reduce using rule 67 (any -> funciones .)
    INTEGER         reduce using rule 67 (any -> funciones .)
    FLOAT           reduce using rule 67 (any -> funciones .)
    NOT             reduce using rule 67 (any -> funciones .)
    $end            reduce using rule 67 (any -> funciones .)
    RLLAVE          reduce using rule 67 (any -> funciones .)
    DEFAULT         reduce using rule 67 (any -> funciones .)
    CASE            reduce using rule 67 (any -> funciones .)
    RETURN          reduce using rule 67 (any -> funciones .)
    GREATER         reduce using rule 209 (something_ex -> funciones .)
    SMALLER         reduce using rule 209 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 209 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 209 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 209 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 209 (something_ex -> funciones .)
    PLUS            reduce using rule 209 (something_ex -> funciones .)
    TIMES           reduce using rule 209 (something_ex -> funciones .)
    DIVIDE          reduce using rule 209 (something_ex -> funciones .)
    MINUS           reduce using rule 209 (something_ex -> funciones .)

  ! COLON           [ reduce using rule 209 (something_ex -> funciones .) ]
  ! PRINT           [ reduce using rule 209 (something_ex -> funciones .) ]
  ! SCAN            [ reduce using rule 209 (something_ex -> funciones .) ]
  ! FOR             [ reduce using rule 209 (something_ex -> funciones .) ]
  ! VAR             [ reduce using rule 209 (something_ex -> funciones .) ]
  ! ID              [ reduce using rule 209 (something_ex -> funciones .) ]
  ! APPEND          [ reduce using rule 209 (something_ex -> funciones .) ]
  ! LEN             [ reduce using rule 209 (something_ex -> funciones .) ]
  ! COPY            [ reduce using rule 209 (something_ex -> funciones .) ]
  ! DELETE          [ reduce using rule 209 (something_ex -> funciones .) ]
  ! IF              [ reduce using rule 209 (something_ex -> funciones .) ]
  ! ELSE            [ reduce using rule 209 (something_ex -> funciones .) ]
  ! TYPE            [ reduce using rule 209 (something_ex -> funciones .) ]
  ! SWITCH          [ reduce using rule 209 (something_ex -> funciones .) ]
  ! FUNC            [ reduce using rule 209 (something_ex -> funciones .) ]
  ! INTEGER         [ reduce using rule 209 (something_ex -> funciones .) ]
  ! FLOAT           [ reduce using rule 209 (something_ex -> funciones .) ]
  ! NOT             [ reduce using rule 209 (something_ex -> funciones .) ]
  ! $end            [ reduce using rule 209 (something_ex -> funciones .) ]
  ! RLLAVE          [ reduce using rule 209 (something_ex -> funciones .) ]
  ! DEFAULT         [ reduce using rule 209 (something_ex -> funciones .) ]
  ! CASE            [ reduce using rule 209 (something_ex -> funciones .) ]
  ! RETURN          [ reduce using rule 209 (something_ex -> funciones .) ]


state 173

    (174) index -> ID .
    (110) index_s -> ID .
    (180) key -> ID .
    (205) something_ex -> ID .
    (144) value -> ID .
    (158) logic_value -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (179) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for RCORCHE resolved using rule 110 (index_s -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 110 (index_s -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 110 (index_s -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 144 (value -> ID .)
    RCORCHE         reduce using rule 110 (index_s -> ID .)
    GREATER         reduce using rule 144 (value -> ID .)
    SMALLER         reduce using rule 144 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 144 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 144 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 144 (value -> ID .)
    NOT_EQUAL       reduce using rule 144 (value -> ID .)
    PLUS            reduce using rule 144 (value -> ID .)
    TIMES           reduce using rule 144 (value -> ID .)
    DIVIDE          reduce using rule 144 (value -> ID .)
    MINUS           reduce using rule 144 (value -> ID .)
    AND             reduce using rule 158 (logic_value -> ID .)
    OR              reduce using rule 158 (logic_value -> ID .)
    LCORCHE         shift and go to state 149

  ! RCORCHE         [ reduce using rule 174 (index -> ID .) ]
  ! RCORCHE         [ reduce using rule 180 (key -> ID .) ]
  ! GREATER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 205 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 205 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 205 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 205 (something_ex -> ID .) ]


state 174

    (173) array_var -> ID LCORCHE index . RCORCHE

    RCORCHE         shift and go to state 236


state 175

    (109) slice_var -> ID LCORCHE index_s . RCORCHE

    RCORCHE         shift and go to state 237


state 176

    (179) map_var -> ID LCORCHE key . RCORCHE

    RCORCHE         shift and go to state 238


state 177

    (175) index -> INTEGER .
    (111) index_s -> INTEGER .
    (44) values -> INTEGER .
    (206) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 111 (index_s -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 44 (values -> INTEGER .)
    RCORCHE         reduce using rule 44 (values -> INTEGER .)
    GREATER         reduce using rule 206 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 206 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 206 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 206 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 206 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 206 (something_ex -> INTEGER .)
    PLUS            reduce using rule 206 (something_ex -> INTEGER .)
    TIMES           reduce using rule 206 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 206 (something_ex -> INTEGER .)
    MINUS           reduce using rule 206 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 175 (index -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 111 (index_s -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 206 (something_ex -> INTEGER .) ]


state 178

    (176) index -> expression .
    (112) index_s -> expression .
    (57) operations -> expression .
    (145) value -> expression .

  ! reduce/reduce conflict for RCORCHE resolved using rule 112 (index_s -> expression .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 57 (operations -> expression .)
    RCORCHE         reduce using rule 57 (operations -> expression .)
    GREATER         reduce using rule 145 (value -> expression .)
    SMALLER         reduce using rule 145 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 145 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 145 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 145 (value -> expression .)
    NOT_EQUAL       reduce using rule 145 (value -> expression .)
    PLUS            reduce using rule 145 (value -> expression .)
    TIMES           reduce using rule 145 (value -> expression .)
    DIVIDE          reduce using rule 145 (value -> expression .)
    MINUS           reduce using rule 145 (value -> expression .)

  ! RCORCHE         [ reduce using rule 176 (index -> expression .) ]
  ! RCORCHE         [ reduce using rule 112 (index_s -> expression .) ]


state 179

    (181) key -> values .

    RCORCHE         reduce using rule 181 (key -> values .)


state 180

    (182) key -> operations .

    RCORCHE         reduce using rule 182 (key -> operations .)


state 181

    (118) funciones -> APPEND LPAREN ID . COMA values RPAREN
    (119) funciones -> APPEND LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 239


state 182

    (120) funciones -> LEN LPAREN ID . RPAREN

    RPAREN          shift and go to state 240


state 183

    (121) funciones -> COPY LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 241


state 184

    (122) funciones -> DELETE LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 242


state 185

    (125) SenIF -> IF comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    comparison                     shift and go to state 8
    codigo                         shift and go to state 243
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    decVarOne                      shift and go to state 33
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 186

    (126) SenIF -> IF TRUE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    codigo                         shift and go to state 244
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    decVarOne                      shift and go to state 33
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 187

    (127) SenIF -> IF FALSE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    codigo                         shift and go to state 245
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    decVarOne                      shift and go to state 33
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 188

    (128) SenElseIF -> ELSE IF comparison . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 246


state 189

    (129) SenElseIF -> ELSE IF TRUE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 247


state 190

    (130) SenElseIF -> ELSE IF FALSE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 248


state 191

    (131) SenElse -> ELSE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 249


state 192

    (132) SenStruct -> TYPE ID STRUCT . LLLAVE declaration RLLAVE

    LLLAVE          shift and go to state 250


state 193

    (163) switch_statement -> SWITCH ID LLLAVE . cases RLLAVE
    (164) cases -> . CASE values POINTS codigo
    (165) cases -> . CASE values POINTS codigo more

    CASE            shift and go to state 252

    cases                          shift and go to state 251

state 194

    (184) func_declaration -> FUNC ID LPAREN . params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> FUNC ID LPAREN . params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (192) params -> . ID data_types
    (193) params -> . more_params
    (194) more_params -> . ID data_types COMA params

    ID              shift and go to state 253

    params                         shift and go to state 254
    more_params                    shift and go to state 255

state 195

    (78) main_func -> FUNC MAIN LPAREN . RPAREN LLLAVE codigo RLLAVE

    RPAREN          shift and go to state 256


state 196

    (195) impresion -> PRINT LPAREN content RPAREN .

    COLON           reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    PRINT           reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    SCAN            reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    FOR             reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    VAR             reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    ID              reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    APPEND          reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    LEN             reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    COPY            reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    DELETE          reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    IF              reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    ELSE            reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    TYPE            reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    SWITCH          reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    FUNC            reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    INTEGER         reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    FLOAT           reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    NOT             reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    $end            reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    RLLAVE          reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    DEFAULT         reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    CASE            reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)
    RETURN          reduce using rule 195 (impresion -> PRINT LPAREN content RPAREN .)


state 197

    (79) scan_func -> SCAN LPAREN POINTER RPAREN .

    COLON           reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    PRINT           reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    SCAN            reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FOR             reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    VAR             reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    ID              reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    APPEND          reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    LEN             reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    COPY            reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    DELETE          reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    IF              reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    ELSE            reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    TYPE            reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    SWITCH          reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FUNC            reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    INTEGER         reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FLOAT           reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    NOT             reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    $end            reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    RLLAVE          reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    DEFAULT         reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    CASE            reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    RETURN          reduce using rule 79 (scan_func -> SCAN LPAREN POINTER RPAREN .)


state 198

    (204) adicionaEx -> op something_ex adicionaEx .

    COLON           reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    PRINT           reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    SCAN            reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    FOR             reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    VAR             reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    ID              reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    APPEND          reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    LEN             reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    COPY            reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    DELETE          reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    IF              reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    ELSE            reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    TYPE            reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    SWITCH          reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    FUNC            reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    INTEGER         reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    FLOAT           reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    NOT             reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    $end            reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    GREATER         reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    SMALLER         reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    GREATER_OR_EQUAL reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    SMALLER_OR_EQUAL reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    EQUAL_COMPARE   reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    NOT_EQUAL       reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    PLUS            reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    TIMES           reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    DIVIDE          reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    MINUS           reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    RLLAVE          reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    DEFAULT         reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    CASE            reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    RETURN          reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    RPAREN          reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    AND             reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    OR              reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    LLLAVE          reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    RCORCHE         reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)
    COMA            reduce using rule 204 (adicionaEx -> op something_ex adicionaEx .)


state 199

    (80) cicloFor -> FOR LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    ID              reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    IF              reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    $end            reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 80 (cicloFor -> FOR LLLAVE codigo RLLAVE .)


state 200

    (81) cicloFor -> FOR comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 257


state 201

    (82) cicloFor -> FOR logic_operation LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 258


state 202

    (83) cicloFor -> FOR decVarOne COLON comparison . COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 259


state 203

    (123) decVarOne -> ID DEQUAL ID .

    COLON           reduce using rule 123 (decVarOne -> ID DEQUAL ID .)


state 204

    (124) decVarOne -> ID DEQUAL INTEGER .

    COLON           reduce using rule 124 (decVarOne -> ID DEQUAL INTEGER .)


state 205

    (174) index -> ID .
    (180) key -> ID .
    (205) something_ex -> ID .
    (144) value -> ID .
    (158) logic_value -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (179) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for RCORCHE resolved using rule 174 (index -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 174 (index -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 144 (value -> ID .)
    RCORCHE         reduce using rule 174 (index -> ID .)
    GREATER         reduce using rule 144 (value -> ID .)
    SMALLER         reduce using rule 144 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 144 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 144 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 144 (value -> ID .)
    NOT_EQUAL       reduce using rule 144 (value -> ID .)
    PLUS            reduce using rule 144 (value -> ID .)
    TIMES           reduce using rule 144 (value -> ID .)
    DIVIDE          reduce using rule 144 (value -> ID .)
    MINUS           reduce using rule 144 (value -> ID .)
    AND             reduce using rule 158 (logic_value -> ID .)
    OR              reduce using rule 158 (logic_value -> ID .)
    LCORCHE         shift and go to state 149

  ! RCORCHE         [ reduce using rule 180 (key -> ID .) ]
  ! GREATER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 205 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 205 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 205 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 205 (something_ex -> ID .) ]


state 206

    (175) index -> INTEGER .
    (44) values -> INTEGER .
    (206) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 44 (values -> INTEGER .)
    RCORCHE         reduce using rule 44 (values -> INTEGER .)
    GREATER         reduce using rule 206 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 206 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 206 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 206 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 206 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 206 (something_ex -> INTEGER .)
    PLUS            reduce using rule 206 (something_ex -> INTEGER .)
    TIMES           reduce using rule 206 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 206 (something_ex -> INTEGER .)
    MINUS           reduce using rule 206 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 175 (index -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 206 (something_ex -> INTEGER .) ]


state 207

    (176) index -> expression .
    (57) operations -> expression .
    (145) value -> expression .

  ! reduce/reduce conflict for RCORCHE resolved using rule 57 (operations -> expression .)
    RCORCHE         reduce using rule 57 (operations -> expression .)
    GREATER         reduce using rule 145 (value -> expression .)
    SMALLER         reduce using rule 145 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 145 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 145 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 145 (value -> expression .)
    NOT_EQUAL       reduce using rule 145 (value -> expression .)
    PLUS            reduce using rule 145 (value -> expression .)
    TIMES           reduce using rule 145 (value -> expression .)
    DIVIDE          reduce using rule 145 (value -> expression .)
    MINUS           reduce using rule 145 (value -> expression .)

  ! RCORCHE         [ reduce using rule 176 (index -> expression .) ]


state 208

    (155) logic_recu -> logic_op logic_value logic_recu .

    PRINT           reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    SCAN            reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    FOR             reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    VAR             reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    ID              reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    APPEND          reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    LEN             reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    COPY            reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    DELETE          reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    IF              reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    ELSE            reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    TYPE            reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    SWITCH          reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    FUNC            reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    INTEGER         reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    FLOAT           reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    NOT             reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    $end            reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    RLLAVE          reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    DEFAULT         reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    CASE            reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    RETURN          reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    LLLAVE          reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    COLON           reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    RPAREN          reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    RCORCHE         reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)
    COMA            reduce using rule 155 (logic_recu -> logic_op logic_value logic_recu .)


state 209

    (88) decVar -> VAR ID EQUAL ID .
    (205) something_ex -> ID .
    (158) logic_value -> ID .
    (144) value -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (179) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for COLON resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for FOR resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for VAR resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for ID resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for LEN resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for COPY resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for IF resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for NOT resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for $end resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for CASE resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 88 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 144 (value -> ID .)
    COLON           reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    PRINT           reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    SCAN            reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    FOR             reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    VAR             reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    ID              reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    APPEND          reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    LEN             reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    COPY            reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    DELETE          reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    IF              reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    ELSE            reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    TYPE            reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    SWITCH          reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    FUNC            reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    INTEGER         reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    FLOAT           reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    NOT             reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    $end            reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    RLLAVE          reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    DEFAULT         reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    CASE            reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    RETURN          reduce using rule 88 (decVar -> VAR ID EQUAL ID .)
    AND             reduce using rule 158 (logic_value -> ID .)
    OR              reduce using rule 158 (logic_value -> ID .)
    GREATER         reduce using rule 144 (value -> ID .)
    SMALLER         reduce using rule 144 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 144 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 144 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 144 (value -> ID .)
    NOT_EQUAL       reduce using rule 144 (value -> ID .)
    PLUS            reduce using rule 144 (value -> ID .)
    TIMES           reduce using rule 144 (value -> ID .)
    DIVIDE          reduce using rule 144 (value -> ID .)
    MINUS           reduce using rule 144 (value -> ID .)
    LCORCHE         shift and go to state 149

  ! GREATER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 205 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 205 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 205 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 205 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 205 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 205 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 205 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 205 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 205 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 205 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 205 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 205 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 205 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 205 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 205 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 205 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 205 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 205 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 205 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 205 (something_ex -> ID .) ]


state 210

    (87) decVar -> VAR ID EQUAL INTEGER .
    (206) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for PRINT resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for SCAN resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for FOR resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for VAR resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for ID resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for APPEND resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for LEN resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for COPY resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for DELETE resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for IF resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for ELSE resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for TYPE resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for SWITCH resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for FUNC resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for INTEGER resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for FLOAT resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for NOT resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    COLON           reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    PRINT           reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    SCAN            reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    FOR             reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    VAR             reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    ID              reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    APPEND          reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    LEN             reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    COPY            reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    DELETE          reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    IF              reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    ELSE            reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    TYPE            reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    SWITCH          reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    FUNC            reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    INTEGER         reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    FLOAT           reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    NOT             reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    $end            reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    RLLAVE          reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    DEFAULT         reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    CASE            reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    RETURN          reduce using rule 87 (decVar -> VAR ID EQUAL INTEGER .)
    GREATER         reduce using rule 206 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 206 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 206 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 206 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 206 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 206 (something_ex -> INTEGER .)
    PLUS            reduce using rule 206 (something_ex -> INTEGER .)
    TIMES           reduce using rule 206 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 206 (something_ex -> INTEGER .)
    MINUS           reduce using rule 206 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! PRINT           [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! SCAN            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! FOR             [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! VAR             [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! ID              [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! APPEND          [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! LEN             [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! COPY            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! DELETE          [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! IF              [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! ELSE            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! TYPE            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! SWITCH          [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! FUNC            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! INTEGER         [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! FLOAT           [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! NOT             [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 206 (something_ex -> INTEGER .) ]


state 211

    (89) decVar -> VAR ID EQUAL FLOAT .
    (207) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for PRINT resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for SCAN resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for FOR resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for VAR resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for ID resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for APPEND resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for LEN resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for COPY resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for DELETE resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for IF resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for ELSE resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for TYPE resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for SWITCH resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for FUNC resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for INTEGER resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for FLOAT resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for NOT resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    COLON           reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    PRINT           reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    SCAN            reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    FOR             reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    VAR             reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    ID              reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    APPEND          reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    LEN             reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    COPY            reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    DELETE          reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    IF              reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    ELSE            reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    TYPE            reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    SWITCH          reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    FUNC            reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    INTEGER         reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    FLOAT           reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    NOT             reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    $end            reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    RLLAVE          reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    DEFAULT         reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    CASE            reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    RETURN          reduce using rule 89 (decVar -> VAR ID EQUAL FLOAT .)
    GREATER         reduce using rule 207 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 207 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 207 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 207 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 207 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 207 (something_ex -> FLOAT .)
    PLUS            reduce using rule 207 (something_ex -> FLOAT .)
    TIMES           reduce using rule 207 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 207 (something_ex -> FLOAT .)
    MINUS           reduce using rule 207 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! PRINT           [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! SCAN            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! FOR             [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! VAR             [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! ID              [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! APPEND          [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! LEN             [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! COPY            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! DELETE          [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! IF              [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! ELSE            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! TYPE            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! SWITCH          [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! FUNC            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! INTEGER         [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! FLOAT           [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! NOT             [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 207 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 207 (something_ex -> FLOAT .) ]


state 212

    (90) decVar -> VAR ID EQUAL expression .
    (145) value -> expression .

    COLON           reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    PRINT           reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    SCAN            reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    FOR             reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    VAR             reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    ID              reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    APPEND          reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    LEN             reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    COPY            reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    DELETE          reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    IF              reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    ELSE            reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    TYPE            reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    SWITCH          reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    FUNC            reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    INTEGER         reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    FLOAT           reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    NOT             reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    $end            reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    RLLAVE          reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    DEFAULT         reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    CASE            reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    RETURN          reduce using rule 90 (decVar -> VAR ID EQUAL expression .)
    GREATER         reduce using rule 145 (value -> expression .)
    SMALLER         reduce using rule 145 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 145 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 145 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 145 (value -> expression .)
    NOT_EQUAL       reduce using rule 145 (value -> expression .)
    PLUS            reduce using rule 145 (value -> expression .)
    TIMES           reduce using rule 145 (value -> expression .)
    DIVIDE          reduce using rule 145 (value -> expression .)
    MINUS           reduce using rule 145 (value -> expression .)


state 213

    (91) decVar -> VAR ID EQUAL logic_operation .

    COLON           reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    PRINT           reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    SCAN            reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    FOR             reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    VAR             reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    ID              reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    APPEND          reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    LEN             reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    COPY            reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    DELETE          reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    IF              reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    ELSE            reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    TYPE            reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    SWITCH          reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    FUNC            reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    INTEGER         reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    FLOAT           reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    NOT             reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    $end            reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    RLLAVE          reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    DEFAULT         reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    CASE            reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)
    RETURN          reduce using rule 91 (decVar -> VAR ID EQUAL logic_operation .)


state 214

    (92) decVar -> VAR ID EQUAL comparison .
    (157) logic_value -> comparison .

    COLON           reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    PRINT           reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    SCAN            reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    FOR             reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    VAR             reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    ID              reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    APPEND          reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    LEN             reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    COPY            reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    DELETE          reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    IF              reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    ELSE            reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    TYPE            reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    SWITCH          reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    FUNC            reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    INTEGER         reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    FLOAT           reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    NOT             reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    $end            reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    RLLAVE          reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    DEFAULT         reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    CASE            reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    RETURN          reduce using rule 92 (decVar -> VAR ID EQUAL comparison .)
    AND             reduce using rule 157 (logic_value -> comparison .)
    OR              reduce using rule 157 (logic_value -> comparison .)


state 215

    (93) decVar -> VAR ID EQUAL STRING .

    COLON           reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    PRINT           reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    SCAN            reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    FOR             reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    VAR             reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    ID              reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    APPEND          reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    LEN             reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    COPY            reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    DELETE          reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    IF              reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    ELSE            reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    TYPE            reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    SWITCH          reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    FUNC            reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    INTEGER         reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    FLOAT           reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    NOT             reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    $end            reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    RLLAVE          reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    DEFAULT         reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    CASE            reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)
    RETURN          reduce using rule 93 (decVar -> VAR ID EQUAL STRING .)


state 216

    (169) array_declaration -> VAR ID EQUAL LCORCHE . capacity RCORCHE data_types arr_content
    (100) slice_declaration -> VAR ID EQUAL LCORCHE . RCORCHE data_types arr_content
    (170) capacity -> . INTEGER
    (171) capacity -> . ID
    (172) capacity -> . expression
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    RCORCHE         shift and go to state 261
    INTEGER         shift and go to state 222
    ID              shift and go to state 218
    FLOAT           shift and go to state 40
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    capacity                       shift and go to state 260
    expression                     shift and go to state 223
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 217

    (101) slice_declaration -> VAR ID EQUAL funM .

    COLON           reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    PRINT           reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    SCAN            reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    FOR             reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    VAR             reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    ID              reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    APPEND          reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    LEN             reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    COPY            reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    DELETE          reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    IF              reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    ELSE            reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    TYPE            reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    SWITCH          reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    FUNC            reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    INTEGER         reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    FLOAT           reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    NOT             reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    $end            reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    RLLAVE          reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    DEFAULT         reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    CASE            reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)
    RETURN          reduce using rule 101 (slice_declaration -> VAR ID EQUAL funM .)


state 218

    (171) capacity -> ID .
    (205) something_ex -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (179) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for RCORCHE resolved using rule 171 (capacity -> ID .)
    RCORCHE         reduce using rule 171 (capacity -> ID .)
    GREATER         reduce using rule 205 (something_ex -> ID .)
    SMALLER         reduce using rule 205 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 205 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 205 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 205 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 205 (something_ex -> ID .)
    PLUS            reduce using rule 205 (something_ex -> ID .)
    TIMES           reduce using rule 205 (something_ex -> ID .)
    DIVIDE          reduce using rule 205 (something_ex -> ID .)
    MINUS           reduce using rule 205 (something_ex -> ID .)
    LCORCHE         shift and go to state 149

  ! RCORCHE         [ reduce using rule 205 (something_ex -> ID .) ]


state 219

    (168) array_declaration -> VAR ID LCORCHE capacity . RCORCHE data_types

    RCORCHE         shift and go to state 262


state 220

    (99) slice_declaration -> VAR ID LCORCHE RCORCHE . data_types
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 224
    INT64           shift and go to state 225
    FLOAT32         shift and go to state 226
    FLOAT64         shift and go to state 227
    BYTE            shift and go to state 228
    WINT            shift and go to state 229
    WFLOAT          shift and go to state 230
    WSTRING         shift and go to state 231
    BOOL            shift and go to state 232

    data_types                     shift and go to state 263

state 221

    (178) map_declaration -> VAR ID LCORCHE data_types . RCORCHE data_types

    RCORCHE         shift and go to state 264


state 222

    (170) capacity -> INTEGER .
    (206) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 170 (capacity -> INTEGER .)
    RCORCHE         reduce using rule 170 (capacity -> INTEGER .)
    GREATER         reduce using rule 206 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 206 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 206 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 206 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 206 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 206 (something_ex -> INTEGER .)
    PLUS            reduce using rule 206 (something_ex -> INTEGER .)
    TIMES           reduce using rule 206 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 206 (something_ex -> INTEGER .)
    MINUS           reduce using rule 206 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 206 (something_ex -> INTEGER .) ]


state 223

    (172) capacity -> expression .

    RCORCHE         reduce using rule 172 (capacity -> expression .)


state 224

    (48) data_types -> INT32 .

    RCORCHE         reduce using rule 48 (data_types -> INT32 .)
    COLON           reduce using rule 48 (data_types -> INT32 .)
    PRINT           reduce using rule 48 (data_types -> INT32 .)
    SCAN            reduce using rule 48 (data_types -> INT32 .)
    FOR             reduce using rule 48 (data_types -> INT32 .)
    VAR             reduce using rule 48 (data_types -> INT32 .)
    ID              reduce using rule 48 (data_types -> INT32 .)
    APPEND          reduce using rule 48 (data_types -> INT32 .)
    LEN             reduce using rule 48 (data_types -> INT32 .)
    COPY            reduce using rule 48 (data_types -> INT32 .)
    DELETE          reduce using rule 48 (data_types -> INT32 .)
    IF              reduce using rule 48 (data_types -> INT32 .)
    ELSE            reduce using rule 48 (data_types -> INT32 .)
    TYPE            reduce using rule 48 (data_types -> INT32 .)
    SWITCH          reduce using rule 48 (data_types -> INT32 .)
    FUNC            reduce using rule 48 (data_types -> INT32 .)
    INTEGER         reduce using rule 48 (data_types -> INT32 .)
    FLOAT           reduce using rule 48 (data_types -> INT32 .)
    NOT             reduce using rule 48 (data_types -> INT32 .)
    $end            reduce using rule 48 (data_types -> INT32 .)
    RLLAVE          reduce using rule 48 (data_types -> INT32 .)
    DEFAULT         reduce using rule 48 (data_types -> INT32 .)
    CASE            reduce using rule 48 (data_types -> INT32 .)
    RETURN          reduce using rule 48 (data_types -> INT32 .)
    LLLAVE          reduce using rule 48 (data_types -> INT32 .)
    COMA            reduce using rule 48 (data_types -> INT32 .)
    RPAREN          reduce using rule 48 (data_types -> INT32 .)


state 225

    (49) data_types -> INT64 .

    RCORCHE         reduce using rule 49 (data_types -> INT64 .)
    COLON           reduce using rule 49 (data_types -> INT64 .)
    PRINT           reduce using rule 49 (data_types -> INT64 .)
    SCAN            reduce using rule 49 (data_types -> INT64 .)
    FOR             reduce using rule 49 (data_types -> INT64 .)
    VAR             reduce using rule 49 (data_types -> INT64 .)
    ID              reduce using rule 49 (data_types -> INT64 .)
    APPEND          reduce using rule 49 (data_types -> INT64 .)
    LEN             reduce using rule 49 (data_types -> INT64 .)
    COPY            reduce using rule 49 (data_types -> INT64 .)
    DELETE          reduce using rule 49 (data_types -> INT64 .)
    IF              reduce using rule 49 (data_types -> INT64 .)
    ELSE            reduce using rule 49 (data_types -> INT64 .)
    TYPE            reduce using rule 49 (data_types -> INT64 .)
    SWITCH          reduce using rule 49 (data_types -> INT64 .)
    FUNC            reduce using rule 49 (data_types -> INT64 .)
    INTEGER         reduce using rule 49 (data_types -> INT64 .)
    FLOAT           reduce using rule 49 (data_types -> INT64 .)
    NOT             reduce using rule 49 (data_types -> INT64 .)
    $end            reduce using rule 49 (data_types -> INT64 .)
    RLLAVE          reduce using rule 49 (data_types -> INT64 .)
    DEFAULT         reduce using rule 49 (data_types -> INT64 .)
    CASE            reduce using rule 49 (data_types -> INT64 .)
    RETURN          reduce using rule 49 (data_types -> INT64 .)
    LLLAVE          reduce using rule 49 (data_types -> INT64 .)
    COMA            reduce using rule 49 (data_types -> INT64 .)
    RPAREN          reduce using rule 49 (data_types -> INT64 .)


state 226

    (50) data_types -> FLOAT32 .

    RCORCHE         reduce using rule 50 (data_types -> FLOAT32 .)
    COLON           reduce using rule 50 (data_types -> FLOAT32 .)
    PRINT           reduce using rule 50 (data_types -> FLOAT32 .)
    SCAN            reduce using rule 50 (data_types -> FLOAT32 .)
    FOR             reduce using rule 50 (data_types -> FLOAT32 .)
    VAR             reduce using rule 50 (data_types -> FLOAT32 .)
    ID              reduce using rule 50 (data_types -> FLOAT32 .)
    APPEND          reduce using rule 50 (data_types -> FLOAT32 .)
    LEN             reduce using rule 50 (data_types -> FLOAT32 .)
    COPY            reduce using rule 50 (data_types -> FLOAT32 .)
    DELETE          reduce using rule 50 (data_types -> FLOAT32 .)
    IF              reduce using rule 50 (data_types -> FLOAT32 .)
    ELSE            reduce using rule 50 (data_types -> FLOAT32 .)
    TYPE            reduce using rule 50 (data_types -> FLOAT32 .)
    SWITCH          reduce using rule 50 (data_types -> FLOAT32 .)
    FUNC            reduce using rule 50 (data_types -> FLOAT32 .)
    INTEGER         reduce using rule 50 (data_types -> FLOAT32 .)
    FLOAT           reduce using rule 50 (data_types -> FLOAT32 .)
    NOT             reduce using rule 50 (data_types -> FLOAT32 .)
    $end            reduce using rule 50 (data_types -> FLOAT32 .)
    RLLAVE          reduce using rule 50 (data_types -> FLOAT32 .)
    DEFAULT         reduce using rule 50 (data_types -> FLOAT32 .)
    CASE            reduce using rule 50 (data_types -> FLOAT32 .)
    RETURN          reduce using rule 50 (data_types -> FLOAT32 .)
    LLLAVE          reduce using rule 50 (data_types -> FLOAT32 .)
    COMA            reduce using rule 50 (data_types -> FLOAT32 .)
    RPAREN          reduce using rule 50 (data_types -> FLOAT32 .)


state 227

    (51) data_types -> FLOAT64 .

    RCORCHE         reduce using rule 51 (data_types -> FLOAT64 .)
    COLON           reduce using rule 51 (data_types -> FLOAT64 .)
    PRINT           reduce using rule 51 (data_types -> FLOAT64 .)
    SCAN            reduce using rule 51 (data_types -> FLOAT64 .)
    FOR             reduce using rule 51 (data_types -> FLOAT64 .)
    VAR             reduce using rule 51 (data_types -> FLOAT64 .)
    ID              reduce using rule 51 (data_types -> FLOAT64 .)
    APPEND          reduce using rule 51 (data_types -> FLOAT64 .)
    LEN             reduce using rule 51 (data_types -> FLOAT64 .)
    COPY            reduce using rule 51 (data_types -> FLOAT64 .)
    DELETE          reduce using rule 51 (data_types -> FLOAT64 .)
    IF              reduce using rule 51 (data_types -> FLOAT64 .)
    ELSE            reduce using rule 51 (data_types -> FLOAT64 .)
    TYPE            reduce using rule 51 (data_types -> FLOAT64 .)
    SWITCH          reduce using rule 51 (data_types -> FLOAT64 .)
    FUNC            reduce using rule 51 (data_types -> FLOAT64 .)
    INTEGER         reduce using rule 51 (data_types -> FLOAT64 .)
    FLOAT           reduce using rule 51 (data_types -> FLOAT64 .)
    NOT             reduce using rule 51 (data_types -> FLOAT64 .)
    $end            reduce using rule 51 (data_types -> FLOAT64 .)
    RLLAVE          reduce using rule 51 (data_types -> FLOAT64 .)
    DEFAULT         reduce using rule 51 (data_types -> FLOAT64 .)
    CASE            reduce using rule 51 (data_types -> FLOAT64 .)
    RETURN          reduce using rule 51 (data_types -> FLOAT64 .)
    LLLAVE          reduce using rule 51 (data_types -> FLOAT64 .)
    COMA            reduce using rule 51 (data_types -> FLOAT64 .)
    RPAREN          reduce using rule 51 (data_types -> FLOAT64 .)


state 228

    (52) data_types -> BYTE .

    RCORCHE         reduce using rule 52 (data_types -> BYTE .)
    COLON           reduce using rule 52 (data_types -> BYTE .)
    PRINT           reduce using rule 52 (data_types -> BYTE .)
    SCAN            reduce using rule 52 (data_types -> BYTE .)
    FOR             reduce using rule 52 (data_types -> BYTE .)
    VAR             reduce using rule 52 (data_types -> BYTE .)
    ID              reduce using rule 52 (data_types -> BYTE .)
    APPEND          reduce using rule 52 (data_types -> BYTE .)
    LEN             reduce using rule 52 (data_types -> BYTE .)
    COPY            reduce using rule 52 (data_types -> BYTE .)
    DELETE          reduce using rule 52 (data_types -> BYTE .)
    IF              reduce using rule 52 (data_types -> BYTE .)
    ELSE            reduce using rule 52 (data_types -> BYTE .)
    TYPE            reduce using rule 52 (data_types -> BYTE .)
    SWITCH          reduce using rule 52 (data_types -> BYTE .)
    FUNC            reduce using rule 52 (data_types -> BYTE .)
    INTEGER         reduce using rule 52 (data_types -> BYTE .)
    FLOAT           reduce using rule 52 (data_types -> BYTE .)
    NOT             reduce using rule 52 (data_types -> BYTE .)
    $end            reduce using rule 52 (data_types -> BYTE .)
    RLLAVE          reduce using rule 52 (data_types -> BYTE .)
    DEFAULT         reduce using rule 52 (data_types -> BYTE .)
    CASE            reduce using rule 52 (data_types -> BYTE .)
    RETURN          reduce using rule 52 (data_types -> BYTE .)
    LLLAVE          reduce using rule 52 (data_types -> BYTE .)
    COMA            reduce using rule 52 (data_types -> BYTE .)
    RPAREN          reduce using rule 52 (data_types -> BYTE .)


state 229

    (53) data_types -> WINT .

    RCORCHE         reduce using rule 53 (data_types -> WINT .)
    COLON           reduce using rule 53 (data_types -> WINT .)
    PRINT           reduce using rule 53 (data_types -> WINT .)
    SCAN            reduce using rule 53 (data_types -> WINT .)
    FOR             reduce using rule 53 (data_types -> WINT .)
    VAR             reduce using rule 53 (data_types -> WINT .)
    ID              reduce using rule 53 (data_types -> WINT .)
    APPEND          reduce using rule 53 (data_types -> WINT .)
    LEN             reduce using rule 53 (data_types -> WINT .)
    COPY            reduce using rule 53 (data_types -> WINT .)
    DELETE          reduce using rule 53 (data_types -> WINT .)
    IF              reduce using rule 53 (data_types -> WINT .)
    ELSE            reduce using rule 53 (data_types -> WINT .)
    TYPE            reduce using rule 53 (data_types -> WINT .)
    SWITCH          reduce using rule 53 (data_types -> WINT .)
    FUNC            reduce using rule 53 (data_types -> WINT .)
    INTEGER         reduce using rule 53 (data_types -> WINT .)
    FLOAT           reduce using rule 53 (data_types -> WINT .)
    NOT             reduce using rule 53 (data_types -> WINT .)
    $end            reduce using rule 53 (data_types -> WINT .)
    RLLAVE          reduce using rule 53 (data_types -> WINT .)
    DEFAULT         reduce using rule 53 (data_types -> WINT .)
    CASE            reduce using rule 53 (data_types -> WINT .)
    RETURN          reduce using rule 53 (data_types -> WINT .)
    LLLAVE          reduce using rule 53 (data_types -> WINT .)
    COMA            reduce using rule 53 (data_types -> WINT .)
    RPAREN          reduce using rule 53 (data_types -> WINT .)


state 230

    (54) data_types -> WFLOAT .

    RCORCHE         reduce using rule 54 (data_types -> WFLOAT .)
    COLON           reduce using rule 54 (data_types -> WFLOAT .)
    PRINT           reduce using rule 54 (data_types -> WFLOAT .)
    SCAN            reduce using rule 54 (data_types -> WFLOAT .)
    FOR             reduce using rule 54 (data_types -> WFLOAT .)
    VAR             reduce using rule 54 (data_types -> WFLOAT .)
    ID              reduce using rule 54 (data_types -> WFLOAT .)
    APPEND          reduce using rule 54 (data_types -> WFLOAT .)
    LEN             reduce using rule 54 (data_types -> WFLOAT .)
    COPY            reduce using rule 54 (data_types -> WFLOAT .)
    DELETE          reduce using rule 54 (data_types -> WFLOAT .)
    IF              reduce using rule 54 (data_types -> WFLOAT .)
    ELSE            reduce using rule 54 (data_types -> WFLOAT .)
    TYPE            reduce using rule 54 (data_types -> WFLOAT .)
    SWITCH          reduce using rule 54 (data_types -> WFLOAT .)
    FUNC            reduce using rule 54 (data_types -> WFLOAT .)
    INTEGER         reduce using rule 54 (data_types -> WFLOAT .)
    FLOAT           reduce using rule 54 (data_types -> WFLOAT .)
    NOT             reduce using rule 54 (data_types -> WFLOAT .)
    $end            reduce using rule 54 (data_types -> WFLOAT .)
    RLLAVE          reduce using rule 54 (data_types -> WFLOAT .)
    DEFAULT         reduce using rule 54 (data_types -> WFLOAT .)
    CASE            reduce using rule 54 (data_types -> WFLOAT .)
    RETURN          reduce using rule 54 (data_types -> WFLOAT .)
    LLLAVE          reduce using rule 54 (data_types -> WFLOAT .)
    COMA            reduce using rule 54 (data_types -> WFLOAT .)
    RPAREN          reduce using rule 54 (data_types -> WFLOAT .)


state 231

    (55) data_types -> WSTRING .

    RCORCHE         reduce using rule 55 (data_types -> WSTRING .)
    COLON           reduce using rule 55 (data_types -> WSTRING .)
    PRINT           reduce using rule 55 (data_types -> WSTRING .)
    SCAN            reduce using rule 55 (data_types -> WSTRING .)
    FOR             reduce using rule 55 (data_types -> WSTRING .)
    VAR             reduce using rule 55 (data_types -> WSTRING .)
    ID              reduce using rule 55 (data_types -> WSTRING .)
    APPEND          reduce using rule 55 (data_types -> WSTRING .)
    LEN             reduce using rule 55 (data_types -> WSTRING .)
    COPY            reduce using rule 55 (data_types -> WSTRING .)
    DELETE          reduce using rule 55 (data_types -> WSTRING .)
    IF              reduce using rule 55 (data_types -> WSTRING .)
    ELSE            reduce using rule 55 (data_types -> WSTRING .)
    TYPE            reduce using rule 55 (data_types -> WSTRING .)
    SWITCH          reduce using rule 55 (data_types -> WSTRING .)
    FUNC            reduce using rule 55 (data_types -> WSTRING .)
    INTEGER         reduce using rule 55 (data_types -> WSTRING .)
    FLOAT           reduce using rule 55 (data_types -> WSTRING .)
    NOT             reduce using rule 55 (data_types -> WSTRING .)
    $end            reduce using rule 55 (data_types -> WSTRING .)
    RLLAVE          reduce using rule 55 (data_types -> WSTRING .)
    DEFAULT         reduce using rule 55 (data_types -> WSTRING .)
    CASE            reduce using rule 55 (data_types -> WSTRING .)
    RETURN          reduce using rule 55 (data_types -> WSTRING .)
    LLLAVE          reduce using rule 55 (data_types -> WSTRING .)
    COMA            reduce using rule 55 (data_types -> WSTRING .)
    RPAREN          reduce using rule 55 (data_types -> WSTRING .)


state 232

    (56) data_types -> BOOL .

    RCORCHE         reduce using rule 56 (data_types -> BOOL .)
    COLON           reduce using rule 56 (data_types -> BOOL .)
    PRINT           reduce using rule 56 (data_types -> BOOL .)
    SCAN            reduce using rule 56 (data_types -> BOOL .)
    FOR             reduce using rule 56 (data_types -> BOOL .)
    VAR             reduce using rule 56 (data_types -> BOOL .)
    ID              reduce using rule 56 (data_types -> BOOL .)
    APPEND          reduce using rule 56 (data_types -> BOOL .)
    LEN             reduce using rule 56 (data_types -> BOOL .)
    COPY            reduce using rule 56 (data_types -> BOOL .)
    DELETE          reduce using rule 56 (data_types -> BOOL .)
    IF              reduce using rule 56 (data_types -> BOOL .)
    ELSE            reduce using rule 56 (data_types -> BOOL .)
    TYPE            reduce using rule 56 (data_types -> BOOL .)
    SWITCH          reduce using rule 56 (data_types -> BOOL .)
    FUNC            reduce using rule 56 (data_types -> BOOL .)
    INTEGER         reduce using rule 56 (data_types -> BOOL .)
    FLOAT           reduce using rule 56 (data_types -> BOOL .)
    NOT             reduce using rule 56 (data_types -> BOOL .)
    $end            reduce using rule 56 (data_types -> BOOL .)
    RLLAVE          reduce using rule 56 (data_types -> BOOL .)
    DEFAULT         reduce using rule 56 (data_types -> BOOL .)
    CASE            reduce using rule 56 (data_types -> BOOL .)
    RETURN          reduce using rule 56 (data_types -> BOOL .)
    LLLAVE          reduce using rule 56 (data_types -> BOOL .)
    COMA            reduce using rule 56 (data_types -> BOOL .)
    RPAREN          reduce using rule 56 (data_types -> BOOL .)


state 233

    (136) cStruct -> ID DEQUAL ID LLLAVE . asignaciones RLLAVE
    (137) asignaciones -> . ID POINTS valor
    (138) asignaciones -> . ID POINTS valor COMA asignaciones

    ID              shift and go to state 265

    asignaciones                   shift and go to state 266

state 234

    (103) slice_declaration -> ID DEQUAL LCORCHE RCORCHE . data_types arr_content
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 224
    INT64           shift and go to state 225
    FLOAT32         shift and go to state 226
    FLOAT64         shift and go to state 227
    BYTE            shift and go to state 228
    WINT            shift and go to state 229
    WFLOAT          shift and go to state 230
    WSTRING         shift and go to state 231
    BOOL            shift and go to state 232

    data_types                     shift and go to state 267

state 235

    (104) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap RPAREN
    (105) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LCORCHE         shift and go to state 268


state 236

    (173) array_var -> ID LCORCHE index RCORCHE .

    COLON           reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    EQUAL           reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    PRINT           reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    SCAN            reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    FOR             reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    VAR             reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    ID              reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    APPEND          reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    LEN             reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    COPY            reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    DELETE          reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    IF              reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    ELSE            reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    TYPE            reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    SWITCH          reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    FUNC            reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    INTEGER         reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    FLOAT           reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    NOT             reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    $end            reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    GREATER         reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    SMALLER         reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    GREATER_OR_EQUAL reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    SMALLER_OR_EQUAL reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    EQUAL_COMPARE   reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    NOT_EQUAL       reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    PLUS            reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    TIMES           reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    DIVIDE          reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    MINUS           reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    RLLAVE          reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    DEFAULT         reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    CASE            reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    RETURN          reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    RPAREN          reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    AND             reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    OR              reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    LLLAVE          reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    RCORCHE         reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)
    COMA            reduce using rule 173 (array_var -> ID LCORCHE index RCORCHE .)


state 237

    (109) slice_var -> ID LCORCHE index_s RCORCHE .

    COLON           reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    EQUAL           reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    PRINT           reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    SCAN            reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FOR             reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    VAR             reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    ID              reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    APPEND          reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    LEN             reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    COPY            reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    DELETE          reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    IF              reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    ELSE            reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    TYPE            reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    SWITCH          reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FUNC            reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    INTEGER         reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FLOAT           reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    NOT             reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    $end            reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    RLLAVE          reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    DEFAULT         reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    CASE            reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)
    RETURN          reduce using rule 109 (slice_var -> ID LCORCHE index_s RCORCHE .)


state 238

    (179) map_var -> ID LCORCHE key RCORCHE .

    GREATER         reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    SMALLER         reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    GREATER_OR_EQUAL reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    SMALLER_OR_EQUAL reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    EQUAL_COMPARE   reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    NOT_EQUAL       reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    PLUS            reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    TIMES           reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    DIVIDE          reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    MINUS           reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    COLON           reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    PRINT           reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    SCAN            reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    FOR             reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    VAR             reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    ID              reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    APPEND          reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    LEN             reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    COPY            reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    DELETE          reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    IF              reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    ELSE            reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    TYPE            reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    SWITCH          reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    FUNC            reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    INTEGER         reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    FLOAT           reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    NOT             reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    $end            reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    RLLAVE          reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    DEFAULT         reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    CASE            reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    RETURN          reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    RPAREN          reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    AND             reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    OR              reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    LLLAVE          reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    RCORCHE         reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)
    COMA            reduce using rule 179 (map_var -> ID LCORCHE key RCORCHE .)


state 239

    (118) funciones -> APPEND LPAREN ID COMA . values RPAREN
    (119) funciones -> APPEND LPAREN ID COMA . ID RPAREN
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE

    ID              shift and go to state 269
    STRING          shift and go to state 122
    INTEGER         shift and go to state 271
    FLOAT           shift and go to state 272
    TRUE            shift and go to state 125
    FALSE           shift and go to state 126

    values                         shift and go to state 270

state 240

    (120) funciones -> LEN LPAREN ID RPAREN .

    COLON           reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    PRINT           reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    SCAN            reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    FOR             reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    VAR             reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    ID              reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    APPEND          reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    LEN             reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    COPY            reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    DELETE          reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    IF              reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    ELSE            reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    TYPE            reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    SWITCH          reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    FUNC            reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    INTEGER         reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    FLOAT           reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    NOT             reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    $end            reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    GREATER         reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    SMALLER         reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    NOT_EQUAL       reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    PLUS            reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    TIMES           reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    DIVIDE          reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    MINUS           reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    RLLAVE          reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    DEFAULT         reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    CASE            reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    RETURN          reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    RPAREN          reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    AND             reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    OR              reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    LLLAVE          reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    RCORCHE         reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)
    COMA            reduce using rule 120 (funciones -> LEN LPAREN ID RPAREN .)


state 241

    (121) funciones -> COPY LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 273


state 242

    (122) funciones -> DELETE LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 274


state 243

    (125) SenIF -> IF comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 275


state 244

    (126) SenIF -> IF TRUE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 276


state 245

    (127) SenIF -> IF FALSE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 277


state 246

    (128) SenElseIF -> ELSE IF comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    comparison                     shift and go to state 8
    codigo                         shift and go to state 278
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    decVarOne                      shift and go to state 33
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 247

    (129) SenElseIF -> ELSE IF TRUE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    codigo                         shift and go to state 279
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    decVarOne                      shift and go to state 33
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 248

    (130) SenElseIF -> ELSE IF FALSE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    codigo                         shift and go to state 280
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    decVarOne                      shift and go to state 33
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 249

    (131) SenElse -> ELSE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 131 (SenElse -> ELSE LLLAVE codigo RLLAVE .)


state 250

    (132) SenStruct -> TYPE ID STRUCT LLLAVE . declaration RLLAVE
    (133) declaration -> . variable data_types
    (134) declaration -> . declaration variable data_types
    (135) variable -> . ID

    ID              shift and go to state 281

    declaration                    shift and go to state 282
    variable                       shift and go to state 283

state 251

    (163) switch_statement -> SWITCH ID LLLAVE cases . RLLAVE

    RLLAVE          shift and go to state 284


state 252

    (164) cases -> CASE . values POINTS codigo
    (165) cases -> CASE . values POINTS codigo more
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE

    STRING          shift and go to state 122
    INTEGER         shift and go to state 271
    FLOAT           shift and go to state 272
    TRUE            shift and go to state 125
    FALSE           shift and go to state 126

    values                         shift and go to state 285

state 253

    (192) params -> ID . data_types
    (194) more_params -> ID . data_types COMA params
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 224
    INT64           shift and go to state 225
    FLOAT32         shift and go to state 226
    FLOAT64         shift and go to state 227
    BYTE            shift and go to state 228
    WINT            shift and go to state 229
    WFLOAT          shift and go to state 230
    WSTRING         shift and go to state 231
    BOOL            shift and go to state 232

    data_types                     shift and go to state 286

state 254

    (184) func_declaration -> FUNC ID LPAREN params . RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> FUNC ID LPAREN params . RPAREN data_types LLLAVE RETURN return_value RLLAVE

    RPAREN          shift and go to state 287


state 255

    (193) params -> more_params .

    RPAREN          reduce using rule 193 (params -> more_params .)


state 256

    (78) main_func -> FUNC MAIN LPAREN RPAREN . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 288


state 257

    (81) cicloFor -> FOR comparison LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    ID              reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    IF              reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    $end            reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 81 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)


state 258

    (82) cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    ID              reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    IF              reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    $end            reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 82 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)


state 259

    (83) cicloFor -> FOR decVarOne COLON comparison COLON . incre LLLAVE codigo RLLAVE
    (84) incre -> . ID INCREASE
    (85) incre -> . ID DECREASE

    ID              shift and go to state 290

    incre                          shift and go to state 289

state 260

    (169) array_declaration -> VAR ID EQUAL LCORCHE capacity . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 291


state 261

    (100) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE . data_types arr_content
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 224
    INT64           shift and go to state 225
    FLOAT32         shift and go to state 226
    FLOAT64         shift and go to state 227
    BYTE            shift and go to state 228
    WINT            shift and go to state 229
    WFLOAT          shift and go to state 230
    WSTRING         shift and go to state 231
    BOOL            shift and go to state 232

    data_types                     shift and go to state 292

state 262

    (168) array_declaration -> VAR ID LCORCHE capacity RCORCHE . data_types
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 224
    INT64           shift and go to state 225
    FLOAT32         shift and go to state 226
    FLOAT64         shift and go to state 227
    BYTE            shift and go to state 228
    WINT            shift and go to state 229
    WFLOAT          shift and go to state 230
    WSTRING         shift and go to state 231
    BOOL            shift and go to state 232

    data_types                     shift and go to state 293

state 263

    (99) slice_declaration -> VAR ID LCORCHE RCORCHE data_types .

    COLON           reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    PRINT           reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    SCAN            reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FOR             reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    VAR             reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    ID              reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    APPEND          reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    LEN             reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    COPY            reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    DELETE          reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    IF              reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    ELSE            reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    TYPE            reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    SWITCH          reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FUNC            reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    INTEGER         reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FLOAT           reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    NOT             reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    $end            reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    RLLAVE          reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    DEFAULT         reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    CASE            reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    RETURN          reduce using rule 99 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)


state 264

    (178) map_declaration -> VAR ID LCORCHE data_types RCORCHE . data_types
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 224
    INT64           shift and go to state 225
    FLOAT32         shift and go to state 226
    FLOAT64         shift and go to state 227
    BYTE            shift and go to state 228
    WINT            shift and go to state 229
    WFLOAT          shift and go to state 230
    WSTRING         shift and go to state 231
    BOOL            shift and go to state 232

    data_types                     shift and go to state 294

state 265

    (137) asignaciones -> ID . POINTS valor
    (138) asignaciones -> ID . POINTS valor COMA asignaciones

    POINTS          shift and go to state 295


state 266

    (136) cStruct -> ID DEQUAL ID LLLAVE asignaciones . RLLAVE

    RLLAVE          shift and go to state 296


state 267

    (103) slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types . arr_content
    (68) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (69) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 298

    arr_content                    shift and go to state 297

state 268

    (104) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap RPAREN
    (105) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap COMA cap RPAREN

    RCORCHE         shift and go to state 299


state 269

    (119) funciones -> APPEND LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 300


state 270

    (118) funciones -> APPEND LPAREN ID COMA values . RPAREN

    RPAREN          shift and go to state 301


state 271

    (44) values -> INTEGER .

    RPAREN          reduce using rule 44 (values -> INTEGER .)
    POINTS          reduce using rule 44 (values -> INTEGER .)


state 272

    (45) values -> FLOAT .

    RPAREN          reduce using rule 45 (values -> FLOAT .)
    POINTS          reduce using rule 45 (values -> FLOAT .)


state 273

    (121) funciones -> COPY LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 302


state 274

    (122) funciones -> DELETE LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 303


state 275

    (125) SenIF -> IF comparison LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    ID              reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    IF              reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    $end            reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 125 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)


state 276

    (126) SenIF -> IF TRUE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 126 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)


state 277

    (127) SenIF -> IF FALSE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 127 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)


state 278

    (128) SenElseIF -> ELSE IF comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 304


state 279

    (129) SenElseIF -> ELSE IF TRUE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 305


state 280

    (130) SenElseIF -> ELSE IF FALSE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 306


state 281

    (135) variable -> ID .

    INT32           reduce using rule 135 (variable -> ID .)
    INT64           reduce using rule 135 (variable -> ID .)
    FLOAT32         reduce using rule 135 (variable -> ID .)
    FLOAT64         reduce using rule 135 (variable -> ID .)
    BYTE            reduce using rule 135 (variable -> ID .)
    WINT            reduce using rule 135 (variable -> ID .)
    WFLOAT          reduce using rule 135 (variable -> ID .)
    WSTRING         reduce using rule 135 (variable -> ID .)
    BOOL            reduce using rule 135 (variable -> ID .)


state 282

    (132) SenStruct -> TYPE ID STRUCT LLLAVE declaration . RLLAVE
    (134) declaration -> declaration . variable data_types
    (135) variable -> . ID

    RLLAVE          shift and go to state 307
    ID              shift and go to state 281

    variable                       shift and go to state 308

state 283

    (133) declaration -> variable . data_types
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 224
    INT64           shift and go to state 225
    FLOAT32         shift and go to state 226
    FLOAT64         shift and go to state 227
    BYTE            shift and go to state 228
    WINT            shift and go to state 229
    WFLOAT          shift and go to state 230
    WSTRING         shift and go to state 231
    BOOL            shift and go to state 232

    data_types                     shift and go to state 309

state 284

    (163) switch_statement -> SWITCH ID LLLAVE cases RLLAVE .

    PRINT           reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    SCAN            reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FOR             reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    VAR             reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    ID              reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    APPEND          reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    LEN             reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    COPY            reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    DELETE          reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    IF              reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    ELSE            reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    TYPE            reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    SWITCH          reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FUNC            reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    INTEGER         reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FLOAT           reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    NOT             reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    $end            reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RLLAVE          reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    DEFAULT         reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    CASE            reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RETURN          reduce using rule 163 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)


state 285

    (164) cases -> CASE values . POINTS codigo
    (165) cases -> CASE values . POINTS codigo more

    POINTS          shift and go to state 310


state 286

    (192) params -> ID data_types .
    (194) more_params -> ID data_types . COMA params

    RPAREN          reduce using rule 192 (params -> ID data_types .)
    COMA            shift and go to state 311


state 287

    (184) func_declaration -> FUNC ID LPAREN params RPAREN . data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> FUNC ID LPAREN params RPAREN . data_types LLLAVE RETURN return_value RLLAVE
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 224
    INT64           shift and go to state 225
    FLOAT32         shift and go to state 226
    FLOAT64         shift and go to state 227
    BYTE            shift and go to state 228
    WINT            shift and go to state 229
    WFLOAT          shift and go to state 230
    WSTRING         shift and go to state 231
    BOOL            shift and go to state 232

    data_types                     shift and go to state 312

state 288

    (78) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    codigo                         shift and go to state 313
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    decVarOne                      shift and go to state 33
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 289

    (83) cicloFor -> FOR decVarOne COLON comparison COLON incre . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 314


state 290

    (84) incre -> ID . INCREASE
    (85) incre -> ID . DECREASE

    INCREASE        shift and go to state 315
    DECREASE        shift and go to state 316


state 291

    (169) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE . data_types arr_content
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 224
    INT64           shift and go to state 225
    FLOAT32         shift and go to state 226
    FLOAT64         shift and go to state 227
    BYTE            shift and go to state 228
    WINT            shift and go to state 229
    WFLOAT          shift and go to state 230
    WSTRING         shift and go to state 231
    BOOL            shift and go to state 232

    data_types                     shift and go to state 317

state 292

    (100) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types . arr_content
    (68) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (69) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 298

    arr_content                    shift and go to state 318

state 293

    (168) array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .

    COLON           reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    PRINT           reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    SCAN            reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FOR             reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    VAR             reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    ID              reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    APPEND          reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    LEN             reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    COPY            reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    DELETE          reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    IF              reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    ELSE            reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    TYPE            reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    SWITCH          reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FUNC            reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    INTEGER         reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FLOAT           reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    NOT             reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    $end            reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RLLAVE          reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    DEFAULT         reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    CASE            reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RETURN          reduce using rule 168 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)


state 294

    (178) map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .

    COLON           reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    PRINT           reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    SCAN            reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FOR             reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    VAR             reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    ID              reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    APPEND          reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    LEN             reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    COPY            reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    DELETE          reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    IF              reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    ELSE            reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    TYPE            reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    SWITCH          reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FUNC            reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    INTEGER         reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FLOAT           reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    NOT             reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    $end            reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    RLLAVE          reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    DEFAULT         reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    CASE            reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    RETURN          reduce using rule 178 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)


state 295

    (137) asignaciones -> ID POINTS . valor
    (138) asignaciones -> ID POINTS . valor COMA asignaciones
    (139) valor -> . ID
    (140) valor -> . INTEGER
    (141) valor -> . TRUE
    (142) valor -> . FALSE

    ID              shift and go to state 319
    INTEGER         shift and go to state 321
    TRUE            shift and go to state 322
    FALSE           shift and go to state 323

    valor                          shift and go to state 320

state 296

    (136) cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .

    PRINT           reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    SCAN            reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FOR             reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    VAR             reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    ID              reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    APPEND          reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    LEN             reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    COPY            reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    DELETE          reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    IF              reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    ELSE            reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    TYPE            reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    SWITCH          reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FUNC            reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    INTEGER         reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FLOAT           reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    NOT             reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    $end            reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    RLLAVE          reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    DEFAULT         reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    CASE            reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    RETURN          reduce using rule 136 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)


state 297

    (103) slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .

    COLON           reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    PRINT           reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    SCAN            reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FOR             reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    VAR             reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    ID              reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    APPEND          reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    LEN             reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    COPY            reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    DELETE          reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    IF              reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    ELSE            reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    TYPE            reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    SWITCH          reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FUNC            reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    INTEGER         reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT           reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    NOT             reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    $end            reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    CASE            reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RETURN          reduce using rule 103 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)


state 298

    (68) arr_content -> LLLAVE . items COMA more_items RLLAVE
    (69) arr_content -> LLLAVE . items RLLAVE
    (72) items -> . values
    (73) items -> . operations
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    STRING          shift and go to state 122
    INTEGER         shift and go to state 123
    FLOAT           shift and go to state 124
    TRUE            shift and go to state 125
    FALSE           shift and go to state 126
    ID              shift and go to state 327
    NOT             shift and go to state 51
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    items                          shift and go to state 324
    values                         shift and go to state 325
    operations                     shift and go to state 326
    expression                     shift and go to state 127
    comparison                     shift and go to state 128
    logic_operation                shift and go to state 129
    something_ex                   shift and go to state 31
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 299

    (104) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap RPAREN
    (105) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap COMA cap RPAREN
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 224
    INT64           shift and go to state 225
    FLOAT32         shift and go to state 226
    FLOAT64         shift and go to state 227
    BYTE            shift and go to state 228
    WINT            shift and go to state 229
    WFLOAT          shift and go to state 230
    WSTRING         shift and go to state 231
    BOOL            shift and go to state 232

    data_types                     shift and go to state 328

state 300

    (119) funciones -> APPEND LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    PRINT           reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SCAN            reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FOR             reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    VAR             reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    ID              reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    APPEND          reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    LEN             reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    COPY            reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DELETE          reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    IF              reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    ELSE            reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    TYPE            reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SWITCH          reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FUNC            reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    INTEGER         reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FLOAT           reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    NOT             reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 119 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)


state 301

    (118) funciones -> APPEND LPAREN ID COMA values RPAREN .

    COLON           reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    PRINT           reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SCAN            reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FOR             reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    VAR             reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    ID              reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    APPEND          reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    LEN             reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    COPY            reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DELETE          reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    IF              reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    ELSE            reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    TYPE            reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SWITCH          reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FUNC            reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    INTEGER         reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FLOAT           reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    NOT             reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    $end            reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    GREATER         reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SMALLER         reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    GREATER_OR_EQUAL reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    EQUAL_COMPARE   reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    NOT_EQUAL       reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    PLUS            reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    TIMES           reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DIVIDE          reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    MINUS           reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RLLAVE          reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DEFAULT         reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    CASE            reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RETURN          reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RPAREN          reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    AND             reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    OR              reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    LLLAVE          reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RCORCHE         reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    COMA            reduce using rule 118 (funciones -> APPEND LPAREN ID COMA values RPAREN .)


state 302

    (121) funciones -> COPY LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    PRINT           reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SCAN            reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FOR             reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    VAR             reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    ID              reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    APPEND          reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    LEN             reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    COPY            reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DELETE          reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    IF              reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    ELSE            reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    TYPE            reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SWITCH          reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FUNC            reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    INTEGER         reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FLOAT           reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    NOT             reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 121 (funciones -> COPY LPAREN ID COMA ID RPAREN .)


state 303

    (122) funciones -> DELETE LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    PRINT           reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SCAN            reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FOR             reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    VAR             reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    ID              reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    APPEND          reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    LEN             reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    COPY            reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DELETE          reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    IF              reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    ELSE            reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    TYPE            reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SWITCH          reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FUNC            reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    INTEGER         reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FLOAT           reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    NOT             reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 122 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)


state 304

    (128) SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    ID              reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    IF              reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    $end            reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 128 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)


state 305

    (129) SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 129 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)


state 306

    (130) SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 130 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)


state 307

    (132) SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .

    PRINT           reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    SCAN            reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FOR             reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    VAR             reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    ID              reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    APPEND          reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    LEN             reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    COPY            reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    DELETE          reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    IF              reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    ELSE            reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    TYPE            reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    SWITCH          reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FUNC            reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    INTEGER         reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FLOAT           reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    NOT             reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    $end            reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RLLAVE          reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    DEFAULT         reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    CASE            reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RETURN          reduce using rule 132 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)


state 308

    (134) declaration -> declaration variable . data_types
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 224
    INT64           shift and go to state 225
    FLOAT32         shift and go to state 226
    FLOAT64         shift and go to state 227
    BYTE            shift and go to state 228
    WINT            shift and go to state 229
    WFLOAT          shift and go to state 230
    WSTRING         shift and go to state 231
    BOOL            shift and go to state 232

    data_types                     shift and go to state 329

state 309

    (133) declaration -> variable data_types .

    RLLAVE          reduce using rule 133 (declaration -> variable data_types .)
    ID              reduce using rule 133 (declaration -> variable data_types .)


state 310

    (164) cases -> CASE values POINTS . codigo
    (165) cases -> CASE values POINTS . codigo more
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    codigo                         shift and go to state 330
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    decVarOne                      shift and go to state 33
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 311

    (194) more_params -> ID data_types COMA . params
    (192) params -> . ID data_types
    (193) params -> . more_params
    (194) more_params -> . ID data_types COMA params

    ID              shift and go to state 253

    params                         shift and go to state 331
    more_params                    shift and go to state 255

state 312

    (184) func_declaration -> FUNC ID LPAREN params RPAREN data_types . LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> FUNC ID LPAREN params RPAREN data_types . LLLAVE RETURN return_value RLLAVE

    LLLAVE          shift and go to state 332


state 313

    (78) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 333


state 314

    (83) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    decVarOne                      shift and go to state 33
    comparison                     shift and go to state 8
    codigo                         shift and go to state 334
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 315

    (84) incre -> ID INCREASE .

    LLLAVE          reduce using rule 84 (incre -> ID INCREASE .)


state 316

    (85) incre -> ID DECREASE .

    LLLAVE          reduce using rule 85 (incre -> ID DECREASE .)


state 317

    (169) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types . arr_content
    (68) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (69) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 298

    arr_content                    shift and go to state 335

state 318

    (100) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .

    COLON           reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    PRINT           reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    SCAN            reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FOR             reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    VAR             reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    ID              reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    APPEND          reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    LEN             reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    COPY            reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    DELETE          reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    IF              reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    ELSE            reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    TYPE            reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    SWITCH          reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FUNC            reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    INTEGER         reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT           reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    NOT             reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    $end            reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    CASE            reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    RETURN          reduce using rule 100 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)


state 319

    (139) valor -> ID .

    COMA            reduce using rule 139 (valor -> ID .)
    RLLAVE          reduce using rule 139 (valor -> ID .)


state 320

    (137) asignaciones -> ID POINTS valor .
    (138) asignaciones -> ID POINTS valor . COMA asignaciones

    RLLAVE          reduce using rule 137 (asignaciones -> ID POINTS valor .)
    COMA            shift and go to state 336


state 321

    (140) valor -> INTEGER .

    COMA            reduce using rule 140 (valor -> INTEGER .)
    RLLAVE          reduce using rule 140 (valor -> INTEGER .)


state 322

    (141) valor -> TRUE .

    COMA            reduce using rule 141 (valor -> TRUE .)
    RLLAVE          reduce using rule 141 (valor -> TRUE .)


state 323

    (142) valor -> FALSE .

    COMA            reduce using rule 142 (valor -> FALSE .)
    RLLAVE          reduce using rule 142 (valor -> FALSE .)


state 324

    (68) arr_content -> LLLAVE items . COMA more_items RLLAVE
    (69) arr_content -> LLLAVE items . RLLAVE

    COMA            shift and go to state 337
    RLLAVE          shift and go to state 338


state 325

    (72) items -> values .

    COMA            reduce using rule 72 (items -> values .)
    RLLAVE          reduce using rule 72 (items -> values .)


state 326

    (73) items -> operations .

    COMA            reduce using rule 73 (items -> operations .)
    RLLAVE          reduce using rule 73 (items -> operations .)


state 327

    (205) something_ex -> ID .
    (144) value -> ID .
    (158) logic_value -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (179) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 144 (value -> ID .)
    COMA            reduce using rule 205 (something_ex -> ID .)
    RLLAVE          reduce using rule 205 (something_ex -> ID .)
    GREATER         reduce using rule 144 (value -> ID .)
    SMALLER         reduce using rule 144 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 144 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 144 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 144 (value -> ID .)
    NOT_EQUAL       reduce using rule 144 (value -> ID .)
    PLUS            reduce using rule 144 (value -> ID .)
    TIMES           reduce using rule 144 (value -> ID .)
    DIVIDE          reduce using rule 144 (value -> ID .)
    MINUS           reduce using rule 144 (value -> ID .)
    AND             reduce using rule 158 (logic_value -> ID .)
    OR              reduce using rule 158 (logic_value -> ID .)
    LCORCHE         shift and go to state 149

  ! GREATER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 205 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 205 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 205 (something_ex -> ID .) ]


state 328

    (104) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap RPAREN
    (105) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap COMA cap RPAREN

    COMA            shift and go to state 339


state 329

    (134) declaration -> declaration variable data_types .

    RLLAVE          reduce using rule 134 (declaration -> declaration variable data_types .)
    ID              reduce using rule 134 (declaration -> declaration variable data_types .)


state 330

    (164) cases -> CASE values POINTS codigo .
    (165) cases -> CASE values POINTS codigo . more
    (166) more -> . cases
    (167) more -> . DEFAULT POINTS codigo
    (164) cases -> . CASE values POINTS codigo
    (165) cases -> . CASE values POINTS codigo more

    RLLAVE          reduce using rule 164 (cases -> CASE values POINTS codigo .)
    DEFAULT         shift and go to state 342
    CASE            shift and go to state 252

    more                           shift and go to state 340
    cases                          shift and go to state 341

state 331

    (194) more_params -> ID data_types COMA params .

    RPAREN          reduce using rule 194 (more_params -> ID data_types COMA params .)


state 332

    (184) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE . codigo RETURN retorno RLLAVE
    (185) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE . RETURN return_value RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    RETURN          shift and go to state 344
    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    codigo                         shift and go to state 343
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    decVarOne                      shift and go to state 33
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 333

    (78) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    ID              reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    IF              reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    $end            reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 78 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)


state 334

    (83) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 345


state 335

    (169) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .

    COLON           reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    PRINT           reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    SCAN            reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FOR             reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    VAR             reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    ID              reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    APPEND          reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    LEN             reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    COPY            reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    DELETE          reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    IF              reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    ELSE            reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    TYPE            reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    SWITCH          reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FUNC            reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    INTEGER         reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FLOAT           reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    NOT             reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    $end            reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    CASE            reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RETURN          reduce using rule 169 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)


state 336

    (138) asignaciones -> ID POINTS valor COMA . asignaciones
    (137) asignaciones -> . ID POINTS valor
    (138) asignaciones -> . ID POINTS valor COMA asignaciones

    ID              shift and go to state 265

    asignaciones                   shift and go to state 346

state 337

    (68) arr_content -> LLLAVE items COMA . more_items RLLAVE
    (70) more_items -> . items COMA more_items
    (71) more_items -> . items
    (72) items -> . values
    (73) items -> . operations
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    STRING          shift and go to state 122
    INTEGER         shift and go to state 123
    FLOAT           shift and go to state 124
    TRUE            shift and go to state 125
    FALSE           shift and go to state 126
    ID              shift and go to state 327
    NOT             shift and go to state 51
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    items                          shift and go to state 347
    more_items                     shift and go to state 348
    values                         shift and go to state 325
    operations                     shift and go to state 326
    expression                     shift and go to state 127
    comparison                     shift and go to state 128
    logic_operation                shift and go to state 129
    something_ex                   shift and go to state 31
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 338

    (69) arr_content -> LLLAVE items RLLAVE .

    COLON           reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    PRINT           reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    SCAN            reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    FOR             reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    VAR             reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    ID              reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    APPEND          reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    LEN             reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    COPY            reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    DELETE          reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    IF              reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    ELSE            reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    TYPE            reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    SWITCH          reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    FUNC            reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    INTEGER         reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    FLOAT           reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    NOT             reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    $end            reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    RLLAVE          reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    DEFAULT         reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    CASE            reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)
    RETURN          reduce using rule 69 (arr_content -> LLLAVE items RLLAVE .)


state 339

    (104) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap RPAREN
    (105) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap COMA cap RPAREN
    (106) cap -> . INTEGER
    (107) cap -> . ID
    (108) cap -> . expression
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    INTEGER         shift and go to state 350
    ID              shift and go to state 351
    FLOAT           shift and go to state 40
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    cap                            shift and go to state 349
    expression                     shift and go to state 352
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 340

    (165) cases -> CASE values POINTS codigo more .

    RLLAVE          reduce using rule 165 (cases -> CASE values POINTS codigo more .)


state 341

    (166) more -> cases .

    RLLAVE          reduce using rule 166 (more -> cases .)


state 342

    (167) more -> DEFAULT . POINTS codigo

    POINTS          shift and go to state 353


state 343

    (184) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo . RETURN retorno RLLAVE

    RETURN          shift and go to state 354


state 344

    (185) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN . return_value RLLAVE
    (186) return_value -> . retorno COLON
    (187) return_value -> . retorno
    (188) retorno -> . ID
    (189) retorno -> . values
    (190) retorno -> . operations
    (191) retorno -> . data_structure
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN

    ID              shift and go to state 355
    STRING          shift and go to state 122
    INTEGER         shift and go to state 123
    FLOAT           shift and go to state 124
    TRUE            shift and go to state 125
    FALSE           shift and go to state 126
    NOT             shift and go to state 51
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    return_value                   shift and go to state 356
    retorno                        shift and go to state 357
    values                         shift and go to state 358
    operations                     shift and go to state 359
    data_structure                 shift and go to state 360
    expression                     shift and go to state 127
    comparison                     shift and go to state 128
    logic_operation                shift and go to state 129
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52
    something_ex                   shift and go to state 31
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    funciones                      shift and go to state 90

state 345

    (83) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    ID              reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    IF              reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    $end            reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 83 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)


state 346

    (138) asignaciones -> ID POINTS valor COMA asignaciones .

    RLLAVE          reduce using rule 138 (asignaciones -> ID POINTS valor COMA asignaciones .)


state 347

    (70) more_items -> items . COMA more_items
    (71) more_items -> items .

    COMA            shift and go to state 361
    RLLAVE          reduce using rule 71 (more_items -> items .)


state 348

    (68) arr_content -> LLLAVE items COMA more_items . RLLAVE

    RLLAVE          shift and go to state 362


state 349

    (104) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . RPAREN
    (105) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . COMA cap RPAREN

    RPAREN          shift and go to state 364
    COMA            shift and go to state 363


state 350

    (106) cap -> INTEGER .
    (206) something_ex -> INTEGER .

  ! reduce/reduce conflict for RPAREN resolved using rule 106 (cap -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 106 (cap -> INTEGER .)
    RPAREN          reduce using rule 106 (cap -> INTEGER .)
    COMA            reduce using rule 106 (cap -> INTEGER .)
    GREATER         reduce using rule 206 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 206 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 206 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 206 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 206 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 206 (something_ex -> INTEGER .)
    PLUS            reduce using rule 206 (something_ex -> INTEGER .)
    TIMES           reduce using rule 206 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 206 (something_ex -> INTEGER .)
    MINUS           reduce using rule 206 (something_ex -> INTEGER .)

  ! RPAREN          [ reduce using rule 206 (something_ex -> INTEGER .) ]
  ! COMA            [ reduce using rule 206 (something_ex -> INTEGER .) ]


state 351

    (107) cap -> ID .
    (205) something_ex -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (179) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for RPAREN resolved using rule 107 (cap -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 107 (cap -> ID .)
    RPAREN          reduce using rule 107 (cap -> ID .)
    COMA            reduce using rule 107 (cap -> ID .)
    GREATER         reduce using rule 205 (something_ex -> ID .)
    SMALLER         reduce using rule 205 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 205 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 205 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 205 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 205 (something_ex -> ID .)
    PLUS            reduce using rule 205 (something_ex -> ID .)
    TIMES           reduce using rule 205 (something_ex -> ID .)
    DIVIDE          reduce using rule 205 (something_ex -> ID .)
    MINUS           reduce using rule 205 (something_ex -> ID .)
    LCORCHE         shift and go to state 149

  ! RPAREN          [ reduce using rule 205 (something_ex -> ID .) ]
  ! COMA            [ reduce using rule 205 (something_ex -> ID .) ]


state 352

    (108) cap -> expression .

    RPAREN          reduce using rule 108 (cap -> expression .)
    COMA            reduce using rule 108 (cap -> expression .)


state 353

    (167) more -> DEFAULT POINTS . codigo
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (195) impresion -> . PRINT LPAREN content RPAREN
    (79) scan_func -> . SCAN LPAREN POINTER RPAREN
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (80) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (81) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (82) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (83) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (86) decVar -> . decVarOne
    (87) decVar -> . VAR ID EQUAL INTEGER
    (88) decVar -> . VAR ID EQUAL ID
    (89) decVar -> . VAR ID EQUAL FLOAT
    (90) decVar -> . VAR ID EQUAL expression
    (91) decVar -> . VAR ID EQUAL logic_operation
    (92) decVar -> . VAR ID EQUAL comparison
    (93) decVar -> . VAR ID EQUAL STRING
    (94) decVar -> . ID DEQUAL STRING
    (95) decVar -> . ID DEQUAL FLOAT
    (96) decVar -> . ID DEQUAL expression
    (97) decVar -> . ID DEQUAL logic_operation
    (98) decVar -> . ID DEQUAL comparison
    (62) var_asignation -> . ID EQUAL any
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (125) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (126) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (127) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (129) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (130) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (131) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (132) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (136) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (163) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (168) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (169) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (173) array_var -> . ID LCORCHE index RCORCHE
    (177) array_assignment -> . array_var EQUAL something
    (99) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (100) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (101) slice_declaration -> . VAR ID EQUAL funM
    (102) slice_declaration -> . ID DEQUAL funM
    (103) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (109) slice_var -> . ID LCORCHE index_s RCORCHE
    (113) slice_assignment -> . slice_var EQUAL something_s
    (178) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (183) map_assignment -> . array_var EQUAL something
    (184) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (185) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (78) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (123) decVarOne -> . ID DEQUAL ID
    (124) decVarOne -> . ID DEQUAL INTEGER
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (179) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    VAR             shift and go to state 37
    ID              shift and go to state 38
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44
    IF              shift and go to state 45
    ELSE            shift and go to state 46
    TYPE            shift and go to state 47
    SWITCH          shift and go to state 48
    FUNC            shift and go to state 49
    INTEGER         shift and go to state 39
    FLOAT           shift and go to state 40
    NOT             shift and go to state 51

    codigo                         shift and go to state 365
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    decVarOne                      shift and go to state 33
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    map_var                        shift and go to state 52

state 354

    (184) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN . retorno RLLAVE
    (188) retorno -> . ID
    (189) retorno -> . values
    (190) retorno -> . operations
    (191) retorno -> . data_structure
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN

    ID              shift and go to state 355
    STRING          shift and go to state 122
    INTEGER         shift and go to state 123
    FLOAT           shift and go to state 124
    TRUE            shift and go to state 125
    FALSE           shift and go to state 126
    NOT             shift and go to state 51
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    retorno                        shift and go to state 366
    values                         shift and go to state 358
    operations                     shift and go to state 359
    data_structure                 shift and go to state 360
    expression                     shift and go to state 127
    comparison                     shift and go to state 128
    logic_operation                shift and go to state 129
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52
    something_ex                   shift and go to state 31
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    funciones                      shift and go to state 90

state 355

    (188) retorno -> ID .
    (173) array_var -> ID . LCORCHE index RCORCHE
    (179) map_var -> ID . LCORCHE key RCORCHE
    (205) something_ex -> ID .
    (144) value -> ID .
    (158) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 188 (retorno -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 188 (retorno -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 144 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 144 (value -> ID .)
    COLON           reduce using rule 188 (retorno -> ID .)
    RLLAVE          reduce using rule 188 (retorno -> ID .)
    LCORCHE         shift and go to state 149
    GREATER         reduce using rule 144 (value -> ID .)
    SMALLER         reduce using rule 144 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 144 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 144 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 144 (value -> ID .)
    NOT_EQUAL       reduce using rule 144 (value -> ID .)
    PLUS            reduce using rule 144 (value -> ID .)
    TIMES           reduce using rule 144 (value -> ID .)
    DIVIDE          reduce using rule 144 (value -> ID .)
    MINUS           reduce using rule 144 (value -> ID .)
    AND             reduce using rule 158 (logic_value -> ID .)
    OR              reduce using rule 158 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 205 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 205 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 205 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 205 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 205 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 205 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 205 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 205 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 205 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 205 (something_ex -> ID .) ]


state 356

    (185) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value . RLLAVE

    RLLAVE          shift and go to state 367


state 357

    (186) return_value -> retorno . COLON
    (187) return_value -> retorno .

    COLON           shift and go to state 368
    RLLAVE          reduce using rule 187 (return_value -> retorno .)


state 358

    (189) retorno -> values .

    COLON           reduce using rule 189 (retorno -> values .)
    RLLAVE          reduce using rule 189 (retorno -> values .)


state 359

    (190) retorno -> operations .

    COLON           reduce using rule 190 (retorno -> operations .)
    RLLAVE          reduce using rule 190 (retorno -> operations .)


state 360

    (191) retorno -> data_structure .
    (208) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 191 (retorno -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 191 (retorno -> data_structure .)
    COLON           reduce using rule 191 (retorno -> data_structure .)
    RLLAVE          reduce using rule 191 (retorno -> data_structure .)
    GREATER         reduce using rule 208 (something_ex -> data_structure .)
    SMALLER         reduce using rule 208 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 208 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 208 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 208 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 208 (something_ex -> data_structure .)
    PLUS            reduce using rule 208 (something_ex -> data_structure .)
    TIMES           reduce using rule 208 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 208 (something_ex -> data_structure .)
    MINUS           reduce using rule 208 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 208 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 208 (something_ex -> data_structure .) ]


state 361

    (70) more_items -> items COMA . more_items
    (70) more_items -> . items COMA more_items
    (71) more_items -> . items
    (72) items -> . values
    (73) items -> . operations
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (143) comparison -> . value op value
    (152) logic_operation -> . logic_value logic_recu
    (153) logic_operation -> . negation
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (144) value -> . ID
    (145) value -> . expression
    (156) logic_value -> . negation
    (157) logic_value -> . comparison
    (158) logic_value -> . ID
    (159) negation -> . NOT comparison
    (160) negation -> . NOT ID
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    STRING          shift and go to state 122
    INTEGER         shift and go to state 123
    FLOAT           shift and go to state 124
    TRUE            shift and go to state 125
    FALSE           shift and go to state 126
    ID              shift and go to state 327
    NOT             shift and go to state 51
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    items                          shift and go to state 347
    more_items                     shift and go to state 369
    values                         shift and go to state 325
    operations                     shift and go to state 326
    expression                     shift and go to state 127
    comparison                     shift and go to state 128
    logic_operation                shift and go to state 129
    something_ex                   shift and go to state 31
    value                          shift and go to state 34
    logic_value                    shift and go to state 35
    negation                       shift and go to state 36
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 362

    (68) arr_content -> LLLAVE items COMA more_items RLLAVE .

    COLON           reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    PRINT           reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    SCAN            reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FOR             reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    VAR             reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    ID              reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    APPEND          reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    LEN             reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    COPY            reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    DELETE          reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    IF              reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    ELSE            reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    TYPE            reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    SWITCH          reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FUNC            reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    INTEGER         reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FLOAT           reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    NOT             reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    $end            reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RLLAVE          reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    DEFAULT         reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    CASE            reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RETURN          reduce using rule 68 (arr_content -> LLLAVE items COMA more_items RLLAVE .)


state 363

    (105) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA . cap RPAREN
    (106) cap -> . INTEGER
    (107) cap -> . ID
    (108) cap -> . expression
    (201) expression -> . something_ex
    (202) expression -> . something_ex adicionaEx
    (205) something_ex -> . ID
    (206) something_ex -> . INTEGER
    (207) something_ex -> . FLOAT
    (208) something_ex -> . data_structure
    (209) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (118) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (119) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (120) funciones -> . LEN LPAREN ID RPAREN
    (121) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (122) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (173) array_var -> . ID LCORCHE index RCORCHE
    (179) map_var -> . ID LCORCHE key RCORCHE

    INTEGER         shift and go to state 350
    ID              shift and go to state 351
    FLOAT           shift and go to state 40
    APPEND          shift and go to state 41
    LEN             shift and go to state 42
    COPY            shift and go to state 43
    DELETE          shift and go to state 44

    cap                            shift and go to state 370
    expression                     shift and go to state 352
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 50
    funciones                      shift and go to state 90
    array_var                      shift and go to state 91
    map_var                        shift and go to state 52

state 364

    (104) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .

    COLON           reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    PRINT           reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    SCAN            reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FOR             reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    VAR             reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    ID              reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    APPEND          reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    LEN             reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    COPY            reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    DELETE          reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    IF              reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    ELSE            reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    TYPE            reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    SWITCH          reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FUNC            reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    INTEGER         reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FLOAT           reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    NOT             reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    $end            reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RLLAVE          reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    DEFAULT         reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    CASE            reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RETURN          reduce using rule 104 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)


state 365

    (167) more -> DEFAULT POINTS codigo .

    RLLAVE          reduce using rule 167 (more -> DEFAULT POINTS codigo .)


state 366

    (184) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno . RLLAVE

    RLLAVE          shift and go to state 371


state 367

    (185) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .

    PRINT           reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    SCAN            reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    FOR             reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    VAR             reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    ID              reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    APPEND          reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    LEN             reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    COPY            reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    DELETE          reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    IF              reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    ELSE            reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    TYPE            reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    SWITCH          reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    FUNC            reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    INTEGER         reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    FLOAT           reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    NOT             reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    $end            reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    RLLAVE          reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    DEFAULT         reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    CASE            reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    RETURN          reduce using rule 185 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)


state 368

    (186) return_value -> retorno COLON .

    RLLAVE          reduce using rule 186 (return_value -> retorno COLON .)


state 369

    (70) more_items -> items COMA more_items .

    RLLAVE          reduce using rule 70 (more_items -> items COMA more_items .)


state 370

    (105) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap . RPAREN

    RPAREN          shift and go to state 372


state 371

    (184) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .

    PRINT           reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    SCAN            reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FOR             reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    VAR             reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    ID              reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    APPEND          reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    LEN             reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    COPY            reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    DELETE          reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    IF              reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    ELSE            reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    TYPE            reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    SWITCH          reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FUNC            reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    INTEGER         reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FLOAT           reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    NOT             reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    $end            reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    RLLAVE          reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    DEFAULT         reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    CASE            reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    RETURN          reduce using rule 184 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)


state 372

    (105) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .

    COLON           reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    PRINT           reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    SCAN            reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FOR             reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    VAR             reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    ID              reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    APPEND          reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    LEN             reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    COPY            reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    DELETE          reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    IF              reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    ELSE            reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    TYPE            reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    SWITCH          reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FUNC            reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    INTEGER         reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FLOAT           reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    NOT             reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    $end            reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RLLAVE          reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    DEFAULT         reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    CASE            reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RETURN          reduce using rule 105 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COLON in state 12 resolved as shift
WARNING: shift/reduce conflict for COLON in state 20 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 31 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 31 resolved as shift
WARNING: shift/reduce conflict for GREATER_OR_EQUAL in state 31 resolved as shift
WARNING: shift/reduce conflict for SMALLER_OR_EQUAL in state 31 resolved as shift
WARNING: shift/reduce conflict for EQUAL_COMPARE in state 31 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 31 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 31 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 31 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 31 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 31 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 142 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 142 resolved as shift
WARNING: shift/reduce conflict for GREATER_OR_EQUAL in state 142 resolved as shift
WARNING: shift/reduce conflict for SMALLER_OR_EQUAL in state 142 resolved as shift
WARNING: shift/reduce conflict for EQUAL_COMPARE in state 142 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 142 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 142 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 142 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 142 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 142 resolved as shift
WARNING: reduce/reduce conflict in state 12 resolved using rule (rule -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 12
WARNING: reduce/reduce conflict in state 20 resolved using rule (rule -> array_var)
WARNING: rejected rule (data_structure -> array_var) in state 20
WARNING: reduce/reduce conflict in state 38 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 38
WARNING: reduce/reduce conflict in state 88 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 88
WARNING: reduce/reduce conflict in state 108 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 108
WARNING: reduce/reduce conflict in state 116 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 116
WARNING: reduce/reduce conflict in state 117 resolved using rule (array_assignment -> array_var EQUAL something)
WARNING: rejected rule (map_assignment -> array_var EQUAL something) in state 117
WARNING: reduce/reduce conflict in state 118 resolved using rule (something -> ID)
WARNING: rejected rule (something_ex -> ID) in state 118
WARNING: reduce/reduce conflict in state 118 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 118
WARNING: reduce/reduce conflict in state 119 resolved using rule (something -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 119
WARNING: reduce/reduce conflict in state 123 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 123
WARNING: reduce/reduce conflict in state 124 resolved using rule (values -> FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 124
WARNING: reduce/reduce conflict in state 131 resolved using rule (something_s -> ID)
WARNING: rejected rule (something_ex -> ID) in state 131
WARNING: reduce/reduce conflict in state 131 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 131
WARNING: reduce/reduce conflict in state 132 resolved using rule (data_structure -> array_var)
WARNING: rejected rule (something_s -> array_var) in state 132
WARNING: reduce/reduce conflict in state 138 resolved using rule (content -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 138
WARNING: reduce/reduce conflict in state 139 resolved using rule (content -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 139
WARNING: reduce/reduce conflict in state 140 resolved using rule (content -> ID)
WARNING: rejected rule (something_ex -> ID) in state 140
WARNING: reduce/reduce conflict in state 140 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 140
WARNING: reduce/reduce conflict in state 154 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 154
WARNING: reduce/reduce conflict in state 157 resolved using rule (decVarOne -> ID DEQUAL ID)
WARNING: rejected rule (something_ex -> ID) in state 157
WARNING: reduce/reduce conflict in state 157 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 157
WARNING: reduce/reduce conflict in state 159 resolved using rule (decVar -> ID DEQUAL FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 159
WARNING: reduce/reduce conflict in state 165 resolved using rule (decVarOne -> ID DEQUAL INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 165
WARNING: reduce/reduce conflict in state 167 resolved using rule (any -> ID)
WARNING: rejected rule (something_ex -> ID) in state 167
WARNING: reduce/reduce conflict in state 167 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 167
WARNING: reduce/reduce conflict in state 171 resolved using rule (any -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 171
WARNING: reduce/reduce conflict in state 172 resolved using rule (any -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 172
WARNING: reduce/reduce conflict in state 173 resolved using rule (index_s -> ID)
WARNING: rejected rule (index -> ID) in state 173
WARNING: reduce/reduce conflict in state 173 resolved using rule (index_s -> ID)
WARNING: rejected rule (key -> ID) in state 173
WARNING: reduce/reduce conflict in state 173 resolved using rule (index_s -> ID)
WARNING: rejected rule (something_ex -> ID) in state 173
WARNING: reduce/reduce conflict in state 173 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 173
WARNING: reduce/reduce conflict in state 177 resolved using rule (index_s -> INTEGER)
WARNING: rejected rule (index -> INTEGER) in state 177
WARNING: reduce/reduce conflict in state 177 resolved using rule (values -> INTEGER)
WARNING: rejected rule (index_s -> INTEGER) in state 177
WARNING: reduce/reduce conflict in state 177 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 177
WARNING: reduce/reduce conflict in state 178 resolved using rule (index_s -> expression)
WARNING: rejected rule (index -> expression) in state 178
WARNING: reduce/reduce conflict in state 178 resolved using rule (operations -> expression)
WARNING: rejected rule (index_s -> expression) in state 178
WARNING: reduce/reduce conflict in state 205 resolved using rule (index -> ID)
WARNING: rejected rule (key -> ID) in state 205
WARNING: reduce/reduce conflict in state 205 resolved using rule (index -> ID)
WARNING: rejected rule (something_ex -> ID) in state 205
WARNING: reduce/reduce conflict in state 205 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 205
WARNING: reduce/reduce conflict in state 206 resolved using rule (values -> INTEGER)
WARNING: rejected rule (index -> INTEGER) in state 206
WARNING: reduce/reduce conflict in state 206 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 206
WARNING: reduce/reduce conflict in state 207 resolved using rule (operations -> expression)
WARNING: rejected rule (index -> expression) in state 207
WARNING: reduce/reduce conflict in state 209 resolved using rule (decVar -> VAR ID EQUAL ID)
WARNING: rejected rule (something_ex -> ID) in state 209
WARNING: reduce/reduce conflict in state 209 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 209
WARNING: reduce/reduce conflict in state 210 resolved using rule (decVar -> VAR ID EQUAL INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 210
WARNING: reduce/reduce conflict in state 211 resolved using rule (decVar -> VAR ID EQUAL FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 211
WARNING: reduce/reduce conflict in state 218 resolved using rule (capacity -> ID)
WARNING: rejected rule (something_ex -> ID) in state 218
WARNING: reduce/reduce conflict in state 222 resolved using rule (capacity -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 222
WARNING: reduce/reduce conflict in state 327 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 327
WARNING: reduce/reduce conflict in state 350 resolved using rule (cap -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 350
WARNING: reduce/reduce conflict in state 351 resolved using rule (cap -> ID)
WARNING: rejected rule (something_ex -> ID) in state 351
WARNING: reduce/reduce conflict in state 355 resolved using rule (retorno -> ID)
WARNING: rejected rule (something_ex -> ID) in state 355
WARNING: reduce/reduce conflict in state 355 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 355
WARNING: reduce/reduce conflict in state 360 resolved using rule (retorno -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 360
WARNING: Rule (map_assignment -> array_var EQUAL something) is never reduced
WARNING: Rule (something_s -> array_var) is never reduced
WARNING: Rule (key -> ID) is never reduced
WARNING: Rule (index -> INTEGER) is never reduced
WARNING: Rule (index_s -> INTEGER) is never reduced
WARNING: Rule (index -> expression) is never reduced
WARNING: Rule (index_s -> expression) is never reduced
