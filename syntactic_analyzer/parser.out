Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    CAP
    COMMENT
    CONST
    INTERFACE
    JOIN
    MAP
    MOD
    MULTI_COMMENT
    PACKAGE

Grammar

Rule 0     S' -> codigo
Rule 1     codigo -> rule
Rule 2     codigo -> more_rules
Rule 3     more_rules -> rule codigo
Rule 4     rule -> impresion COLON
Rule 5     rule -> impresion
Rule 6     rule -> scan_func COLON
Rule 7     rule -> scan_func
Rule 8     rule -> expression COLON
Rule 9     rule -> expression
Rule 10    rule -> cicloFor
Rule 11    rule -> comparison
Rule 12    rule -> logic_operation
Rule 13    rule -> decVar COLON
Rule 14    rule -> decVar
Rule 15    rule -> var_asignation
Rule 16    rule -> var_asignation COLON
Rule 17    rule -> funciones
Rule 18    rule -> funciones COLON
Rule 19    rule -> SenIF
Rule 20    rule -> SenElseIF
Rule 21    rule -> SenElse
Rule 22    rule -> SenStruct
Rule 23    rule -> cStruct
Rule 24    rule -> switch_statement
Rule 25    rule -> array_declaration COLON
Rule 26    rule -> array_declaration
Rule 27    rule -> array_var COLON
Rule 28    rule -> array_var
Rule 29    rule -> array_assignment COLON
Rule 30    rule -> array_assignment
Rule 31    rule -> slice_declaration COLON
Rule 32    rule -> slice_declaration
Rule 33    rule -> slice_var COLON
Rule 34    rule -> slice_var
Rule 35    rule -> slice_assignment COLON
Rule 36    rule -> slice_assignment
Rule 37    rule -> map_declaration COLON
Rule 38    rule -> map_declaration
Rule 39    rule -> map_assignment COLON
Rule 40    rule -> map_assignment
Rule 41    rule -> func_declaration
Rule 42    rule -> main_func
Rule 43    values -> STRING
Rule 44    values -> INTEGER
Rule 45    values -> FLOAT
Rule 46    values -> TRUE
Rule 47    values -> FALSE
Rule 48    data_types -> INT32
Rule 49    data_types -> INT64
Rule 50    data_types -> FLOAT32
Rule 51    data_types -> FLOAT64
Rule 52    data_types -> BYTE
Rule 53    data_types -> WINT
Rule 54    data_types -> WFLOAT
Rule 55    data_types -> WSTRING
Rule 56    data_types -> BOOL
Rule 57    operations -> expression
Rule 58    operations -> comparison
Rule 59    operations -> logic_operation
Rule 60    data_structure -> array_var
Rule 61    data_structure -> map_var
Rule 62    var_asignation -> ID EQUAL any
Rule 63    any -> values
Rule 64    any -> operations
Rule 65    any -> ID
Rule 66    any -> data_structure
Rule 67    any -> funciones
Rule 68    any -> call_func
Rule 69    arr_content -> LLLAVE items COMA more_items RLLAVE
Rule 70    arr_content -> LLLAVE items RLLAVE
Rule 71    more_items -> items COMA more_items
Rule 72    more_items -> items
Rule 73    items -> values
Rule 74    items -> operations
Rule 75    something -> ID
Rule 76    something -> data_structure
Rule 77    something -> values
Rule 78    something -> operations
Rule 79    main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
Rule 80    scan_func -> SCAN LPAREN POINTER RPAREN
Rule 81    call_func -> ID LPAREN list_params RPAREN
Rule 82    call_func -> ID LPAREN RPAREN
Rule 83    list_params -> ID
Rule 84    list_params -> ID COMA more_p
Rule 85    more_p -> list_params
Rule 86    cicloFor -> FOR LLLAVE codigo RLLAVE
Rule 87    cicloFor -> FOR comparison LLLAVE codigo RLLAVE
Rule 88    cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE
Rule 89    cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
Rule 90    incre -> ID INCREASE
Rule 91    incre -> ID DECREASE
Rule 92    decVar -> static
Rule 93    decVar -> dynamic
Rule 94    static -> single
Rule 95    static -> multiple
Rule 96    multiple -> list_var data_types
Rule 97    list_var -> VAR ID COMA more
Rule 98    more -> ID
Rule 99    more -> ID COMA more
Rule 100   single -> VAR ID data_types
Rule 101   single -> VAR ID data_types EQUAL funciones
Rule 102   single -> VAR ID data_types EQUAL ID
Rule 103   single -> VAR ID data_types EQUAL data_structure
Rule 104   single -> VAR ID data_type_and_value
Rule 105   data_type_and_value -> WSTRING EQUAL STRING
Rule 106   data_type_and_value -> WINT EQUAL int_value
Rule 107   data_type_and_value -> INT32 EQUAL int_value
Rule 108   data_type_and_value -> INT64 EQUAL int_value
Rule 109   data_type_and_value -> WFLOAT EQUAL float_value
Rule 110   data_type_and_value -> FLOAT32 EQUAL float_value
Rule 111   data_type_and_value -> FLOAT64 EQUAL float_value
Rule 112   data_type_and_value -> BOOL EQUAL bool_value
Rule 113   int_value -> INTEGER
Rule 114   int_value -> expression
Rule 115   bool_value -> TRUE
Rule 116   bool_value -> FALSE
Rule 117   bool_value -> comparison
Rule 118   bool_value -> logic_operation
Rule 119   float_value -> FLOAT
Rule 120   dynamic -> ID DEQUAL values
Rule 121   slice_declaration -> VAR ID LCORCHE RCORCHE data_types
Rule 122   slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
Rule 123   slice_declaration -> VAR ID EQUAL funM
Rule 124   slice_declaration -> ID DEQUAL funM
Rule 125   slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content
Rule 126   funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
Rule 127   funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
Rule 128   cap -> INTEGER
Rule 129   cap -> ID
Rule 130   cap -> expression
Rule 131   slice_var -> ID LCORCHE index_s RCORCHE
Rule 132   index_s -> ID
Rule 133   index_s -> INTEGER
Rule 134   index_s -> expression
Rule 135   slice_assignment -> slice_var EQUAL something_s
Rule 136   something_s -> ID
Rule 137   something_s -> array_var
Rule 138   something_s -> values
Rule 139   something_s -> operations
Rule 140   funciones -> APPEND LPAREN ID COMA values RPAREN
Rule 141   funciones -> APPEND LPAREN ID COMA ID RPAREN
Rule 142   funciones -> LEN LPAREN ID RPAREN
Rule 143   funciones -> COPY LPAREN ID COMA ID RPAREN
Rule 144   funciones -> DELETE LPAREN ID COMA ID RPAREN
Rule 145   funciones -> call_func
Rule 146   decVarOne -> ID DEQUAL ID
Rule 147   decVarOne -> ID DEQUAL INTEGER
Rule 148   SenIF -> IF comparison LLLAVE codigo RLLAVE
Rule 149   SenIF -> IF TRUE LLLAVE codigo RLLAVE
Rule 150   SenIF -> IF FALSE LLLAVE codigo RLLAVE
Rule 151   SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE
Rule 152   SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE
Rule 153   SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE
Rule 154   SenElse -> ELSE LLLAVE codigo RLLAVE
Rule 155   SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE
Rule 156   declaration -> variable data_types
Rule 157   declaration -> declaration variable data_types
Rule 158   variable -> ID
Rule 159   cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE
Rule 160   asignaciones -> ID POINTS valor
Rule 161   asignaciones -> ID POINTS valor COMA asignaciones
Rule 162   valor -> ID
Rule 163   valor -> INTEGER
Rule 164   valor -> TRUE
Rule 165   valor -> FALSE
Rule 166   comparison -> value op value
Rule 167   value -> ID
Rule 168   value -> expression
Rule 169   op -> GREATER
Rule 170   op -> SMALLER
Rule 171   op -> GREATER_OR_EQUAL
Rule 172   op -> SMALLER_OR_EQUAL
Rule 173   op -> EQUAL_COMPARE
Rule 174   op -> NOT_EQUAL
Rule 175   logic_operation -> logic_value logic_recu
Rule 176   logic_operation -> negation
Rule 177   logic_recu -> logic_op logic_value
Rule 178   logic_recu -> logic_op logic_value logic_recu
Rule 179   logic_value -> negation
Rule 180   logic_value -> comparison
Rule 181   logic_value -> ID
Rule 182   negation -> NOT comparison
Rule 183   negation -> NOT ID
Rule 184   logic_op -> AND
Rule 185   logic_op -> OR
Rule 186   switch_statement -> SWITCH ID LLLAVE cases RLLAVE
Rule 187   cases -> CASE values POINTS codigo
Rule 188   cases -> CASE values POINTS codigo more
Rule 189   more -> cases
Rule 190   more -> DEFAULT POINTS codigo
Rule 191   array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types
Rule 192   array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
Rule 193   capacity -> INTEGER
Rule 194   capacity -> ID
Rule 195   capacity -> expression
Rule 196   array_var -> ID LCORCHE index RCORCHE
Rule 197   index -> ID
Rule 198   index -> INTEGER
Rule 199   index -> expression
Rule 200   array_assignment -> array_var EQUAL something
Rule 201   map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types
Rule 202   map_var -> ID LCORCHE key RCORCHE
Rule 203   key -> ID
Rule 204   key -> values
Rule 205   key -> operations
Rule 206   map_assignment -> map_var EQUAL something
Rule 207   func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
Rule 208   func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
Rule 209   return_value -> retorno COLON
Rule 210   return_value -> retorno
Rule 211   retorno -> ID
Rule 212   retorno -> values
Rule 213   retorno -> operations
Rule 214   retorno -> data_structure
Rule 215   params -> ID data_types
Rule 216   params -> more_params
Rule 217   more_params -> ID data_types COMA params
Rule 218   impresion -> PRINT LPAREN content RPAREN
Rule 219   content -> values
Rule 220   content -> operations
Rule 221   content -> funciones
Rule 222   content -> data_structure
Rule 223   content -> ID
Rule 224   expression -> something_ex
Rule 225   expression -> something_ex adicionaEx
Rule 226   adicionaEx -> op something_ex
Rule 227   adicionaEx -> op something_ex adicionaEx
Rule 228   something_ex -> ID
Rule 229   something_ex -> INTEGER
Rule 230   something_ex -> FLOAT
Rule 231   something_ex -> data_structure
Rule 232   something_ex -> funciones
Rule 233   op -> PLUS
Rule 234   op -> TIMES
Rule 235   op -> DIVIDE
Rule 236   op -> MINUS

Terminals, with rules where they appear

AND                  : 184
APPEND               : 140 141
ARRAY                : 
BOOL                 : 56 112
BYTE                 : 52
CAP                  : 
CASE                 : 187 188
COLON                : 4 6 8 13 16 18 25 27 29 31 33 35 37 39 89 89 209
COMA                 : 69 71 84 97 99 126 127 127 140 141 143 144 161 217
COMMENT              : 
CONST                : 
COPY                 : 143
DECREASE             : 91
DEFAULT              : 190
DELETE               : 144
DEQUAL               : 120 124 125 146 147 159
DIVIDE               : 235
ELSE                 : 151 152 153 154
EQUAL                : 62 101 102 103 105 106 107 108 109 110 111 112 122 123 135 192 200 206
EQUAL_COMPARE        : 173
FALSE                : 47 116 150 153 165
FLOAT                : 45 119 230
FLOAT32              : 50 110
FLOAT64              : 51 111
FOR                  : 86 87 88 89
FUNC                 : 79 207 208
GREATER              : 169
GREATER_OR_EQUAL     : 171
ID                   : 62 65 75 81 82 83 84 90 91 97 98 99 100 101 102 102 103 104 120 121 122 123 124 125 129 131 132 136 140 141 141 142 143 143 144 144 146 146 147 155 158 159 159 160 161 162 167 181 183 186 191 192 194 196 197 201 202 203 207 208 211 215 217 223 228
IF                   : 148 149 150 151 152 153
INCREASE             : 90
INT32                : 48 107
INT64                : 49 108
INTEGER              : 44 113 128 133 147 163 193 198 229
INTERFACE            : 
JOIN                 : 
LCORCHE              : 121 122 125 126 127 131 191 192 196 201 202
LEN                  : 142
LLLAVE               : 69 70 79 86 87 88 89 148 149 150 151 152 153 154 155 159 186 207 208
LPAREN               : 79 80 81 82 126 127 140 141 142 143 144 207 208 218
MAIN                 : 79
MAKE                 : 126 127
MAP                  : 
MINUS                : 236
MOD                  : 
MULTI_COMMENT        : 
NOT                  : 182 183
NOT_EQUAL            : 174
OR                   : 185
PACKAGE              : 
PLUS                 : 233
POINTER              : 80
POINTS               : 160 161 187 188 190
PRINT                : 218
RCORCHE              : 121 122 125 126 127 131 191 192 196 201 202
RETURN               : 207 208
RLLAVE               : 69 70 79 86 87 88 89 148 149 150 151 152 153 154 155 159 186 207 208
RPAREN               : 79 80 81 82 126 127 140 141 142 143 144 207 208 218
SCAN                 : 80
SMALLER              : 170
SMALLER_OR_EQUAL     : 172
STRING               : 43 105
STRUCT               : 155
SWITCH               : 186
TIMES                : 234
TRUE                 : 46 115 149 152 164
TYPE                 : 155
VAR                  : 97 100 101 102 103 104 121 122 123 191 192 201
WFLOAT               : 54 109
WINT                 : 53 106
WSTRING              : 55 105
error                : 

Nonterminals, with rules where they appear

SenElse              : 21
SenElseIF            : 20
SenIF                : 19
SenStruct            : 22
adicionaEx           : 225 227
any                  : 62
arr_content          : 122 125 192
array_assignment     : 29 30
array_declaration    : 25 26
array_var            : 27 28 60 137 200
asignaciones         : 159 161
bool_value           : 112
cStruct              : 23
call_func            : 68 145
cap                  : 126 127 127
capacity             : 191 192
cases                : 186 189
cicloFor             : 10
codigo               : 3 79 86 87 88 89 148 149 150 151 152 153 154 187 188 190 207 0
comparison           : 11 58 87 89 117 148 151 180 182
content              : 218
data_structure       : 66 76 103 214 222 231
data_type_and_value  : 104
data_types           : 96 100 101 102 103 121 122 125 126 127 156 157 191 192 201 201 207 208 215 217
decVar               : 13 14
decVarOne            : 89
declaration          : 155 157
dynamic              : 93
expression           : 8 9 57 114 130 134 168 195 199
float_value          : 109 110 111
funM                 : 123 124
func_declaration     : 41
funciones            : 17 18 67 101 221 232
impresion            : 4 5
incre                : 89
index                : 196
index_s              : 131
int_value            : 106 107 108
items                : 69 70 71 72
key                  : 202
list_params          : 81 85
list_var             : 96
logic_op             : 177 178
logic_operation      : 12 59 88 118
logic_recu           : 175 178
logic_value          : 175 177 178
main_func            : 42
map_assignment       : 39 40
map_declaration      : 37 38
map_var              : 61 206
more                 : 97 99 188
more_items           : 69 71
more_p               : 84
more_params          : 216
more_rules           : 2
multiple             : 95
negation             : 176 179
op                   : 166 226 227
operations           : 64 74 78 139 205 213 220
params               : 207 208 217
retorno              : 207 209 210
return_value         : 208
rule                 : 1 3
scan_func            : 6 7
single               : 94
slice_assignment     : 35 36
slice_declaration    : 31 32
slice_var            : 33 34 135
something            : 200 206
something_ex         : 224 225 226 227
something_s          : 135
static               : 92
switch_statement     : 24
valor                : 160 161
value                : 166 166
values               : 63 73 77 120 138 140 187 188 204 212 219
var_asignation       : 15 16
variable             : 156 157

Parsing method: LALR

state 0

    (0) S' -> . codigo
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

    codigo                         shift and go to state 1
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 1

    (0) S' -> codigo .



state 2

    (1) codigo -> rule .
    (3) more_rules -> rule . codigo
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

  ! shift/reduce conflict for ID resolved as shift
    $end            reduce using rule 1 (codigo -> rule .)
    RLLAVE          reduce using rule 1 (codigo -> rule .)
    INT32           reduce using rule 1 (codigo -> rule .)
    INT64           reduce using rule 1 (codigo -> rule .)
    FLOAT32         reduce using rule 1 (codigo -> rule .)
    FLOAT64         reduce using rule 1 (codigo -> rule .)
    BYTE            reduce using rule 1 (codigo -> rule .)
    WINT            reduce using rule 1 (codigo -> rule .)
    WFLOAT          reduce using rule 1 (codigo -> rule .)
    WSTRING         reduce using rule 1 (codigo -> rule .)
    BOOL            reduce using rule 1 (codigo -> rule .)
    DEFAULT         reduce using rule 1 (codigo -> rule .)
    CASE            reduce using rule 1 (codigo -> rule .)
    RETURN          reduce using rule 1 (codigo -> rule .)
    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

  ! ID              [ reduce using rule 1 (codigo -> rule .) ]

    rule                           shift and go to state 2
    codigo                         shift and go to state 58
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 3

    (2) codigo -> more_rules .

    $end            reduce using rule 2 (codigo -> more_rules .)
    RLLAVE          reduce using rule 2 (codigo -> more_rules .)
    INT32           reduce using rule 2 (codigo -> more_rules .)
    INT64           reduce using rule 2 (codigo -> more_rules .)
    FLOAT32         reduce using rule 2 (codigo -> more_rules .)
    FLOAT64         reduce using rule 2 (codigo -> more_rules .)
    BYTE            reduce using rule 2 (codigo -> more_rules .)
    WINT            reduce using rule 2 (codigo -> more_rules .)
    WFLOAT          reduce using rule 2 (codigo -> more_rules .)
    WSTRING         reduce using rule 2 (codigo -> more_rules .)
    BOOL            reduce using rule 2 (codigo -> more_rules .)
    ID              reduce using rule 2 (codigo -> more_rules .)
    DEFAULT         reduce using rule 2 (codigo -> more_rules .)
    CASE            reduce using rule 2 (codigo -> more_rules .)
    RETURN          reduce using rule 2 (codigo -> more_rules .)


state 4

    (4) rule -> impresion . COLON
    (5) rule -> impresion .

    COLON           shift and go to state 59
    PRINT           reduce using rule 5 (rule -> impresion .)
    SCAN            reduce using rule 5 (rule -> impresion .)
    FOR             reduce using rule 5 (rule -> impresion .)
    ID              reduce using rule 5 (rule -> impresion .)
    APPEND          reduce using rule 5 (rule -> impresion .)
    LEN             reduce using rule 5 (rule -> impresion .)
    COPY            reduce using rule 5 (rule -> impresion .)
    DELETE          reduce using rule 5 (rule -> impresion .)
    IF              reduce using rule 5 (rule -> impresion .)
    ELSE            reduce using rule 5 (rule -> impresion .)
    TYPE            reduce using rule 5 (rule -> impresion .)
    SWITCH          reduce using rule 5 (rule -> impresion .)
    VAR             reduce using rule 5 (rule -> impresion .)
    FUNC            reduce using rule 5 (rule -> impresion .)
    INTEGER         reduce using rule 5 (rule -> impresion .)
    FLOAT           reduce using rule 5 (rule -> impresion .)
    NOT             reduce using rule 5 (rule -> impresion .)
    $end            reduce using rule 5 (rule -> impresion .)
    RLLAVE          reduce using rule 5 (rule -> impresion .)
    INT32           reduce using rule 5 (rule -> impresion .)
    INT64           reduce using rule 5 (rule -> impresion .)
    FLOAT32         reduce using rule 5 (rule -> impresion .)
    FLOAT64         reduce using rule 5 (rule -> impresion .)
    BYTE            reduce using rule 5 (rule -> impresion .)
    WINT            reduce using rule 5 (rule -> impresion .)
    WFLOAT          reduce using rule 5 (rule -> impresion .)
    WSTRING         reduce using rule 5 (rule -> impresion .)
    BOOL            reduce using rule 5 (rule -> impresion .)
    DEFAULT         reduce using rule 5 (rule -> impresion .)
    CASE            reduce using rule 5 (rule -> impresion .)
    RETURN          reduce using rule 5 (rule -> impresion .)


state 5

    (6) rule -> scan_func . COLON
    (7) rule -> scan_func .

    COLON           shift and go to state 60
    PRINT           reduce using rule 7 (rule -> scan_func .)
    SCAN            reduce using rule 7 (rule -> scan_func .)
    FOR             reduce using rule 7 (rule -> scan_func .)
    ID              reduce using rule 7 (rule -> scan_func .)
    APPEND          reduce using rule 7 (rule -> scan_func .)
    LEN             reduce using rule 7 (rule -> scan_func .)
    COPY            reduce using rule 7 (rule -> scan_func .)
    DELETE          reduce using rule 7 (rule -> scan_func .)
    IF              reduce using rule 7 (rule -> scan_func .)
    ELSE            reduce using rule 7 (rule -> scan_func .)
    TYPE            reduce using rule 7 (rule -> scan_func .)
    SWITCH          reduce using rule 7 (rule -> scan_func .)
    VAR             reduce using rule 7 (rule -> scan_func .)
    FUNC            reduce using rule 7 (rule -> scan_func .)
    INTEGER         reduce using rule 7 (rule -> scan_func .)
    FLOAT           reduce using rule 7 (rule -> scan_func .)
    NOT             reduce using rule 7 (rule -> scan_func .)
    $end            reduce using rule 7 (rule -> scan_func .)
    RLLAVE          reduce using rule 7 (rule -> scan_func .)
    INT32           reduce using rule 7 (rule -> scan_func .)
    INT64           reduce using rule 7 (rule -> scan_func .)
    FLOAT32         reduce using rule 7 (rule -> scan_func .)
    FLOAT64         reduce using rule 7 (rule -> scan_func .)
    BYTE            reduce using rule 7 (rule -> scan_func .)
    WINT            reduce using rule 7 (rule -> scan_func .)
    WFLOAT          reduce using rule 7 (rule -> scan_func .)
    WSTRING         reduce using rule 7 (rule -> scan_func .)
    BOOL            reduce using rule 7 (rule -> scan_func .)
    DEFAULT         reduce using rule 7 (rule -> scan_func .)
    CASE            reduce using rule 7 (rule -> scan_func .)
    RETURN          reduce using rule 7 (rule -> scan_func .)


state 6

    (8) rule -> expression . COLON
    (9) rule -> expression .
    (168) value -> expression .

    COLON           shift and go to state 61
    PRINT           reduce using rule 9 (rule -> expression .)
    SCAN            reduce using rule 9 (rule -> expression .)
    FOR             reduce using rule 9 (rule -> expression .)
    ID              reduce using rule 9 (rule -> expression .)
    APPEND          reduce using rule 9 (rule -> expression .)
    LEN             reduce using rule 9 (rule -> expression .)
    COPY            reduce using rule 9 (rule -> expression .)
    DELETE          reduce using rule 9 (rule -> expression .)
    IF              reduce using rule 9 (rule -> expression .)
    ELSE            reduce using rule 9 (rule -> expression .)
    TYPE            reduce using rule 9 (rule -> expression .)
    SWITCH          reduce using rule 9 (rule -> expression .)
    VAR             reduce using rule 9 (rule -> expression .)
    FUNC            reduce using rule 9 (rule -> expression .)
    INTEGER         reduce using rule 9 (rule -> expression .)
    FLOAT           reduce using rule 9 (rule -> expression .)
    NOT             reduce using rule 9 (rule -> expression .)
    $end            reduce using rule 9 (rule -> expression .)
    RLLAVE          reduce using rule 9 (rule -> expression .)
    INT32           reduce using rule 9 (rule -> expression .)
    INT64           reduce using rule 9 (rule -> expression .)
    FLOAT32         reduce using rule 9 (rule -> expression .)
    FLOAT64         reduce using rule 9 (rule -> expression .)
    BYTE            reduce using rule 9 (rule -> expression .)
    WINT            reduce using rule 9 (rule -> expression .)
    WFLOAT          reduce using rule 9 (rule -> expression .)
    WSTRING         reduce using rule 9 (rule -> expression .)
    BOOL            reduce using rule 9 (rule -> expression .)
    DEFAULT         reduce using rule 9 (rule -> expression .)
    CASE            reduce using rule 9 (rule -> expression .)
    RETURN          reduce using rule 9 (rule -> expression .)
    GREATER         reduce using rule 168 (value -> expression .)
    SMALLER         reduce using rule 168 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 168 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 168 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 168 (value -> expression .)
    NOT_EQUAL       reduce using rule 168 (value -> expression .)
    PLUS            reduce using rule 168 (value -> expression .)
    TIMES           reduce using rule 168 (value -> expression .)
    DIVIDE          reduce using rule 168 (value -> expression .)
    MINUS           reduce using rule 168 (value -> expression .)


state 7

    (10) rule -> cicloFor .

    PRINT           reduce using rule 10 (rule -> cicloFor .)
    SCAN            reduce using rule 10 (rule -> cicloFor .)
    FOR             reduce using rule 10 (rule -> cicloFor .)
    ID              reduce using rule 10 (rule -> cicloFor .)
    APPEND          reduce using rule 10 (rule -> cicloFor .)
    LEN             reduce using rule 10 (rule -> cicloFor .)
    COPY            reduce using rule 10 (rule -> cicloFor .)
    DELETE          reduce using rule 10 (rule -> cicloFor .)
    IF              reduce using rule 10 (rule -> cicloFor .)
    ELSE            reduce using rule 10 (rule -> cicloFor .)
    TYPE            reduce using rule 10 (rule -> cicloFor .)
    SWITCH          reduce using rule 10 (rule -> cicloFor .)
    VAR             reduce using rule 10 (rule -> cicloFor .)
    FUNC            reduce using rule 10 (rule -> cicloFor .)
    INTEGER         reduce using rule 10 (rule -> cicloFor .)
    FLOAT           reduce using rule 10 (rule -> cicloFor .)
    NOT             reduce using rule 10 (rule -> cicloFor .)
    $end            reduce using rule 10 (rule -> cicloFor .)
    RLLAVE          reduce using rule 10 (rule -> cicloFor .)
    INT32           reduce using rule 10 (rule -> cicloFor .)
    INT64           reduce using rule 10 (rule -> cicloFor .)
    FLOAT32         reduce using rule 10 (rule -> cicloFor .)
    FLOAT64         reduce using rule 10 (rule -> cicloFor .)
    BYTE            reduce using rule 10 (rule -> cicloFor .)
    WINT            reduce using rule 10 (rule -> cicloFor .)
    WFLOAT          reduce using rule 10 (rule -> cicloFor .)
    WSTRING         reduce using rule 10 (rule -> cicloFor .)
    BOOL            reduce using rule 10 (rule -> cicloFor .)
    DEFAULT         reduce using rule 10 (rule -> cicloFor .)
    CASE            reduce using rule 10 (rule -> cicloFor .)
    RETURN          reduce using rule 10 (rule -> cicloFor .)


state 8

    (11) rule -> comparison .
    (180) logic_value -> comparison .

    PRINT           reduce using rule 11 (rule -> comparison .)
    SCAN            reduce using rule 11 (rule -> comparison .)
    FOR             reduce using rule 11 (rule -> comparison .)
    ID              reduce using rule 11 (rule -> comparison .)
    APPEND          reduce using rule 11 (rule -> comparison .)
    LEN             reduce using rule 11 (rule -> comparison .)
    COPY            reduce using rule 11 (rule -> comparison .)
    DELETE          reduce using rule 11 (rule -> comparison .)
    IF              reduce using rule 11 (rule -> comparison .)
    ELSE            reduce using rule 11 (rule -> comparison .)
    TYPE            reduce using rule 11 (rule -> comparison .)
    SWITCH          reduce using rule 11 (rule -> comparison .)
    VAR             reduce using rule 11 (rule -> comparison .)
    FUNC            reduce using rule 11 (rule -> comparison .)
    INTEGER         reduce using rule 11 (rule -> comparison .)
    FLOAT           reduce using rule 11 (rule -> comparison .)
    NOT             reduce using rule 11 (rule -> comparison .)
    $end            reduce using rule 11 (rule -> comparison .)
    RLLAVE          reduce using rule 11 (rule -> comparison .)
    INT32           reduce using rule 11 (rule -> comparison .)
    INT64           reduce using rule 11 (rule -> comparison .)
    FLOAT32         reduce using rule 11 (rule -> comparison .)
    FLOAT64         reduce using rule 11 (rule -> comparison .)
    BYTE            reduce using rule 11 (rule -> comparison .)
    WINT            reduce using rule 11 (rule -> comparison .)
    WFLOAT          reduce using rule 11 (rule -> comparison .)
    WSTRING         reduce using rule 11 (rule -> comparison .)
    BOOL            reduce using rule 11 (rule -> comparison .)
    DEFAULT         reduce using rule 11 (rule -> comparison .)
    CASE            reduce using rule 11 (rule -> comparison .)
    RETURN          reduce using rule 11 (rule -> comparison .)
    AND             reduce using rule 180 (logic_value -> comparison .)
    OR              reduce using rule 180 (logic_value -> comparison .)


state 9

    (12) rule -> logic_operation .

    PRINT           reduce using rule 12 (rule -> logic_operation .)
    SCAN            reduce using rule 12 (rule -> logic_operation .)
    FOR             reduce using rule 12 (rule -> logic_operation .)
    ID              reduce using rule 12 (rule -> logic_operation .)
    APPEND          reduce using rule 12 (rule -> logic_operation .)
    LEN             reduce using rule 12 (rule -> logic_operation .)
    COPY            reduce using rule 12 (rule -> logic_operation .)
    DELETE          reduce using rule 12 (rule -> logic_operation .)
    IF              reduce using rule 12 (rule -> logic_operation .)
    ELSE            reduce using rule 12 (rule -> logic_operation .)
    TYPE            reduce using rule 12 (rule -> logic_operation .)
    SWITCH          reduce using rule 12 (rule -> logic_operation .)
    VAR             reduce using rule 12 (rule -> logic_operation .)
    FUNC            reduce using rule 12 (rule -> logic_operation .)
    INTEGER         reduce using rule 12 (rule -> logic_operation .)
    FLOAT           reduce using rule 12 (rule -> logic_operation .)
    NOT             reduce using rule 12 (rule -> logic_operation .)
    $end            reduce using rule 12 (rule -> logic_operation .)
    RLLAVE          reduce using rule 12 (rule -> logic_operation .)
    INT32           reduce using rule 12 (rule -> logic_operation .)
    INT64           reduce using rule 12 (rule -> logic_operation .)
    FLOAT32         reduce using rule 12 (rule -> logic_operation .)
    FLOAT64         reduce using rule 12 (rule -> logic_operation .)
    BYTE            reduce using rule 12 (rule -> logic_operation .)
    WINT            reduce using rule 12 (rule -> logic_operation .)
    WFLOAT          reduce using rule 12 (rule -> logic_operation .)
    WSTRING         reduce using rule 12 (rule -> logic_operation .)
    BOOL            reduce using rule 12 (rule -> logic_operation .)
    DEFAULT         reduce using rule 12 (rule -> logic_operation .)
    CASE            reduce using rule 12 (rule -> logic_operation .)
    RETURN          reduce using rule 12 (rule -> logic_operation .)


state 10

    (13) rule -> decVar . COLON
    (14) rule -> decVar .

    COLON           shift and go to state 62
    PRINT           reduce using rule 14 (rule -> decVar .)
    SCAN            reduce using rule 14 (rule -> decVar .)
    FOR             reduce using rule 14 (rule -> decVar .)
    ID              reduce using rule 14 (rule -> decVar .)
    APPEND          reduce using rule 14 (rule -> decVar .)
    LEN             reduce using rule 14 (rule -> decVar .)
    COPY            reduce using rule 14 (rule -> decVar .)
    DELETE          reduce using rule 14 (rule -> decVar .)
    IF              reduce using rule 14 (rule -> decVar .)
    ELSE            reduce using rule 14 (rule -> decVar .)
    TYPE            reduce using rule 14 (rule -> decVar .)
    SWITCH          reduce using rule 14 (rule -> decVar .)
    VAR             reduce using rule 14 (rule -> decVar .)
    FUNC            reduce using rule 14 (rule -> decVar .)
    INTEGER         reduce using rule 14 (rule -> decVar .)
    FLOAT           reduce using rule 14 (rule -> decVar .)
    NOT             reduce using rule 14 (rule -> decVar .)
    $end            reduce using rule 14 (rule -> decVar .)
    RLLAVE          reduce using rule 14 (rule -> decVar .)
    INT32           reduce using rule 14 (rule -> decVar .)
    INT64           reduce using rule 14 (rule -> decVar .)
    FLOAT32         reduce using rule 14 (rule -> decVar .)
    FLOAT64         reduce using rule 14 (rule -> decVar .)
    BYTE            reduce using rule 14 (rule -> decVar .)
    WINT            reduce using rule 14 (rule -> decVar .)
    WFLOAT          reduce using rule 14 (rule -> decVar .)
    WSTRING         reduce using rule 14 (rule -> decVar .)
    BOOL            reduce using rule 14 (rule -> decVar .)
    DEFAULT         reduce using rule 14 (rule -> decVar .)
    CASE            reduce using rule 14 (rule -> decVar .)
    RETURN          reduce using rule 14 (rule -> decVar .)


state 11

    (15) rule -> var_asignation .
    (16) rule -> var_asignation . COLON

    PRINT           reduce using rule 15 (rule -> var_asignation .)
    SCAN            reduce using rule 15 (rule -> var_asignation .)
    FOR             reduce using rule 15 (rule -> var_asignation .)
    ID              reduce using rule 15 (rule -> var_asignation .)
    APPEND          reduce using rule 15 (rule -> var_asignation .)
    LEN             reduce using rule 15 (rule -> var_asignation .)
    COPY            reduce using rule 15 (rule -> var_asignation .)
    DELETE          reduce using rule 15 (rule -> var_asignation .)
    IF              reduce using rule 15 (rule -> var_asignation .)
    ELSE            reduce using rule 15 (rule -> var_asignation .)
    TYPE            reduce using rule 15 (rule -> var_asignation .)
    SWITCH          reduce using rule 15 (rule -> var_asignation .)
    VAR             reduce using rule 15 (rule -> var_asignation .)
    FUNC            reduce using rule 15 (rule -> var_asignation .)
    INTEGER         reduce using rule 15 (rule -> var_asignation .)
    FLOAT           reduce using rule 15 (rule -> var_asignation .)
    NOT             reduce using rule 15 (rule -> var_asignation .)
    $end            reduce using rule 15 (rule -> var_asignation .)
    RLLAVE          reduce using rule 15 (rule -> var_asignation .)
    INT32           reduce using rule 15 (rule -> var_asignation .)
    INT64           reduce using rule 15 (rule -> var_asignation .)
    FLOAT32         reduce using rule 15 (rule -> var_asignation .)
    FLOAT64         reduce using rule 15 (rule -> var_asignation .)
    BYTE            reduce using rule 15 (rule -> var_asignation .)
    WINT            reduce using rule 15 (rule -> var_asignation .)
    WFLOAT          reduce using rule 15 (rule -> var_asignation .)
    WSTRING         reduce using rule 15 (rule -> var_asignation .)
    BOOL            reduce using rule 15 (rule -> var_asignation .)
    DEFAULT         reduce using rule 15 (rule -> var_asignation .)
    CASE            reduce using rule 15 (rule -> var_asignation .)
    RETURN          reduce using rule 15 (rule -> var_asignation .)
    COLON           shift and go to state 63


state 12

    (17) rule -> funciones .
    (18) rule -> funciones . COLON
    (232) something_ex -> funciones .

  ! shift/reduce conflict for COLON resolved as shift
  ! reduce/reduce conflict for PRINT resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for SCAN resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for FOR resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for ID resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for APPEND resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for LEN resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for COPY resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for DELETE resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for IF resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for ELSE resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for TYPE resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for SWITCH resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for VAR resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for FUNC resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for INTEGER resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for FLOAT resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for NOT resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for $end resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for INT32 resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for INT64 resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for BYTE resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for WINT resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for WSTRING resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for BOOL resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for CASE resolved using rule 17 (rule -> funciones .)
  ! reduce/reduce conflict for RETURN resolved using rule 17 (rule -> funciones .)
    PRINT           reduce using rule 17 (rule -> funciones .)
    SCAN            reduce using rule 17 (rule -> funciones .)
    FOR             reduce using rule 17 (rule -> funciones .)
    ID              reduce using rule 17 (rule -> funciones .)
    APPEND          reduce using rule 17 (rule -> funciones .)
    LEN             reduce using rule 17 (rule -> funciones .)
    COPY            reduce using rule 17 (rule -> funciones .)
    DELETE          reduce using rule 17 (rule -> funciones .)
    IF              reduce using rule 17 (rule -> funciones .)
    ELSE            reduce using rule 17 (rule -> funciones .)
    TYPE            reduce using rule 17 (rule -> funciones .)
    SWITCH          reduce using rule 17 (rule -> funciones .)
    VAR             reduce using rule 17 (rule -> funciones .)
    FUNC            reduce using rule 17 (rule -> funciones .)
    INTEGER         reduce using rule 17 (rule -> funciones .)
    FLOAT           reduce using rule 17 (rule -> funciones .)
    NOT             reduce using rule 17 (rule -> funciones .)
    $end            reduce using rule 17 (rule -> funciones .)
    RLLAVE          reduce using rule 17 (rule -> funciones .)
    INT32           reduce using rule 17 (rule -> funciones .)
    INT64           reduce using rule 17 (rule -> funciones .)
    FLOAT32         reduce using rule 17 (rule -> funciones .)
    FLOAT64         reduce using rule 17 (rule -> funciones .)
    BYTE            reduce using rule 17 (rule -> funciones .)
    WINT            reduce using rule 17 (rule -> funciones .)
    WFLOAT          reduce using rule 17 (rule -> funciones .)
    WSTRING         reduce using rule 17 (rule -> funciones .)
    BOOL            reduce using rule 17 (rule -> funciones .)
    DEFAULT         reduce using rule 17 (rule -> funciones .)
    CASE            reduce using rule 17 (rule -> funciones .)
    RETURN          reduce using rule 17 (rule -> funciones .)
    COLON           shift and go to state 64
    GREATER         reduce using rule 232 (something_ex -> funciones .)
    SMALLER         reduce using rule 232 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 232 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 232 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 232 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 232 (something_ex -> funciones .)
    PLUS            reduce using rule 232 (something_ex -> funciones .)
    TIMES           reduce using rule 232 (something_ex -> funciones .)
    DIVIDE          reduce using rule 232 (something_ex -> funciones .)
    MINUS           reduce using rule 232 (something_ex -> funciones .)

  ! COLON           [ reduce using rule 232 (something_ex -> funciones .) ]
  ! PRINT           [ reduce using rule 232 (something_ex -> funciones .) ]
  ! SCAN            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! FOR             [ reduce using rule 232 (something_ex -> funciones .) ]
  ! ID              [ reduce using rule 232 (something_ex -> funciones .) ]
  ! APPEND          [ reduce using rule 232 (something_ex -> funciones .) ]
  ! LEN             [ reduce using rule 232 (something_ex -> funciones .) ]
  ! COPY            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! DELETE          [ reduce using rule 232 (something_ex -> funciones .) ]
  ! IF              [ reduce using rule 232 (something_ex -> funciones .) ]
  ! ELSE            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! TYPE            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! SWITCH          [ reduce using rule 232 (something_ex -> funciones .) ]
  ! VAR             [ reduce using rule 232 (something_ex -> funciones .) ]
  ! FUNC            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! INTEGER         [ reduce using rule 232 (something_ex -> funciones .) ]
  ! FLOAT           [ reduce using rule 232 (something_ex -> funciones .) ]
  ! NOT             [ reduce using rule 232 (something_ex -> funciones .) ]
  ! $end            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! RLLAVE          [ reduce using rule 232 (something_ex -> funciones .) ]
  ! INT32           [ reduce using rule 232 (something_ex -> funciones .) ]
  ! INT64           [ reduce using rule 232 (something_ex -> funciones .) ]
  ! FLOAT32         [ reduce using rule 232 (something_ex -> funciones .) ]
  ! FLOAT64         [ reduce using rule 232 (something_ex -> funciones .) ]
  ! BYTE            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! WINT            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! WFLOAT          [ reduce using rule 232 (something_ex -> funciones .) ]
  ! WSTRING         [ reduce using rule 232 (something_ex -> funciones .) ]
  ! BOOL            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! DEFAULT         [ reduce using rule 232 (something_ex -> funciones .) ]
  ! CASE            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! RETURN          [ reduce using rule 232 (something_ex -> funciones .) ]


state 13

    (19) rule -> SenIF .

    PRINT           reduce using rule 19 (rule -> SenIF .)
    SCAN            reduce using rule 19 (rule -> SenIF .)
    FOR             reduce using rule 19 (rule -> SenIF .)
    ID              reduce using rule 19 (rule -> SenIF .)
    APPEND          reduce using rule 19 (rule -> SenIF .)
    LEN             reduce using rule 19 (rule -> SenIF .)
    COPY            reduce using rule 19 (rule -> SenIF .)
    DELETE          reduce using rule 19 (rule -> SenIF .)
    IF              reduce using rule 19 (rule -> SenIF .)
    ELSE            reduce using rule 19 (rule -> SenIF .)
    TYPE            reduce using rule 19 (rule -> SenIF .)
    SWITCH          reduce using rule 19 (rule -> SenIF .)
    VAR             reduce using rule 19 (rule -> SenIF .)
    FUNC            reduce using rule 19 (rule -> SenIF .)
    INTEGER         reduce using rule 19 (rule -> SenIF .)
    FLOAT           reduce using rule 19 (rule -> SenIF .)
    NOT             reduce using rule 19 (rule -> SenIF .)
    $end            reduce using rule 19 (rule -> SenIF .)
    RLLAVE          reduce using rule 19 (rule -> SenIF .)
    INT32           reduce using rule 19 (rule -> SenIF .)
    INT64           reduce using rule 19 (rule -> SenIF .)
    FLOAT32         reduce using rule 19 (rule -> SenIF .)
    FLOAT64         reduce using rule 19 (rule -> SenIF .)
    BYTE            reduce using rule 19 (rule -> SenIF .)
    WINT            reduce using rule 19 (rule -> SenIF .)
    WFLOAT          reduce using rule 19 (rule -> SenIF .)
    WSTRING         reduce using rule 19 (rule -> SenIF .)
    BOOL            reduce using rule 19 (rule -> SenIF .)
    DEFAULT         reduce using rule 19 (rule -> SenIF .)
    CASE            reduce using rule 19 (rule -> SenIF .)
    RETURN          reduce using rule 19 (rule -> SenIF .)


state 14

    (20) rule -> SenElseIF .

    PRINT           reduce using rule 20 (rule -> SenElseIF .)
    SCAN            reduce using rule 20 (rule -> SenElseIF .)
    FOR             reduce using rule 20 (rule -> SenElseIF .)
    ID              reduce using rule 20 (rule -> SenElseIF .)
    APPEND          reduce using rule 20 (rule -> SenElseIF .)
    LEN             reduce using rule 20 (rule -> SenElseIF .)
    COPY            reduce using rule 20 (rule -> SenElseIF .)
    DELETE          reduce using rule 20 (rule -> SenElseIF .)
    IF              reduce using rule 20 (rule -> SenElseIF .)
    ELSE            reduce using rule 20 (rule -> SenElseIF .)
    TYPE            reduce using rule 20 (rule -> SenElseIF .)
    SWITCH          reduce using rule 20 (rule -> SenElseIF .)
    VAR             reduce using rule 20 (rule -> SenElseIF .)
    FUNC            reduce using rule 20 (rule -> SenElseIF .)
    INTEGER         reduce using rule 20 (rule -> SenElseIF .)
    FLOAT           reduce using rule 20 (rule -> SenElseIF .)
    NOT             reduce using rule 20 (rule -> SenElseIF .)
    $end            reduce using rule 20 (rule -> SenElseIF .)
    RLLAVE          reduce using rule 20 (rule -> SenElseIF .)
    INT32           reduce using rule 20 (rule -> SenElseIF .)
    INT64           reduce using rule 20 (rule -> SenElseIF .)
    FLOAT32         reduce using rule 20 (rule -> SenElseIF .)
    FLOAT64         reduce using rule 20 (rule -> SenElseIF .)
    BYTE            reduce using rule 20 (rule -> SenElseIF .)
    WINT            reduce using rule 20 (rule -> SenElseIF .)
    WFLOAT          reduce using rule 20 (rule -> SenElseIF .)
    WSTRING         reduce using rule 20 (rule -> SenElseIF .)
    BOOL            reduce using rule 20 (rule -> SenElseIF .)
    DEFAULT         reduce using rule 20 (rule -> SenElseIF .)
    CASE            reduce using rule 20 (rule -> SenElseIF .)
    RETURN          reduce using rule 20 (rule -> SenElseIF .)


state 15

    (21) rule -> SenElse .

    PRINT           reduce using rule 21 (rule -> SenElse .)
    SCAN            reduce using rule 21 (rule -> SenElse .)
    FOR             reduce using rule 21 (rule -> SenElse .)
    ID              reduce using rule 21 (rule -> SenElse .)
    APPEND          reduce using rule 21 (rule -> SenElse .)
    LEN             reduce using rule 21 (rule -> SenElse .)
    COPY            reduce using rule 21 (rule -> SenElse .)
    DELETE          reduce using rule 21 (rule -> SenElse .)
    IF              reduce using rule 21 (rule -> SenElse .)
    ELSE            reduce using rule 21 (rule -> SenElse .)
    TYPE            reduce using rule 21 (rule -> SenElse .)
    SWITCH          reduce using rule 21 (rule -> SenElse .)
    VAR             reduce using rule 21 (rule -> SenElse .)
    FUNC            reduce using rule 21 (rule -> SenElse .)
    INTEGER         reduce using rule 21 (rule -> SenElse .)
    FLOAT           reduce using rule 21 (rule -> SenElse .)
    NOT             reduce using rule 21 (rule -> SenElse .)
    $end            reduce using rule 21 (rule -> SenElse .)
    RLLAVE          reduce using rule 21 (rule -> SenElse .)
    INT32           reduce using rule 21 (rule -> SenElse .)
    INT64           reduce using rule 21 (rule -> SenElse .)
    FLOAT32         reduce using rule 21 (rule -> SenElse .)
    FLOAT64         reduce using rule 21 (rule -> SenElse .)
    BYTE            reduce using rule 21 (rule -> SenElse .)
    WINT            reduce using rule 21 (rule -> SenElse .)
    WFLOAT          reduce using rule 21 (rule -> SenElse .)
    WSTRING         reduce using rule 21 (rule -> SenElse .)
    BOOL            reduce using rule 21 (rule -> SenElse .)
    DEFAULT         reduce using rule 21 (rule -> SenElse .)
    CASE            reduce using rule 21 (rule -> SenElse .)
    RETURN          reduce using rule 21 (rule -> SenElse .)


state 16

    (22) rule -> SenStruct .

    PRINT           reduce using rule 22 (rule -> SenStruct .)
    SCAN            reduce using rule 22 (rule -> SenStruct .)
    FOR             reduce using rule 22 (rule -> SenStruct .)
    ID              reduce using rule 22 (rule -> SenStruct .)
    APPEND          reduce using rule 22 (rule -> SenStruct .)
    LEN             reduce using rule 22 (rule -> SenStruct .)
    COPY            reduce using rule 22 (rule -> SenStruct .)
    DELETE          reduce using rule 22 (rule -> SenStruct .)
    IF              reduce using rule 22 (rule -> SenStruct .)
    ELSE            reduce using rule 22 (rule -> SenStruct .)
    TYPE            reduce using rule 22 (rule -> SenStruct .)
    SWITCH          reduce using rule 22 (rule -> SenStruct .)
    VAR             reduce using rule 22 (rule -> SenStruct .)
    FUNC            reduce using rule 22 (rule -> SenStruct .)
    INTEGER         reduce using rule 22 (rule -> SenStruct .)
    FLOAT           reduce using rule 22 (rule -> SenStruct .)
    NOT             reduce using rule 22 (rule -> SenStruct .)
    $end            reduce using rule 22 (rule -> SenStruct .)
    RLLAVE          reduce using rule 22 (rule -> SenStruct .)
    INT32           reduce using rule 22 (rule -> SenStruct .)
    INT64           reduce using rule 22 (rule -> SenStruct .)
    FLOAT32         reduce using rule 22 (rule -> SenStruct .)
    FLOAT64         reduce using rule 22 (rule -> SenStruct .)
    BYTE            reduce using rule 22 (rule -> SenStruct .)
    WINT            reduce using rule 22 (rule -> SenStruct .)
    WFLOAT          reduce using rule 22 (rule -> SenStruct .)
    WSTRING         reduce using rule 22 (rule -> SenStruct .)
    BOOL            reduce using rule 22 (rule -> SenStruct .)
    DEFAULT         reduce using rule 22 (rule -> SenStruct .)
    CASE            reduce using rule 22 (rule -> SenStruct .)
    RETURN          reduce using rule 22 (rule -> SenStruct .)


state 17

    (23) rule -> cStruct .

    PRINT           reduce using rule 23 (rule -> cStruct .)
    SCAN            reduce using rule 23 (rule -> cStruct .)
    FOR             reduce using rule 23 (rule -> cStruct .)
    ID              reduce using rule 23 (rule -> cStruct .)
    APPEND          reduce using rule 23 (rule -> cStruct .)
    LEN             reduce using rule 23 (rule -> cStruct .)
    COPY            reduce using rule 23 (rule -> cStruct .)
    DELETE          reduce using rule 23 (rule -> cStruct .)
    IF              reduce using rule 23 (rule -> cStruct .)
    ELSE            reduce using rule 23 (rule -> cStruct .)
    TYPE            reduce using rule 23 (rule -> cStruct .)
    SWITCH          reduce using rule 23 (rule -> cStruct .)
    VAR             reduce using rule 23 (rule -> cStruct .)
    FUNC            reduce using rule 23 (rule -> cStruct .)
    INTEGER         reduce using rule 23 (rule -> cStruct .)
    FLOAT           reduce using rule 23 (rule -> cStruct .)
    NOT             reduce using rule 23 (rule -> cStruct .)
    $end            reduce using rule 23 (rule -> cStruct .)
    RLLAVE          reduce using rule 23 (rule -> cStruct .)
    INT32           reduce using rule 23 (rule -> cStruct .)
    INT64           reduce using rule 23 (rule -> cStruct .)
    FLOAT32         reduce using rule 23 (rule -> cStruct .)
    FLOAT64         reduce using rule 23 (rule -> cStruct .)
    BYTE            reduce using rule 23 (rule -> cStruct .)
    WINT            reduce using rule 23 (rule -> cStruct .)
    WFLOAT          reduce using rule 23 (rule -> cStruct .)
    WSTRING         reduce using rule 23 (rule -> cStruct .)
    BOOL            reduce using rule 23 (rule -> cStruct .)
    DEFAULT         reduce using rule 23 (rule -> cStruct .)
    CASE            reduce using rule 23 (rule -> cStruct .)
    RETURN          reduce using rule 23 (rule -> cStruct .)


state 18

    (24) rule -> switch_statement .

    PRINT           reduce using rule 24 (rule -> switch_statement .)
    SCAN            reduce using rule 24 (rule -> switch_statement .)
    FOR             reduce using rule 24 (rule -> switch_statement .)
    ID              reduce using rule 24 (rule -> switch_statement .)
    APPEND          reduce using rule 24 (rule -> switch_statement .)
    LEN             reduce using rule 24 (rule -> switch_statement .)
    COPY            reduce using rule 24 (rule -> switch_statement .)
    DELETE          reduce using rule 24 (rule -> switch_statement .)
    IF              reduce using rule 24 (rule -> switch_statement .)
    ELSE            reduce using rule 24 (rule -> switch_statement .)
    TYPE            reduce using rule 24 (rule -> switch_statement .)
    SWITCH          reduce using rule 24 (rule -> switch_statement .)
    VAR             reduce using rule 24 (rule -> switch_statement .)
    FUNC            reduce using rule 24 (rule -> switch_statement .)
    INTEGER         reduce using rule 24 (rule -> switch_statement .)
    FLOAT           reduce using rule 24 (rule -> switch_statement .)
    NOT             reduce using rule 24 (rule -> switch_statement .)
    $end            reduce using rule 24 (rule -> switch_statement .)
    RLLAVE          reduce using rule 24 (rule -> switch_statement .)
    INT32           reduce using rule 24 (rule -> switch_statement .)
    INT64           reduce using rule 24 (rule -> switch_statement .)
    FLOAT32         reduce using rule 24 (rule -> switch_statement .)
    FLOAT64         reduce using rule 24 (rule -> switch_statement .)
    BYTE            reduce using rule 24 (rule -> switch_statement .)
    WINT            reduce using rule 24 (rule -> switch_statement .)
    WFLOAT          reduce using rule 24 (rule -> switch_statement .)
    WSTRING         reduce using rule 24 (rule -> switch_statement .)
    BOOL            reduce using rule 24 (rule -> switch_statement .)
    DEFAULT         reduce using rule 24 (rule -> switch_statement .)
    CASE            reduce using rule 24 (rule -> switch_statement .)
    RETURN          reduce using rule 24 (rule -> switch_statement .)


state 19

    (25) rule -> array_declaration . COLON
    (26) rule -> array_declaration .

    COLON           shift and go to state 65
    PRINT           reduce using rule 26 (rule -> array_declaration .)
    SCAN            reduce using rule 26 (rule -> array_declaration .)
    FOR             reduce using rule 26 (rule -> array_declaration .)
    ID              reduce using rule 26 (rule -> array_declaration .)
    APPEND          reduce using rule 26 (rule -> array_declaration .)
    LEN             reduce using rule 26 (rule -> array_declaration .)
    COPY            reduce using rule 26 (rule -> array_declaration .)
    DELETE          reduce using rule 26 (rule -> array_declaration .)
    IF              reduce using rule 26 (rule -> array_declaration .)
    ELSE            reduce using rule 26 (rule -> array_declaration .)
    TYPE            reduce using rule 26 (rule -> array_declaration .)
    SWITCH          reduce using rule 26 (rule -> array_declaration .)
    VAR             reduce using rule 26 (rule -> array_declaration .)
    FUNC            reduce using rule 26 (rule -> array_declaration .)
    INTEGER         reduce using rule 26 (rule -> array_declaration .)
    FLOAT           reduce using rule 26 (rule -> array_declaration .)
    NOT             reduce using rule 26 (rule -> array_declaration .)
    $end            reduce using rule 26 (rule -> array_declaration .)
    RLLAVE          reduce using rule 26 (rule -> array_declaration .)
    INT32           reduce using rule 26 (rule -> array_declaration .)
    INT64           reduce using rule 26 (rule -> array_declaration .)
    FLOAT32         reduce using rule 26 (rule -> array_declaration .)
    FLOAT64         reduce using rule 26 (rule -> array_declaration .)
    BYTE            reduce using rule 26 (rule -> array_declaration .)
    WINT            reduce using rule 26 (rule -> array_declaration .)
    WFLOAT          reduce using rule 26 (rule -> array_declaration .)
    WSTRING         reduce using rule 26 (rule -> array_declaration .)
    BOOL            reduce using rule 26 (rule -> array_declaration .)
    DEFAULT         reduce using rule 26 (rule -> array_declaration .)
    CASE            reduce using rule 26 (rule -> array_declaration .)
    RETURN          reduce using rule 26 (rule -> array_declaration .)


state 20

    (27) rule -> array_var . COLON
    (28) rule -> array_var .
    (200) array_assignment -> array_var . EQUAL something
    (60) data_structure -> array_var .

  ! shift/reduce conflict for COLON resolved as shift
  ! reduce/reduce conflict for PRINT resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for SCAN resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for FOR resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for ID resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for APPEND resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for LEN resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for COPY resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for DELETE resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for IF resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for ELSE resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for TYPE resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for SWITCH resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for VAR resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for FUNC resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for INTEGER resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for FLOAT resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for NOT resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for $end resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for INT32 resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for INT64 resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for BYTE resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for WINT resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for WSTRING resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for BOOL resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for CASE resolved using rule 28 (rule -> array_var .)
  ! reduce/reduce conflict for RETURN resolved using rule 28 (rule -> array_var .)
    COLON           shift and go to state 66
    PRINT           reduce using rule 28 (rule -> array_var .)
    SCAN            reduce using rule 28 (rule -> array_var .)
    FOR             reduce using rule 28 (rule -> array_var .)
    ID              reduce using rule 28 (rule -> array_var .)
    APPEND          reduce using rule 28 (rule -> array_var .)
    LEN             reduce using rule 28 (rule -> array_var .)
    COPY            reduce using rule 28 (rule -> array_var .)
    DELETE          reduce using rule 28 (rule -> array_var .)
    IF              reduce using rule 28 (rule -> array_var .)
    ELSE            reduce using rule 28 (rule -> array_var .)
    TYPE            reduce using rule 28 (rule -> array_var .)
    SWITCH          reduce using rule 28 (rule -> array_var .)
    VAR             reduce using rule 28 (rule -> array_var .)
    FUNC            reduce using rule 28 (rule -> array_var .)
    INTEGER         reduce using rule 28 (rule -> array_var .)
    FLOAT           reduce using rule 28 (rule -> array_var .)
    NOT             reduce using rule 28 (rule -> array_var .)
    $end            reduce using rule 28 (rule -> array_var .)
    RLLAVE          reduce using rule 28 (rule -> array_var .)
    INT32           reduce using rule 28 (rule -> array_var .)
    INT64           reduce using rule 28 (rule -> array_var .)
    FLOAT32         reduce using rule 28 (rule -> array_var .)
    FLOAT64         reduce using rule 28 (rule -> array_var .)
    BYTE            reduce using rule 28 (rule -> array_var .)
    WINT            reduce using rule 28 (rule -> array_var .)
    WFLOAT          reduce using rule 28 (rule -> array_var .)
    WSTRING         reduce using rule 28 (rule -> array_var .)
    BOOL            reduce using rule 28 (rule -> array_var .)
    DEFAULT         reduce using rule 28 (rule -> array_var .)
    CASE            reduce using rule 28 (rule -> array_var .)
    RETURN          reduce using rule 28 (rule -> array_var .)
    EQUAL           shift and go to state 67
    GREATER         reduce using rule 60 (data_structure -> array_var .)
    SMALLER         reduce using rule 60 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 60 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 60 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 60 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 60 (data_structure -> array_var .)
    PLUS            reduce using rule 60 (data_structure -> array_var .)
    TIMES           reduce using rule 60 (data_structure -> array_var .)
    DIVIDE          reduce using rule 60 (data_structure -> array_var .)
    MINUS           reduce using rule 60 (data_structure -> array_var .)

  ! COLON           [ reduce using rule 60 (data_structure -> array_var .) ]
  ! PRINT           [ reduce using rule 60 (data_structure -> array_var .) ]
  ! SCAN            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! FOR             [ reduce using rule 60 (data_structure -> array_var .) ]
  ! ID              [ reduce using rule 60 (data_structure -> array_var .) ]
  ! APPEND          [ reduce using rule 60 (data_structure -> array_var .) ]
  ! LEN             [ reduce using rule 60 (data_structure -> array_var .) ]
  ! COPY            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! DELETE          [ reduce using rule 60 (data_structure -> array_var .) ]
  ! IF              [ reduce using rule 60 (data_structure -> array_var .) ]
  ! ELSE            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! TYPE            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! SWITCH          [ reduce using rule 60 (data_structure -> array_var .) ]
  ! VAR             [ reduce using rule 60 (data_structure -> array_var .) ]
  ! FUNC            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! INTEGER         [ reduce using rule 60 (data_structure -> array_var .) ]
  ! FLOAT           [ reduce using rule 60 (data_structure -> array_var .) ]
  ! NOT             [ reduce using rule 60 (data_structure -> array_var .) ]
  ! $end            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! RLLAVE          [ reduce using rule 60 (data_structure -> array_var .) ]
  ! INT32           [ reduce using rule 60 (data_structure -> array_var .) ]
  ! INT64           [ reduce using rule 60 (data_structure -> array_var .) ]
  ! FLOAT32         [ reduce using rule 60 (data_structure -> array_var .) ]
  ! FLOAT64         [ reduce using rule 60 (data_structure -> array_var .) ]
  ! BYTE            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! WINT            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! WFLOAT          [ reduce using rule 60 (data_structure -> array_var .) ]
  ! WSTRING         [ reduce using rule 60 (data_structure -> array_var .) ]
  ! BOOL            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! DEFAULT         [ reduce using rule 60 (data_structure -> array_var .) ]
  ! CASE            [ reduce using rule 60 (data_structure -> array_var .) ]
  ! RETURN          [ reduce using rule 60 (data_structure -> array_var .) ]


state 21

    (29) rule -> array_assignment . COLON
    (30) rule -> array_assignment .

    COLON           shift and go to state 68
    PRINT           reduce using rule 30 (rule -> array_assignment .)
    SCAN            reduce using rule 30 (rule -> array_assignment .)
    FOR             reduce using rule 30 (rule -> array_assignment .)
    ID              reduce using rule 30 (rule -> array_assignment .)
    APPEND          reduce using rule 30 (rule -> array_assignment .)
    LEN             reduce using rule 30 (rule -> array_assignment .)
    COPY            reduce using rule 30 (rule -> array_assignment .)
    DELETE          reduce using rule 30 (rule -> array_assignment .)
    IF              reduce using rule 30 (rule -> array_assignment .)
    ELSE            reduce using rule 30 (rule -> array_assignment .)
    TYPE            reduce using rule 30 (rule -> array_assignment .)
    SWITCH          reduce using rule 30 (rule -> array_assignment .)
    VAR             reduce using rule 30 (rule -> array_assignment .)
    FUNC            reduce using rule 30 (rule -> array_assignment .)
    INTEGER         reduce using rule 30 (rule -> array_assignment .)
    FLOAT           reduce using rule 30 (rule -> array_assignment .)
    NOT             reduce using rule 30 (rule -> array_assignment .)
    $end            reduce using rule 30 (rule -> array_assignment .)
    RLLAVE          reduce using rule 30 (rule -> array_assignment .)
    INT32           reduce using rule 30 (rule -> array_assignment .)
    INT64           reduce using rule 30 (rule -> array_assignment .)
    FLOAT32         reduce using rule 30 (rule -> array_assignment .)
    FLOAT64         reduce using rule 30 (rule -> array_assignment .)
    BYTE            reduce using rule 30 (rule -> array_assignment .)
    WINT            reduce using rule 30 (rule -> array_assignment .)
    WFLOAT          reduce using rule 30 (rule -> array_assignment .)
    WSTRING         reduce using rule 30 (rule -> array_assignment .)
    BOOL            reduce using rule 30 (rule -> array_assignment .)
    DEFAULT         reduce using rule 30 (rule -> array_assignment .)
    CASE            reduce using rule 30 (rule -> array_assignment .)
    RETURN          reduce using rule 30 (rule -> array_assignment .)


state 22

    (31) rule -> slice_declaration . COLON
    (32) rule -> slice_declaration .

    COLON           shift and go to state 69
    PRINT           reduce using rule 32 (rule -> slice_declaration .)
    SCAN            reduce using rule 32 (rule -> slice_declaration .)
    FOR             reduce using rule 32 (rule -> slice_declaration .)
    ID              reduce using rule 32 (rule -> slice_declaration .)
    APPEND          reduce using rule 32 (rule -> slice_declaration .)
    LEN             reduce using rule 32 (rule -> slice_declaration .)
    COPY            reduce using rule 32 (rule -> slice_declaration .)
    DELETE          reduce using rule 32 (rule -> slice_declaration .)
    IF              reduce using rule 32 (rule -> slice_declaration .)
    ELSE            reduce using rule 32 (rule -> slice_declaration .)
    TYPE            reduce using rule 32 (rule -> slice_declaration .)
    SWITCH          reduce using rule 32 (rule -> slice_declaration .)
    VAR             reduce using rule 32 (rule -> slice_declaration .)
    FUNC            reduce using rule 32 (rule -> slice_declaration .)
    INTEGER         reduce using rule 32 (rule -> slice_declaration .)
    FLOAT           reduce using rule 32 (rule -> slice_declaration .)
    NOT             reduce using rule 32 (rule -> slice_declaration .)
    $end            reduce using rule 32 (rule -> slice_declaration .)
    RLLAVE          reduce using rule 32 (rule -> slice_declaration .)
    INT32           reduce using rule 32 (rule -> slice_declaration .)
    INT64           reduce using rule 32 (rule -> slice_declaration .)
    FLOAT32         reduce using rule 32 (rule -> slice_declaration .)
    FLOAT64         reduce using rule 32 (rule -> slice_declaration .)
    BYTE            reduce using rule 32 (rule -> slice_declaration .)
    WINT            reduce using rule 32 (rule -> slice_declaration .)
    WFLOAT          reduce using rule 32 (rule -> slice_declaration .)
    WSTRING         reduce using rule 32 (rule -> slice_declaration .)
    BOOL            reduce using rule 32 (rule -> slice_declaration .)
    DEFAULT         reduce using rule 32 (rule -> slice_declaration .)
    CASE            reduce using rule 32 (rule -> slice_declaration .)
    RETURN          reduce using rule 32 (rule -> slice_declaration .)


state 23

    (33) rule -> slice_var . COLON
    (34) rule -> slice_var .
    (135) slice_assignment -> slice_var . EQUAL something_s

    COLON           shift and go to state 70
    PRINT           reduce using rule 34 (rule -> slice_var .)
    SCAN            reduce using rule 34 (rule -> slice_var .)
    FOR             reduce using rule 34 (rule -> slice_var .)
    ID              reduce using rule 34 (rule -> slice_var .)
    APPEND          reduce using rule 34 (rule -> slice_var .)
    LEN             reduce using rule 34 (rule -> slice_var .)
    COPY            reduce using rule 34 (rule -> slice_var .)
    DELETE          reduce using rule 34 (rule -> slice_var .)
    IF              reduce using rule 34 (rule -> slice_var .)
    ELSE            reduce using rule 34 (rule -> slice_var .)
    TYPE            reduce using rule 34 (rule -> slice_var .)
    SWITCH          reduce using rule 34 (rule -> slice_var .)
    VAR             reduce using rule 34 (rule -> slice_var .)
    FUNC            reduce using rule 34 (rule -> slice_var .)
    INTEGER         reduce using rule 34 (rule -> slice_var .)
    FLOAT           reduce using rule 34 (rule -> slice_var .)
    NOT             reduce using rule 34 (rule -> slice_var .)
    $end            reduce using rule 34 (rule -> slice_var .)
    RLLAVE          reduce using rule 34 (rule -> slice_var .)
    INT32           reduce using rule 34 (rule -> slice_var .)
    INT64           reduce using rule 34 (rule -> slice_var .)
    FLOAT32         reduce using rule 34 (rule -> slice_var .)
    FLOAT64         reduce using rule 34 (rule -> slice_var .)
    BYTE            reduce using rule 34 (rule -> slice_var .)
    WINT            reduce using rule 34 (rule -> slice_var .)
    WFLOAT          reduce using rule 34 (rule -> slice_var .)
    WSTRING         reduce using rule 34 (rule -> slice_var .)
    BOOL            reduce using rule 34 (rule -> slice_var .)
    DEFAULT         reduce using rule 34 (rule -> slice_var .)
    CASE            reduce using rule 34 (rule -> slice_var .)
    RETURN          reduce using rule 34 (rule -> slice_var .)
    EQUAL           shift and go to state 71


state 24

    (35) rule -> slice_assignment . COLON
    (36) rule -> slice_assignment .

    COLON           shift and go to state 72
    PRINT           reduce using rule 36 (rule -> slice_assignment .)
    SCAN            reduce using rule 36 (rule -> slice_assignment .)
    FOR             reduce using rule 36 (rule -> slice_assignment .)
    ID              reduce using rule 36 (rule -> slice_assignment .)
    APPEND          reduce using rule 36 (rule -> slice_assignment .)
    LEN             reduce using rule 36 (rule -> slice_assignment .)
    COPY            reduce using rule 36 (rule -> slice_assignment .)
    DELETE          reduce using rule 36 (rule -> slice_assignment .)
    IF              reduce using rule 36 (rule -> slice_assignment .)
    ELSE            reduce using rule 36 (rule -> slice_assignment .)
    TYPE            reduce using rule 36 (rule -> slice_assignment .)
    SWITCH          reduce using rule 36 (rule -> slice_assignment .)
    VAR             reduce using rule 36 (rule -> slice_assignment .)
    FUNC            reduce using rule 36 (rule -> slice_assignment .)
    INTEGER         reduce using rule 36 (rule -> slice_assignment .)
    FLOAT           reduce using rule 36 (rule -> slice_assignment .)
    NOT             reduce using rule 36 (rule -> slice_assignment .)
    $end            reduce using rule 36 (rule -> slice_assignment .)
    RLLAVE          reduce using rule 36 (rule -> slice_assignment .)
    INT32           reduce using rule 36 (rule -> slice_assignment .)
    INT64           reduce using rule 36 (rule -> slice_assignment .)
    FLOAT32         reduce using rule 36 (rule -> slice_assignment .)
    FLOAT64         reduce using rule 36 (rule -> slice_assignment .)
    BYTE            reduce using rule 36 (rule -> slice_assignment .)
    WINT            reduce using rule 36 (rule -> slice_assignment .)
    WFLOAT          reduce using rule 36 (rule -> slice_assignment .)
    WSTRING         reduce using rule 36 (rule -> slice_assignment .)
    BOOL            reduce using rule 36 (rule -> slice_assignment .)
    DEFAULT         reduce using rule 36 (rule -> slice_assignment .)
    CASE            reduce using rule 36 (rule -> slice_assignment .)
    RETURN          reduce using rule 36 (rule -> slice_assignment .)


state 25

    (37) rule -> map_declaration . COLON
    (38) rule -> map_declaration .

    COLON           shift and go to state 73
    PRINT           reduce using rule 38 (rule -> map_declaration .)
    SCAN            reduce using rule 38 (rule -> map_declaration .)
    FOR             reduce using rule 38 (rule -> map_declaration .)
    ID              reduce using rule 38 (rule -> map_declaration .)
    APPEND          reduce using rule 38 (rule -> map_declaration .)
    LEN             reduce using rule 38 (rule -> map_declaration .)
    COPY            reduce using rule 38 (rule -> map_declaration .)
    DELETE          reduce using rule 38 (rule -> map_declaration .)
    IF              reduce using rule 38 (rule -> map_declaration .)
    ELSE            reduce using rule 38 (rule -> map_declaration .)
    TYPE            reduce using rule 38 (rule -> map_declaration .)
    SWITCH          reduce using rule 38 (rule -> map_declaration .)
    VAR             reduce using rule 38 (rule -> map_declaration .)
    FUNC            reduce using rule 38 (rule -> map_declaration .)
    INTEGER         reduce using rule 38 (rule -> map_declaration .)
    FLOAT           reduce using rule 38 (rule -> map_declaration .)
    NOT             reduce using rule 38 (rule -> map_declaration .)
    $end            reduce using rule 38 (rule -> map_declaration .)
    RLLAVE          reduce using rule 38 (rule -> map_declaration .)
    INT32           reduce using rule 38 (rule -> map_declaration .)
    INT64           reduce using rule 38 (rule -> map_declaration .)
    FLOAT32         reduce using rule 38 (rule -> map_declaration .)
    FLOAT64         reduce using rule 38 (rule -> map_declaration .)
    BYTE            reduce using rule 38 (rule -> map_declaration .)
    WINT            reduce using rule 38 (rule -> map_declaration .)
    WFLOAT          reduce using rule 38 (rule -> map_declaration .)
    WSTRING         reduce using rule 38 (rule -> map_declaration .)
    BOOL            reduce using rule 38 (rule -> map_declaration .)
    DEFAULT         reduce using rule 38 (rule -> map_declaration .)
    CASE            reduce using rule 38 (rule -> map_declaration .)
    RETURN          reduce using rule 38 (rule -> map_declaration .)


state 26

    (39) rule -> map_assignment . COLON
    (40) rule -> map_assignment .

    COLON           shift and go to state 74
    PRINT           reduce using rule 40 (rule -> map_assignment .)
    SCAN            reduce using rule 40 (rule -> map_assignment .)
    FOR             reduce using rule 40 (rule -> map_assignment .)
    ID              reduce using rule 40 (rule -> map_assignment .)
    APPEND          reduce using rule 40 (rule -> map_assignment .)
    LEN             reduce using rule 40 (rule -> map_assignment .)
    COPY            reduce using rule 40 (rule -> map_assignment .)
    DELETE          reduce using rule 40 (rule -> map_assignment .)
    IF              reduce using rule 40 (rule -> map_assignment .)
    ELSE            reduce using rule 40 (rule -> map_assignment .)
    TYPE            reduce using rule 40 (rule -> map_assignment .)
    SWITCH          reduce using rule 40 (rule -> map_assignment .)
    VAR             reduce using rule 40 (rule -> map_assignment .)
    FUNC            reduce using rule 40 (rule -> map_assignment .)
    INTEGER         reduce using rule 40 (rule -> map_assignment .)
    FLOAT           reduce using rule 40 (rule -> map_assignment .)
    NOT             reduce using rule 40 (rule -> map_assignment .)
    $end            reduce using rule 40 (rule -> map_assignment .)
    RLLAVE          reduce using rule 40 (rule -> map_assignment .)
    INT32           reduce using rule 40 (rule -> map_assignment .)
    INT64           reduce using rule 40 (rule -> map_assignment .)
    FLOAT32         reduce using rule 40 (rule -> map_assignment .)
    FLOAT64         reduce using rule 40 (rule -> map_assignment .)
    BYTE            reduce using rule 40 (rule -> map_assignment .)
    WINT            reduce using rule 40 (rule -> map_assignment .)
    WFLOAT          reduce using rule 40 (rule -> map_assignment .)
    WSTRING         reduce using rule 40 (rule -> map_assignment .)
    BOOL            reduce using rule 40 (rule -> map_assignment .)
    DEFAULT         reduce using rule 40 (rule -> map_assignment .)
    CASE            reduce using rule 40 (rule -> map_assignment .)
    RETURN          reduce using rule 40 (rule -> map_assignment .)


state 27

    (41) rule -> func_declaration .

    PRINT           reduce using rule 41 (rule -> func_declaration .)
    SCAN            reduce using rule 41 (rule -> func_declaration .)
    FOR             reduce using rule 41 (rule -> func_declaration .)
    ID              reduce using rule 41 (rule -> func_declaration .)
    APPEND          reduce using rule 41 (rule -> func_declaration .)
    LEN             reduce using rule 41 (rule -> func_declaration .)
    COPY            reduce using rule 41 (rule -> func_declaration .)
    DELETE          reduce using rule 41 (rule -> func_declaration .)
    IF              reduce using rule 41 (rule -> func_declaration .)
    ELSE            reduce using rule 41 (rule -> func_declaration .)
    TYPE            reduce using rule 41 (rule -> func_declaration .)
    SWITCH          reduce using rule 41 (rule -> func_declaration .)
    VAR             reduce using rule 41 (rule -> func_declaration .)
    FUNC            reduce using rule 41 (rule -> func_declaration .)
    INTEGER         reduce using rule 41 (rule -> func_declaration .)
    FLOAT           reduce using rule 41 (rule -> func_declaration .)
    NOT             reduce using rule 41 (rule -> func_declaration .)
    $end            reduce using rule 41 (rule -> func_declaration .)
    RLLAVE          reduce using rule 41 (rule -> func_declaration .)
    INT32           reduce using rule 41 (rule -> func_declaration .)
    INT64           reduce using rule 41 (rule -> func_declaration .)
    FLOAT32         reduce using rule 41 (rule -> func_declaration .)
    FLOAT64         reduce using rule 41 (rule -> func_declaration .)
    BYTE            reduce using rule 41 (rule -> func_declaration .)
    WINT            reduce using rule 41 (rule -> func_declaration .)
    WFLOAT          reduce using rule 41 (rule -> func_declaration .)
    WSTRING         reduce using rule 41 (rule -> func_declaration .)
    BOOL            reduce using rule 41 (rule -> func_declaration .)
    DEFAULT         reduce using rule 41 (rule -> func_declaration .)
    CASE            reduce using rule 41 (rule -> func_declaration .)
    RETURN          reduce using rule 41 (rule -> func_declaration .)


state 28

    (42) rule -> main_func .

    PRINT           reduce using rule 42 (rule -> main_func .)
    SCAN            reduce using rule 42 (rule -> main_func .)
    FOR             reduce using rule 42 (rule -> main_func .)
    ID              reduce using rule 42 (rule -> main_func .)
    APPEND          reduce using rule 42 (rule -> main_func .)
    LEN             reduce using rule 42 (rule -> main_func .)
    COPY            reduce using rule 42 (rule -> main_func .)
    DELETE          reduce using rule 42 (rule -> main_func .)
    IF              reduce using rule 42 (rule -> main_func .)
    ELSE            reduce using rule 42 (rule -> main_func .)
    TYPE            reduce using rule 42 (rule -> main_func .)
    SWITCH          reduce using rule 42 (rule -> main_func .)
    VAR             reduce using rule 42 (rule -> main_func .)
    FUNC            reduce using rule 42 (rule -> main_func .)
    INTEGER         reduce using rule 42 (rule -> main_func .)
    FLOAT           reduce using rule 42 (rule -> main_func .)
    NOT             reduce using rule 42 (rule -> main_func .)
    $end            reduce using rule 42 (rule -> main_func .)
    RLLAVE          reduce using rule 42 (rule -> main_func .)
    INT32           reduce using rule 42 (rule -> main_func .)
    INT64           reduce using rule 42 (rule -> main_func .)
    FLOAT32         reduce using rule 42 (rule -> main_func .)
    FLOAT64         reduce using rule 42 (rule -> main_func .)
    BYTE            reduce using rule 42 (rule -> main_func .)
    WINT            reduce using rule 42 (rule -> main_func .)
    WFLOAT          reduce using rule 42 (rule -> main_func .)
    WSTRING         reduce using rule 42 (rule -> main_func .)
    BOOL            reduce using rule 42 (rule -> main_func .)
    DEFAULT         reduce using rule 42 (rule -> main_func .)
    CASE            reduce using rule 42 (rule -> main_func .)
    RETURN          reduce using rule 42 (rule -> main_func .)


state 29

    (218) impresion -> PRINT . LPAREN content RPAREN

    LPAREN          shift and go to state 75


state 30

    (80) scan_func -> SCAN . LPAREN POINTER RPAREN

    LPAREN          shift and go to state 76


state 31

    (224) expression -> something_ex .
    (225) expression -> something_ex . adicionaEx
    (226) adicionaEx -> . op something_ex
    (227) adicionaEx -> . op something_ex adicionaEx
    (169) op -> . GREATER
    (170) op -> . SMALLER
    (171) op -> . GREATER_OR_EQUAL
    (172) op -> . SMALLER_OR_EQUAL
    (173) op -> . EQUAL_COMPARE
    (174) op -> . NOT_EQUAL
    (233) op -> . PLUS
    (234) op -> . TIMES
    (235) op -> . DIVIDE
    (236) op -> . MINUS

  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL_COMPARE resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    COLON           reduce using rule 224 (expression -> something_ex .)
    PRINT           reduce using rule 224 (expression -> something_ex .)
    SCAN            reduce using rule 224 (expression -> something_ex .)
    FOR             reduce using rule 224 (expression -> something_ex .)
    ID              reduce using rule 224 (expression -> something_ex .)
    APPEND          reduce using rule 224 (expression -> something_ex .)
    LEN             reduce using rule 224 (expression -> something_ex .)
    COPY            reduce using rule 224 (expression -> something_ex .)
    DELETE          reduce using rule 224 (expression -> something_ex .)
    IF              reduce using rule 224 (expression -> something_ex .)
    ELSE            reduce using rule 224 (expression -> something_ex .)
    TYPE            reduce using rule 224 (expression -> something_ex .)
    SWITCH          reduce using rule 224 (expression -> something_ex .)
    VAR             reduce using rule 224 (expression -> something_ex .)
    FUNC            reduce using rule 224 (expression -> something_ex .)
    INTEGER         reduce using rule 224 (expression -> something_ex .)
    FLOAT           reduce using rule 224 (expression -> something_ex .)
    NOT             reduce using rule 224 (expression -> something_ex .)
    $end            reduce using rule 224 (expression -> something_ex .)
    RLLAVE          reduce using rule 224 (expression -> something_ex .)
    INT32           reduce using rule 224 (expression -> something_ex .)
    INT64           reduce using rule 224 (expression -> something_ex .)
    FLOAT32         reduce using rule 224 (expression -> something_ex .)
    FLOAT64         reduce using rule 224 (expression -> something_ex .)
    BYTE            reduce using rule 224 (expression -> something_ex .)
    WINT            reduce using rule 224 (expression -> something_ex .)
    WFLOAT          reduce using rule 224 (expression -> something_ex .)
    WSTRING         reduce using rule 224 (expression -> something_ex .)
    BOOL            reduce using rule 224 (expression -> something_ex .)
    DEFAULT         reduce using rule 224 (expression -> something_ex .)
    CASE            reduce using rule 224 (expression -> something_ex .)
    RETURN          reduce using rule 224 (expression -> something_ex .)
    RPAREN          reduce using rule 224 (expression -> something_ex .)
    AND             reduce using rule 224 (expression -> something_ex .)
    OR              reduce using rule 224 (expression -> something_ex .)
    LLLAVE          reduce using rule 224 (expression -> something_ex .)
    RCORCHE         reduce using rule 224 (expression -> something_ex .)
    COMA            reduce using rule 224 (expression -> something_ex .)
    GREATER         shift and go to state 79
    SMALLER         shift and go to state 80
    GREATER_OR_EQUAL shift and go to state 81
    SMALLER_OR_EQUAL shift and go to state 82
    EQUAL_COMPARE   shift and go to state 83
    NOT_EQUAL       shift and go to state 84
    PLUS            shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MINUS           shift and go to state 88

  ! GREATER         [ reduce using rule 224 (expression -> something_ex .) ]
  ! SMALLER         [ reduce using rule 224 (expression -> something_ex .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 224 (expression -> something_ex .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 224 (expression -> something_ex .) ]
  ! EQUAL_COMPARE   [ reduce using rule 224 (expression -> something_ex .) ]
  ! NOT_EQUAL       [ reduce using rule 224 (expression -> something_ex .) ]
  ! PLUS            [ reduce using rule 224 (expression -> something_ex .) ]
  ! TIMES           [ reduce using rule 224 (expression -> something_ex .) ]
  ! DIVIDE          [ reduce using rule 224 (expression -> something_ex .) ]
  ! MINUS           [ reduce using rule 224 (expression -> something_ex .) ]

    adicionaEx                     shift and go to state 77
    op                             shift and go to state 78

state 32

    (86) cicloFor -> FOR . LLLAVE codigo RLLAVE
    (87) cicloFor -> FOR . comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> FOR . logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> FOR . decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (146) decVarOne -> . ID DEQUAL ID
    (147) decVarOne -> . ID DEQUAL INTEGER
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    LLLAVE          shift and go to state 89
    ID              shift and go to state 93
    NOT             shift and go to state 54
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    comparison                     shift and go to state 90
    logic_operation                shift and go to state 91
    decVarOne                      shift and go to state 92
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    expression                     shift and go to state 94
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 33

    (166) comparison -> value . op value
    (169) op -> . GREATER
    (170) op -> . SMALLER
    (171) op -> . GREATER_OR_EQUAL
    (172) op -> . SMALLER_OR_EQUAL
    (173) op -> . EQUAL_COMPARE
    (174) op -> . NOT_EQUAL
    (233) op -> . PLUS
    (234) op -> . TIMES
    (235) op -> . DIVIDE
    (236) op -> . MINUS

    GREATER         shift and go to state 79
    SMALLER         shift and go to state 80
    GREATER_OR_EQUAL shift and go to state 81
    SMALLER_OR_EQUAL shift and go to state 82
    EQUAL_COMPARE   shift and go to state 83
    NOT_EQUAL       shift and go to state 84
    PLUS            shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MINUS           shift and go to state 88

    op                             shift and go to state 98

state 34

    (175) logic_operation -> logic_value . logic_recu
    (177) logic_recu -> . logic_op logic_value
    (178) logic_recu -> . logic_op logic_value logic_recu
    (184) logic_op -> . AND
    (185) logic_op -> . OR

    AND             shift and go to state 101
    OR              shift and go to state 102

    logic_recu                     shift and go to state 99
    logic_op                       shift and go to state 100

state 35

    (176) logic_operation -> negation .
    (179) logic_value -> negation .

    PRINT           reduce using rule 176 (logic_operation -> negation .)
    SCAN            reduce using rule 176 (logic_operation -> negation .)
    FOR             reduce using rule 176 (logic_operation -> negation .)
    ID              reduce using rule 176 (logic_operation -> negation .)
    APPEND          reduce using rule 176 (logic_operation -> negation .)
    LEN             reduce using rule 176 (logic_operation -> negation .)
    COPY            reduce using rule 176 (logic_operation -> negation .)
    DELETE          reduce using rule 176 (logic_operation -> negation .)
    IF              reduce using rule 176 (logic_operation -> negation .)
    ELSE            reduce using rule 176 (logic_operation -> negation .)
    TYPE            reduce using rule 176 (logic_operation -> negation .)
    SWITCH          reduce using rule 176 (logic_operation -> negation .)
    VAR             reduce using rule 176 (logic_operation -> negation .)
    FUNC            reduce using rule 176 (logic_operation -> negation .)
    INTEGER         reduce using rule 176 (logic_operation -> negation .)
    FLOAT           reduce using rule 176 (logic_operation -> negation .)
    NOT             reduce using rule 176 (logic_operation -> negation .)
    $end            reduce using rule 176 (logic_operation -> negation .)
    RLLAVE          reduce using rule 176 (logic_operation -> negation .)
    INT32           reduce using rule 176 (logic_operation -> negation .)
    INT64           reduce using rule 176 (logic_operation -> negation .)
    FLOAT32         reduce using rule 176 (logic_operation -> negation .)
    FLOAT64         reduce using rule 176 (logic_operation -> negation .)
    BYTE            reduce using rule 176 (logic_operation -> negation .)
    WINT            reduce using rule 176 (logic_operation -> negation .)
    WFLOAT          reduce using rule 176 (logic_operation -> negation .)
    WSTRING         reduce using rule 176 (logic_operation -> negation .)
    BOOL            reduce using rule 176 (logic_operation -> negation .)
    DEFAULT         reduce using rule 176 (logic_operation -> negation .)
    CASE            reduce using rule 176 (logic_operation -> negation .)
    RETURN          reduce using rule 176 (logic_operation -> negation .)
    LLLAVE          reduce using rule 176 (logic_operation -> negation .)
    COLON           reduce using rule 176 (logic_operation -> negation .)
    RPAREN          reduce using rule 176 (logic_operation -> negation .)
    RCORCHE         reduce using rule 176 (logic_operation -> negation .)
    COMA            reduce using rule 176 (logic_operation -> negation .)
    AND             reduce using rule 179 (logic_value -> negation .)
    OR              reduce using rule 179 (logic_value -> negation .)


state 36

    (92) decVar -> static .

    COLON           reduce using rule 92 (decVar -> static .)
    PRINT           reduce using rule 92 (decVar -> static .)
    SCAN            reduce using rule 92 (decVar -> static .)
    FOR             reduce using rule 92 (decVar -> static .)
    ID              reduce using rule 92 (decVar -> static .)
    APPEND          reduce using rule 92 (decVar -> static .)
    LEN             reduce using rule 92 (decVar -> static .)
    COPY            reduce using rule 92 (decVar -> static .)
    DELETE          reduce using rule 92 (decVar -> static .)
    IF              reduce using rule 92 (decVar -> static .)
    ELSE            reduce using rule 92 (decVar -> static .)
    TYPE            reduce using rule 92 (decVar -> static .)
    SWITCH          reduce using rule 92 (decVar -> static .)
    VAR             reduce using rule 92 (decVar -> static .)
    FUNC            reduce using rule 92 (decVar -> static .)
    INTEGER         reduce using rule 92 (decVar -> static .)
    FLOAT           reduce using rule 92 (decVar -> static .)
    NOT             reduce using rule 92 (decVar -> static .)
    $end            reduce using rule 92 (decVar -> static .)
    RLLAVE          reduce using rule 92 (decVar -> static .)
    INT32           reduce using rule 92 (decVar -> static .)
    INT64           reduce using rule 92 (decVar -> static .)
    FLOAT32         reduce using rule 92 (decVar -> static .)
    FLOAT64         reduce using rule 92 (decVar -> static .)
    BYTE            reduce using rule 92 (decVar -> static .)
    WINT            reduce using rule 92 (decVar -> static .)
    WFLOAT          reduce using rule 92 (decVar -> static .)
    WSTRING         reduce using rule 92 (decVar -> static .)
    BOOL            reduce using rule 92 (decVar -> static .)
    DEFAULT         reduce using rule 92 (decVar -> static .)
    CASE            reduce using rule 92 (decVar -> static .)
    RETURN          reduce using rule 92 (decVar -> static .)


state 37

    (93) decVar -> dynamic .

    COLON           reduce using rule 93 (decVar -> dynamic .)
    PRINT           reduce using rule 93 (decVar -> dynamic .)
    SCAN            reduce using rule 93 (decVar -> dynamic .)
    FOR             reduce using rule 93 (decVar -> dynamic .)
    ID              reduce using rule 93 (decVar -> dynamic .)
    APPEND          reduce using rule 93 (decVar -> dynamic .)
    LEN             reduce using rule 93 (decVar -> dynamic .)
    COPY            reduce using rule 93 (decVar -> dynamic .)
    DELETE          reduce using rule 93 (decVar -> dynamic .)
    IF              reduce using rule 93 (decVar -> dynamic .)
    ELSE            reduce using rule 93 (decVar -> dynamic .)
    TYPE            reduce using rule 93 (decVar -> dynamic .)
    SWITCH          reduce using rule 93 (decVar -> dynamic .)
    VAR             reduce using rule 93 (decVar -> dynamic .)
    FUNC            reduce using rule 93 (decVar -> dynamic .)
    INTEGER         reduce using rule 93 (decVar -> dynamic .)
    FLOAT           reduce using rule 93 (decVar -> dynamic .)
    NOT             reduce using rule 93 (decVar -> dynamic .)
    $end            reduce using rule 93 (decVar -> dynamic .)
    RLLAVE          reduce using rule 93 (decVar -> dynamic .)
    INT32           reduce using rule 93 (decVar -> dynamic .)
    INT64           reduce using rule 93 (decVar -> dynamic .)
    FLOAT32         reduce using rule 93 (decVar -> dynamic .)
    FLOAT64         reduce using rule 93 (decVar -> dynamic .)
    BYTE            reduce using rule 93 (decVar -> dynamic .)
    WINT            reduce using rule 93 (decVar -> dynamic .)
    WFLOAT          reduce using rule 93 (decVar -> dynamic .)
    WSTRING         reduce using rule 93 (decVar -> dynamic .)
    BOOL            reduce using rule 93 (decVar -> dynamic .)
    DEFAULT         reduce using rule 93 (decVar -> dynamic .)
    CASE            reduce using rule 93 (decVar -> dynamic .)
    RETURN          reduce using rule 93 (decVar -> dynamic .)


state 38

    (62) var_asignation -> ID . EQUAL any
    (159) cStruct -> ID . DEQUAL ID LLLAVE asignaciones RLLAVE
    (196) array_var -> ID . LCORCHE index RCORCHE
    (124) slice_declaration -> ID . DEQUAL funM
    (125) slice_declaration -> ID . DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> ID . LCORCHE index_s RCORCHE
    (228) something_ex -> ID .
    (167) value -> ID .
    (181) logic_value -> ID .
    (120) dynamic -> ID . DEQUAL values
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN
    (202) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 167 (value -> ID .)
    EQUAL           shift and go to state 103
    DEQUAL          shift and go to state 104
    LCORCHE         shift and go to state 105
    COLON           reduce using rule 228 (something_ex -> ID .)
    PRINT           reduce using rule 228 (something_ex -> ID .)
    SCAN            reduce using rule 228 (something_ex -> ID .)
    FOR             reduce using rule 228 (something_ex -> ID .)
    ID              reduce using rule 228 (something_ex -> ID .)
    APPEND          reduce using rule 228 (something_ex -> ID .)
    LEN             reduce using rule 228 (something_ex -> ID .)
    COPY            reduce using rule 228 (something_ex -> ID .)
    DELETE          reduce using rule 228 (something_ex -> ID .)
    IF              reduce using rule 228 (something_ex -> ID .)
    ELSE            reduce using rule 228 (something_ex -> ID .)
    TYPE            reduce using rule 228 (something_ex -> ID .)
    SWITCH          reduce using rule 228 (something_ex -> ID .)
    VAR             reduce using rule 228 (something_ex -> ID .)
    FUNC            reduce using rule 228 (something_ex -> ID .)
    INTEGER         reduce using rule 228 (something_ex -> ID .)
    FLOAT           reduce using rule 228 (something_ex -> ID .)
    NOT             reduce using rule 228 (something_ex -> ID .)
    $end            reduce using rule 228 (something_ex -> ID .)
    RLLAVE          reduce using rule 228 (something_ex -> ID .)
    INT32           reduce using rule 228 (something_ex -> ID .)
    INT64           reduce using rule 228 (something_ex -> ID .)
    FLOAT32         reduce using rule 228 (something_ex -> ID .)
    FLOAT64         reduce using rule 228 (something_ex -> ID .)
    BYTE            reduce using rule 228 (something_ex -> ID .)
    WINT            reduce using rule 228 (something_ex -> ID .)
    WFLOAT          reduce using rule 228 (something_ex -> ID .)
    WSTRING         reduce using rule 228 (something_ex -> ID .)
    BOOL            reduce using rule 228 (something_ex -> ID .)
    DEFAULT         reduce using rule 228 (something_ex -> ID .)
    CASE            reduce using rule 228 (something_ex -> ID .)
    RETURN          reduce using rule 228 (something_ex -> ID .)
    GREATER         reduce using rule 167 (value -> ID .)
    SMALLER         reduce using rule 167 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 167 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 167 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 167 (value -> ID .)
    NOT_EQUAL       reduce using rule 167 (value -> ID .)
    PLUS            reduce using rule 167 (value -> ID .)
    TIMES           reduce using rule 167 (value -> ID .)
    DIVIDE          reduce using rule 167 (value -> ID .)
    MINUS           reduce using rule 167 (value -> ID .)
    AND             reduce using rule 181 (logic_value -> ID .)
    OR              reduce using rule 181 (logic_value -> ID .)
    LPAREN          shift and go to state 106

  ! GREATER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 228 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 228 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 228 (something_ex -> ID .) ]


state 39

    (140) funciones -> APPEND . LPAREN ID COMA values RPAREN
    (141) funciones -> APPEND . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 107


state 40

    (142) funciones -> LEN . LPAREN ID RPAREN

    LPAREN          shift and go to state 108


state 41

    (143) funciones -> COPY . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 109


state 42

    (144) funciones -> DELETE . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 110


state 43

    (145) funciones -> call_func .

    COLON           reduce using rule 145 (funciones -> call_func .)
    PRINT           reduce using rule 145 (funciones -> call_func .)
    SCAN            reduce using rule 145 (funciones -> call_func .)
    FOR             reduce using rule 145 (funciones -> call_func .)
    ID              reduce using rule 145 (funciones -> call_func .)
    APPEND          reduce using rule 145 (funciones -> call_func .)
    LEN             reduce using rule 145 (funciones -> call_func .)
    COPY            reduce using rule 145 (funciones -> call_func .)
    DELETE          reduce using rule 145 (funciones -> call_func .)
    IF              reduce using rule 145 (funciones -> call_func .)
    ELSE            reduce using rule 145 (funciones -> call_func .)
    TYPE            reduce using rule 145 (funciones -> call_func .)
    SWITCH          reduce using rule 145 (funciones -> call_func .)
    VAR             reduce using rule 145 (funciones -> call_func .)
    FUNC            reduce using rule 145 (funciones -> call_func .)
    INTEGER         reduce using rule 145 (funciones -> call_func .)
    FLOAT           reduce using rule 145 (funciones -> call_func .)
    NOT             reduce using rule 145 (funciones -> call_func .)
    $end            reduce using rule 145 (funciones -> call_func .)
    GREATER         reduce using rule 145 (funciones -> call_func .)
    SMALLER         reduce using rule 145 (funciones -> call_func .)
    GREATER_OR_EQUAL reduce using rule 145 (funciones -> call_func .)
    SMALLER_OR_EQUAL reduce using rule 145 (funciones -> call_func .)
    EQUAL_COMPARE   reduce using rule 145 (funciones -> call_func .)
    NOT_EQUAL       reduce using rule 145 (funciones -> call_func .)
    PLUS            reduce using rule 145 (funciones -> call_func .)
    TIMES           reduce using rule 145 (funciones -> call_func .)
    DIVIDE          reduce using rule 145 (funciones -> call_func .)
    MINUS           reduce using rule 145 (funciones -> call_func .)
    RLLAVE          reduce using rule 145 (funciones -> call_func .)
    INT32           reduce using rule 145 (funciones -> call_func .)
    INT64           reduce using rule 145 (funciones -> call_func .)
    FLOAT32         reduce using rule 145 (funciones -> call_func .)
    FLOAT64         reduce using rule 145 (funciones -> call_func .)
    BYTE            reduce using rule 145 (funciones -> call_func .)
    WINT            reduce using rule 145 (funciones -> call_func .)
    WFLOAT          reduce using rule 145 (funciones -> call_func .)
    WSTRING         reduce using rule 145 (funciones -> call_func .)
    BOOL            reduce using rule 145 (funciones -> call_func .)
    DEFAULT         reduce using rule 145 (funciones -> call_func .)
    CASE            reduce using rule 145 (funciones -> call_func .)
    RETURN          reduce using rule 145 (funciones -> call_func .)
    RPAREN          reduce using rule 145 (funciones -> call_func .)
    AND             reduce using rule 145 (funciones -> call_func .)
    OR              reduce using rule 145 (funciones -> call_func .)
    LLLAVE          reduce using rule 145 (funciones -> call_func .)
    RCORCHE         reduce using rule 145 (funciones -> call_func .)
    COMA            reduce using rule 145 (funciones -> call_func .)


state 44

    (148) SenIF -> IF . comparison LLLAVE codigo RLLAVE
    (149) SenIF -> IF . TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> IF . FALSE LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (167) value -> . ID
    (168) value -> . expression
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    TRUE            shift and go to state 112
    FALSE           shift and go to state 113
    ID              shift and go to state 114
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    comparison                     shift and go to state 111
    value                          shift and go to state 33
    expression                     shift and go to state 94
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 45

    (151) SenElseIF -> ELSE . IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> ELSE . IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> ELSE . IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> ELSE . LLLAVE codigo RLLAVE

    IF              shift and go to state 115
    LLLAVE          shift and go to state 116


state 46

    (155) SenStruct -> TYPE . ID STRUCT LLLAVE declaration RLLAVE

    ID              shift and go to state 117


state 47

    (186) switch_statement -> SWITCH . ID LLLAVE cases RLLAVE

    ID              shift and go to state 118


state 48

    (191) array_declaration -> VAR . ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> VAR . ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (121) slice_declaration -> VAR . ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> VAR . ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> VAR . ID EQUAL funM
    (201) map_declaration -> VAR . ID LCORCHE data_types RCORCHE data_types
    (100) single -> VAR . ID data_types
    (101) single -> VAR . ID data_types EQUAL funciones
    (102) single -> VAR . ID data_types EQUAL ID
    (103) single -> VAR . ID data_types EQUAL data_structure
    (104) single -> VAR . ID data_type_and_value
    (97) list_var -> VAR . ID COMA more

    ID              shift and go to state 119


state 49

    (206) map_assignment -> map_var . EQUAL something
    (61) data_structure -> map_var .

    EQUAL           shift and go to state 120
    GREATER         reduce using rule 61 (data_structure -> map_var .)
    SMALLER         reduce using rule 61 (data_structure -> map_var .)
    GREATER_OR_EQUAL reduce using rule 61 (data_structure -> map_var .)
    SMALLER_OR_EQUAL reduce using rule 61 (data_structure -> map_var .)
    EQUAL_COMPARE   reduce using rule 61 (data_structure -> map_var .)
    NOT_EQUAL       reduce using rule 61 (data_structure -> map_var .)
    PLUS            reduce using rule 61 (data_structure -> map_var .)
    TIMES           reduce using rule 61 (data_structure -> map_var .)
    DIVIDE          reduce using rule 61 (data_structure -> map_var .)
    MINUS           reduce using rule 61 (data_structure -> map_var .)
    COLON           reduce using rule 61 (data_structure -> map_var .)
    PRINT           reduce using rule 61 (data_structure -> map_var .)
    SCAN            reduce using rule 61 (data_structure -> map_var .)
    FOR             reduce using rule 61 (data_structure -> map_var .)
    ID              reduce using rule 61 (data_structure -> map_var .)
    APPEND          reduce using rule 61 (data_structure -> map_var .)
    LEN             reduce using rule 61 (data_structure -> map_var .)
    COPY            reduce using rule 61 (data_structure -> map_var .)
    DELETE          reduce using rule 61 (data_structure -> map_var .)
    IF              reduce using rule 61 (data_structure -> map_var .)
    ELSE            reduce using rule 61 (data_structure -> map_var .)
    TYPE            reduce using rule 61 (data_structure -> map_var .)
    SWITCH          reduce using rule 61 (data_structure -> map_var .)
    VAR             reduce using rule 61 (data_structure -> map_var .)
    FUNC            reduce using rule 61 (data_structure -> map_var .)
    INTEGER         reduce using rule 61 (data_structure -> map_var .)
    FLOAT           reduce using rule 61 (data_structure -> map_var .)
    NOT             reduce using rule 61 (data_structure -> map_var .)
    $end            reduce using rule 61 (data_structure -> map_var .)
    RLLAVE          reduce using rule 61 (data_structure -> map_var .)
    INT32           reduce using rule 61 (data_structure -> map_var .)
    INT64           reduce using rule 61 (data_structure -> map_var .)
    FLOAT32         reduce using rule 61 (data_structure -> map_var .)
    FLOAT64         reduce using rule 61 (data_structure -> map_var .)
    BYTE            reduce using rule 61 (data_structure -> map_var .)
    WINT            reduce using rule 61 (data_structure -> map_var .)
    WFLOAT          reduce using rule 61 (data_structure -> map_var .)
    WSTRING         reduce using rule 61 (data_structure -> map_var .)
    BOOL            reduce using rule 61 (data_structure -> map_var .)
    DEFAULT         reduce using rule 61 (data_structure -> map_var .)
    CASE            reduce using rule 61 (data_structure -> map_var .)
    RETURN          reduce using rule 61 (data_structure -> map_var .)


state 50

    (207) func_declaration -> FUNC . ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> FUNC . ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> FUNC . MAIN LPAREN RPAREN LLLAVE codigo RLLAVE

    ID              shift and go to state 121
    MAIN            shift and go to state 122


state 51

    (229) something_ex -> INTEGER .

    GREATER         reduce using rule 229 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 229 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 229 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 229 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 229 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 229 (something_ex -> INTEGER .)
    PLUS            reduce using rule 229 (something_ex -> INTEGER .)
    TIMES           reduce using rule 229 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 229 (something_ex -> INTEGER .)
    MINUS           reduce using rule 229 (something_ex -> INTEGER .)
    COLON           reduce using rule 229 (something_ex -> INTEGER .)
    PRINT           reduce using rule 229 (something_ex -> INTEGER .)
    SCAN            reduce using rule 229 (something_ex -> INTEGER .)
    FOR             reduce using rule 229 (something_ex -> INTEGER .)
    ID              reduce using rule 229 (something_ex -> INTEGER .)
    APPEND          reduce using rule 229 (something_ex -> INTEGER .)
    LEN             reduce using rule 229 (something_ex -> INTEGER .)
    COPY            reduce using rule 229 (something_ex -> INTEGER .)
    DELETE          reduce using rule 229 (something_ex -> INTEGER .)
    IF              reduce using rule 229 (something_ex -> INTEGER .)
    ELSE            reduce using rule 229 (something_ex -> INTEGER .)
    TYPE            reduce using rule 229 (something_ex -> INTEGER .)
    SWITCH          reduce using rule 229 (something_ex -> INTEGER .)
    VAR             reduce using rule 229 (something_ex -> INTEGER .)
    FUNC            reduce using rule 229 (something_ex -> INTEGER .)
    INTEGER         reduce using rule 229 (something_ex -> INTEGER .)
    FLOAT           reduce using rule 229 (something_ex -> INTEGER .)
    NOT             reduce using rule 229 (something_ex -> INTEGER .)
    $end            reduce using rule 229 (something_ex -> INTEGER .)
    RLLAVE          reduce using rule 229 (something_ex -> INTEGER .)
    INT32           reduce using rule 229 (something_ex -> INTEGER .)
    INT64           reduce using rule 229 (something_ex -> INTEGER .)
    FLOAT32         reduce using rule 229 (something_ex -> INTEGER .)
    FLOAT64         reduce using rule 229 (something_ex -> INTEGER .)
    BYTE            reduce using rule 229 (something_ex -> INTEGER .)
    WINT            reduce using rule 229 (something_ex -> INTEGER .)
    WFLOAT          reduce using rule 229 (something_ex -> INTEGER .)
    WSTRING         reduce using rule 229 (something_ex -> INTEGER .)
    BOOL            reduce using rule 229 (something_ex -> INTEGER .)
    DEFAULT         reduce using rule 229 (something_ex -> INTEGER .)
    CASE            reduce using rule 229 (something_ex -> INTEGER .)
    RETURN          reduce using rule 229 (something_ex -> INTEGER .)
    RPAREN          reduce using rule 229 (something_ex -> INTEGER .)
    AND             reduce using rule 229 (something_ex -> INTEGER .)
    OR              reduce using rule 229 (something_ex -> INTEGER .)
    LLLAVE          reduce using rule 229 (something_ex -> INTEGER .)
    RCORCHE         reduce using rule 229 (something_ex -> INTEGER .)
    COMA            reduce using rule 229 (something_ex -> INTEGER .)


state 52

    (230) something_ex -> FLOAT .

    GREATER         reduce using rule 230 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 230 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 230 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 230 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 230 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 230 (something_ex -> FLOAT .)
    PLUS            reduce using rule 230 (something_ex -> FLOAT .)
    TIMES           reduce using rule 230 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 230 (something_ex -> FLOAT .)
    MINUS           reduce using rule 230 (something_ex -> FLOAT .)
    COLON           reduce using rule 230 (something_ex -> FLOAT .)
    PRINT           reduce using rule 230 (something_ex -> FLOAT .)
    SCAN            reduce using rule 230 (something_ex -> FLOAT .)
    FOR             reduce using rule 230 (something_ex -> FLOAT .)
    ID              reduce using rule 230 (something_ex -> FLOAT .)
    APPEND          reduce using rule 230 (something_ex -> FLOAT .)
    LEN             reduce using rule 230 (something_ex -> FLOAT .)
    COPY            reduce using rule 230 (something_ex -> FLOAT .)
    DELETE          reduce using rule 230 (something_ex -> FLOAT .)
    IF              reduce using rule 230 (something_ex -> FLOAT .)
    ELSE            reduce using rule 230 (something_ex -> FLOAT .)
    TYPE            reduce using rule 230 (something_ex -> FLOAT .)
    SWITCH          reduce using rule 230 (something_ex -> FLOAT .)
    VAR             reduce using rule 230 (something_ex -> FLOAT .)
    FUNC            reduce using rule 230 (something_ex -> FLOAT .)
    INTEGER         reduce using rule 230 (something_ex -> FLOAT .)
    FLOAT           reduce using rule 230 (something_ex -> FLOAT .)
    NOT             reduce using rule 230 (something_ex -> FLOAT .)
    $end            reduce using rule 230 (something_ex -> FLOAT .)
    RLLAVE          reduce using rule 230 (something_ex -> FLOAT .)
    INT32           reduce using rule 230 (something_ex -> FLOAT .)
    INT64           reduce using rule 230 (something_ex -> FLOAT .)
    FLOAT32         reduce using rule 230 (something_ex -> FLOAT .)
    FLOAT64         reduce using rule 230 (something_ex -> FLOAT .)
    BYTE            reduce using rule 230 (something_ex -> FLOAT .)
    WINT            reduce using rule 230 (something_ex -> FLOAT .)
    WFLOAT          reduce using rule 230 (something_ex -> FLOAT .)
    WSTRING         reduce using rule 230 (something_ex -> FLOAT .)
    BOOL            reduce using rule 230 (something_ex -> FLOAT .)
    DEFAULT         reduce using rule 230 (something_ex -> FLOAT .)
    CASE            reduce using rule 230 (something_ex -> FLOAT .)
    RETURN          reduce using rule 230 (something_ex -> FLOAT .)
    RPAREN          reduce using rule 230 (something_ex -> FLOAT .)
    AND             reduce using rule 230 (something_ex -> FLOAT .)
    OR              reduce using rule 230 (something_ex -> FLOAT .)
    LLLAVE          reduce using rule 230 (something_ex -> FLOAT .)
    RCORCHE         reduce using rule 230 (something_ex -> FLOAT .)
    COMA            reduce using rule 230 (something_ex -> FLOAT .)


state 53

    (231) something_ex -> data_structure .

    GREATER         reduce using rule 231 (something_ex -> data_structure .)
    SMALLER         reduce using rule 231 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 231 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 231 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 231 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 231 (something_ex -> data_structure .)
    PLUS            reduce using rule 231 (something_ex -> data_structure .)
    TIMES           reduce using rule 231 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 231 (something_ex -> data_structure .)
    MINUS           reduce using rule 231 (something_ex -> data_structure .)
    COLON           reduce using rule 231 (something_ex -> data_structure .)
    PRINT           reduce using rule 231 (something_ex -> data_structure .)
    SCAN            reduce using rule 231 (something_ex -> data_structure .)
    FOR             reduce using rule 231 (something_ex -> data_structure .)
    ID              reduce using rule 231 (something_ex -> data_structure .)
    APPEND          reduce using rule 231 (something_ex -> data_structure .)
    LEN             reduce using rule 231 (something_ex -> data_structure .)
    COPY            reduce using rule 231 (something_ex -> data_structure .)
    DELETE          reduce using rule 231 (something_ex -> data_structure .)
    IF              reduce using rule 231 (something_ex -> data_structure .)
    ELSE            reduce using rule 231 (something_ex -> data_structure .)
    TYPE            reduce using rule 231 (something_ex -> data_structure .)
    SWITCH          reduce using rule 231 (something_ex -> data_structure .)
    VAR             reduce using rule 231 (something_ex -> data_structure .)
    FUNC            reduce using rule 231 (something_ex -> data_structure .)
    INTEGER         reduce using rule 231 (something_ex -> data_structure .)
    FLOAT           reduce using rule 231 (something_ex -> data_structure .)
    NOT             reduce using rule 231 (something_ex -> data_structure .)
    $end            reduce using rule 231 (something_ex -> data_structure .)
    RLLAVE          reduce using rule 231 (something_ex -> data_structure .)
    INT32           reduce using rule 231 (something_ex -> data_structure .)
    INT64           reduce using rule 231 (something_ex -> data_structure .)
    FLOAT32         reduce using rule 231 (something_ex -> data_structure .)
    FLOAT64         reduce using rule 231 (something_ex -> data_structure .)
    BYTE            reduce using rule 231 (something_ex -> data_structure .)
    WINT            reduce using rule 231 (something_ex -> data_structure .)
    WFLOAT          reduce using rule 231 (something_ex -> data_structure .)
    WSTRING         reduce using rule 231 (something_ex -> data_structure .)
    BOOL            reduce using rule 231 (something_ex -> data_structure .)
    DEFAULT         reduce using rule 231 (something_ex -> data_structure .)
    CASE            reduce using rule 231 (something_ex -> data_structure .)
    RETURN          reduce using rule 231 (something_ex -> data_structure .)
    RPAREN          reduce using rule 231 (something_ex -> data_structure .)
    AND             reduce using rule 231 (something_ex -> data_structure .)
    OR              reduce using rule 231 (something_ex -> data_structure .)
    LLLAVE          reduce using rule 231 (something_ex -> data_structure .)
    RCORCHE         reduce using rule 231 (something_ex -> data_structure .)
    COMA            reduce using rule 231 (something_ex -> data_structure .)


state 54

    (182) negation -> NOT . comparison
    (183) negation -> NOT . ID
    (166) comparison -> . value op value
    (167) value -> . ID
    (168) value -> . expression
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 124
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    comparison                     shift and go to state 123
    value                          shift and go to state 33
    expression                     shift and go to state 94
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 55

    (94) static -> single .

    COLON           reduce using rule 94 (static -> single .)
    PRINT           reduce using rule 94 (static -> single .)
    SCAN            reduce using rule 94 (static -> single .)
    FOR             reduce using rule 94 (static -> single .)
    ID              reduce using rule 94 (static -> single .)
    APPEND          reduce using rule 94 (static -> single .)
    LEN             reduce using rule 94 (static -> single .)
    COPY            reduce using rule 94 (static -> single .)
    DELETE          reduce using rule 94 (static -> single .)
    IF              reduce using rule 94 (static -> single .)
    ELSE            reduce using rule 94 (static -> single .)
    TYPE            reduce using rule 94 (static -> single .)
    SWITCH          reduce using rule 94 (static -> single .)
    VAR             reduce using rule 94 (static -> single .)
    FUNC            reduce using rule 94 (static -> single .)
    INTEGER         reduce using rule 94 (static -> single .)
    FLOAT           reduce using rule 94 (static -> single .)
    NOT             reduce using rule 94 (static -> single .)
    $end            reduce using rule 94 (static -> single .)
    RLLAVE          reduce using rule 94 (static -> single .)
    INT32           reduce using rule 94 (static -> single .)
    INT64           reduce using rule 94 (static -> single .)
    FLOAT32         reduce using rule 94 (static -> single .)
    FLOAT64         reduce using rule 94 (static -> single .)
    BYTE            reduce using rule 94 (static -> single .)
    WINT            reduce using rule 94 (static -> single .)
    WFLOAT          reduce using rule 94 (static -> single .)
    WSTRING         reduce using rule 94 (static -> single .)
    BOOL            reduce using rule 94 (static -> single .)
    DEFAULT         reduce using rule 94 (static -> single .)
    CASE            reduce using rule 94 (static -> single .)
    RETURN          reduce using rule 94 (static -> single .)


state 56

    (95) static -> multiple .

    COLON           reduce using rule 95 (static -> multiple .)
    PRINT           reduce using rule 95 (static -> multiple .)
    SCAN            reduce using rule 95 (static -> multiple .)
    FOR             reduce using rule 95 (static -> multiple .)
    ID              reduce using rule 95 (static -> multiple .)
    APPEND          reduce using rule 95 (static -> multiple .)
    LEN             reduce using rule 95 (static -> multiple .)
    COPY            reduce using rule 95 (static -> multiple .)
    DELETE          reduce using rule 95 (static -> multiple .)
    IF              reduce using rule 95 (static -> multiple .)
    ELSE            reduce using rule 95 (static -> multiple .)
    TYPE            reduce using rule 95 (static -> multiple .)
    SWITCH          reduce using rule 95 (static -> multiple .)
    VAR             reduce using rule 95 (static -> multiple .)
    FUNC            reduce using rule 95 (static -> multiple .)
    INTEGER         reduce using rule 95 (static -> multiple .)
    FLOAT           reduce using rule 95 (static -> multiple .)
    NOT             reduce using rule 95 (static -> multiple .)
    $end            reduce using rule 95 (static -> multiple .)
    RLLAVE          reduce using rule 95 (static -> multiple .)
    INT32           reduce using rule 95 (static -> multiple .)
    INT64           reduce using rule 95 (static -> multiple .)
    FLOAT32         reduce using rule 95 (static -> multiple .)
    FLOAT64         reduce using rule 95 (static -> multiple .)
    BYTE            reduce using rule 95 (static -> multiple .)
    WINT            reduce using rule 95 (static -> multiple .)
    WFLOAT          reduce using rule 95 (static -> multiple .)
    WSTRING         reduce using rule 95 (static -> multiple .)
    BOOL            reduce using rule 95 (static -> multiple .)
    DEFAULT         reduce using rule 95 (static -> multiple .)
    CASE            reduce using rule 95 (static -> multiple .)
    RETURN          reduce using rule 95 (static -> multiple .)


state 57

    (96) multiple -> list_var . data_types
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 126
    INT64           shift and go to state 127
    FLOAT32         shift and go to state 128
    FLOAT64         shift and go to state 129
    BYTE            shift and go to state 130
    WINT            shift and go to state 131
    WFLOAT          shift and go to state 132
    WSTRING         shift and go to state 133
    BOOL            shift and go to state 134

    data_types                     shift and go to state 125

state 58

    (3) more_rules -> rule codigo .

    $end            reduce using rule 3 (more_rules -> rule codigo .)
    RLLAVE          reduce using rule 3 (more_rules -> rule codigo .)
    INT32           reduce using rule 3 (more_rules -> rule codigo .)
    INT64           reduce using rule 3 (more_rules -> rule codigo .)
    FLOAT32         reduce using rule 3 (more_rules -> rule codigo .)
    FLOAT64         reduce using rule 3 (more_rules -> rule codigo .)
    BYTE            reduce using rule 3 (more_rules -> rule codigo .)
    WINT            reduce using rule 3 (more_rules -> rule codigo .)
    WFLOAT          reduce using rule 3 (more_rules -> rule codigo .)
    WSTRING         reduce using rule 3 (more_rules -> rule codigo .)
    BOOL            reduce using rule 3 (more_rules -> rule codigo .)
    ID              reduce using rule 3 (more_rules -> rule codigo .)
    DEFAULT         reduce using rule 3 (more_rules -> rule codigo .)
    CASE            reduce using rule 3 (more_rules -> rule codigo .)
    RETURN          reduce using rule 3 (more_rules -> rule codigo .)


state 59

    (4) rule -> impresion COLON .

    PRINT           reduce using rule 4 (rule -> impresion COLON .)
    SCAN            reduce using rule 4 (rule -> impresion COLON .)
    FOR             reduce using rule 4 (rule -> impresion COLON .)
    ID              reduce using rule 4 (rule -> impresion COLON .)
    APPEND          reduce using rule 4 (rule -> impresion COLON .)
    LEN             reduce using rule 4 (rule -> impresion COLON .)
    COPY            reduce using rule 4 (rule -> impresion COLON .)
    DELETE          reduce using rule 4 (rule -> impresion COLON .)
    IF              reduce using rule 4 (rule -> impresion COLON .)
    ELSE            reduce using rule 4 (rule -> impresion COLON .)
    TYPE            reduce using rule 4 (rule -> impresion COLON .)
    SWITCH          reduce using rule 4 (rule -> impresion COLON .)
    VAR             reduce using rule 4 (rule -> impresion COLON .)
    FUNC            reduce using rule 4 (rule -> impresion COLON .)
    INTEGER         reduce using rule 4 (rule -> impresion COLON .)
    FLOAT           reduce using rule 4 (rule -> impresion COLON .)
    NOT             reduce using rule 4 (rule -> impresion COLON .)
    $end            reduce using rule 4 (rule -> impresion COLON .)
    RLLAVE          reduce using rule 4 (rule -> impresion COLON .)
    INT32           reduce using rule 4 (rule -> impresion COLON .)
    INT64           reduce using rule 4 (rule -> impresion COLON .)
    FLOAT32         reduce using rule 4 (rule -> impresion COLON .)
    FLOAT64         reduce using rule 4 (rule -> impresion COLON .)
    BYTE            reduce using rule 4 (rule -> impresion COLON .)
    WINT            reduce using rule 4 (rule -> impresion COLON .)
    WFLOAT          reduce using rule 4 (rule -> impresion COLON .)
    WSTRING         reduce using rule 4 (rule -> impresion COLON .)
    BOOL            reduce using rule 4 (rule -> impresion COLON .)
    DEFAULT         reduce using rule 4 (rule -> impresion COLON .)
    CASE            reduce using rule 4 (rule -> impresion COLON .)
    RETURN          reduce using rule 4 (rule -> impresion COLON .)


state 60

    (6) rule -> scan_func COLON .

    PRINT           reduce using rule 6 (rule -> scan_func COLON .)
    SCAN            reduce using rule 6 (rule -> scan_func COLON .)
    FOR             reduce using rule 6 (rule -> scan_func COLON .)
    ID              reduce using rule 6 (rule -> scan_func COLON .)
    APPEND          reduce using rule 6 (rule -> scan_func COLON .)
    LEN             reduce using rule 6 (rule -> scan_func COLON .)
    COPY            reduce using rule 6 (rule -> scan_func COLON .)
    DELETE          reduce using rule 6 (rule -> scan_func COLON .)
    IF              reduce using rule 6 (rule -> scan_func COLON .)
    ELSE            reduce using rule 6 (rule -> scan_func COLON .)
    TYPE            reduce using rule 6 (rule -> scan_func COLON .)
    SWITCH          reduce using rule 6 (rule -> scan_func COLON .)
    VAR             reduce using rule 6 (rule -> scan_func COLON .)
    FUNC            reduce using rule 6 (rule -> scan_func COLON .)
    INTEGER         reduce using rule 6 (rule -> scan_func COLON .)
    FLOAT           reduce using rule 6 (rule -> scan_func COLON .)
    NOT             reduce using rule 6 (rule -> scan_func COLON .)
    $end            reduce using rule 6 (rule -> scan_func COLON .)
    RLLAVE          reduce using rule 6 (rule -> scan_func COLON .)
    INT32           reduce using rule 6 (rule -> scan_func COLON .)
    INT64           reduce using rule 6 (rule -> scan_func COLON .)
    FLOAT32         reduce using rule 6 (rule -> scan_func COLON .)
    FLOAT64         reduce using rule 6 (rule -> scan_func COLON .)
    BYTE            reduce using rule 6 (rule -> scan_func COLON .)
    WINT            reduce using rule 6 (rule -> scan_func COLON .)
    WFLOAT          reduce using rule 6 (rule -> scan_func COLON .)
    WSTRING         reduce using rule 6 (rule -> scan_func COLON .)
    BOOL            reduce using rule 6 (rule -> scan_func COLON .)
    DEFAULT         reduce using rule 6 (rule -> scan_func COLON .)
    CASE            reduce using rule 6 (rule -> scan_func COLON .)
    RETURN          reduce using rule 6 (rule -> scan_func COLON .)


state 61

    (8) rule -> expression COLON .

    PRINT           reduce using rule 8 (rule -> expression COLON .)
    SCAN            reduce using rule 8 (rule -> expression COLON .)
    FOR             reduce using rule 8 (rule -> expression COLON .)
    ID              reduce using rule 8 (rule -> expression COLON .)
    APPEND          reduce using rule 8 (rule -> expression COLON .)
    LEN             reduce using rule 8 (rule -> expression COLON .)
    COPY            reduce using rule 8 (rule -> expression COLON .)
    DELETE          reduce using rule 8 (rule -> expression COLON .)
    IF              reduce using rule 8 (rule -> expression COLON .)
    ELSE            reduce using rule 8 (rule -> expression COLON .)
    TYPE            reduce using rule 8 (rule -> expression COLON .)
    SWITCH          reduce using rule 8 (rule -> expression COLON .)
    VAR             reduce using rule 8 (rule -> expression COLON .)
    FUNC            reduce using rule 8 (rule -> expression COLON .)
    INTEGER         reduce using rule 8 (rule -> expression COLON .)
    FLOAT           reduce using rule 8 (rule -> expression COLON .)
    NOT             reduce using rule 8 (rule -> expression COLON .)
    $end            reduce using rule 8 (rule -> expression COLON .)
    RLLAVE          reduce using rule 8 (rule -> expression COLON .)
    INT32           reduce using rule 8 (rule -> expression COLON .)
    INT64           reduce using rule 8 (rule -> expression COLON .)
    FLOAT32         reduce using rule 8 (rule -> expression COLON .)
    FLOAT64         reduce using rule 8 (rule -> expression COLON .)
    BYTE            reduce using rule 8 (rule -> expression COLON .)
    WINT            reduce using rule 8 (rule -> expression COLON .)
    WFLOAT          reduce using rule 8 (rule -> expression COLON .)
    WSTRING         reduce using rule 8 (rule -> expression COLON .)
    BOOL            reduce using rule 8 (rule -> expression COLON .)
    DEFAULT         reduce using rule 8 (rule -> expression COLON .)
    CASE            reduce using rule 8 (rule -> expression COLON .)
    RETURN          reduce using rule 8 (rule -> expression COLON .)


state 62

    (13) rule -> decVar COLON .

    PRINT           reduce using rule 13 (rule -> decVar COLON .)
    SCAN            reduce using rule 13 (rule -> decVar COLON .)
    FOR             reduce using rule 13 (rule -> decVar COLON .)
    ID              reduce using rule 13 (rule -> decVar COLON .)
    APPEND          reduce using rule 13 (rule -> decVar COLON .)
    LEN             reduce using rule 13 (rule -> decVar COLON .)
    COPY            reduce using rule 13 (rule -> decVar COLON .)
    DELETE          reduce using rule 13 (rule -> decVar COLON .)
    IF              reduce using rule 13 (rule -> decVar COLON .)
    ELSE            reduce using rule 13 (rule -> decVar COLON .)
    TYPE            reduce using rule 13 (rule -> decVar COLON .)
    SWITCH          reduce using rule 13 (rule -> decVar COLON .)
    VAR             reduce using rule 13 (rule -> decVar COLON .)
    FUNC            reduce using rule 13 (rule -> decVar COLON .)
    INTEGER         reduce using rule 13 (rule -> decVar COLON .)
    FLOAT           reduce using rule 13 (rule -> decVar COLON .)
    NOT             reduce using rule 13 (rule -> decVar COLON .)
    $end            reduce using rule 13 (rule -> decVar COLON .)
    RLLAVE          reduce using rule 13 (rule -> decVar COLON .)
    INT32           reduce using rule 13 (rule -> decVar COLON .)
    INT64           reduce using rule 13 (rule -> decVar COLON .)
    FLOAT32         reduce using rule 13 (rule -> decVar COLON .)
    FLOAT64         reduce using rule 13 (rule -> decVar COLON .)
    BYTE            reduce using rule 13 (rule -> decVar COLON .)
    WINT            reduce using rule 13 (rule -> decVar COLON .)
    WFLOAT          reduce using rule 13 (rule -> decVar COLON .)
    WSTRING         reduce using rule 13 (rule -> decVar COLON .)
    BOOL            reduce using rule 13 (rule -> decVar COLON .)
    DEFAULT         reduce using rule 13 (rule -> decVar COLON .)
    CASE            reduce using rule 13 (rule -> decVar COLON .)
    RETURN          reduce using rule 13 (rule -> decVar COLON .)


state 63

    (16) rule -> var_asignation COLON .

    PRINT           reduce using rule 16 (rule -> var_asignation COLON .)
    SCAN            reduce using rule 16 (rule -> var_asignation COLON .)
    FOR             reduce using rule 16 (rule -> var_asignation COLON .)
    ID              reduce using rule 16 (rule -> var_asignation COLON .)
    APPEND          reduce using rule 16 (rule -> var_asignation COLON .)
    LEN             reduce using rule 16 (rule -> var_asignation COLON .)
    COPY            reduce using rule 16 (rule -> var_asignation COLON .)
    DELETE          reduce using rule 16 (rule -> var_asignation COLON .)
    IF              reduce using rule 16 (rule -> var_asignation COLON .)
    ELSE            reduce using rule 16 (rule -> var_asignation COLON .)
    TYPE            reduce using rule 16 (rule -> var_asignation COLON .)
    SWITCH          reduce using rule 16 (rule -> var_asignation COLON .)
    VAR             reduce using rule 16 (rule -> var_asignation COLON .)
    FUNC            reduce using rule 16 (rule -> var_asignation COLON .)
    INTEGER         reduce using rule 16 (rule -> var_asignation COLON .)
    FLOAT           reduce using rule 16 (rule -> var_asignation COLON .)
    NOT             reduce using rule 16 (rule -> var_asignation COLON .)
    $end            reduce using rule 16 (rule -> var_asignation COLON .)
    RLLAVE          reduce using rule 16 (rule -> var_asignation COLON .)
    INT32           reduce using rule 16 (rule -> var_asignation COLON .)
    INT64           reduce using rule 16 (rule -> var_asignation COLON .)
    FLOAT32         reduce using rule 16 (rule -> var_asignation COLON .)
    FLOAT64         reduce using rule 16 (rule -> var_asignation COLON .)
    BYTE            reduce using rule 16 (rule -> var_asignation COLON .)
    WINT            reduce using rule 16 (rule -> var_asignation COLON .)
    WFLOAT          reduce using rule 16 (rule -> var_asignation COLON .)
    WSTRING         reduce using rule 16 (rule -> var_asignation COLON .)
    BOOL            reduce using rule 16 (rule -> var_asignation COLON .)
    DEFAULT         reduce using rule 16 (rule -> var_asignation COLON .)
    CASE            reduce using rule 16 (rule -> var_asignation COLON .)
    RETURN          reduce using rule 16 (rule -> var_asignation COLON .)


state 64

    (18) rule -> funciones COLON .

    PRINT           reduce using rule 18 (rule -> funciones COLON .)
    SCAN            reduce using rule 18 (rule -> funciones COLON .)
    FOR             reduce using rule 18 (rule -> funciones COLON .)
    ID              reduce using rule 18 (rule -> funciones COLON .)
    APPEND          reduce using rule 18 (rule -> funciones COLON .)
    LEN             reduce using rule 18 (rule -> funciones COLON .)
    COPY            reduce using rule 18 (rule -> funciones COLON .)
    DELETE          reduce using rule 18 (rule -> funciones COLON .)
    IF              reduce using rule 18 (rule -> funciones COLON .)
    ELSE            reduce using rule 18 (rule -> funciones COLON .)
    TYPE            reduce using rule 18 (rule -> funciones COLON .)
    SWITCH          reduce using rule 18 (rule -> funciones COLON .)
    VAR             reduce using rule 18 (rule -> funciones COLON .)
    FUNC            reduce using rule 18 (rule -> funciones COLON .)
    INTEGER         reduce using rule 18 (rule -> funciones COLON .)
    FLOAT           reduce using rule 18 (rule -> funciones COLON .)
    NOT             reduce using rule 18 (rule -> funciones COLON .)
    $end            reduce using rule 18 (rule -> funciones COLON .)
    RLLAVE          reduce using rule 18 (rule -> funciones COLON .)
    INT32           reduce using rule 18 (rule -> funciones COLON .)
    INT64           reduce using rule 18 (rule -> funciones COLON .)
    FLOAT32         reduce using rule 18 (rule -> funciones COLON .)
    FLOAT64         reduce using rule 18 (rule -> funciones COLON .)
    BYTE            reduce using rule 18 (rule -> funciones COLON .)
    WINT            reduce using rule 18 (rule -> funciones COLON .)
    WFLOAT          reduce using rule 18 (rule -> funciones COLON .)
    WSTRING         reduce using rule 18 (rule -> funciones COLON .)
    BOOL            reduce using rule 18 (rule -> funciones COLON .)
    DEFAULT         reduce using rule 18 (rule -> funciones COLON .)
    CASE            reduce using rule 18 (rule -> funciones COLON .)
    RETURN          reduce using rule 18 (rule -> funciones COLON .)


state 65

    (25) rule -> array_declaration COLON .

    PRINT           reduce using rule 25 (rule -> array_declaration COLON .)
    SCAN            reduce using rule 25 (rule -> array_declaration COLON .)
    FOR             reduce using rule 25 (rule -> array_declaration COLON .)
    ID              reduce using rule 25 (rule -> array_declaration COLON .)
    APPEND          reduce using rule 25 (rule -> array_declaration COLON .)
    LEN             reduce using rule 25 (rule -> array_declaration COLON .)
    COPY            reduce using rule 25 (rule -> array_declaration COLON .)
    DELETE          reduce using rule 25 (rule -> array_declaration COLON .)
    IF              reduce using rule 25 (rule -> array_declaration COLON .)
    ELSE            reduce using rule 25 (rule -> array_declaration COLON .)
    TYPE            reduce using rule 25 (rule -> array_declaration COLON .)
    SWITCH          reduce using rule 25 (rule -> array_declaration COLON .)
    VAR             reduce using rule 25 (rule -> array_declaration COLON .)
    FUNC            reduce using rule 25 (rule -> array_declaration COLON .)
    INTEGER         reduce using rule 25 (rule -> array_declaration COLON .)
    FLOAT           reduce using rule 25 (rule -> array_declaration COLON .)
    NOT             reduce using rule 25 (rule -> array_declaration COLON .)
    $end            reduce using rule 25 (rule -> array_declaration COLON .)
    RLLAVE          reduce using rule 25 (rule -> array_declaration COLON .)
    INT32           reduce using rule 25 (rule -> array_declaration COLON .)
    INT64           reduce using rule 25 (rule -> array_declaration COLON .)
    FLOAT32         reduce using rule 25 (rule -> array_declaration COLON .)
    FLOAT64         reduce using rule 25 (rule -> array_declaration COLON .)
    BYTE            reduce using rule 25 (rule -> array_declaration COLON .)
    WINT            reduce using rule 25 (rule -> array_declaration COLON .)
    WFLOAT          reduce using rule 25 (rule -> array_declaration COLON .)
    WSTRING         reduce using rule 25 (rule -> array_declaration COLON .)
    BOOL            reduce using rule 25 (rule -> array_declaration COLON .)
    DEFAULT         reduce using rule 25 (rule -> array_declaration COLON .)
    CASE            reduce using rule 25 (rule -> array_declaration COLON .)
    RETURN          reduce using rule 25 (rule -> array_declaration COLON .)


state 66

    (27) rule -> array_var COLON .

    PRINT           reduce using rule 27 (rule -> array_var COLON .)
    SCAN            reduce using rule 27 (rule -> array_var COLON .)
    FOR             reduce using rule 27 (rule -> array_var COLON .)
    ID              reduce using rule 27 (rule -> array_var COLON .)
    APPEND          reduce using rule 27 (rule -> array_var COLON .)
    LEN             reduce using rule 27 (rule -> array_var COLON .)
    COPY            reduce using rule 27 (rule -> array_var COLON .)
    DELETE          reduce using rule 27 (rule -> array_var COLON .)
    IF              reduce using rule 27 (rule -> array_var COLON .)
    ELSE            reduce using rule 27 (rule -> array_var COLON .)
    TYPE            reduce using rule 27 (rule -> array_var COLON .)
    SWITCH          reduce using rule 27 (rule -> array_var COLON .)
    VAR             reduce using rule 27 (rule -> array_var COLON .)
    FUNC            reduce using rule 27 (rule -> array_var COLON .)
    INTEGER         reduce using rule 27 (rule -> array_var COLON .)
    FLOAT           reduce using rule 27 (rule -> array_var COLON .)
    NOT             reduce using rule 27 (rule -> array_var COLON .)
    $end            reduce using rule 27 (rule -> array_var COLON .)
    RLLAVE          reduce using rule 27 (rule -> array_var COLON .)
    INT32           reduce using rule 27 (rule -> array_var COLON .)
    INT64           reduce using rule 27 (rule -> array_var COLON .)
    FLOAT32         reduce using rule 27 (rule -> array_var COLON .)
    FLOAT64         reduce using rule 27 (rule -> array_var COLON .)
    BYTE            reduce using rule 27 (rule -> array_var COLON .)
    WINT            reduce using rule 27 (rule -> array_var COLON .)
    WFLOAT          reduce using rule 27 (rule -> array_var COLON .)
    WSTRING         reduce using rule 27 (rule -> array_var COLON .)
    BOOL            reduce using rule 27 (rule -> array_var COLON .)
    DEFAULT         reduce using rule 27 (rule -> array_var COLON .)
    CASE            reduce using rule 27 (rule -> array_var COLON .)
    RETURN          reduce using rule 27 (rule -> array_var COLON .)


state 67

    (200) array_assignment -> array_var EQUAL . something
    (75) something -> . ID
    (76) something -> . data_structure
    (77) something -> . values
    (78) something -> . operations
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 136
    STRING          shift and go to state 140
    INTEGER         shift and go to state 141
    FLOAT           shift and go to state 142
    TRUE            shift and go to state 143
    FALSE           shift and go to state 144
    NOT             shift and go to state 54
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    array_var                      shift and go to state 96
    something                      shift and go to state 135
    data_structure                 shift and go to state 137
    values                         shift and go to state 138
    operations                     shift and go to state 139
    map_var                        shift and go to state 97
    expression                     shift and go to state 145
    comparison                     shift and go to state 146
    logic_operation                shift and go to state 147
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    funciones                      shift and go to state 95
    call_func                      shift and go to state 43

state 68

    (29) rule -> array_assignment COLON .

    PRINT           reduce using rule 29 (rule -> array_assignment COLON .)
    SCAN            reduce using rule 29 (rule -> array_assignment COLON .)
    FOR             reduce using rule 29 (rule -> array_assignment COLON .)
    ID              reduce using rule 29 (rule -> array_assignment COLON .)
    APPEND          reduce using rule 29 (rule -> array_assignment COLON .)
    LEN             reduce using rule 29 (rule -> array_assignment COLON .)
    COPY            reduce using rule 29 (rule -> array_assignment COLON .)
    DELETE          reduce using rule 29 (rule -> array_assignment COLON .)
    IF              reduce using rule 29 (rule -> array_assignment COLON .)
    ELSE            reduce using rule 29 (rule -> array_assignment COLON .)
    TYPE            reduce using rule 29 (rule -> array_assignment COLON .)
    SWITCH          reduce using rule 29 (rule -> array_assignment COLON .)
    VAR             reduce using rule 29 (rule -> array_assignment COLON .)
    FUNC            reduce using rule 29 (rule -> array_assignment COLON .)
    INTEGER         reduce using rule 29 (rule -> array_assignment COLON .)
    FLOAT           reduce using rule 29 (rule -> array_assignment COLON .)
    NOT             reduce using rule 29 (rule -> array_assignment COLON .)
    $end            reduce using rule 29 (rule -> array_assignment COLON .)
    RLLAVE          reduce using rule 29 (rule -> array_assignment COLON .)
    INT32           reduce using rule 29 (rule -> array_assignment COLON .)
    INT64           reduce using rule 29 (rule -> array_assignment COLON .)
    FLOAT32         reduce using rule 29 (rule -> array_assignment COLON .)
    FLOAT64         reduce using rule 29 (rule -> array_assignment COLON .)
    BYTE            reduce using rule 29 (rule -> array_assignment COLON .)
    WINT            reduce using rule 29 (rule -> array_assignment COLON .)
    WFLOAT          reduce using rule 29 (rule -> array_assignment COLON .)
    WSTRING         reduce using rule 29 (rule -> array_assignment COLON .)
    BOOL            reduce using rule 29 (rule -> array_assignment COLON .)
    DEFAULT         reduce using rule 29 (rule -> array_assignment COLON .)
    CASE            reduce using rule 29 (rule -> array_assignment COLON .)
    RETURN          reduce using rule 29 (rule -> array_assignment COLON .)


state 69

    (31) rule -> slice_declaration COLON .

    PRINT           reduce using rule 31 (rule -> slice_declaration COLON .)
    SCAN            reduce using rule 31 (rule -> slice_declaration COLON .)
    FOR             reduce using rule 31 (rule -> slice_declaration COLON .)
    ID              reduce using rule 31 (rule -> slice_declaration COLON .)
    APPEND          reduce using rule 31 (rule -> slice_declaration COLON .)
    LEN             reduce using rule 31 (rule -> slice_declaration COLON .)
    COPY            reduce using rule 31 (rule -> slice_declaration COLON .)
    DELETE          reduce using rule 31 (rule -> slice_declaration COLON .)
    IF              reduce using rule 31 (rule -> slice_declaration COLON .)
    ELSE            reduce using rule 31 (rule -> slice_declaration COLON .)
    TYPE            reduce using rule 31 (rule -> slice_declaration COLON .)
    SWITCH          reduce using rule 31 (rule -> slice_declaration COLON .)
    VAR             reduce using rule 31 (rule -> slice_declaration COLON .)
    FUNC            reduce using rule 31 (rule -> slice_declaration COLON .)
    INTEGER         reduce using rule 31 (rule -> slice_declaration COLON .)
    FLOAT           reduce using rule 31 (rule -> slice_declaration COLON .)
    NOT             reduce using rule 31 (rule -> slice_declaration COLON .)
    $end            reduce using rule 31 (rule -> slice_declaration COLON .)
    RLLAVE          reduce using rule 31 (rule -> slice_declaration COLON .)
    INT32           reduce using rule 31 (rule -> slice_declaration COLON .)
    INT64           reduce using rule 31 (rule -> slice_declaration COLON .)
    FLOAT32         reduce using rule 31 (rule -> slice_declaration COLON .)
    FLOAT64         reduce using rule 31 (rule -> slice_declaration COLON .)
    BYTE            reduce using rule 31 (rule -> slice_declaration COLON .)
    WINT            reduce using rule 31 (rule -> slice_declaration COLON .)
    WFLOAT          reduce using rule 31 (rule -> slice_declaration COLON .)
    WSTRING         reduce using rule 31 (rule -> slice_declaration COLON .)
    BOOL            reduce using rule 31 (rule -> slice_declaration COLON .)
    DEFAULT         reduce using rule 31 (rule -> slice_declaration COLON .)
    CASE            reduce using rule 31 (rule -> slice_declaration COLON .)
    RETURN          reduce using rule 31 (rule -> slice_declaration COLON .)


state 70

    (33) rule -> slice_var COLON .

    PRINT           reduce using rule 33 (rule -> slice_var COLON .)
    SCAN            reduce using rule 33 (rule -> slice_var COLON .)
    FOR             reduce using rule 33 (rule -> slice_var COLON .)
    ID              reduce using rule 33 (rule -> slice_var COLON .)
    APPEND          reduce using rule 33 (rule -> slice_var COLON .)
    LEN             reduce using rule 33 (rule -> slice_var COLON .)
    COPY            reduce using rule 33 (rule -> slice_var COLON .)
    DELETE          reduce using rule 33 (rule -> slice_var COLON .)
    IF              reduce using rule 33 (rule -> slice_var COLON .)
    ELSE            reduce using rule 33 (rule -> slice_var COLON .)
    TYPE            reduce using rule 33 (rule -> slice_var COLON .)
    SWITCH          reduce using rule 33 (rule -> slice_var COLON .)
    VAR             reduce using rule 33 (rule -> slice_var COLON .)
    FUNC            reduce using rule 33 (rule -> slice_var COLON .)
    INTEGER         reduce using rule 33 (rule -> slice_var COLON .)
    FLOAT           reduce using rule 33 (rule -> slice_var COLON .)
    NOT             reduce using rule 33 (rule -> slice_var COLON .)
    $end            reduce using rule 33 (rule -> slice_var COLON .)
    RLLAVE          reduce using rule 33 (rule -> slice_var COLON .)
    INT32           reduce using rule 33 (rule -> slice_var COLON .)
    INT64           reduce using rule 33 (rule -> slice_var COLON .)
    FLOAT32         reduce using rule 33 (rule -> slice_var COLON .)
    FLOAT64         reduce using rule 33 (rule -> slice_var COLON .)
    BYTE            reduce using rule 33 (rule -> slice_var COLON .)
    WINT            reduce using rule 33 (rule -> slice_var COLON .)
    WFLOAT          reduce using rule 33 (rule -> slice_var COLON .)
    WSTRING         reduce using rule 33 (rule -> slice_var COLON .)
    BOOL            reduce using rule 33 (rule -> slice_var COLON .)
    DEFAULT         reduce using rule 33 (rule -> slice_var COLON .)
    CASE            reduce using rule 33 (rule -> slice_var COLON .)
    RETURN          reduce using rule 33 (rule -> slice_var COLON .)


state 71

    (135) slice_assignment -> slice_var EQUAL . something_s
    (136) something_s -> . ID
    (137) something_s -> . array_var
    (138) something_s -> . values
    (139) something_s -> . operations
    (196) array_var -> . ID LCORCHE index RCORCHE
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 149
    STRING          shift and go to state 140
    INTEGER         shift and go to state 141
    FLOAT           shift and go to state 142
    TRUE            shift and go to state 143
    FALSE           shift and go to state 144
    NOT             shift and go to state 54
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    something_s                    shift and go to state 148
    array_var                      shift and go to state 150
    values                         shift and go to state 151
    operations                     shift and go to state 152
    expression                     shift and go to state 145
    comparison                     shift and go to state 146
    logic_operation                shift and go to state 147
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 72

    (35) rule -> slice_assignment COLON .

    PRINT           reduce using rule 35 (rule -> slice_assignment COLON .)
    SCAN            reduce using rule 35 (rule -> slice_assignment COLON .)
    FOR             reduce using rule 35 (rule -> slice_assignment COLON .)
    ID              reduce using rule 35 (rule -> slice_assignment COLON .)
    APPEND          reduce using rule 35 (rule -> slice_assignment COLON .)
    LEN             reduce using rule 35 (rule -> slice_assignment COLON .)
    COPY            reduce using rule 35 (rule -> slice_assignment COLON .)
    DELETE          reduce using rule 35 (rule -> slice_assignment COLON .)
    IF              reduce using rule 35 (rule -> slice_assignment COLON .)
    ELSE            reduce using rule 35 (rule -> slice_assignment COLON .)
    TYPE            reduce using rule 35 (rule -> slice_assignment COLON .)
    SWITCH          reduce using rule 35 (rule -> slice_assignment COLON .)
    VAR             reduce using rule 35 (rule -> slice_assignment COLON .)
    FUNC            reduce using rule 35 (rule -> slice_assignment COLON .)
    INTEGER         reduce using rule 35 (rule -> slice_assignment COLON .)
    FLOAT           reduce using rule 35 (rule -> slice_assignment COLON .)
    NOT             reduce using rule 35 (rule -> slice_assignment COLON .)
    $end            reduce using rule 35 (rule -> slice_assignment COLON .)
    RLLAVE          reduce using rule 35 (rule -> slice_assignment COLON .)
    INT32           reduce using rule 35 (rule -> slice_assignment COLON .)
    INT64           reduce using rule 35 (rule -> slice_assignment COLON .)
    FLOAT32         reduce using rule 35 (rule -> slice_assignment COLON .)
    FLOAT64         reduce using rule 35 (rule -> slice_assignment COLON .)
    BYTE            reduce using rule 35 (rule -> slice_assignment COLON .)
    WINT            reduce using rule 35 (rule -> slice_assignment COLON .)
    WFLOAT          reduce using rule 35 (rule -> slice_assignment COLON .)
    WSTRING         reduce using rule 35 (rule -> slice_assignment COLON .)
    BOOL            reduce using rule 35 (rule -> slice_assignment COLON .)
    DEFAULT         reduce using rule 35 (rule -> slice_assignment COLON .)
    CASE            reduce using rule 35 (rule -> slice_assignment COLON .)
    RETURN          reduce using rule 35 (rule -> slice_assignment COLON .)


state 73

    (37) rule -> map_declaration COLON .

    PRINT           reduce using rule 37 (rule -> map_declaration COLON .)
    SCAN            reduce using rule 37 (rule -> map_declaration COLON .)
    FOR             reduce using rule 37 (rule -> map_declaration COLON .)
    ID              reduce using rule 37 (rule -> map_declaration COLON .)
    APPEND          reduce using rule 37 (rule -> map_declaration COLON .)
    LEN             reduce using rule 37 (rule -> map_declaration COLON .)
    COPY            reduce using rule 37 (rule -> map_declaration COLON .)
    DELETE          reduce using rule 37 (rule -> map_declaration COLON .)
    IF              reduce using rule 37 (rule -> map_declaration COLON .)
    ELSE            reduce using rule 37 (rule -> map_declaration COLON .)
    TYPE            reduce using rule 37 (rule -> map_declaration COLON .)
    SWITCH          reduce using rule 37 (rule -> map_declaration COLON .)
    VAR             reduce using rule 37 (rule -> map_declaration COLON .)
    FUNC            reduce using rule 37 (rule -> map_declaration COLON .)
    INTEGER         reduce using rule 37 (rule -> map_declaration COLON .)
    FLOAT           reduce using rule 37 (rule -> map_declaration COLON .)
    NOT             reduce using rule 37 (rule -> map_declaration COLON .)
    $end            reduce using rule 37 (rule -> map_declaration COLON .)
    RLLAVE          reduce using rule 37 (rule -> map_declaration COLON .)
    INT32           reduce using rule 37 (rule -> map_declaration COLON .)
    INT64           reduce using rule 37 (rule -> map_declaration COLON .)
    FLOAT32         reduce using rule 37 (rule -> map_declaration COLON .)
    FLOAT64         reduce using rule 37 (rule -> map_declaration COLON .)
    BYTE            reduce using rule 37 (rule -> map_declaration COLON .)
    WINT            reduce using rule 37 (rule -> map_declaration COLON .)
    WFLOAT          reduce using rule 37 (rule -> map_declaration COLON .)
    WSTRING         reduce using rule 37 (rule -> map_declaration COLON .)
    BOOL            reduce using rule 37 (rule -> map_declaration COLON .)
    DEFAULT         reduce using rule 37 (rule -> map_declaration COLON .)
    CASE            reduce using rule 37 (rule -> map_declaration COLON .)
    RETURN          reduce using rule 37 (rule -> map_declaration COLON .)


state 74

    (39) rule -> map_assignment COLON .

    PRINT           reduce using rule 39 (rule -> map_assignment COLON .)
    SCAN            reduce using rule 39 (rule -> map_assignment COLON .)
    FOR             reduce using rule 39 (rule -> map_assignment COLON .)
    ID              reduce using rule 39 (rule -> map_assignment COLON .)
    APPEND          reduce using rule 39 (rule -> map_assignment COLON .)
    LEN             reduce using rule 39 (rule -> map_assignment COLON .)
    COPY            reduce using rule 39 (rule -> map_assignment COLON .)
    DELETE          reduce using rule 39 (rule -> map_assignment COLON .)
    IF              reduce using rule 39 (rule -> map_assignment COLON .)
    ELSE            reduce using rule 39 (rule -> map_assignment COLON .)
    TYPE            reduce using rule 39 (rule -> map_assignment COLON .)
    SWITCH          reduce using rule 39 (rule -> map_assignment COLON .)
    VAR             reduce using rule 39 (rule -> map_assignment COLON .)
    FUNC            reduce using rule 39 (rule -> map_assignment COLON .)
    INTEGER         reduce using rule 39 (rule -> map_assignment COLON .)
    FLOAT           reduce using rule 39 (rule -> map_assignment COLON .)
    NOT             reduce using rule 39 (rule -> map_assignment COLON .)
    $end            reduce using rule 39 (rule -> map_assignment COLON .)
    RLLAVE          reduce using rule 39 (rule -> map_assignment COLON .)
    INT32           reduce using rule 39 (rule -> map_assignment COLON .)
    INT64           reduce using rule 39 (rule -> map_assignment COLON .)
    FLOAT32         reduce using rule 39 (rule -> map_assignment COLON .)
    FLOAT64         reduce using rule 39 (rule -> map_assignment COLON .)
    BYTE            reduce using rule 39 (rule -> map_assignment COLON .)
    WINT            reduce using rule 39 (rule -> map_assignment COLON .)
    WFLOAT          reduce using rule 39 (rule -> map_assignment COLON .)
    WSTRING         reduce using rule 39 (rule -> map_assignment COLON .)
    BOOL            reduce using rule 39 (rule -> map_assignment COLON .)
    DEFAULT         reduce using rule 39 (rule -> map_assignment COLON .)
    CASE            reduce using rule 39 (rule -> map_assignment COLON .)
    RETURN          reduce using rule 39 (rule -> map_assignment COLON .)


state 75

    (218) impresion -> PRINT LPAREN . content RPAREN
    (219) content -> . values
    (220) content -> . operations
    (221) content -> . funciones
    (222) content -> . data_structure
    (223) content -> . ID
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID

    ID              shift and go to state 158
    STRING          shift and go to state 140
    INTEGER         shift and go to state 141
    FLOAT           shift and go to state 142
    TRUE            shift and go to state 143
    FALSE           shift and go to state 144
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    NOT             shift and go to state 54

    content                        shift and go to state 153
    values                         shift and go to state 154
    operations                     shift and go to state 155
    funciones                      shift and go to state 156
    data_structure                 shift and go to state 157
    expression                     shift and go to state 145
    comparison                     shift and go to state 146
    logic_operation                shift and go to state 147
    call_func                      shift and go to state 43
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35

state 76

    (80) scan_func -> SCAN LPAREN . POINTER RPAREN

    POINTER         shift and go to state 159


state 77

    (225) expression -> something_ex adicionaEx .

    COLON           reduce using rule 225 (expression -> something_ex adicionaEx .)
    PRINT           reduce using rule 225 (expression -> something_ex adicionaEx .)
    SCAN            reduce using rule 225 (expression -> something_ex adicionaEx .)
    FOR             reduce using rule 225 (expression -> something_ex adicionaEx .)
    ID              reduce using rule 225 (expression -> something_ex adicionaEx .)
    APPEND          reduce using rule 225 (expression -> something_ex adicionaEx .)
    LEN             reduce using rule 225 (expression -> something_ex adicionaEx .)
    COPY            reduce using rule 225 (expression -> something_ex adicionaEx .)
    DELETE          reduce using rule 225 (expression -> something_ex adicionaEx .)
    IF              reduce using rule 225 (expression -> something_ex adicionaEx .)
    ELSE            reduce using rule 225 (expression -> something_ex adicionaEx .)
    TYPE            reduce using rule 225 (expression -> something_ex adicionaEx .)
    SWITCH          reduce using rule 225 (expression -> something_ex adicionaEx .)
    VAR             reduce using rule 225 (expression -> something_ex adicionaEx .)
    FUNC            reduce using rule 225 (expression -> something_ex adicionaEx .)
    INTEGER         reduce using rule 225 (expression -> something_ex adicionaEx .)
    FLOAT           reduce using rule 225 (expression -> something_ex adicionaEx .)
    NOT             reduce using rule 225 (expression -> something_ex adicionaEx .)
    $end            reduce using rule 225 (expression -> something_ex adicionaEx .)
    GREATER         reduce using rule 225 (expression -> something_ex adicionaEx .)
    SMALLER         reduce using rule 225 (expression -> something_ex adicionaEx .)
    GREATER_OR_EQUAL reduce using rule 225 (expression -> something_ex adicionaEx .)
    SMALLER_OR_EQUAL reduce using rule 225 (expression -> something_ex adicionaEx .)
    EQUAL_COMPARE   reduce using rule 225 (expression -> something_ex adicionaEx .)
    NOT_EQUAL       reduce using rule 225 (expression -> something_ex adicionaEx .)
    PLUS            reduce using rule 225 (expression -> something_ex adicionaEx .)
    TIMES           reduce using rule 225 (expression -> something_ex adicionaEx .)
    DIVIDE          reduce using rule 225 (expression -> something_ex adicionaEx .)
    MINUS           reduce using rule 225 (expression -> something_ex adicionaEx .)
    RLLAVE          reduce using rule 225 (expression -> something_ex adicionaEx .)
    INT32           reduce using rule 225 (expression -> something_ex adicionaEx .)
    INT64           reduce using rule 225 (expression -> something_ex adicionaEx .)
    FLOAT32         reduce using rule 225 (expression -> something_ex adicionaEx .)
    FLOAT64         reduce using rule 225 (expression -> something_ex adicionaEx .)
    BYTE            reduce using rule 225 (expression -> something_ex adicionaEx .)
    WINT            reduce using rule 225 (expression -> something_ex adicionaEx .)
    WFLOAT          reduce using rule 225 (expression -> something_ex adicionaEx .)
    WSTRING         reduce using rule 225 (expression -> something_ex adicionaEx .)
    BOOL            reduce using rule 225 (expression -> something_ex adicionaEx .)
    DEFAULT         reduce using rule 225 (expression -> something_ex adicionaEx .)
    CASE            reduce using rule 225 (expression -> something_ex adicionaEx .)
    RETURN          reduce using rule 225 (expression -> something_ex adicionaEx .)
    RPAREN          reduce using rule 225 (expression -> something_ex adicionaEx .)
    AND             reduce using rule 225 (expression -> something_ex adicionaEx .)
    OR              reduce using rule 225 (expression -> something_ex adicionaEx .)
    LLLAVE          reduce using rule 225 (expression -> something_ex adicionaEx .)
    RCORCHE         reduce using rule 225 (expression -> something_ex adicionaEx .)
    COMA            reduce using rule 225 (expression -> something_ex adicionaEx .)


state 78

    (226) adicionaEx -> op . something_ex
    (227) adicionaEx -> op . something_ex adicionaEx
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 161
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    something_ex                   shift and go to state 160
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 79

    (169) op -> GREATER .

    ID              reduce using rule 169 (op -> GREATER .)
    INTEGER         reduce using rule 169 (op -> GREATER .)
    FLOAT           reduce using rule 169 (op -> GREATER .)
    APPEND          reduce using rule 169 (op -> GREATER .)
    LEN             reduce using rule 169 (op -> GREATER .)
    COPY            reduce using rule 169 (op -> GREATER .)
    DELETE          reduce using rule 169 (op -> GREATER .)


state 80

    (170) op -> SMALLER .

    ID              reduce using rule 170 (op -> SMALLER .)
    INTEGER         reduce using rule 170 (op -> SMALLER .)
    FLOAT           reduce using rule 170 (op -> SMALLER .)
    APPEND          reduce using rule 170 (op -> SMALLER .)
    LEN             reduce using rule 170 (op -> SMALLER .)
    COPY            reduce using rule 170 (op -> SMALLER .)
    DELETE          reduce using rule 170 (op -> SMALLER .)


state 81

    (171) op -> GREATER_OR_EQUAL .

    ID              reduce using rule 171 (op -> GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 171 (op -> GREATER_OR_EQUAL .)
    FLOAT           reduce using rule 171 (op -> GREATER_OR_EQUAL .)
    APPEND          reduce using rule 171 (op -> GREATER_OR_EQUAL .)
    LEN             reduce using rule 171 (op -> GREATER_OR_EQUAL .)
    COPY            reduce using rule 171 (op -> GREATER_OR_EQUAL .)
    DELETE          reduce using rule 171 (op -> GREATER_OR_EQUAL .)


state 82

    (172) op -> SMALLER_OR_EQUAL .

    ID              reduce using rule 172 (op -> SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 172 (op -> SMALLER_OR_EQUAL .)
    FLOAT           reduce using rule 172 (op -> SMALLER_OR_EQUAL .)
    APPEND          reduce using rule 172 (op -> SMALLER_OR_EQUAL .)
    LEN             reduce using rule 172 (op -> SMALLER_OR_EQUAL .)
    COPY            reduce using rule 172 (op -> SMALLER_OR_EQUAL .)
    DELETE          reduce using rule 172 (op -> SMALLER_OR_EQUAL .)


state 83

    (173) op -> EQUAL_COMPARE .

    ID              reduce using rule 173 (op -> EQUAL_COMPARE .)
    INTEGER         reduce using rule 173 (op -> EQUAL_COMPARE .)
    FLOAT           reduce using rule 173 (op -> EQUAL_COMPARE .)
    APPEND          reduce using rule 173 (op -> EQUAL_COMPARE .)
    LEN             reduce using rule 173 (op -> EQUAL_COMPARE .)
    COPY            reduce using rule 173 (op -> EQUAL_COMPARE .)
    DELETE          reduce using rule 173 (op -> EQUAL_COMPARE .)


state 84

    (174) op -> NOT_EQUAL .

    ID              reduce using rule 174 (op -> NOT_EQUAL .)
    INTEGER         reduce using rule 174 (op -> NOT_EQUAL .)
    FLOAT           reduce using rule 174 (op -> NOT_EQUAL .)
    APPEND          reduce using rule 174 (op -> NOT_EQUAL .)
    LEN             reduce using rule 174 (op -> NOT_EQUAL .)
    COPY            reduce using rule 174 (op -> NOT_EQUAL .)
    DELETE          reduce using rule 174 (op -> NOT_EQUAL .)


state 85

    (233) op -> PLUS .

    ID              reduce using rule 233 (op -> PLUS .)
    INTEGER         reduce using rule 233 (op -> PLUS .)
    FLOAT           reduce using rule 233 (op -> PLUS .)
    APPEND          reduce using rule 233 (op -> PLUS .)
    LEN             reduce using rule 233 (op -> PLUS .)
    COPY            reduce using rule 233 (op -> PLUS .)
    DELETE          reduce using rule 233 (op -> PLUS .)


state 86

    (234) op -> TIMES .

    ID              reduce using rule 234 (op -> TIMES .)
    INTEGER         reduce using rule 234 (op -> TIMES .)
    FLOAT           reduce using rule 234 (op -> TIMES .)
    APPEND          reduce using rule 234 (op -> TIMES .)
    LEN             reduce using rule 234 (op -> TIMES .)
    COPY            reduce using rule 234 (op -> TIMES .)
    DELETE          reduce using rule 234 (op -> TIMES .)


state 87

    (235) op -> DIVIDE .

    ID              reduce using rule 235 (op -> DIVIDE .)
    INTEGER         reduce using rule 235 (op -> DIVIDE .)
    FLOAT           reduce using rule 235 (op -> DIVIDE .)
    APPEND          reduce using rule 235 (op -> DIVIDE .)
    LEN             reduce using rule 235 (op -> DIVIDE .)
    COPY            reduce using rule 235 (op -> DIVIDE .)
    DELETE          reduce using rule 235 (op -> DIVIDE .)


state 88

    (236) op -> MINUS .

    ID              reduce using rule 236 (op -> MINUS .)
    INTEGER         reduce using rule 236 (op -> MINUS .)
    FLOAT           reduce using rule 236 (op -> MINUS .)
    APPEND          reduce using rule 236 (op -> MINUS .)
    LEN             reduce using rule 236 (op -> MINUS .)
    COPY            reduce using rule 236 (op -> MINUS .)
    DELETE          reduce using rule 236 (op -> MINUS .)


state 89

    (86) cicloFor -> FOR LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

    codigo                         shift and go to state 162
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 90

    (87) cicloFor -> FOR comparison . LLLAVE codigo RLLAVE
    (180) logic_value -> comparison .

    LLLAVE          shift and go to state 163
    AND             reduce using rule 180 (logic_value -> comparison .)
    OR              reduce using rule 180 (logic_value -> comparison .)


state 91

    (88) cicloFor -> FOR logic_operation . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 164


state 92

    (89) cicloFor -> FOR decVarOne . COLON comparison COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 165


state 93

    (146) decVarOne -> ID . DEQUAL ID
    (147) decVarOne -> ID . DEQUAL INTEGER
    (167) value -> ID .
    (181) logic_value -> ID .
    (228) something_ex -> ID .
    (196) array_var -> ID . LCORCHE index RCORCHE
    (202) map_var -> ID . LCORCHE key RCORCHE
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 167 (value -> ID .)
    DEQUAL          shift and go to state 166
    GREATER         reduce using rule 167 (value -> ID .)
    SMALLER         reduce using rule 167 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 167 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 167 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 167 (value -> ID .)
    NOT_EQUAL       reduce using rule 167 (value -> ID .)
    PLUS            reduce using rule 167 (value -> ID .)
    TIMES           reduce using rule 167 (value -> ID .)
    DIVIDE          reduce using rule 167 (value -> ID .)
    MINUS           reduce using rule 167 (value -> ID .)
    AND             reduce using rule 181 (logic_value -> ID .)
    OR              reduce using rule 181 (logic_value -> ID .)
    LCORCHE         shift and go to state 167
    LPAREN          shift and go to state 106

  ! GREATER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 228 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 228 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 228 (something_ex -> ID .) ]


state 94

    (168) value -> expression .

    GREATER         reduce using rule 168 (value -> expression .)
    SMALLER         reduce using rule 168 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 168 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 168 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 168 (value -> expression .)
    NOT_EQUAL       reduce using rule 168 (value -> expression .)
    PLUS            reduce using rule 168 (value -> expression .)
    TIMES           reduce using rule 168 (value -> expression .)
    DIVIDE          reduce using rule 168 (value -> expression .)
    MINUS           reduce using rule 168 (value -> expression .)
    PRINT           reduce using rule 168 (value -> expression .)
    SCAN            reduce using rule 168 (value -> expression .)
    FOR             reduce using rule 168 (value -> expression .)
    ID              reduce using rule 168 (value -> expression .)
    APPEND          reduce using rule 168 (value -> expression .)
    LEN             reduce using rule 168 (value -> expression .)
    COPY            reduce using rule 168 (value -> expression .)
    DELETE          reduce using rule 168 (value -> expression .)
    IF              reduce using rule 168 (value -> expression .)
    ELSE            reduce using rule 168 (value -> expression .)
    TYPE            reduce using rule 168 (value -> expression .)
    SWITCH          reduce using rule 168 (value -> expression .)
    VAR             reduce using rule 168 (value -> expression .)
    FUNC            reduce using rule 168 (value -> expression .)
    INTEGER         reduce using rule 168 (value -> expression .)
    FLOAT           reduce using rule 168 (value -> expression .)
    NOT             reduce using rule 168 (value -> expression .)
    $end            reduce using rule 168 (value -> expression .)
    AND             reduce using rule 168 (value -> expression .)
    OR              reduce using rule 168 (value -> expression .)
    RLLAVE          reduce using rule 168 (value -> expression .)
    INT32           reduce using rule 168 (value -> expression .)
    INT64           reduce using rule 168 (value -> expression .)
    FLOAT32         reduce using rule 168 (value -> expression .)
    FLOAT64         reduce using rule 168 (value -> expression .)
    BYTE            reduce using rule 168 (value -> expression .)
    WINT            reduce using rule 168 (value -> expression .)
    WFLOAT          reduce using rule 168 (value -> expression .)
    WSTRING         reduce using rule 168 (value -> expression .)
    BOOL            reduce using rule 168 (value -> expression .)
    DEFAULT         reduce using rule 168 (value -> expression .)
    CASE            reduce using rule 168 (value -> expression .)
    RETURN          reduce using rule 168 (value -> expression .)
    LLLAVE          reduce using rule 168 (value -> expression .)
    COLON           reduce using rule 168 (value -> expression .)
    RPAREN          reduce using rule 168 (value -> expression .)
    RCORCHE         reduce using rule 168 (value -> expression .)
    COMA            reduce using rule 168 (value -> expression .)


state 95

    (232) something_ex -> funciones .

    GREATER         reduce using rule 232 (something_ex -> funciones .)
    SMALLER         reduce using rule 232 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 232 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 232 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 232 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 232 (something_ex -> funciones .)
    PLUS            reduce using rule 232 (something_ex -> funciones .)
    TIMES           reduce using rule 232 (something_ex -> funciones .)
    DIVIDE          reduce using rule 232 (something_ex -> funciones .)
    MINUS           reduce using rule 232 (something_ex -> funciones .)
    COLON           reduce using rule 232 (something_ex -> funciones .)
    PRINT           reduce using rule 232 (something_ex -> funciones .)
    SCAN            reduce using rule 232 (something_ex -> funciones .)
    FOR             reduce using rule 232 (something_ex -> funciones .)
    ID              reduce using rule 232 (something_ex -> funciones .)
    APPEND          reduce using rule 232 (something_ex -> funciones .)
    LEN             reduce using rule 232 (something_ex -> funciones .)
    COPY            reduce using rule 232 (something_ex -> funciones .)
    DELETE          reduce using rule 232 (something_ex -> funciones .)
    IF              reduce using rule 232 (something_ex -> funciones .)
    ELSE            reduce using rule 232 (something_ex -> funciones .)
    TYPE            reduce using rule 232 (something_ex -> funciones .)
    SWITCH          reduce using rule 232 (something_ex -> funciones .)
    VAR             reduce using rule 232 (something_ex -> funciones .)
    FUNC            reduce using rule 232 (something_ex -> funciones .)
    INTEGER         reduce using rule 232 (something_ex -> funciones .)
    FLOAT           reduce using rule 232 (something_ex -> funciones .)
    NOT             reduce using rule 232 (something_ex -> funciones .)
    $end            reduce using rule 232 (something_ex -> funciones .)
    RLLAVE          reduce using rule 232 (something_ex -> funciones .)
    INT32           reduce using rule 232 (something_ex -> funciones .)
    INT64           reduce using rule 232 (something_ex -> funciones .)
    FLOAT32         reduce using rule 232 (something_ex -> funciones .)
    FLOAT64         reduce using rule 232 (something_ex -> funciones .)
    BYTE            reduce using rule 232 (something_ex -> funciones .)
    WINT            reduce using rule 232 (something_ex -> funciones .)
    WFLOAT          reduce using rule 232 (something_ex -> funciones .)
    WSTRING         reduce using rule 232 (something_ex -> funciones .)
    BOOL            reduce using rule 232 (something_ex -> funciones .)
    DEFAULT         reduce using rule 232 (something_ex -> funciones .)
    CASE            reduce using rule 232 (something_ex -> funciones .)
    RETURN          reduce using rule 232 (something_ex -> funciones .)
    RPAREN          reduce using rule 232 (something_ex -> funciones .)
    AND             reduce using rule 232 (something_ex -> funciones .)
    OR              reduce using rule 232 (something_ex -> funciones .)
    LLLAVE          reduce using rule 232 (something_ex -> funciones .)
    RCORCHE         reduce using rule 232 (something_ex -> funciones .)
    COMA            reduce using rule 232 (something_ex -> funciones .)


state 96

    (60) data_structure -> array_var .

    GREATER         reduce using rule 60 (data_structure -> array_var .)
    SMALLER         reduce using rule 60 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 60 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 60 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 60 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 60 (data_structure -> array_var .)
    PLUS            reduce using rule 60 (data_structure -> array_var .)
    TIMES           reduce using rule 60 (data_structure -> array_var .)
    DIVIDE          reduce using rule 60 (data_structure -> array_var .)
    MINUS           reduce using rule 60 (data_structure -> array_var .)
    COLON           reduce using rule 60 (data_structure -> array_var .)
    PRINT           reduce using rule 60 (data_structure -> array_var .)
    SCAN            reduce using rule 60 (data_structure -> array_var .)
    FOR             reduce using rule 60 (data_structure -> array_var .)
    ID              reduce using rule 60 (data_structure -> array_var .)
    APPEND          reduce using rule 60 (data_structure -> array_var .)
    LEN             reduce using rule 60 (data_structure -> array_var .)
    COPY            reduce using rule 60 (data_structure -> array_var .)
    DELETE          reduce using rule 60 (data_structure -> array_var .)
    IF              reduce using rule 60 (data_structure -> array_var .)
    ELSE            reduce using rule 60 (data_structure -> array_var .)
    TYPE            reduce using rule 60 (data_structure -> array_var .)
    SWITCH          reduce using rule 60 (data_structure -> array_var .)
    VAR             reduce using rule 60 (data_structure -> array_var .)
    FUNC            reduce using rule 60 (data_structure -> array_var .)
    INTEGER         reduce using rule 60 (data_structure -> array_var .)
    FLOAT           reduce using rule 60 (data_structure -> array_var .)
    NOT             reduce using rule 60 (data_structure -> array_var .)
    $end            reduce using rule 60 (data_structure -> array_var .)
    RLLAVE          reduce using rule 60 (data_structure -> array_var .)
    INT32           reduce using rule 60 (data_structure -> array_var .)
    INT64           reduce using rule 60 (data_structure -> array_var .)
    FLOAT32         reduce using rule 60 (data_structure -> array_var .)
    FLOAT64         reduce using rule 60 (data_structure -> array_var .)
    BYTE            reduce using rule 60 (data_structure -> array_var .)
    WINT            reduce using rule 60 (data_structure -> array_var .)
    WFLOAT          reduce using rule 60 (data_structure -> array_var .)
    WSTRING         reduce using rule 60 (data_structure -> array_var .)
    BOOL            reduce using rule 60 (data_structure -> array_var .)
    DEFAULT         reduce using rule 60 (data_structure -> array_var .)
    CASE            reduce using rule 60 (data_structure -> array_var .)
    RETURN          reduce using rule 60 (data_structure -> array_var .)
    RPAREN          reduce using rule 60 (data_structure -> array_var .)
    AND             reduce using rule 60 (data_structure -> array_var .)
    OR              reduce using rule 60 (data_structure -> array_var .)
    LLLAVE          reduce using rule 60 (data_structure -> array_var .)
    RCORCHE         reduce using rule 60 (data_structure -> array_var .)
    COMA            reduce using rule 60 (data_structure -> array_var .)


state 97

    (61) data_structure -> map_var .

    GREATER         reduce using rule 61 (data_structure -> map_var .)
    SMALLER         reduce using rule 61 (data_structure -> map_var .)
    GREATER_OR_EQUAL reduce using rule 61 (data_structure -> map_var .)
    SMALLER_OR_EQUAL reduce using rule 61 (data_structure -> map_var .)
    EQUAL_COMPARE   reduce using rule 61 (data_structure -> map_var .)
    NOT_EQUAL       reduce using rule 61 (data_structure -> map_var .)
    PLUS            reduce using rule 61 (data_structure -> map_var .)
    TIMES           reduce using rule 61 (data_structure -> map_var .)
    DIVIDE          reduce using rule 61 (data_structure -> map_var .)
    MINUS           reduce using rule 61 (data_structure -> map_var .)
    COLON           reduce using rule 61 (data_structure -> map_var .)
    PRINT           reduce using rule 61 (data_structure -> map_var .)
    SCAN            reduce using rule 61 (data_structure -> map_var .)
    FOR             reduce using rule 61 (data_structure -> map_var .)
    ID              reduce using rule 61 (data_structure -> map_var .)
    APPEND          reduce using rule 61 (data_structure -> map_var .)
    LEN             reduce using rule 61 (data_structure -> map_var .)
    COPY            reduce using rule 61 (data_structure -> map_var .)
    DELETE          reduce using rule 61 (data_structure -> map_var .)
    IF              reduce using rule 61 (data_structure -> map_var .)
    ELSE            reduce using rule 61 (data_structure -> map_var .)
    TYPE            reduce using rule 61 (data_structure -> map_var .)
    SWITCH          reduce using rule 61 (data_structure -> map_var .)
    VAR             reduce using rule 61 (data_structure -> map_var .)
    FUNC            reduce using rule 61 (data_structure -> map_var .)
    INTEGER         reduce using rule 61 (data_structure -> map_var .)
    FLOAT           reduce using rule 61 (data_structure -> map_var .)
    NOT             reduce using rule 61 (data_structure -> map_var .)
    $end            reduce using rule 61 (data_structure -> map_var .)
    RLLAVE          reduce using rule 61 (data_structure -> map_var .)
    INT32           reduce using rule 61 (data_structure -> map_var .)
    INT64           reduce using rule 61 (data_structure -> map_var .)
    FLOAT32         reduce using rule 61 (data_structure -> map_var .)
    FLOAT64         reduce using rule 61 (data_structure -> map_var .)
    BYTE            reduce using rule 61 (data_structure -> map_var .)
    WINT            reduce using rule 61 (data_structure -> map_var .)
    WFLOAT          reduce using rule 61 (data_structure -> map_var .)
    WSTRING         reduce using rule 61 (data_structure -> map_var .)
    BOOL            reduce using rule 61 (data_structure -> map_var .)
    DEFAULT         reduce using rule 61 (data_structure -> map_var .)
    CASE            reduce using rule 61 (data_structure -> map_var .)
    RETURN          reduce using rule 61 (data_structure -> map_var .)
    RPAREN          reduce using rule 61 (data_structure -> map_var .)
    AND             reduce using rule 61 (data_structure -> map_var .)
    OR              reduce using rule 61 (data_structure -> map_var .)
    LLLAVE          reduce using rule 61 (data_structure -> map_var .)
    RCORCHE         reduce using rule 61 (data_structure -> map_var .)
    COMA            reduce using rule 61 (data_structure -> map_var .)


state 98

    (166) comparison -> value op . value
    (167) value -> . ID
    (168) value -> . expression
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 114
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    value                          shift and go to state 168
    expression                     shift and go to state 94
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 99

    (175) logic_operation -> logic_value logic_recu .

    PRINT           reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    SCAN            reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    FOR             reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    ID              reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    APPEND          reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    LEN             reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    COPY            reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    DELETE          reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    IF              reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    ELSE            reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    TYPE            reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    SWITCH          reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    VAR             reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    FUNC            reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    INTEGER         reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    FLOAT           reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    NOT             reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    $end            reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    RLLAVE          reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    INT32           reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    INT64           reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    FLOAT32         reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    FLOAT64         reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    BYTE            reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    WINT            reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    WFLOAT          reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    WSTRING         reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    BOOL            reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    DEFAULT         reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    CASE            reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    RETURN          reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    LLLAVE          reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    COLON           reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    RPAREN          reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    RCORCHE         reduce using rule 175 (logic_operation -> logic_value logic_recu .)
    COMA            reduce using rule 175 (logic_operation -> logic_value logic_recu .)


state 100

    (177) logic_recu -> logic_op . logic_value
    (178) logic_recu -> logic_op . logic_value logic_recu
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (166) comparison -> . value op value
    (167) value -> . ID
    (168) value -> . expression
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 172
    NOT             shift and go to state 54
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    logic_value                    shift and go to state 169
    negation                       shift and go to state 170
    comparison                     shift and go to state 171
    value                          shift and go to state 33
    expression                     shift and go to state 94
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 101

    (184) logic_op -> AND .

    ID              reduce using rule 184 (logic_op -> AND .)
    NOT             reduce using rule 184 (logic_op -> AND .)
    INTEGER         reduce using rule 184 (logic_op -> AND .)
    FLOAT           reduce using rule 184 (logic_op -> AND .)
    APPEND          reduce using rule 184 (logic_op -> AND .)
    LEN             reduce using rule 184 (logic_op -> AND .)
    COPY            reduce using rule 184 (logic_op -> AND .)
    DELETE          reduce using rule 184 (logic_op -> AND .)


state 102

    (185) logic_op -> OR .

    ID              reduce using rule 185 (logic_op -> OR .)
    NOT             reduce using rule 185 (logic_op -> OR .)
    INTEGER         reduce using rule 185 (logic_op -> OR .)
    FLOAT           reduce using rule 185 (logic_op -> OR .)
    APPEND          reduce using rule 185 (logic_op -> OR .)
    LEN             reduce using rule 185 (logic_op -> OR .)
    COPY            reduce using rule 185 (logic_op -> OR .)
    DELETE          reduce using rule 185 (logic_op -> OR .)


state 103

    (62) var_asignation -> ID EQUAL . any
    (63) any -> . values
    (64) any -> . operations
    (65) any -> . ID
    (66) any -> . data_structure
    (67) any -> . funciones
    (68) any -> . call_func
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID

    ID              shift and go to state 173
    STRING          shift and go to state 140
    INTEGER         shift and go to state 141
    FLOAT           shift and go to state 142
    TRUE            shift and go to state 143
    FALSE           shift and go to state 144
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    NOT             shift and go to state 54

    any                            shift and go to state 174
    values                         shift and go to state 175
    operations                     shift and go to state 176
    data_structure                 shift and go to state 177
    funciones                      shift and go to state 178
    call_func                      shift and go to state 179
    expression                     shift and go to state 145
    comparison                     shift and go to state 146
    logic_operation                shift and go to state 147
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35

state 104

    (159) cStruct -> ID DEQUAL . ID LLLAVE asignaciones RLLAVE
    (124) slice_declaration -> ID DEQUAL . funM
    (125) slice_declaration -> ID DEQUAL . LCORCHE RCORCHE data_types arr_content
    (120) dynamic -> ID DEQUAL . values
    (126) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (127) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE

    ID              shift and go to state 180
    LCORCHE         shift and go to state 182
    MAKE            shift and go to state 184
    STRING          shift and go to state 140
    INTEGER         shift and go to state 185
    FLOAT           shift and go to state 186
    TRUE            shift and go to state 143
    FALSE           shift and go to state 144

    funM                           shift and go to state 181
    values                         shift and go to state 183

state 105

    (196) array_var -> ID LCORCHE . index RCORCHE
    (131) slice_var -> ID LCORCHE . index_s RCORCHE
    (202) map_var -> ID LCORCHE . key RCORCHE
    (197) index -> . ID
    (198) index -> . INTEGER
    (199) index -> . expression
    (132) index_s -> . ID
    (133) index_s -> . INTEGER
    (134) index_s -> . expression
    (203) key -> . ID
    (204) key -> . values
    (205) key -> . operations
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 187
    INTEGER         shift and go to state 191
    STRING          shift and go to state 140
    FLOAT           shift and go to state 142
    TRUE            shift and go to state 143
    FALSE           shift and go to state 144
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    NOT             shift and go to state 54

    index                          shift and go to state 188
    index_s                        shift and go to state 189
    key                            shift and go to state 190
    expression                     shift and go to state 192
    values                         shift and go to state 193
    operations                     shift and go to state 194
    something_ex                   shift and go to state 31
    comparison                     shift and go to state 146
    logic_operation                shift and go to state 147
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 106

    (81) call_func -> ID LPAREN . list_params RPAREN
    (82) call_func -> ID LPAREN . RPAREN
    (83) list_params -> . ID
    (84) list_params -> . ID COMA more_p

    RPAREN          shift and go to state 197
    ID              shift and go to state 195

    list_params                    shift and go to state 196

state 107

    (140) funciones -> APPEND LPAREN . ID COMA values RPAREN
    (141) funciones -> APPEND LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 198


state 108

    (142) funciones -> LEN LPAREN . ID RPAREN

    ID              shift and go to state 199


state 109

    (143) funciones -> COPY LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 200


state 110

    (144) funciones -> DELETE LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 201


state 111

    (148) SenIF -> IF comparison . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 202


state 112

    (149) SenIF -> IF TRUE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 203


state 113

    (150) SenIF -> IF FALSE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 204


state 114

    (167) value -> ID .
    (228) something_ex -> ID .
    (196) array_var -> ID . LCORCHE index RCORCHE
    (202) map_var -> ID . LCORCHE key RCORCHE
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for INT32 resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for INT64 resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for BYTE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for WINT resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for WSTRING resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for LLLAVE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 167 (value -> ID .)
    GREATER         reduce using rule 167 (value -> ID .)
    SMALLER         reduce using rule 167 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 167 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 167 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 167 (value -> ID .)
    NOT_EQUAL       reduce using rule 167 (value -> ID .)
    PLUS            reduce using rule 167 (value -> ID .)
    TIMES           reduce using rule 167 (value -> ID .)
    DIVIDE          reduce using rule 167 (value -> ID .)
    MINUS           reduce using rule 167 (value -> ID .)
    PRINT           reduce using rule 167 (value -> ID .)
    SCAN            reduce using rule 167 (value -> ID .)
    FOR             reduce using rule 167 (value -> ID .)
    ID              reduce using rule 167 (value -> ID .)
    APPEND          reduce using rule 167 (value -> ID .)
    LEN             reduce using rule 167 (value -> ID .)
    COPY            reduce using rule 167 (value -> ID .)
    DELETE          reduce using rule 167 (value -> ID .)
    IF              reduce using rule 167 (value -> ID .)
    ELSE            reduce using rule 167 (value -> ID .)
    TYPE            reduce using rule 167 (value -> ID .)
    SWITCH          reduce using rule 167 (value -> ID .)
    VAR             reduce using rule 167 (value -> ID .)
    FUNC            reduce using rule 167 (value -> ID .)
    INTEGER         reduce using rule 167 (value -> ID .)
    FLOAT           reduce using rule 167 (value -> ID .)
    NOT             reduce using rule 167 (value -> ID .)
    $end            reduce using rule 167 (value -> ID .)
    AND             reduce using rule 167 (value -> ID .)
    OR              reduce using rule 167 (value -> ID .)
    RLLAVE          reduce using rule 167 (value -> ID .)
    INT32           reduce using rule 167 (value -> ID .)
    INT64           reduce using rule 167 (value -> ID .)
    FLOAT32         reduce using rule 167 (value -> ID .)
    FLOAT64         reduce using rule 167 (value -> ID .)
    BYTE            reduce using rule 167 (value -> ID .)
    WINT            reduce using rule 167 (value -> ID .)
    WFLOAT          reduce using rule 167 (value -> ID .)
    WSTRING         reduce using rule 167 (value -> ID .)
    BOOL            reduce using rule 167 (value -> ID .)
    DEFAULT         reduce using rule 167 (value -> ID .)
    CASE            reduce using rule 167 (value -> ID .)
    RETURN          reduce using rule 167 (value -> ID .)
    LLLAVE          reduce using rule 167 (value -> ID .)
    COLON           reduce using rule 167 (value -> ID .)
    RPAREN          reduce using rule 167 (value -> ID .)
    RCORCHE         reduce using rule 167 (value -> ID .)
    COMA            reduce using rule 167 (value -> ID .)
    LCORCHE         shift and go to state 167
    LPAREN          shift and go to state 106

  ! GREATER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 228 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 228 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 228 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 228 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 228 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 228 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 228 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 228 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 228 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 228 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 228 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 228 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 228 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 228 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 228 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 228 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 228 (something_ex -> ID .) ]
  ! AND             [ reduce using rule 228 (something_ex -> ID .) ]
  ! OR              [ reduce using rule 228 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! INT32           [ reduce using rule 228 (something_ex -> ID .) ]
  ! INT64           [ reduce using rule 228 (something_ex -> ID .) ]
  ! FLOAT32         [ reduce using rule 228 (something_ex -> ID .) ]
  ! FLOAT64         [ reduce using rule 228 (something_ex -> ID .) ]
  ! BYTE            [ reduce using rule 228 (something_ex -> ID .) ]
  ! WINT            [ reduce using rule 228 (something_ex -> ID .) ]
  ! WFLOAT          [ reduce using rule 228 (something_ex -> ID .) ]
  ! WSTRING         [ reduce using rule 228 (something_ex -> ID .) ]
  ! BOOL            [ reduce using rule 228 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 228 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 228 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 228 (something_ex -> ID .) ]
  ! LLLAVE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 228 (something_ex -> ID .) ]
  ! RPAREN          [ reduce using rule 228 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 228 (something_ex -> ID .) ]
  ! COMA            [ reduce using rule 228 (something_ex -> ID .) ]


state 115

    (151) SenElseIF -> ELSE IF . comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> ELSE IF . TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> ELSE IF . FALSE LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (167) value -> . ID
    (168) value -> . expression
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    TRUE            shift and go to state 206
    FALSE           shift and go to state 207
    ID              shift and go to state 114
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    comparison                     shift and go to state 205
    value                          shift and go to state 33
    expression                     shift and go to state 94
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 116

    (154) SenElse -> ELSE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

    codigo                         shift and go to state 208
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 117

    (155) SenStruct -> TYPE ID . STRUCT LLLAVE declaration RLLAVE

    STRUCT          shift and go to state 209


state 118

    (186) switch_statement -> SWITCH ID . LLLAVE cases RLLAVE

    LLLAVE          shift and go to state 210


state 119

    (191) array_declaration -> VAR ID . LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> VAR ID . EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (121) slice_declaration -> VAR ID . LCORCHE RCORCHE data_types
    (122) slice_declaration -> VAR ID . EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> VAR ID . EQUAL funM
    (201) map_declaration -> VAR ID . LCORCHE data_types RCORCHE data_types
    (100) single -> VAR ID . data_types
    (101) single -> VAR ID . data_types EQUAL funciones
    (102) single -> VAR ID . data_types EQUAL ID
    (103) single -> VAR ID . data_types EQUAL data_structure
    (104) single -> VAR ID . data_type_and_value
    (97) list_var -> VAR ID . COMA more
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL
    (105) data_type_and_value -> . WSTRING EQUAL STRING
    (106) data_type_and_value -> . WINT EQUAL int_value
    (107) data_type_and_value -> . INT32 EQUAL int_value
    (108) data_type_and_value -> . INT64 EQUAL int_value
    (109) data_type_and_value -> . WFLOAT EQUAL float_value
    (110) data_type_and_value -> . FLOAT32 EQUAL float_value
    (111) data_type_and_value -> . FLOAT64 EQUAL float_value
    (112) data_type_and_value -> . BOOL EQUAL bool_value

    LCORCHE         shift and go to state 211
    EQUAL           shift and go to state 213
    COMA            shift and go to state 215
    INT32           shift and go to state 216
    INT64           shift and go to state 217
    FLOAT32         shift and go to state 218
    FLOAT64         shift and go to state 219
    BYTE            shift and go to state 130
    WINT            shift and go to state 220
    WFLOAT          shift and go to state 221
    WSTRING         shift and go to state 222
    BOOL            shift and go to state 223

    data_types                     shift and go to state 212
    data_type_and_value            shift and go to state 214

state 120

    (206) map_assignment -> map_var EQUAL . something
    (75) something -> . ID
    (76) something -> . data_structure
    (77) something -> . values
    (78) something -> . operations
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 136
    STRING          shift and go to state 140
    INTEGER         shift and go to state 141
    FLOAT           shift and go to state 142
    TRUE            shift and go to state 143
    FALSE           shift and go to state 144
    NOT             shift and go to state 54
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    map_var                        shift and go to state 97
    something                      shift and go to state 224
    data_structure                 shift and go to state 137
    values                         shift and go to state 138
    operations                     shift and go to state 139
    array_var                      shift and go to state 96
    expression                     shift and go to state 145
    comparison                     shift and go to state 146
    logic_operation                shift and go to state 147
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    funciones                      shift and go to state 95
    call_func                      shift and go to state 43

state 121

    (207) func_declaration -> FUNC ID . LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> FUNC ID . LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE

    LPAREN          shift and go to state 225


state 122

    (79) main_func -> FUNC MAIN . LPAREN RPAREN LLLAVE codigo RLLAVE

    LPAREN          shift and go to state 226


state 123

    (182) negation -> NOT comparison .

    PRINT           reduce using rule 182 (negation -> NOT comparison .)
    SCAN            reduce using rule 182 (negation -> NOT comparison .)
    FOR             reduce using rule 182 (negation -> NOT comparison .)
    ID              reduce using rule 182 (negation -> NOT comparison .)
    APPEND          reduce using rule 182 (negation -> NOT comparison .)
    LEN             reduce using rule 182 (negation -> NOT comparison .)
    COPY            reduce using rule 182 (negation -> NOT comparison .)
    DELETE          reduce using rule 182 (negation -> NOT comparison .)
    IF              reduce using rule 182 (negation -> NOT comparison .)
    ELSE            reduce using rule 182 (negation -> NOT comparison .)
    TYPE            reduce using rule 182 (negation -> NOT comparison .)
    SWITCH          reduce using rule 182 (negation -> NOT comparison .)
    VAR             reduce using rule 182 (negation -> NOT comparison .)
    FUNC            reduce using rule 182 (negation -> NOT comparison .)
    INTEGER         reduce using rule 182 (negation -> NOT comparison .)
    FLOAT           reduce using rule 182 (negation -> NOT comparison .)
    NOT             reduce using rule 182 (negation -> NOT comparison .)
    $end            reduce using rule 182 (negation -> NOT comparison .)
    AND             reduce using rule 182 (negation -> NOT comparison .)
    OR              reduce using rule 182 (negation -> NOT comparison .)
    RLLAVE          reduce using rule 182 (negation -> NOT comparison .)
    INT32           reduce using rule 182 (negation -> NOT comparison .)
    INT64           reduce using rule 182 (negation -> NOT comparison .)
    FLOAT32         reduce using rule 182 (negation -> NOT comparison .)
    FLOAT64         reduce using rule 182 (negation -> NOT comparison .)
    BYTE            reduce using rule 182 (negation -> NOT comparison .)
    WINT            reduce using rule 182 (negation -> NOT comparison .)
    WFLOAT          reduce using rule 182 (negation -> NOT comparison .)
    WSTRING         reduce using rule 182 (negation -> NOT comparison .)
    BOOL            reduce using rule 182 (negation -> NOT comparison .)
    DEFAULT         reduce using rule 182 (negation -> NOT comparison .)
    CASE            reduce using rule 182 (negation -> NOT comparison .)
    RETURN          reduce using rule 182 (negation -> NOT comparison .)
    LLLAVE          reduce using rule 182 (negation -> NOT comparison .)
    COLON           reduce using rule 182 (negation -> NOT comparison .)
    RPAREN          reduce using rule 182 (negation -> NOT comparison .)
    RCORCHE         reduce using rule 182 (negation -> NOT comparison .)
    COMA            reduce using rule 182 (negation -> NOT comparison .)


state 124

    (183) negation -> NOT ID .
    (167) value -> ID .
    (228) something_ex -> ID .
    (196) array_var -> ID . LCORCHE index RCORCHE
    (202) map_var -> ID . LCORCHE key RCORCHE
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 167 (value -> ID .)
    PRINT           reduce using rule 183 (negation -> NOT ID .)
    SCAN            reduce using rule 183 (negation -> NOT ID .)
    FOR             reduce using rule 183 (negation -> NOT ID .)
    ID              reduce using rule 183 (negation -> NOT ID .)
    APPEND          reduce using rule 183 (negation -> NOT ID .)
    LEN             reduce using rule 183 (negation -> NOT ID .)
    COPY            reduce using rule 183 (negation -> NOT ID .)
    DELETE          reduce using rule 183 (negation -> NOT ID .)
    IF              reduce using rule 183 (negation -> NOT ID .)
    ELSE            reduce using rule 183 (negation -> NOT ID .)
    TYPE            reduce using rule 183 (negation -> NOT ID .)
    SWITCH          reduce using rule 183 (negation -> NOT ID .)
    VAR             reduce using rule 183 (negation -> NOT ID .)
    FUNC            reduce using rule 183 (negation -> NOT ID .)
    INTEGER         reduce using rule 183 (negation -> NOT ID .)
    FLOAT           reduce using rule 183 (negation -> NOT ID .)
    NOT             reduce using rule 183 (negation -> NOT ID .)
    $end            reduce using rule 183 (negation -> NOT ID .)
    AND             reduce using rule 183 (negation -> NOT ID .)
    OR              reduce using rule 183 (negation -> NOT ID .)
    RLLAVE          reduce using rule 183 (negation -> NOT ID .)
    INT32           reduce using rule 183 (negation -> NOT ID .)
    INT64           reduce using rule 183 (negation -> NOT ID .)
    FLOAT32         reduce using rule 183 (negation -> NOT ID .)
    FLOAT64         reduce using rule 183 (negation -> NOT ID .)
    BYTE            reduce using rule 183 (negation -> NOT ID .)
    WINT            reduce using rule 183 (negation -> NOT ID .)
    WFLOAT          reduce using rule 183 (negation -> NOT ID .)
    WSTRING         reduce using rule 183 (negation -> NOT ID .)
    BOOL            reduce using rule 183 (negation -> NOT ID .)
    DEFAULT         reduce using rule 183 (negation -> NOT ID .)
    CASE            reduce using rule 183 (negation -> NOT ID .)
    RETURN          reduce using rule 183 (negation -> NOT ID .)
    LLLAVE          reduce using rule 183 (negation -> NOT ID .)
    COLON           reduce using rule 183 (negation -> NOT ID .)
    RPAREN          reduce using rule 183 (negation -> NOT ID .)
    RCORCHE         reduce using rule 183 (negation -> NOT ID .)
    COMA            reduce using rule 183 (negation -> NOT ID .)
    GREATER         reduce using rule 167 (value -> ID .)
    SMALLER         reduce using rule 167 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 167 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 167 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 167 (value -> ID .)
    NOT_EQUAL       reduce using rule 167 (value -> ID .)
    PLUS            reduce using rule 167 (value -> ID .)
    TIMES           reduce using rule 167 (value -> ID .)
    DIVIDE          reduce using rule 167 (value -> ID .)
    MINUS           reduce using rule 167 (value -> ID .)
    LCORCHE         shift and go to state 167
    LPAREN          shift and go to state 106

  ! GREATER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 228 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 228 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 228 (something_ex -> ID .) ]


state 125

    (96) multiple -> list_var data_types .

    COLON           reduce using rule 96 (multiple -> list_var data_types .)
    PRINT           reduce using rule 96 (multiple -> list_var data_types .)
    SCAN            reduce using rule 96 (multiple -> list_var data_types .)
    FOR             reduce using rule 96 (multiple -> list_var data_types .)
    ID              reduce using rule 96 (multiple -> list_var data_types .)
    APPEND          reduce using rule 96 (multiple -> list_var data_types .)
    LEN             reduce using rule 96 (multiple -> list_var data_types .)
    COPY            reduce using rule 96 (multiple -> list_var data_types .)
    DELETE          reduce using rule 96 (multiple -> list_var data_types .)
    IF              reduce using rule 96 (multiple -> list_var data_types .)
    ELSE            reduce using rule 96 (multiple -> list_var data_types .)
    TYPE            reduce using rule 96 (multiple -> list_var data_types .)
    SWITCH          reduce using rule 96 (multiple -> list_var data_types .)
    VAR             reduce using rule 96 (multiple -> list_var data_types .)
    FUNC            reduce using rule 96 (multiple -> list_var data_types .)
    INTEGER         reduce using rule 96 (multiple -> list_var data_types .)
    FLOAT           reduce using rule 96 (multiple -> list_var data_types .)
    NOT             reduce using rule 96 (multiple -> list_var data_types .)
    $end            reduce using rule 96 (multiple -> list_var data_types .)
    RLLAVE          reduce using rule 96 (multiple -> list_var data_types .)
    INT32           reduce using rule 96 (multiple -> list_var data_types .)
    INT64           reduce using rule 96 (multiple -> list_var data_types .)
    FLOAT32         reduce using rule 96 (multiple -> list_var data_types .)
    FLOAT64         reduce using rule 96 (multiple -> list_var data_types .)
    BYTE            reduce using rule 96 (multiple -> list_var data_types .)
    WINT            reduce using rule 96 (multiple -> list_var data_types .)
    WFLOAT          reduce using rule 96 (multiple -> list_var data_types .)
    WSTRING         reduce using rule 96 (multiple -> list_var data_types .)
    BOOL            reduce using rule 96 (multiple -> list_var data_types .)
    DEFAULT         reduce using rule 96 (multiple -> list_var data_types .)
    CASE            reduce using rule 96 (multiple -> list_var data_types .)
    RETURN          reduce using rule 96 (multiple -> list_var data_types .)


state 126

    (48) data_types -> INT32 .

    COLON           reduce using rule 48 (data_types -> INT32 .)
    PRINT           reduce using rule 48 (data_types -> INT32 .)
    SCAN            reduce using rule 48 (data_types -> INT32 .)
    FOR             reduce using rule 48 (data_types -> INT32 .)
    ID              reduce using rule 48 (data_types -> INT32 .)
    APPEND          reduce using rule 48 (data_types -> INT32 .)
    LEN             reduce using rule 48 (data_types -> INT32 .)
    COPY            reduce using rule 48 (data_types -> INT32 .)
    DELETE          reduce using rule 48 (data_types -> INT32 .)
    IF              reduce using rule 48 (data_types -> INT32 .)
    ELSE            reduce using rule 48 (data_types -> INT32 .)
    TYPE            reduce using rule 48 (data_types -> INT32 .)
    SWITCH          reduce using rule 48 (data_types -> INT32 .)
    VAR             reduce using rule 48 (data_types -> INT32 .)
    FUNC            reduce using rule 48 (data_types -> INT32 .)
    INTEGER         reduce using rule 48 (data_types -> INT32 .)
    FLOAT           reduce using rule 48 (data_types -> INT32 .)
    NOT             reduce using rule 48 (data_types -> INT32 .)
    $end            reduce using rule 48 (data_types -> INT32 .)
    RLLAVE          reduce using rule 48 (data_types -> INT32 .)
    INT32           reduce using rule 48 (data_types -> INT32 .)
    INT64           reduce using rule 48 (data_types -> INT32 .)
    FLOAT32         reduce using rule 48 (data_types -> INT32 .)
    FLOAT64         reduce using rule 48 (data_types -> INT32 .)
    BYTE            reduce using rule 48 (data_types -> INT32 .)
    WINT            reduce using rule 48 (data_types -> INT32 .)
    WFLOAT          reduce using rule 48 (data_types -> INT32 .)
    WSTRING         reduce using rule 48 (data_types -> INT32 .)
    BOOL            reduce using rule 48 (data_types -> INT32 .)
    DEFAULT         reduce using rule 48 (data_types -> INT32 .)
    CASE            reduce using rule 48 (data_types -> INT32 .)
    RETURN          reduce using rule 48 (data_types -> INT32 .)
    RCORCHE         reduce using rule 48 (data_types -> INT32 .)
    LLLAVE          reduce using rule 48 (data_types -> INT32 .)
    COMA            reduce using rule 48 (data_types -> INT32 .)
    RPAREN          reduce using rule 48 (data_types -> INT32 .)


state 127

    (49) data_types -> INT64 .

    COLON           reduce using rule 49 (data_types -> INT64 .)
    PRINT           reduce using rule 49 (data_types -> INT64 .)
    SCAN            reduce using rule 49 (data_types -> INT64 .)
    FOR             reduce using rule 49 (data_types -> INT64 .)
    ID              reduce using rule 49 (data_types -> INT64 .)
    APPEND          reduce using rule 49 (data_types -> INT64 .)
    LEN             reduce using rule 49 (data_types -> INT64 .)
    COPY            reduce using rule 49 (data_types -> INT64 .)
    DELETE          reduce using rule 49 (data_types -> INT64 .)
    IF              reduce using rule 49 (data_types -> INT64 .)
    ELSE            reduce using rule 49 (data_types -> INT64 .)
    TYPE            reduce using rule 49 (data_types -> INT64 .)
    SWITCH          reduce using rule 49 (data_types -> INT64 .)
    VAR             reduce using rule 49 (data_types -> INT64 .)
    FUNC            reduce using rule 49 (data_types -> INT64 .)
    INTEGER         reduce using rule 49 (data_types -> INT64 .)
    FLOAT           reduce using rule 49 (data_types -> INT64 .)
    NOT             reduce using rule 49 (data_types -> INT64 .)
    $end            reduce using rule 49 (data_types -> INT64 .)
    RLLAVE          reduce using rule 49 (data_types -> INT64 .)
    INT32           reduce using rule 49 (data_types -> INT64 .)
    INT64           reduce using rule 49 (data_types -> INT64 .)
    FLOAT32         reduce using rule 49 (data_types -> INT64 .)
    FLOAT64         reduce using rule 49 (data_types -> INT64 .)
    BYTE            reduce using rule 49 (data_types -> INT64 .)
    WINT            reduce using rule 49 (data_types -> INT64 .)
    WFLOAT          reduce using rule 49 (data_types -> INT64 .)
    WSTRING         reduce using rule 49 (data_types -> INT64 .)
    BOOL            reduce using rule 49 (data_types -> INT64 .)
    DEFAULT         reduce using rule 49 (data_types -> INT64 .)
    CASE            reduce using rule 49 (data_types -> INT64 .)
    RETURN          reduce using rule 49 (data_types -> INT64 .)
    RCORCHE         reduce using rule 49 (data_types -> INT64 .)
    LLLAVE          reduce using rule 49 (data_types -> INT64 .)
    COMA            reduce using rule 49 (data_types -> INT64 .)
    RPAREN          reduce using rule 49 (data_types -> INT64 .)


state 128

    (50) data_types -> FLOAT32 .

    COLON           reduce using rule 50 (data_types -> FLOAT32 .)
    PRINT           reduce using rule 50 (data_types -> FLOAT32 .)
    SCAN            reduce using rule 50 (data_types -> FLOAT32 .)
    FOR             reduce using rule 50 (data_types -> FLOAT32 .)
    ID              reduce using rule 50 (data_types -> FLOAT32 .)
    APPEND          reduce using rule 50 (data_types -> FLOAT32 .)
    LEN             reduce using rule 50 (data_types -> FLOAT32 .)
    COPY            reduce using rule 50 (data_types -> FLOAT32 .)
    DELETE          reduce using rule 50 (data_types -> FLOAT32 .)
    IF              reduce using rule 50 (data_types -> FLOAT32 .)
    ELSE            reduce using rule 50 (data_types -> FLOAT32 .)
    TYPE            reduce using rule 50 (data_types -> FLOAT32 .)
    SWITCH          reduce using rule 50 (data_types -> FLOAT32 .)
    VAR             reduce using rule 50 (data_types -> FLOAT32 .)
    FUNC            reduce using rule 50 (data_types -> FLOAT32 .)
    INTEGER         reduce using rule 50 (data_types -> FLOAT32 .)
    FLOAT           reduce using rule 50 (data_types -> FLOAT32 .)
    NOT             reduce using rule 50 (data_types -> FLOAT32 .)
    $end            reduce using rule 50 (data_types -> FLOAT32 .)
    RLLAVE          reduce using rule 50 (data_types -> FLOAT32 .)
    INT32           reduce using rule 50 (data_types -> FLOAT32 .)
    INT64           reduce using rule 50 (data_types -> FLOAT32 .)
    FLOAT32         reduce using rule 50 (data_types -> FLOAT32 .)
    FLOAT64         reduce using rule 50 (data_types -> FLOAT32 .)
    BYTE            reduce using rule 50 (data_types -> FLOAT32 .)
    WINT            reduce using rule 50 (data_types -> FLOAT32 .)
    WFLOAT          reduce using rule 50 (data_types -> FLOAT32 .)
    WSTRING         reduce using rule 50 (data_types -> FLOAT32 .)
    BOOL            reduce using rule 50 (data_types -> FLOAT32 .)
    DEFAULT         reduce using rule 50 (data_types -> FLOAT32 .)
    CASE            reduce using rule 50 (data_types -> FLOAT32 .)
    RETURN          reduce using rule 50 (data_types -> FLOAT32 .)
    RCORCHE         reduce using rule 50 (data_types -> FLOAT32 .)
    LLLAVE          reduce using rule 50 (data_types -> FLOAT32 .)
    COMA            reduce using rule 50 (data_types -> FLOAT32 .)
    RPAREN          reduce using rule 50 (data_types -> FLOAT32 .)


state 129

    (51) data_types -> FLOAT64 .

    COLON           reduce using rule 51 (data_types -> FLOAT64 .)
    PRINT           reduce using rule 51 (data_types -> FLOAT64 .)
    SCAN            reduce using rule 51 (data_types -> FLOAT64 .)
    FOR             reduce using rule 51 (data_types -> FLOAT64 .)
    ID              reduce using rule 51 (data_types -> FLOAT64 .)
    APPEND          reduce using rule 51 (data_types -> FLOAT64 .)
    LEN             reduce using rule 51 (data_types -> FLOAT64 .)
    COPY            reduce using rule 51 (data_types -> FLOAT64 .)
    DELETE          reduce using rule 51 (data_types -> FLOAT64 .)
    IF              reduce using rule 51 (data_types -> FLOAT64 .)
    ELSE            reduce using rule 51 (data_types -> FLOAT64 .)
    TYPE            reduce using rule 51 (data_types -> FLOAT64 .)
    SWITCH          reduce using rule 51 (data_types -> FLOAT64 .)
    VAR             reduce using rule 51 (data_types -> FLOAT64 .)
    FUNC            reduce using rule 51 (data_types -> FLOAT64 .)
    INTEGER         reduce using rule 51 (data_types -> FLOAT64 .)
    FLOAT           reduce using rule 51 (data_types -> FLOAT64 .)
    NOT             reduce using rule 51 (data_types -> FLOAT64 .)
    $end            reduce using rule 51 (data_types -> FLOAT64 .)
    RLLAVE          reduce using rule 51 (data_types -> FLOAT64 .)
    INT32           reduce using rule 51 (data_types -> FLOAT64 .)
    INT64           reduce using rule 51 (data_types -> FLOAT64 .)
    FLOAT32         reduce using rule 51 (data_types -> FLOAT64 .)
    FLOAT64         reduce using rule 51 (data_types -> FLOAT64 .)
    BYTE            reduce using rule 51 (data_types -> FLOAT64 .)
    WINT            reduce using rule 51 (data_types -> FLOAT64 .)
    WFLOAT          reduce using rule 51 (data_types -> FLOAT64 .)
    WSTRING         reduce using rule 51 (data_types -> FLOAT64 .)
    BOOL            reduce using rule 51 (data_types -> FLOAT64 .)
    DEFAULT         reduce using rule 51 (data_types -> FLOAT64 .)
    CASE            reduce using rule 51 (data_types -> FLOAT64 .)
    RETURN          reduce using rule 51 (data_types -> FLOAT64 .)
    RCORCHE         reduce using rule 51 (data_types -> FLOAT64 .)
    LLLAVE          reduce using rule 51 (data_types -> FLOAT64 .)
    COMA            reduce using rule 51 (data_types -> FLOAT64 .)
    RPAREN          reduce using rule 51 (data_types -> FLOAT64 .)


state 130

    (52) data_types -> BYTE .

    COLON           reduce using rule 52 (data_types -> BYTE .)
    PRINT           reduce using rule 52 (data_types -> BYTE .)
    SCAN            reduce using rule 52 (data_types -> BYTE .)
    FOR             reduce using rule 52 (data_types -> BYTE .)
    ID              reduce using rule 52 (data_types -> BYTE .)
    APPEND          reduce using rule 52 (data_types -> BYTE .)
    LEN             reduce using rule 52 (data_types -> BYTE .)
    COPY            reduce using rule 52 (data_types -> BYTE .)
    DELETE          reduce using rule 52 (data_types -> BYTE .)
    IF              reduce using rule 52 (data_types -> BYTE .)
    ELSE            reduce using rule 52 (data_types -> BYTE .)
    TYPE            reduce using rule 52 (data_types -> BYTE .)
    SWITCH          reduce using rule 52 (data_types -> BYTE .)
    VAR             reduce using rule 52 (data_types -> BYTE .)
    FUNC            reduce using rule 52 (data_types -> BYTE .)
    INTEGER         reduce using rule 52 (data_types -> BYTE .)
    FLOAT           reduce using rule 52 (data_types -> BYTE .)
    NOT             reduce using rule 52 (data_types -> BYTE .)
    $end            reduce using rule 52 (data_types -> BYTE .)
    RLLAVE          reduce using rule 52 (data_types -> BYTE .)
    INT32           reduce using rule 52 (data_types -> BYTE .)
    INT64           reduce using rule 52 (data_types -> BYTE .)
    FLOAT32         reduce using rule 52 (data_types -> BYTE .)
    FLOAT64         reduce using rule 52 (data_types -> BYTE .)
    BYTE            reduce using rule 52 (data_types -> BYTE .)
    WINT            reduce using rule 52 (data_types -> BYTE .)
    WFLOAT          reduce using rule 52 (data_types -> BYTE .)
    WSTRING         reduce using rule 52 (data_types -> BYTE .)
    BOOL            reduce using rule 52 (data_types -> BYTE .)
    DEFAULT         reduce using rule 52 (data_types -> BYTE .)
    CASE            reduce using rule 52 (data_types -> BYTE .)
    RETURN          reduce using rule 52 (data_types -> BYTE .)
    EQUAL           reduce using rule 52 (data_types -> BYTE .)
    RCORCHE         reduce using rule 52 (data_types -> BYTE .)
    LLLAVE          reduce using rule 52 (data_types -> BYTE .)
    COMA            reduce using rule 52 (data_types -> BYTE .)
    RPAREN          reduce using rule 52 (data_types -> BYTE .)


state 131

    (53) data_types -> WINT .

    COLON           reduce using rule 53 (data_types -> WINT .)
    PRINT           reduce using rule 53 (data_types -> WINT .)
    SCAN            reduce using rule 53 (data_types -> WINT .)
    FOR             reduce using rule 53 (data_types -> WINT .)
    ID              reduce using rule 53 (data_types -> WINT .)
    APPEND          reduce using rule 53 (data_types -> WINT .)
    LEN             reduce using rule 53 (data_types -> WINT .)
    COPY            reduce using rule 53 (data_types -> WINT .)
    DELETE          reduce using rule 53 (data_types -> WINT .)
    IF              reduce using rule 53 (data_types -> WINT .)
    ELSE            reduce using rule 53 (data_types -> WINT .)
    TYPE            reduce using rule 53 (data_types -> WINT .)
    SWITCH          reduce using rule 53 (data_types -> WINT .)
    VAR             reduce using rule 53 (data_types -> WINT .)
    FUNC            reduce using rule 53 (data_types -> WINT .)
    INTEGER         reduce using rule 53 (data_types -> WINT .)
    FLOAT           reduce using rule 53 (data_types -> WINT .)
    NOT             reduce using rule 53 (data_types -> WINT .)
    $end            reduce using rule 53 (data_types -> WINT .)
    RLLAVE          reduce using rule 53 (data_types -> WINT .)
    INT32           reduce using rule 53 (data_types -> WINT .)
    INT64           reduce using rule 53 (data_types -> WINT .)
    FLOAT32         reduce using rule 53 (data_types -> WINT .)
    FLOAT64         reduce using rule 53 (data_types -> WINT .)
    BYTE            reduce using rule 53 (data_types -> WINT .)
    WINT            reduce using rule 53 (data_types -> WINT .)
    WFLOAT          reduce using rule 53 (data_types -> WINT .)
    WSTRING         reduce using rule 53 (data_types -> WINT .)
    BOOL            reduce using rule 53 (data_types -> WINT .)
    DEFAULT         reduce using rule 53 (data_types -> WINT .)
    CASE            reduce using rule 53 (data_types -> WINT .)
    RETURN          reduce using rule 53 (data_types -> WINT .)
    RCORCHE         reduce using rule 53 (data_types -> WINT .)
    LLLAVE          reduce using rule 53 (data_types -> WINT .)
    COMA            reduce using rule 53 (data_types -> WINT .)
    RPAREN          reduce using rule 53 (data_types -> WINT .)


state 132

    (54) data_types -> WFLOAT .

    COLON           reduce using rule 54 (data_types -> WFLOAT .)
    PRINT           reduce using rule 54 (data_types -> WFLOAT .)
    SCAN            reduce using rule 54 (data_types -> WFLOAT .)
    FOR             reduce using rule 54 (data_types -> WFLOAT .)
    ID              reduce using rule 54 (data_types -> WFLOAT .)
    APPEND          reduce using rule 54 (data_types -> WFLOAT .)
    LEN             reduce using rule 54 (data_types -> WFLOAT .)
    COPY            reduce using rule 54 (data_types -> WFLOAT .)
    DELETE          reduce using rule 54 (data_types -> WFLOAT .)
    IF              reduce using rule 54 (data_types -> WFLOAT .)
    ELSE            reduce using rule 54 (data_types -> WFLOAT .)
    TYPE            reduce using rule 54 (data_types -> WFLOAT .)
    SWITCH          reduce using rule 54 (data_types -> WFLOAT .)
    VAR             reduce using rule 54 (data_types -> WFLOAT .)
    FUNC            reduce using rule 54 (data_types -> WFLOAT .)
    INTEGER         reduce using rule 54 (data_types -> WFLOAT .)
    FLOAT           reduce using rule 54 (data_types -> WFLOAT .)
    NOT             reduce using rule 54 (data_types -> WFLOAT .)
    $end            reduce using rule 54 (data_types -> WFLOAT .)
    RLLAVE          reduce using rule 54 (data_types -> WFLOAT .)
    INT32           reduce using rule 54 (data_types -> WFLOAT .)
    INT64           reduce using rule 54 (data_types -> WFLOAT .)
    FLOAT32         reduce using rule 54 (data_types -> WFLOAT .)
    FLOAT64         reduce using rule 54 (data_types -> WFLOAT .)
    BYTE            reduce using rule 54 (data_types -> WFLOAT .)
    WINT            reduce using rule 54 (data_types -> WFLOAT .)
    WFLOAT          reduce using rule 54 (data_types -> WFLOAT .)
    WSTRING         reduce using rule 54 (data_types -> WFLOAT .)
    BOOL            reduce using rule 54 (data_types -> WFLOAT .)
    DEFAULT         reduce using rule 54 (data_types -> WFLOAT .)
    CASE            reduce using rule 54 (data_types -> WFLOAT .)
    RETURN          reduce using rule 54 (data_types -> WFLOAT .)
    RCORCHE         reduce using rule 54 (data_types -> WFLOAT .)
    LLLAVE          reduce using rule 54 (data_types -> WFLOAT .)
    COMA            reduce using rule 54 (data_types -> WFLOAT .)
    RPAREN          reduce using rule 54 (data_types -> WFLOAT .)


state 133

    (55) data_types -> WSTRING .

    COLON           reduce using rule 55 (data_types -> WSTRING .)
    PRINT           reduce using rule 55 (data_types -> WSTRING .)
    SCAN            reduce using rule 55 (data_types -> WSTRING .)
    FOR             reduce using rule 55 (data_types -> WSTRING .)
    ID              reduce using rule 55 (data_types -> WSTRING .)
    APPEND          reduce using rule 55 (data_types -> WSTRING .)
    LEN             reduce using rule 55 (data_types -> WSTRING .)
    COPY            reduce using rule 55 (data_types -> WSTRING .)
    DELETE          reduce using rule 55 (data_types -> WSTRING .)
    IF              reduce using rule 55 (data_types -> WSTRING .)
    ELSE            reduce using rule 55 (data_types -> WSTRING .)
    TYPE            reduce using rule 55 (data_types -> WSTRING .)
    SWITCH          reduce using rule 55 (data_types -> WSTRING .)
    VAR             reduce using rule 55 (data_types -> WSTRING .)
    FUNC            reduce using rule 55 (data_types -> WSTRING .)
    INTEGER         reduce using rule 55 (data_types -> WSTRING .)
    FLOAT           reduce using rule 55 (data_types -> WSTRING .)
    NOT             reduce using rule 55 (data_types -> WSTRING .)
    $end            reduce using rule 55 (data_types -> WSTRING .)
    RLLAVE          reduce using rule 55 (data_types -> WSTRING .)
    INT32           reduce using rule 55 (data_types -> WSTRING .)
    INT64           reduce using rule 55 (data_types -> WSTRING .)
    FLOAT32         reduce using rule 55 (data_types -> WSTRING .)
    FLOAT64         reduce using rule 55 (data_types -> WSTRING .)
    BYTE            reduce using rule 55 (data_types -> WSTRING .)
    WINT            reduce using rule 55 (data_types -> WSTRING .)
    WFLOAT          reduce using rule 55 (data_types -> WSTRING .)
    WSTRING         reduce using rule 55 (data_types -> WSTRING .)
    BOOL            reduce using rule 55 (data_types -> WSTRING .)
    DEFAULT         reduce using rule 55 (data_types -> WSTRING .)
    CASE            reduce using rule 55 (data_types -> WSTRING .)
    RETURN          reduce using rule 55 (data_types -> WSTRING .)
    RCORCHE         reduce using rule 55 (data_types -> WSTRING .)
    LLLAVE          reduce using rule 55 (data_types -> WSTRING .)
    COMA            reduce using rule 55 (data_types -> WSTRING .)
    RPAREN          reduce using rule 55 (data_types -> WSTRING .)


state 134

    (56) data_types -> BOOL .

    COLON           reduce using rule 56 (data_types -> BOOL .)
    PRINT           reduce using rule 56 (data_types -> BOOL .)
    SCAN            reduce using rule 56 (data_types -> BOOL .)
    FOR             reduce using rule 56 (data_types -> BOOL .)
    ID              reduce using rule 56 (data_types -> BOOL .)
    APPEND          reduce using rule 56 (data_types -> BOOL .)
    LEN             reduce using rule 56 (data_types -> BOOL .)
    COPY            reduce using rule 56 (data_types -> BOOL .)
    DELETE          reduce using rule 56 (data_types -> BOOL .)
    IF              reduce using rule 56 (data_types -> BOOL .)
    ELSE            reduce using rule 56 (data_types -> BOOL .)
    TYPE            reduce using rule 56 (data_types -> BOOL .)
    SWITCH          reduce using rule 56 (data_types -> BOOL .)
    VAR             reduce using rule 56 (data_types -> BOOL .)
    FUNC            reduce using rule 56 (data_types -> BOOL .)
    INTEGER         reduce using rule 56 (data_types -> BOOL .)
    FLOAT           reduce using rule 56 (data_types -> BOOL .)
    NOT             reduce using rule 56 (data_types -> BOOL .)
    $end            reduce using rule 56 (data_types -> BOOL .)
    RLLAVE          reduce using rule 56 (data_types -> BOOL .)
    INT32           reduce using rule 56 (data_types -> BOOL .)
    INT64           reduce using rule 56 (data_types -> BOOL .)
    FLOAT32         reduce using rule 56 (data_types -> BOOL .)
    FLOAT64         reduce using rule 56 (data_types -> BOOL .)
    BYTE            reduce using rule 56 (data_types -> BOOL .)
    WINT            reduce using rule 56 (data_types -> BOOL .)
    WFLOAT          reduce using rule 56 (data_types -> BOOL .)
    WSTRING         reduce using rule 56 (data_types -> BOOL .)
    BOOL            reduce using rule 56 (data_types -> BOOL .)
    DEFAULT         reduce using rule 56 (data_types -> BOOL .)
    CASE            reduce using rule 56 (data_types -> BOOL .)
    RETURN          reduce using rule 56 (data_types -> BOOL .)
    RCORCHE         reduce using rule 56 (data_types -> BOOL .)
    LLLAVE          reduce using rule 56 (data_types -> BOOL .)
    COMA            reduce using rule 56 (data_types -> BOOL .)
    RPAREN          reduce using rule 56 (data_types -> BOOL .)


state 135

    (200) array_assignment -> array_var EQUAL something .

    COLON           reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    PRINT           reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    SCAN            reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    FOR             reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    ID              reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    APPEND          reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    LEN             reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    COPY            reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    DELETE          reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    IF              reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    ELSE            reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    TYPE            reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    SWITCH          reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    VAR             reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    FUNC            reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    INTEGER         reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    FLOAT           reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    NOT             reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    $end            reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    RLLAVE          reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    INT32           reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    INT64           reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    FLOAT32         reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    FLOAT64         reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    BYTE            reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    WINT            reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    WFLOAT          reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    WSTRING         reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    BOOL            reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    DEFAULT         reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    CASE            reduce using rule 200 (array_assignment -> array_var EQUAL something .)
    RETURN          reduce using rule 200 (array_assignment -> array_var EQUAL something .)


state 136

    (75) something -> ID .
    (196) array_var -> ID . LCORCHE index RCORCHE
    (202) map_var -> ID . LCORCHE key RCORCHE
    (228) something_ex -> ID .
    (167) value -> ID .
    (181) logic_value -> ID .
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for COLON resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for INT32 resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for INT64 resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for BYTE resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for WINT resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for WSTRING resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 75 (something -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 167 (value -> ID .)
    COLON           reduce using rule 75 (something -> ID .)
    PRINT           reduce using rule 75 (something -> ID .)
    SCAN            reduce using rule 75 (something -> ID .)
    FOR             reduce using rule 75 (something -> ID .)
    ID              reduce using rule 75 (something -> ID .)
    APPEND          reduce using rule 75 (something -> ID .)
    LEN             reduce using rule 75 (something -> ID .)
    COPY            reduce using rule 75 (something -> ID .)
    DELETE          reduce using rule 75 (something -> ID .)
    IF              reduce using rule 75 (something -> ID .)
    ELSE            reduce using rule 75 (something -> ID .)
    TYPE            reduce using rule 75 (something -> ID .)
    SWITCH          reduce using rule 75 (something -> ID .)
    VAR             reduce using rule 75 (something -> ID .)
    FUNC            reduce using rule 75 (something -> ID .)
    INTEGER         reduce using rule 75 (something -> ID .)
    FLOAT           reduce using rule 75 (something -> ID .)
    NOT             reduce using rule 75 (something -> ID .)
    $end            reduce using rule 75 (something -> ID .)
    RLLAVE          reduce using rule 75 (something -> ID .)
    INT32           reduce using rule 75 (something -> ID .)
    INT64           reduce using rule 75 (something -> ID .)
    FLOAT32         reduce using rule 75 (something -> ID .)
    FLOAT64         reduce using rule 75 (something -> ID .)
    BYTE            reduce using rule 75 (something -> ID .)
    WINT            reduce using rule 75 (something -> ID .)
    WFLOAT          reduce using rule 75 (something -> ID .)
    WSTRING         reduce using rule 75 (something -> ID .)
    BOOL            reduce using rule 75 (something -> ID .)
    DEFAULT         reduce using rule 75 (something -> ID .)
    CASE            reduce using rule 75 (something -> ID .)
    RETURN          reduce using rule 75 (something -> ID .)
    LCORCHE         shift and go to state 167
    GREATER         reduce using rule 167 (value -> ID .)
    SMALLER         reduce using rule 167 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 167 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 167 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 167 (value -> ID .)
    NOT_EQUAL       reduce using rule 167 (value -> ID .)
    PLUS            reduce using rule 167 (value -> ID .)
    TIMES           reduce using rule 167 (value -> ID .)
    DIVIDE          reduce using rule 167 (value -> ID .)
    MINUS           reduce using rule 167 (value -> ID .)
    AND             reduce using rule 181 (logic_value -> ID .)
    OR              reduce using rule 181 (logic_value -> ID .)
    LPAREN          shift and go to state 106

  ! GREATER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 228 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 228 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 228 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 228 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 228 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 228 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 228 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 228 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 228 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 228 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 228 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 228 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 228 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 228 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 228 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 228 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 228 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 228 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! INT32           [ reduce using rule 228 (something_ex -> ID .) ]
  ! INT64           [ reduce using rule 228 (something_ex -> ID .) ]
  ! FLOAT32         [ reduce using rule 228 (something_ex -> ID .) ]
  ! FLOAT64         [ reduce using rule 228 (something_ex -> ID .) ]
  ! BYTE            [ reduce using rule 228 (something_ex -> ID .) ]
  ! WINT            [ reduce using rule 228 (something_ex -> ID .) ]
  ! WFLOAT          [ reduce using rule 228 (something_ex -> ID .) ]
  ! WSTRING         [ reduce using rule 228 (something_ex -> ID .) ]
  ! BOOL            [ reduce using rule 228 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 228 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 228 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 228 (something_ex -> ID .) ]


state 137

    (76) something -> data_structure .
    (231) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for PRINT resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for SCAN resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for FOR resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for ID resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for APPEND resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for LEN resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for COPY resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for DELETE resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for IF resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for ELSE resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for TYPE resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for SWITCH resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for VAR resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for FUNC resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for INTEGER resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for FLOAT resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for NOT resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for $end resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for INT32 resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for INT64 resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for BYTE resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for WINT resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for WSTRING resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for BOOL resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for CASE resolved using rule 76 (something -> data_structure .)
  ! reduce/reduce conflict for RETURN resolved using rule 76 (something -> data_structure .)
    COLON           reduce using rule 76 (something -> data_structure .)
    PRINT           reduce using rule 76 (something -> data_structure .)
    SCAN            reduce using rule 76 (something -> data_structure .)
    FOR             reduce using rule 76 (something -> data_structure .)
    ID              reduce using rule 76 (something -> data_structure .)
    APPEND          reduce using rule 76 (something -> data_structure .)
    LEN             reduce using rule 76 (something -> data_structure .)
    COPY            reduce using rule 76 (something -> data_structure .)
    DELETE          reduce using rule 76 (something -> data_structure .)
    IF              reduce using rule 76 (something -> data_structure .)
    ELSE            reduce using rule 76 (something -> data_structure .)
    TYPE            reduce using rule 76 (something -> data_structure .)
    SWITCH          reduce using rule 76 (something -> data_structure .)
    VAR             reduce using rule 76 (something -> data_structure .)
    FUNC            reduce using rule 76 (something -> data_structure .)
    INTEGER         reduce using rule 76 (something -> data_structure .)
    FLOAT           reduce using rule 76 (something -> data_structure .)
    NOT             reduce using rule 76 (something -> data_structure .)
    $end            reduce using rule 76 (something -> data_structure .)
    RLLAVE          reduce using rule 76 (something -> data_structure .)
    INT32           reduce using rule 76 (something -> data_structure .)
    INT64           reduce using rule 76 (something -> data_structure .)
    FLOAT32         reduce using rule 76 (something -> data_structure .)
    FLOAT64         reduce using rule 76 (something -> data_structure .)
    BYTE            reduce using rule 76 (something -> data_structure .)
    WINT            reduce using rule 76 (something -> data_structure .)
    WFLOAT          reduce using rule 76 (something -> data_structure .)
    WSTRING         reduce using rule 76 (something -> data_structure .)
    BOOL            reduce using rule 76 (something -> data_structure .)
    DEFAULT         reduce using rule 76 (something -> data_structure .)
    CASE            reduce using rule 76 (something -> data_structure .)
    RETURN          reduce using rule 76 (something -> data_structure .)
    GREATER         reduce using rule 231 (something_ex -> data_structure .)
    SMALLER         reduce using rule 231 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 231 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 231 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 231 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 231 (something_ex -> data_structure .)
    PLUS            reduce using rule 231 (something_ex -> data_structure .)
    TIMES           reduce using rule 231 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 231 (something_ex -> data_structure .)
    MINUS           reduce using rule 231 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! PRINT           [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! SCAN            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! FOR             [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! ID              [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! APPEND          [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! LEN             [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! COPY            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! DELETE          [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! IF              [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! ELSE            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! TYPE            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! SWITCH          [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! VAR             [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! FUNC            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! INTEGER         [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! FLOAT           [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! NOT             [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! $end            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! INT32           [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! INT64           [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! FLOAT32         [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! FLOAT64         [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! BYTE            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! WINT            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! WFLOAT          [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! WSTRING         [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! BOOL            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! DEFAULT         [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! CASE            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! RETURN          [ reduce using rule 231 (something_ex -> data_structure .) ]


state 138

    (77) something -> values .

    COLON           reduce using rule 77 (something -> values .)
    PRINT           reduce using rule 77 (something -> values .)
    SCAN            reduce using rule 77 (something -> values .)
    FOR             reduce using rule 77 (something -> values .)
    ID              reduce using rule 77 (something -> values .)
    APPEND          reduce using rule 77 (something -> values .)
    LEN             reduce using rule 77 (something -> values .)
    COPY            reduce using rule 77 (something -> values .)
    DELETE          reduce using rule 77 (something -> values .)
    IF              reduce using rule 77 (something -> values .)
    ELSE            reduce using rule 77 (something -> values .)
    TYPE            reduce using rule 77 (something -> values .)
    SWITCH          reduce using rule 77 (something -> values .)
    VAR             reduce using rule 77 (something -> values .)
    FUNC            reduce using rule 77 (something -> values .)
    INTEGER         reduce using rule 77 (something -> values .)
    FLOAT           reduce using rule 77 (something -> values .)
    NOT             reduce using rule 77 (something -> values .)
    $end            reduce using rule 77 (something -> values .)
    RLLAVE          reduce using rule 77 (something -> values .)
    INT32           reduce using rule 77 (something -> values .)
    INT64           reduce using rule 77 (something -> values .)
    FLOAT32         reduce using rule 77 (something -> values .)
    FLOAT64         reduce using rule 77 (something -> values .)
    BYTE            reduce using rule 77 (something -> values .)
    WINT            reduce using rule 77 (something -> values .)
    WFLOAT          reduce using rule 77 (something -> values .)
    WSTRING         reduce using rule 77 (something -> values .)
    BOOL            reduce using rule 77 (something -> values .)
    DEFAULT         reduce using rule 77 (something -> values .)
    CASE            reduce using rule 77 (something -> values .)
    RETURN          reduce using rule 77 (something -> values .)


state 139

    (78) something -> operations .

    COLON           reduce using rule 78 (something -> operations .)
    PRINT           reduce using rule 78 (something -> operations .)
    SCAN            reduce using rule 78 (something -> operations .)
    FOR             reduce using rule 78 (something -> operations .)
    ID              reduce using rule 78 (something -> operations .)
    APPEND          reduce using rule 78 (something -> operations .)
    LEN             reduce using rule 78 (something -> operations .)
    COPY            reduce using rule 78 (something -> operations .)
    DELETE          reduce using rule 78 (something -> operations .)
    IF              reduce using rule 78 (something -> operations .)
    ELSE            reduce using rule 78 (something -> operations .)
    TYPE            reduce using rule 78 (something -> operations .)
    SWITCH          reduce using rule 78 (something -> operations .)
    VAR             reduce using rule 78 (something -> operations .)
    FUNC            reduce using rule 78 (something -> operations .)
    INTEGER         reduce using rule 78 (something -> operations .)
    FLOAT           reduce using rule 78 (something -> operations .)
    NOT             reduce using rule 78 (something -> operations .)
    $end            reduce using rule 78 (something -> operations .)
    RLLAVE          reduce using rule 78 (something -> operations .)
    INT32           reduce using rule 78 (something -> operations .)
    INT64           reduce using rule 78 (something -> operations .)
    FLOAT32         reduce using rule 78 (something -> operations .)
    FLOAT64         reduce using rule 78 (something -> operations .)
    BYTE            reduce using rule 78 (something -> operations .)
    WINT            reduce using rule 78 (something -> operations .)
    WFLOAT          reduce using rule 78 (something -> operations .)
    WSTRING         reduce using rule 78 (something -> operations .)
    BOOL            reduce using rule 78 (something -> operations .)
    DEFAULT         reduce using rule 78 (something -> operations .)
    CASE            reduce using rule 78 (something -> operations .)
    RETURN          reduce using rule 78 (something -> operations .)


state 140

    (43) values -> STRING .

    COLON           reduce using rule 43 (values -> STRING .)
    PRINT           reduce using rule 43 (values -> STRING .)
    SCAN            reduce using rule 43 (values -> STRING .)
    FOR             reduce using rule 43 (values -> STRING .)
    ID              reduce using rule 43 (values -> STRING .)
    APPEND          reduce using rule 43 (values -> STRING .)
    LEN             reduce using rule 43 (values -> STRING .)
    COPY            reduce using rule 43 (values -> STRING .)
    DELETE          reduce using rule 43 (values -> STRING .)
    IF              reduce using rule 43 (values -> STRING .)
    ELSE            reduce using rule 43 (values -> STRING .)
    TYPE            reduce using rule 43 (values -> STRING .)
    SWITCH          reduce using rule 43 (values -> STRING .)
    VAR             reduce using rule 43 (values -> STRING .)
    FUNC            reduce using rule 43 (values -> STRING .)
    INTEGER         reduce using rule 43 (values -> STRING .)
    FLOAT           reduce using rule 43 (values -> STRING .)
    NOT             reduce using rule 43 (values -> STRING .)
    $end            reduce using rule 43 (values -> STRING .)
    RLLAVE          reduce using rule 43 (values -> STRING .)
    INT32           reduce using rule 43 (values -> STRING .)
    INT64           reduce using rule 43 (values -> STRING .)
    FLOAT32         reduce using rule 43 (values -> STRING .)
    FLOAT64         reduce using rule 43 (values -> STRING .)
    BYTE            reduce using rule 43 (values -> STRING .)
    WINT            reduce using rule 43 (values -> STRING .)
    WFLOAT          reduce using rule 43 (values -> STRING .)
    WSTRING         reduce using rule 43 (values -> STRING .)
    BOOL            reduce using rule 43 (values -> STRING .)
    DEFAULT         reduce using rule 43 (values -> STRING .)
    CASE            reduce using rule 43 (values -> STRING .)
    RETURN          reduce using rule 43 (values -> STRING .)
    RPAREN          reduce using rule 43 (values -> STRING .)
    RCORCHE         reduce using rule 43 (values -> STRING .)
    POINTS          reduce using rule 43 (values -> STRING .)
    COMA            reduce using rule 43 (values -> STRING .)


state 141

    (44) values -> INTEGER .
    (229) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for PRINT resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for SCAN resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for FOR resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for ID resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for APPEND resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for LEN resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for COPY resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for DELETE resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for IF resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for ELSE resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for TYPE resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for SWITCH resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for VAR resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for FUNC resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for INTEGER resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for FLOAT resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for NOT resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for INT32 resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for INT64 resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for BYTE resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for WINT resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for WSTRING resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for BOOL resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 44 (values -> INTEGER .)
    COLON           reduce using rule 44 (values -> INTEGER .)
    PRINT           reduce using rule 44 (values -> INTEGER .)
    SCAN            reduce using rule 44 (values -> INTEGER .)
    FOR             reduce using rule 44 (values -> INTEGER .)
    ID              reduce using rule 44 (values -> INTEGER .)
    APPEND          reduce using rule 44 (values -> INTEGER .)
    LEN             reduce using rule 44 (values -> INTEGER .)
    COPY            reduce using rule 44 (values -> INTEGER .)
    DELETE          reduce using rule 44 (values -> INTEGER .)
    IF              reduce using rule 44 (values -> INTEGER .)
    ELSE            reduce using rule 44 (values -> INTEGER .)
    TYPE            reduce using rule 44 (values -> INTEGER .)
    SWITCH          reduce using rule 44 (values -> INTEGER .)
    VAR             reduce using rule 44 (values -> INTEGER .)
    FUNC            reduce using rule 44 (values -> INTEGER .)
    INTEGER         reduce using rule 44 (values -> INTEGER .)
    FLOAT           reduce using rule 44 (values -> INTEGER .)
    NOT             reduce using rule 44 (values -> INTEGER .)
    $end            reduce using rule 44 (values -> INTEGER .)
    RLLAVE          reduce using rule 44 (values -> INTEGER .)
    INT32           reduce using rule 44 (values -> INTEGER .)
    INT64           reduce using rule 44 (values -> INTEGER .)
    FLOAT32         reduce using rule 44 (values -> INTEGER .)
    FLOAT64         reduce using rule 44 (values -> INTEGER .)
    BYTE            reduce using rule 44 (values -> INTEGER .)
    WINT            reduce using rule 44 (values -> INTEGER .)
    WFLOAT          reduce using rule 44 (values -> INTEGER .)
    WSTRING         reduce using rule 44 (values -> INTEGER .)
    BOOL            reduce using rule 44 (values -> INTEGER .)
    DEFAULT         reduce using rule 44 (values -> INTEGER .)
    CASE            reduce using rule 44 (values -> INTEGER .)
    RETURN          reduce using rule 44 (values -> INTEGER .)
    RPAREN          reduce using rule 44 (values -> INTEGER .)
    COMA            reduce using rule 44 (values -> INTEGER .)
    GREATER         reduce using rule 229 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 229 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 229 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 229 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 229 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 229 (something_ex -> INTEGER .)
    PLUS            reduce using rule 229 (something_ex -> INTEGER .)
    TIMES           reduce using rule 229 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 229 (something_ex -> INTEGER .)
    MINUS           reduce using rule 229 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! PRINT           [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! SCAN            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! FOR             [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! ID              [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! APPEND          [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! LEN             [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! COPY            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! DELETE          [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! IF              [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! ELSE            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! TYPE            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! SWITCH          [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! VAR             [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! FUNC            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! INTEGER         [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! FLOAT           [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! NOT             [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! INT32           [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! INT64           [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! FLOAT32         [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! FLOAT64         [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! BYTE            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! WINT            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! WFLOAT          [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! WSTRING         [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! BOOL            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! RPAREN          [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! COMA            [ reduce using rule 229 (something_ex -> INTEGER .) ]


state 142

    (45) values -> FLOAT .
    (230) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for PRINT resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for SCAN resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for FOR resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for ID resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for APPEND resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for LEN resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for COPY resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for DELETE resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for IF resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for ELSE resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for TYPE resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for SWITCH resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for VAR resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for FUNC resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for INTEGER resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for FLOAT resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for NOT resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for INT32 resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for INT64 resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for BYTE resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for WINT resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for WSTRING resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for BOOL resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for RPAREN resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 45 (values -> FLOAT .)
  ! reduce/reduce conflict for COMA resolved using rule 45 (values -> FLOAT .)
    COLON           reduce using rule 45 (values -> FLOAT .)
    PRINT           reduce using rule 45 (values -> FLOAT .)
    SCAN            reduce using rule 45 (values -> FLOAT .)
    FOR             reduce using rule 45 (values -> FLOAT .)
    ID              reduce using rule 45 (values -> FLOAT .)
    APPEND          reduce using rule 45 (values -> FLOAT .)
    LEN             reduce using rule 45 (values -> FLOAT .)
    COPY            reduce using rule 45 (values -> FLOAT .)
    DELETE          reduce using rule 45 (values -> FLOAT .)
    IF              reduce using rule 45 (values -> FLOAT .)
    ELSE            reduce using rule 45 (values -> FLOAT .)
    TYPE            reduce using rule 45 (values -> FLOAT .)
    SWITCH          reduce using rule 45 (values -> FLOAT .)
    VAR             reduce using rule 45 (values -> FLOAT .)
    FUNC            reduce using rule 45 (values -> FLOAT .)
    INTEGER         reduce using rule 45 (values -> FLOAT .)
    FLOAT           reduce using rule 45 (values -> FLOAT .)
    NOT             reduce using rule 45 (values -> FLOAT .)
    $end            reduce using rule 45 (values -> FLOAT .)
    RLLAVE          reduce using rule 45 (values -> FLOAT .)
    INT32           reduce using rule 45 (values -> FLOAT .)
    INT64           reduce using rule 45 (values -> FLOAT .)
    FLOAT32         reduce using rule 45 (values -> FLOAT .)
    FLOAT64         reduce using rule 45 (values -> FLOAT .)
    BYTE            reduce using rule 45 (values -> FLOAT .)
    WINT            reduce using rule 45 (values -> FLOAT .)
    WFLOAT          reduce using rule 45 (values -> FLOAT .)
    WSTRING         reduce using rule 45 (values -> FLOAT .)
    BOOL            reduce using rule 45 (values -> FLOAT .)
    DEFAULT         reduce using rule 45 (values -> FLOAT .)
    CASE            reduce using rule 45 (values -> FLOAT .)
    RETURN          reduce using rule 45 (values -> FLOAT .)
    RPAREN          reduce using rule 45 (values -> FLOAT .)
    RCORCHE         reduce using rule 45 (values -> FLOAT .)
    COMA            reduce using rule 45 (values -> FLOAT .)
    GREATER         reduce using rule 230 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 230 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 230 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 230 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 230 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 230 (something_ex -> FLOAT .)
    PLUS            reduce using rule 230 (something_ex -> FLOAT .)
    TIMES           reduce using rule 230 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 230 (something_ex -> FLOAT .)
    MINUS           reduce using rule 230 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! PRINT           [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! SCAN            [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! FOR             [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! ID              [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! APPEND          [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! LEN             [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! COPY            [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! DELETE          [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! IF              [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! ELSE            [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! TYPE            [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! SWITCH          [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! VAR             [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! FUNC            [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! INTEGER         [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! FLOAT           [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! NOT             [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! INT32           [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! INT64           [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! FLOAT32         [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! FLOAT64         [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! BYTE            [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! WINT            [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! WFLOAT          [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! WSTRING         [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! BOOL            [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! RPAREN          [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! RCORCHE         [ reduce using rule 230 (something_ex -> FLOAT .) ]
  ! COMA            [ reduce using rule 230 (something_ex -> FLOAT .) ]


state 143

    (46) values -> TRUE .

    COLON           reduce using rule 46 (values -> TRUE .)
    PRINT           reduce using rule 46 (values -> TRUE .)
    SCAN            reduce using rule 46 (values -> TRUE .)
    FOR             reduce using rule 46 (values -> TRUE .)
    ID              reduce using rule 46 (values -> TRUE .)
    APPEND          reduce using rule 46 (values -> TRUE .)
    LEN             reduce using rule 46 (values -> TRUE .)
    COPY            reduce using rule 46 (values -> TRUE .)
    DELETE          reduce using rule 46 (values -> TRUE .)
    IF              reduce using rule 46 (values -> TRUE .)
    ELSE            reduce using rule 46 (values -> TRUE .)
    TYPE            reduce using rule 46 (values -> TRUE .)
    SWITCH          reduce using rule 46 (values -> TRUE .)
    VAR             reduce using rule 46 (values -> TRUE .)
    FUNC            reduce using rule 46 (values -> TRUE .)
    INTEGER         reduce using rule 46 (values -> TRUE .)
    FLOAT           reduce using rule 46 (values -> TRUE .)
    NOT             reduce using rule 46 (values -> TRUE .)
    $end            reduce using rule 46 (values -> TRUE .)
    RLLAVE          reduce using rule 46 (values -> TRUE .)
    INT32           reduce using rule 46 (values -> TRUE .)
    INT64           reduce using rule 46 (values -> TRUE .)
    FLOAT32         reduce using rule 46 (values -> TRUE .)
    FLOAT64         reduce using rule 46 (values -> TRUE .)
    BYTE            reduce using rule 46 (values -> TRUE .)
    WINT            reduce using rule 46 (values -> TRUE .)
    WFLOAT          reduce using rule 46 (values -> TRUE .)
    WSTRING         reduce using rule 46 (values -> TRUE .)
    BOOL            reduce using rule 46 (values -> TRUE .)
    DEFAULT         reduce using rule 46 (values -> TRUE .)
    CASE            reduce using rule 46 (values -> TRUE .)
    RETURN          reduce using rule 46 (values -> TRUE .)
    RPAREN          reduce using rule 46 (values -> TRUE .)
    RCORCHE         reduce using rule 46 (values -> TRUE .)
    POINTS          reduce using rule 46 (values -> TRUE .)
    COMA            reduce using rule 46 (values -> TRUE .)


state 144

    (47) values -> FALSE .

    COLON           reduce using rule 47 (values -> FALSE .)
    PRINT           reduce using rule 47 (values -> FALSE .)
    SCAN            reduce using rule 47 (values -> FALSE .)
    FOR             reduce using rule 47 (values -> FALSE .)
    ID              reduce using rule 47 (values -> FALSE .)
    APPEND          reduce using rule 47 (values -> FALSE .)
    LEN             reduce using rule 47 (values -> FALSE .)
    COPY            reduce using rule 47 (values -> FALSE .)
    DELETE          reduce using rule 47 (values -> FALSE .)
    IF              reduce using rule 47 (values -> FALSE .)
    ELSE            reduce using rule 47 (values -> FALSE .)
    TYPE            reduce using rule 47 (values -> FALSE .)
    SWITCH          reduce using rule 47 (values -> FALSE .)
    VAR             reduce using rule 47 (values -> FALSE .)
    FUNC            reduce using rule 47 (values -> FALSE .)
    INTEGER         reduce using rule 47 (values -> FALSE .)
    FLOAT           reduce using rule 47 (values -> FALSE .)
    NOT             reduce using rule 47 (values -> FALSE .)
    $end            reduce using rule 47 (values -> FALSE .)
    RLLAVE          reduce using rule 47 (values -> FALSE .)
    INT32           reduce using rule 47 (values -> FALSE .)
    INT64           reduce using rule 47 (values -> FALSE .)
    FLOAT32         reduce using rule 47 (values -> FALSE .)
    FLOAT64         reduce using rule 47 (values -> FALSE .)
    BYTE            reduce using rule 47 (values -> FALSE .)
    WINT            reduce using rule 47 (values -> FALSE .)
    WFLOAT          reduce using rule 47 (values -> FALSE .)
    WSTRING         reduce using rule 47 (values -> FALSE .)
    BOOL            reduce using rule 47 (values -> FALSE .)
    DEFAULT         reduce using rule 47 (values -> FALSE .)
    CASE            reduce using rule 47 (values -> FALSE .)
    RETURN          reduce using rule 47 (values -> FALSE .)
    RPAREN          reduce using rule 47 (values -> FALSE .)
    RCORCHE         reduce using rule 47 (values -> FALSE .)
    POINTS          reduce using rule 47 (values -> FALSE .)
    COMA            reduce using rule 47 (values -> FALSE .)


state 145

    (57) operations -> expression .
    (168) value -> expression .

    COLON           reduce using rule 57 (operations -> expression .)
    PRINT           reduce using rule 57 (operations -> expression .)
    SCAN            reduce using rule 57 (operations -> expression .)
    FOR             reduce using rule 57 (operations -> expression .)
    ID              reduce using rule 57 (operations -> expression .)
    APPEND          reduce using rule 57 (operations -> expression .)
    LEN             reduce using rule 57 (operations -> expression .)
    COPY            reduce using rule 57 (operations -> expression .)
    DELETE          reduce using rule 57 (operations -> expression .)
    IF              reduce using rule 57 (operations -> expression .)
    ELSE            reduce using rule 57 (operations -> expression .)
    TYPE            reduce using rule 57 (operations -> expression .)
    SWITCH          reduce using rule 57 (operations -> expression .)
    VAR             reduce using rule 57 (operations -> expression .)
    FUNC            reduce using rule 57 (operations -> expression .)
    INTEGER         reduce using rule 57 (operations -> expression .)
    FLOAT           reduce using rule 57 (operations -> expression .)
    NOT             reduce using rule 57 (operations -> expression .)
    $end            reduce using rule 57 (operations -> expression .)
    RLLAVE          reduce using rule 57 (operations -> expression .)
    INT32           reduce using rule 57 (operations -> expression .)
    INT64           reduce using rule 57 (operations -> expression .)
    FLOAT32         reduce using rule 57 (operations -> expression .)
    FLOAT64         reduce using rule 57 (operations -> expression .)
    BYTE            reduce using rule 57 (operations -> expression .)
    WINT            reduce using rule 57 (operations -> expression .)
    WFLOAT          reduce using rule 57 (operations -> expression .)
    WSTRING         reduce using rule 57 (operations -> expression .)
    BOOL            reduce using rule 57 (operations -> expression .)
    DEFAULT         reduce using rule 57 (operations -> expression .)
    CASE            reduce using rule 57 (operations -> expression .)
    RETURN          reduce using rule 57 (operations -> expression .)
    RPAREN          reduce using rule 57 (operations -> expression .)
    COMA            reduce using rule 57 (operations -> expression .)
    GREATER         reduce using rule 168 (value -> expression .)
    SMALLER         reduce using rule 168 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 168 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 168 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 168 (value -> expression .)
    NOT_EQUAL       reduce using rule 168 (value -> expression .)
    PLUS            reduce using rule 168 (value -> expression .)
    TIMES           reduce using rule 168 (value -> expression .)
    DIVIDE          reduce using rule 168 (value -> expression .)
    MINUS           reduce using rule 168 (value -> expression .)


state 146

    (58) operations -> comparison .
    (180) logic_value -> comparison .

    COLON           reduce using rule 58 (operations -> comparison .)
    PRINT           reduce using rule 58 (operations -> comparison .)
    SCAN            reduce using rule 58 (operations -> comparison .)
    FOR             reduce using rule 58 (operations -> comparison .)
    ID              reduce using rule 58 (operations -> comparison .)
    APPEND          reduce using rule 58 (operations -> comparison .)
    LEN             reduce using rule 58 (operations -> comparison .)
    COPY            reduce using rule 58 (operations -> comparison .)
    DELETE          reduce using rule 58 (operations -> comparison .)
    IF              reduce using rule 58 (operations -> comparison .)
    ELSE            reduce using rule 58 (operations -> comparison .)
    TYPE            reduce using rule 58 (operations -> comparison .)
    SWITCH          reduce using rule 58 (operations -> comparison .)
    VAR             reduce using rule 58 (operations -> comparison .)
    FUNC            reduce using rule 58 (operations -> comparison .)
    INTEGER         reduce using rule 58 (operations -> comparison .)
    FLOAT           reduce using rule 58 (operations -> comparison .)
    NOT             reduce using rule 58 (operations -> comparison .)
    $end            reduce using rule 58 (operations -> comparison .)
    RLLAVE          reduce using rule 58 (operations -> comparison .)
    INT32           reduce using rule 58 (operations -> comparison .)
    INT64           reduce using rule 58 (operations -> comparison .)
    FLOAT32         reduce using rule 58 (operations -> comparison .)
    FLOAT64         reduce using rule 58 (operations -> comparison .)
    BYTE            reduce using rule 58 (operations -> comparison .)
    WINT            reduce using rule 58 (operations -> comparison .)
    WFLOAT          reduce using rule 58 (operations -> comparison .)
    WSTRING         reduce using rule 58 (operations -> comparison .)
    BOOL            reduce using rule 58 (operations -> comparison .)
    DEFAULT         reduce using rule 58 (operations -> comparison .)
    CASE            reduce using rule 58 (operations -> comparison .)
    RETURN          reduce using rule 58 (operations -> comparison .)
    RPAREN          reduce using rule 58 (operations -> comparison .)
    RCORCHE         reduce using rule 58 (operations -> comparison .)
    COMA            reduce using rule 58 (operations -> comparison .)
    AND             reduce using rule 180 (logic_value -> comparison .)
    OR              reduce using rule 180 (logic_value -> comparison .)


state 147

    (59) operations -> logic_operation .

    COLON           reduce using rule 59 (operations -> logic_operation .)
    PRINT           reduce using rule 59 (operations -> logic_operation .)
    SCAN            reduce using rule 59 (operations -> logic_operation .)
    FOR             reduce using rule 59 (operations -> logic_operation .)
    ID              reduce using rule 59 (operations -> logic_operation .)
    APPEND          reduce using rule 59 (operations -> logic_operation .)
    LEN             reduce using rule 59 (operations -> logic_operation .)
    COPY            reduce using rule 59 (operations -> logic_operation .)
    DELETE          reduce using rule 59 (operations -> logic_operation .)
    IF              reduce using rule 59 (operations -> logic_operation .)
    ELSE            reduce using rule 59 (operations -> logic_operation .)
    TYPE            reduce using rule 59 (operations -> logic_operation .)
    SWITCH          reduce using rule 59 (operations -> logic_operation .)
    VAR             reduce using rule 59 (operations -> logic_operation .)
    FUNC            reduce using rule 59 (operations -> logic_operation .)
    INTEGER         reduce using rule 59 (operations -> logic_operation .)
    FLOAT           reduce using rule 59 (operations -> logic_operation .)
    NOT             reduce using rule 59 (operations -> logic_operation .)
    $end            reduce using rule 59 (operations -> logic_operation .)
    RLLAVE          reduce using rule 59 (operations -> logic_operation .)
    INT32           reduce using rule 59 (operations -> logic_operation .)
    INT64           reduce using rule 59 (operations -> logic_operation .)
    FLOAT32         reduce using rule 59 (operations -> logic_operation .)
    FLOAT64         reduce using rule 59 (operations -> logic_operation .)
    BYTE            reduce using rule 59 (operations -> logic_operation .)
    WINT            reduce using rule 59 (operations -> logic_operation .)
    WFLOAT          reduce using rule 59 (operations -> logic_operation .)
    WSTRING         reduce using rule 59 (operations -> logic_operation .)
    BOOL            reduce using rule 59 (operations -> logic_operation .)
    DEFAULT         reduce using rule 59 (operations -> logic_operation .)
    CASE            reduce using rule 59 (operations -> logic_operation .)
    RETURN          reduce using rule 59 (operations -> logic_operation .)
    RPAREN          reduce using rule 59 (operations -> logic_operation .)
    RCORCHE         reduce using rule 59 (operations -> logic_operation .)
    COMA            reduce using rule 59 (operations -> logic_operation .)


state 148

    (135) slice_assignment -> slice_var EQUAL something_s .

    COLON           reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    PRINT           reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    SCAN            reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    FOR             reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    ID              reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    APPEND          reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    LEN             reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    COPY            reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    DELETE          reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    IF              reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    ELSE            reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    TYPE            reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    SWITCH          reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    VAR             reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    FUNC            reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    INTEGER         reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    FLOAT           reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    NOT             reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    $end            reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    RLLAVE          reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    INT32           reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    INT64           reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    FLOAT32         reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    FLOAT64         reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    BYTE            reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    WINT            reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    WFLOAT          reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    WSTRING         reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    BOOL            reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    DEFAULT         reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    CASE            reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)
    RETURN          reduce using rule 135 (slice_assignment -> slice_var EQUAL something_s .)


state 149

    (136) something_s -> ID .
    (196) array_var -> ID . LCORCHE index RCORCHE
    (228) something_ex -> ID .
    (167) value -> ID .
    (181) logic_value -> ID .
    (202) map_var -> ID . LCORCHE key RCORCHE
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for COLON resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for INT32 resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for INT64 resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for BYTE resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for WINT resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for WSTRING resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 136 (something_s -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 167 (value -> ID .)
    COLON           reduce using rule 136 (something_s -> ID .)
    PRINT           reduce using rule 136 (something_s -> ID .)
    SCAN            reduce using rule 136 (something_s -> ID .)
    FOR             reduce using rule 136 (something_s -> ID .)
    ID              reduce using rule 136 (something_s -> ID .)
    APPEND          reduce using rule 136 (something_s -> ID .)
    LEN             reduce using rule 136 (something_s -> ID .)
    COPY            reduce using rule 136 (something_s -> ID .)
    DELETE          reduce using rule 136 (something_s -> ID .)
    IF              reduce using rule 136 (something_s -> ID .)
    ELSE            reduce using rule 136 (something_s -> ID .)
    TYPE            reduce using rule 136 (something_s -> ID .)
    SWITCH          reduce using rule 136 (something_s -> ID .)
    VAR             reduce using rule 136 (something_s -> ID .)
    FUNC            reduce using rule 136 (something_s -> ID .)
    INTEGER         reduce using rule 136 (something_s -> ID .)
    FLOAT           reduce using rule 136 (something_s -> ID .)
    NOT             reduce using rule 136 (something_s -> ID .)
    $end            reduce using rule 136 (something_s -> ID .)
    RLLAVE          reduce using rule 136 (something_s -> ID .)
    INT32           reduce using rule 136 (something_s -> ID .)
    INT64           reduce using rule 136 (something_s -> ID .)
    FLOAT32         reduce using rule 136 (something_s -> ID .)
    FLOAT64         reduce using rule 136 (something_s -> ID .)
    BYTE            reduce using rule 136 (something_s -> ID .)
    WINT            reduce using rule 136 (something_s -> ID .)
    WFLOAT          reduce using rule 136 (something_s -> ID .)
    WSTRING         reduce using rule 136 (something_s -> ID .)
    BOOL            reduce using rule 136 (something_s -> ID .)
    DEFAULT         reduce using rule 136 (something_s -> ID .)
    CASE            reduce using rule 136 (something_s -> ID .)
    RETURN          reduce using rule 136 (something_s -> ID .)
    LCORCHE         shift and go to state 167
    GREATER         reduce using rule 167 (value -> ID .)
    SMALLER         reduce using rule 167 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 167 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 167 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 167 (value -> ID .)
    NOT_EQUAL       reduce using rule 167 (value -> ID .)
    PLUS            reduce using rule 167 (value -> ID .)
    TIMES           reduce using rule 167 (value -> ID .)
    DIVIDE          reduce using rule 167 (value -> ID .)
    MINUS           reduce using rule 167 (value -> ID .)
    AND             reduce using rule 181 (logic_value -> ID .)
    OR              reduce using rule 181 (logic_value -> ID .)
    LPAREN          shift and go to state 106

  ! GREATER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 228 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 228 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 228 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 228 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 228 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 228 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 228 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 228 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 228 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 228 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 228 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 228 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 228 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 228 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 228 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 228 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 228 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 228 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! INT32           [ reduce using rule 228 (something_ex -> ID .) ]
  ! INT64           [ reduce using rule 228 (something_ex -> ID .) ]
  ! FLOAT32         [ reduce using rule 228 (something_ex -> ID .) ]
  ! FLOAT64         [ reduce using rule 228 (something_ex -> ID .) ]
  ! BYTE            [ reduce using rule 228 (something_ex -> ID .) ]
  ! WINT            [ reduce using rule 228 (something_ex -> ID .) ]
  ! WFLOAT          [ reduce using rule 228 (something_ex -> ID .) ]
  ! WSTRING         [ reduce using rule 228 (something_ex -> ID .) ]
  ! BOOL            [ reduce using rule 228 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 228 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 228 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 228 (something_ex -> ID .) ]


state 150

    (137) something_s -> array_var .
    (60) data_structure -> array_var .

  ! reduce/reduce conflict for COLON resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for PRINT resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for SCAN resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for FOR resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for ID resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for APPEND resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for LEN resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for COPY resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for DELETE resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for IF resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for ELSE resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for TYPE resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for SWITCH resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for VAR resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for FUNC resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for INTEGER resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for FLOAT resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for NOT resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for $end resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for INT32 resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for INT64 resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for BYTE resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for WINT resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for WSTRING resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for BOOL resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for CASE resolved using rule 60 (data_structure -> array_var .)
  ! reduce/reduce conflict for RETURN resolved using rule 60 (data_structure -> array_var .)
    GREATER         reduce using rule 60 (data_structure -> array_var .)
    SMALLER         reduce using rule 60 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 60 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 60 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 60 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 60 (data_structure -> array_var .)
    PLUS            reduce using rule 60 (data_structure -> array_var .)
    TIMES           reduce using rule 60 (data_structure -> array_var .)
    DIVIDE          reduce using rule 60 (data_structure -> array_var .)
    MINUS           reduce using rule 60 (data_structure -> array_var .)
    COLON           reduce using rule 60 (data_structure -> array_var .)
    PRINT           reduce using rule 60 (data_structure -> array_var .)
    SCAN            reduce using rule 60 (data_structure -> array_var .)
    FOR             reduce using rule 60 (data_structure -> array_var .)
    ID              reduce using rule 60 (data_structure -> array_var .)
    APPEND          reduce using rule 60 (data_structure -> array_var .)
    LEN             reduce using rule 60 (data_structure -> array_var .)
    COPY            reduce using rule 60 (data_structure -> array_var .)
    DELETE          reduce using rule 60 (data_structure -> array_var .)
    IF              reduce using rule 60 (data_structure -> array_var .)
    ELSE            reduce using rule 60 (data_structure -> array_var .)
    TYPE            reduce using rule 60 (data_structure -> array_var .)
    SWITCH          reduce using rule 60 (data_structure -> array_var .)
    VAR             reduce using rule 60 (data_structure -> array_var .)
    FUNC            reduce using rule 60 (data_structure -> array_var .)
    INTEGER         reduce using rule 60 (data_structure -> array_var .)
    FLOAT           reduce using rule 60 (data_structure -> array_var .)
    NOT             reduce using rule 60 (data_structure -> array_var .)
    $end            reduce using rule 60 (data_structure -> array_var .)
    RLLAVE          reduce using rule 60 (data_structure -> array_var .)
    INT32           reduce using rule 60 (data_structure -> array_var .)
    INT64           reduce using rule 60 (data_structure -> array_var .)
    FLOAT32         reduce using rule 60 (data_structure -> array_var .)
    FLOAT64         reduce using rule 60 (data_structure -> array_var .)
    BYTE            reduce using rule 60 (data_structure -> array_var .)
    WINT            reduce using rule 60 (data_structure -> array_var .)
    WFLOAT          reduce using rule 60 (data_structure -> array_var .)
    WSTRING         reduce using rule 60 (data_structure -> array_var .)
    BOOL            reduce using rule 60 (data_structure -> array_var .)
    DEFAULT         reduce using rule 60 (data_structure -> array_var .)
    CASE            reduce using rule 60 (data_structure -> array_var .)
    RETURN          reduce using rule 60 (data_structure -> array_var .)

  ! COLON           [ reduce using rule 137 (something_s -> array_var .) ]
  ! PRINT           [ reduce using rule 137 (something_s -> array_var .) ]
  ! SCAN            [ reduce using rule 137 (something_s -> array_var .) ]
  ! FOR             [ reduce using rule 137 (something_s -> array_var .) ]
  ! ID              [ reduce using rule 137 (something_s -> array_var .) ]
  ! APPEND          [ reduce using rule 137 (something_s -> array_var .) ]
  ! LEN             [ reduce using rule 137 (something_s -> array_var .) ]
  ! COPY            [ reduce using rule 137 (something_s -> array_var .) ]
  ! DELETE          [ reduce using rule 137 (something_s -> array_var .) ]
  ! IF              [ reduce using rule 137 (something_s -> array_var .) ]
  ! ELSE            [ reduce using rule 137 (something_s -> array_var .) ]
  ! TYPE            [ reduce using rule 137 (something_s -> array_var .) ]
  ! SWITCH          [ reduce using rule 137 (something_s -> array_var .) ]
  ! VAR             [ reduce using rule 137 (something_s -> array_var .) ]
  ! FUNC            [ reduce using rule 137 (something_s -> array_var .) ]
  ! INTEGER         [ reduce using rule 137 (something_s -> array_var .) ]
  ! FLOAT           [ reduce using rule 137 (something_s -> array_var .) ]
  ! NOT             [ reduce using rule 137 (something_s -> array_var .) ]
  ! $end            [ reduce using rule 137 (something_s -> array_var .) ]
  ! RLLAVE          [ reduce using rule 137 (something_s -> array_var .) ]
  ! INT32           [ reduce using rule 137 (something_s -> array_var .) ]
  ! INT64           [ reduce using rule 137 (something_s -> array_var .) ]
  ! FLOAT32         [ reduce using rule 137 (something_s -> array_var .) ]
  ! FLOAT64         [ reduce using rule 137 (something_s -> array_var .) ]
  ! BYTE            [ reduce using rule 137 (something_s -> array_var .) ]
  ! WINT            [ reduce using rule 137 (something_s -> array_var .) ]
  ! WFLOAT          [ reduce using rule 137 (something_s -> array_var .) ]
  ! WSTRING         [ reduce using rule 137 (something_s -> array_var .) ]
  ! BOOL            [ reduce using rule 137 (something_s -> array_var .) ]
  ! DEFAULT         [ reduce using rule 137 (something_s -> array_var .) ]
  ! CASE            [ reduce using rule 137 (something_s -> array_var .) ]
  ! RETURN          [ reduce using rule 137 (something_s -> array_var .) ]


state 151

    (138) something_s -> values .

    COLON           reduce using rule 138 (something_s -> values .)
    PRINT           reduce using rule 138 (something_s -> values .)
    SCAN            reduce using rule 138 (something_s -> values .)
    FOR             reduce using rule 138 (something_s -> values .)
    ID              reduce using rule 138 (something_s -> values .)
    APPEND          reduce using rule 138 (something_s -> values .)
    LEN             reduce using rule 138 (something_s -> values .)
    COPY            reduce using rule 138 (something_s -> values .)
    DELETE          reduce using rule 138 (something_s -> values .)
    IF              reduce using rule 138 (something_s -> values .)
    ELSE            reduce using rule 138 (something_s -> values .)
    TYPE            reduce using rule 138 (something_s -> values .)
    SWITCH          reduce using rule 138 (something_s -> values .)
    VAR             reduce using rule 138 (something_s -> values .)
    FUNC            reduce using rule 138 (something_s -> values .)
    INTEGER         reduce using rule 138 (something_s -> values .)
    FLOAT           reduce using rule 138 (something_s -> values .)
    NOT             reduce using rule 138 (something_s -> values .)
    $end            reduce using rule 138 (something_s -> values .)
    RLLAVE          reduce using rule 138 (something_s -> values .)
    INT32           reduce using rule 138 (something_s -> values .)
    INT64           reduce using rule 138 (something_s -> values .)
    FLOAT32         reduce using rule 138 (something_s -> values .)
    FLOAT64         reduce using rule 138 (something_s -> values .)
    BYTE            reduce using rule 138 (something_s -> values .)
    WINT            reduce using rule 138 (something_s -> values .)
    WFLOAT          reduce using rule 138 (something_s -> values .)
    WSTRING         reduce using rule 138 (something_s -> values .)
    BOOL            reduce using rule 138 (something_s -> values .)
    DEFAULT         reduce using rule 138 (something_s -> values .)
    CASE            reduce using rule 138 (something_s -> values .)
    RETURN          reduce using rule 138 (something_s -> values .)


state 152

    (139) something_s -> operations .

    COLON           reduce using rule 139 (something_s -> operations .)
    PRINT           reduce using rule 139 (something_s -> operations .)
    SCAN            reduce using rule 139 (something_s -> operations .)
    FOR             reduce using rule 139 (something_s -> operations .)
    ID              reduce using rule 139 (something_s -> operations .)
    APPEND          reduce using rule 139 (something_s -> operations .)
    LEN             reduce using rule 139 (something_s -> operations .)
    COPY            reduce using rule 139 (something_s -> operations .)
    DELETE          reduce using rule 139 (something_s -> operations .)
    IF              reduce using rule 139 (something_s -> operations .)
    ELSE            reduce using rule 139 (something_s -> operations .)
    TYPE            reduce using rule 139 (something_s -> operations .)
    SWITCH          reduce using rule 139 (something_s -> operations .)
    VAR             reduce using rule 139 (something_s -> operations .)
    FUNC            reduce using rule 139 (something_s -> operations .)
    INTEGER         reduce using rule 139 (something_s -> operations .)
    FLOAT           reduce using rule 139 (something_s -> operations .)
    NOT             reduce using rule 139 (something_s -> operations .)
    $end            reduce using rule 139 (something_s -> operations .)
    RLLAVE          reduce using rule 139 (something_s -> operations .)
    INT32           reduce using rule 139 (something_s -> operations .)
    INT64           reduce using rule 139 (something_s -> operations .)
    FLOAT32         reduce using rule 139 (something_s -> operations .)
    FLOAT64         reduce using rule 139 (something_s -> operations .)
    BYTE            reduce using rule 139 (something_s -> operations .)
    WINT            reduce using rule 139 (something_s -> operations .)
    WFLOAT          reduce using rule 139 (something_s -> operations .)
    WSTRING         reduce using rule 139 (something_s -> operations .)
    BOOL            reduce using rule 139 (something_s -> operations .)
    DEFAULT         reduce using rule 139 (something_s -> operations .)
    CASE            reduce using rule 139 (something_s -> operations .)
    RETURN          reduce using rule 139 (something_s -> operations .)


state 153

    (218) impresion -> PRINT LPAREN content . RPAREN

    RPAREN          shift and go to state 227


state 154

    (219) content -> values .

    RPAREN          reduce using rule 219 (content -> values .)


state 155

    (220) content -> operations .

    RPAREN          reduce using rule 220 (content -> operations .)


state 156

    (221) content -> funciones .
    (232) something_ex -> funciones .

  ! reduce/reduce conflict for RPAREN resolved using rule 221 (content -> funciones .)
    RPAREN          reduce using rule 221 (content -> funciones .)
    GREATER         reduce using rule 232 (something_ex -> funciones .)
    SMALLER         reduce using rule 232 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 232 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 232 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 232 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 232 (something_ex -> funciones .)
    PLUS            reduce using rule 232 (something_ex -> funciones .)
    TIMES           reduce using rule 232 (something_ex -> funciones .)
    DIVIDE          reduce using rule 232 (something_ex -> funciones .)
    MINUS           reduce using rule 232 (something_ex -> funciones .)

  ! RPAREN          [ reduce using rule 232 (something_ex -> funciones .) ]


state 157

    (222) content -> data_structure .
    (231) something_ex -> data_structure .

  ! reduce/reduce conflict for RPAREN resolved using rule 222 (content -> data_structure .)
    RPAREN          reduce using rule 222 (content -> data_structure .)
    GREATER         reduce using rule 231 (something_ex -> data_structure .)
    SMALLER         reduce using rule 231 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 231 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 231 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 231 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 231 (something_ex -> data_structure .)
    PLUS            reduce using rule 231 (something_ex -> data_structure .)
    TIMES           reduce using rule 231 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 231 (something_ex -> data_structure .)
    MINUS           reduce using rule 231 (something_ex -> data_structure .)

  ! RPAREN          [ reduce using rule 231 (something_ex -> data_structure .) ]


state 158

    (223) content -> ID .
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN
    (196) array_var -> ID . LCORCHE index RCORCHE
    (202) map_var -> ID . LCORCHE key RCORCHE
    (228) something_ex -> ID .
    (167) value -> ID .
    (181) logic_value -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 223 (content -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 167 (value -> ID .)
    RPAREN          reduce using rule 223 (content -> ID .)
    LPAREN          shift and go to state 106
    LCORCHE         shift and go to state 167
    GREATER         reduce using rule 167 (value -> ID .)
    SMALLER         reduce using rule 167 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 167 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 167 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 167 (value -> ID .)
    NOT_EQUAL       reduce using rule 167 (value -> ID .)
    PLUS            reduce using rule 167 (value -> ID .)
    TIMES           reduce using rule 167 (value -> ID .)
    DIVIDE          reduce using rule 167 (value -> ID .)
    MINUS           reduce using rule 167 (value -> ID .)
    AND             reduce using rule 181 (logic_value -> ID .)
    OR              reduce using rule 181 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 228 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 228 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 228 (something_ex -> ID .) ]
  ! RPAREN          [ reduce using rule 228 (something_ex -> ID .) ]


state 159

    (80) scan_func -> SCAN LPAREN POINTER . RPAREN

    RPAREN          shift and go to state 228


state 160

    (226) adicionaEx -> op something_ex .
    (227) adicionaEx -> op something_ex . adicionaEx
    (226) adicionaEx -> . op something_ex
    (227) adicionaEx -> . op something_ex adicionaEx
    (169) op -> . GREATER
    (170) op -> . SMALLER
    (171) op -> . GREATER_OR_EQUAL
    (172) op -> . SMALLER_OR_EQUAL
    (173) op -> . EQUAL_COMPARE
    (174) op -> . NOT_EQUAL
    (233) op -> . PLUS
    (234) op -> . TIMES
    (235) op -> . DIVIDE
    (236) op -> . MINUS

  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL_COMPARE resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    COLON           reduce using rule 226 (adicionaEx -> op something_ex .)
    PRINT           reduce using rule 226 (adicionaEx -> op something_ex .)
    SCAN            reduce using rule 226 (adicionaEx -> op something_ex .)
    FOR             reduce using rule 226 (adicionaEx -> op something_ex .)
    ID              reduce using rule 226 (adicionaEx -> op something_ex .)
    APPEND          reduce using rule 226 (adicionaEx -> op something_ex .)
    LEN             reduce using rule 226 (adicionaEx -> op something_ex .)
    COPY            reduce using rule 226 (adicionaEx -> op something_ex .)
    DELETE          reduce using rule 226 (adicionaEx -> op something_ex .)
    IF              reduce using rule 226 (adicionaEx -> op something_ex .)
    ELSE            reduce using rule 226 (adicionaEx -> op something_ex .)
    TYPE            reduce using rule 226 (adicionaEx -> op something_ex .)
    SWITCH          reduce using rule 226 (adicionaEx -> op something_ex .)
    VAR             reduce using rule 226 (adicionaEx -> op something_ex .)
    FUNC            reduce using rule 226 (adicionaEx -> op something_ex .)
    INTEGER         reduce using rule 226 (adicionaEx -> op something_ex .)
    FLOAT           reduce using rule 226 (adicionaEx -> op something_ex .)
    NOT             reduce using rule 226 (adicionaEx -> op something_ex .)
    $end            reduce using rule 226 (adicionaEx -> op something_ex .)
    RLLAVE          reduce using rule 226 (adicionaEx -> op something_ex .)
    INT32           reduce using rule 226 (adicionaEx -> op something_ex .)
    INT64           reduce using rule 226 (adicionaEx -> op something_ex .)
    FLOAT32         reduce using rule 226 (adicionaEx -> op something_ex .)
    FLOAT64         reduce using rule 226 (adicionaEx -> op something_ex .)
    BYTE            reduce using rule 226 (adicionaEx -> op something_ex .)
    WINT            reduce using rule 226 (adicionaEx -> op something_ex .)
    WFLOAT          reduce using rule 226 (adicionaEx -> op something_ex .)
    WSTRING         reduce using rule 226 (adicionaEx -> op something_ex .)
    BOOL            reduce using rule 226 (adicionaEx -> op something_ex .)
    DEFAULT         reduce using rule 226 (adicionaEx -> op something_ex .)
    CASE            reduce using rule 226 (adicionaEx -> op something_ex .)
    RETURN          reduce using rule 226 (adicionaEx -> op something_ex .)
    RPAREN          reduce using rule 226 (adicionaEx -> op something_ex .)
    AND             reduce using rule 226 (adicionaEx -> op something_ex .)
    OR              reduce using rule 226 (adicionaEx -> op something_ex .)
    LLLAVE          reduce using rule 226 (adicionaEx -> op something_ex .)
    RCORCHE         reduce using rule 226 (adicionaEx -> op something_ex .)
    COMA            reduce using rule 226 (adicionaEx -> op something_ex .)
    GREATER         shift and go to state 79
    SMALLER         shift and go to state 80
    GREATER_OR_EQUAL shift and go to state 81
    SMALLER_OR_EQUAL shift and go to state 82
    EQUAL_COMPARE   shift and go to state 83
    NOT_EQUAL       shift and go to state 84
    PLUS            shift and go to state 85
    TIMES           shift and go to state 86
    DIVIDE          shift and go to state 87
    MINUS           shift and go to state 88

  ! GREATER         [ reduce using rule 226 (adicionaEx -> op something_ex .) ]
  ! SMALLER         [ reduce using rule 226 (adicionaEx -> op something_ex .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 226 (adicionaEx -> op something_ex .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 226 (adicionaEx -> op something_ex .) ]
  ! EQUAL_COMPARE   [ reduce using rule 226 (adicionaEx -> op something_ex .) ]
  ! NOT_EQUAL       [ reduce using rule 226 (adicionaEx -> op something_ex .) ]
  ! PLUS            [ reduce using rule 226 (adicionaEx -> op something_ex .) ]
  ! TIMES           [ reduce using rule 226 (adicionaEx -> op something_ex .) ]
  ! DIVIDE          [ reduce using rule 226 (adicionaEx -> op something_ex .) ]
  ! MINUS           [ reduce using rule 226 (adicionaEx -> op something_ex .) ]

    op                             shift and go to state 78
    adicionaEx                     shift and go to state 229

state 161

    (228) something_ex -> ID .
    (196) array_var -> ID . LCORCHE index RCORCHE
    (202) map_var -> ID . LCORCHE key RCORCHE
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN

    GREATER         reduce using rule 228 (something_ex -> ID .)
    SMALLER         reduce using rule 228 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 228 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 228 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 228 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 228 (something_ex -> ID .)
    PLUS            reduce using rule 228 (something_ex -> ID .)
    TIMES           reduce using rule 228 (something_ex -> ID .)
    DIVIDE          reduce using rule 228 (something_ex -> ID .)
    MINUS           reduce using rule 228 (something_ex -> ID .)
    COLON           reduce using rule 228 (something_ex -> ID .)
    PRINT           reduce using rule 228 (something_ex -> ID .)
    SCAN            reduce using rule 228 (something_ex -> ID .)
    FOR             reduce using rule 228 (something_ex -> ID .)
    ID              reduce using rule 228 (something_ex -> ID .)
    APPEND          reduce using rule 228 (something_ex -> ID .)
    LEN             reduce using rule 228 (something_ex -> ID .)
    COPY            reduce using rule 228 (something_ex -> ID .)
    DELETE          reduce using rule 228 (something_ex -> ID .)
    IF              reduce using rule 228 (something_ex -> ID .)
    ELSE            reduce using rule 228 (something_ex -> ID .)
    TYPE            reduce using rule 228 (something_ex -> ID .)
    SWITCH          reduce using rule 228 (something_ex -> ID .)
    VAR             reduce using rule 228 (something_ex -> ID .)
    FUNC            reduce using rule 228 (something_ex -> ID .)
    INTEGER         reduce using rule 228 (something_ex -> ID .)
    FLOAT           reduce using rule 228 (something_ex -> ID .)
    NOT             reduce using rule 228 (something_ex -> ID .)
    $end            reduce using rule 228 (something_ex -> ID .)
    RLLAVE          reduce using rule 228 (something_ex -> ID .)
    INT32           reduce using rule 228 (something_ex -> ID .)
    INT64           reduce using rule 228 (something_ex -> ID .)
    FLOAT32         reduce using rule 228 (something_ex -> ID .)
    FLOAT64         reduce using rule 228 (something_ex -> ID .)
    BYTE            reduce using rule 228 (something_ex -> ID .)
    WINT            reduce using rule 228 (something_ex -> ID .)
    WFLOAT          reduce using rule 228 (something_ex -> ID .)
    WSTRING         reduce using rule 228 (something_ex -> ID .)
    BOOL            reduce using rule 228 (something_ex -> ID .)
    DEFAULT         reduce using rule 228 (something_ex -> ID .)
    CASE            reduce using rule 228 (something_ex -> ID .)
    RETURN          reduce using rule 228 (something_ex -> ID .)
    RPAREN          reduce using rule 228 (something_ex -> ID .)
    AND             reduce using rule 228 (something_ex -> ID .)
    OR              reduce using rule 228 (something_ex -> ID .)
    LLLAVE          reduce using rule 228 (something_ex -> ID .)
    RCORCHE         reduce using rule 228 (something_ex -> ID .)
    COMA            reduce using rule 228 (something_ex -> ID .)
    LCORCHE         shift and go to state 167
    LPAREN          shift and go to state 106


state 162

    (86) cicloFor -> FOR LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 230


state 163

    (87) cicloFor -> FOR comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

    comparison                     shift and go to state 8
    codigo                         shift and go to state 231
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 164

    (88) cicloFor -> FOR logic_operation LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

    logic_operation                shift and go to state 9
    codigo                         shift and go to state 232
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 165

    (89) cicloFor -> FOR decVarOne COLON . comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (167) value -> . ID
    (168) value -> . expression
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 114
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    comparison                     shift and go to state 233
    value                          shift and go to state 33
    expression                     shift and go to state 94
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 166

    (146) decVarOne -> ID DEQUAL . ID
    (147) decVarOne -> ID DEQUAL . INTEGER

    ID              shift and go to state 234
    INTEGER         shift and go to state 235


state 167

    (196) array_var -> ID LCORCHE . index RCORCHE
    (202) map_var -> ID LCORCHE . key RCORCHE
    (197) index -> . ID
    (198) index -> . INTEGER
    (199) index -> . expression
    (203) key -> . ID
    (204) key -> . values
    (205) key -> . operations
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 236
    INTEGER         shift and go to state 237
    STRING          shift and go to state 140
    FLOAT           shift and go to state 142
    TRUE            shift and go to state 143
    FALSE           shift and go to state 144
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    NOT             shift and go to state 54

    index                          shift and go to state 188
    key                            shift and go to state 190
    expression                     shift and go to state 238
    values                         shift and go to state 193
    operations                     shift and go to state 194
    something_ex                   shift and go to state 31
    comparison                     shift and go to state 146
    logic_operation                shift and go to state 147
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 168

    (166) comparison -> value op value .

    PRINT           reduce using rule 166 (comparison -> value op value .)
    SCAN            reduce using rule 166 (comparison -> value op value .)
    FOR             reduce using rule 166 (comparison -> value op value .)
    ID              reduce using rule 166 (comparison -> value op value .)
    APPEND          reduce using rule 166 (comparison -> value op value .)
    LEN             reduce using rule 166 (comparison -> value op value .)
    COPY            reduce using rule 166 (comparison -> value op value .)
    DELETE          reduce using rule 166 (comparison -> value op value .)
    IF              reduce using rule 166 (comparison -> value op value .)
    ELSE            reduce using rule 166 (comparison -> value op value .)
    TYPE            reduce using rule 166 (comparison -> value op value .)
    SWITCH          reduce using rule 166 (comparison -> value op value .)
    VAR             reduce using rule 166 (comparison -> value op value .)
    FUNC            reduce using rule 166 (comparison -> value op value .)
    INTEGER         reduce using rule 166 (comparison -> value op value .)
    FLOAT           reduce using rule 166 (comparison -> value op value .)
    NOT             reduce using rule 166 (comparison -> value op value .)
    $end            reduce using rule 166 (comparison -> value op value .)
    AND             reduce using rule 166 (comparison -> value op value .)
    OR              reduce using rule 166 (comparison -> value op value .)
    RLLAVE          reduce using rule 166 (comparison -> value op value .)
    INT32           reduce using rule 166 (comparison -> value op value .)
    INT64           reduce using rule 166 (comparison -> value op value .)
    FLOAT32         reduce using rule 166 (comparison -> value op value .)
    FLOAT64         reduce using rule 166 (comparison -> value op value .)
    BYTE            reduce using rule 166 (comparison -> value op value .)
    WINT            reduce using rule 166 (comparison -> value op value .)
    WFLOAT          reduce using rule 166 (comparison -> value op value .)
    WSTRING         reduce using rule 166 (comparison -> value op value .)
    BOOL            reduce using rule 166 (comparison -> value op value .)
    DEFAULT         reduce using rule 166 (comparison -> value op value .)
    CASE            reduce using rule 166 (comparison -> value op value .)
    RETURN          reduce using rule 166 (comparison -> value op value .)
    LLLAVE          reduce using rule 166 (comparison -> value op value .)
    COLON           reduce using rule 166 (comparison -> value op value .)
    RPAREN          reduce using rule 166 (comparison -> value op value .)
    RCORCHE         reduce using rule 166 (comparison -> value op value .)
    COMA            reduce using rule 166 (comparison -> value op value .)


state 169

    (177) logic_recu -> logic_op logic_value .
    (178) logic_recu -> logic_op logic_value . logic_recu
    (177) logic_recu -> . logic_op logic_value
    (178) logic_recu -> . logic_op logic_value logic_recu
    (184) logic_op -> . AND
    (185) logic_op -> . OR

    PRINT           reduce using rule 177 (logic_recu -> logic_op logic_value .)
    SCAN            reduce using rule 177 (logic_recu -> logic_op logic_value .)
    FOR             reduce using rule 177 (logic_recu -> logic_op logic_value .)
    ID              reduce using rule 177 (logic_recu -> logic_op logic_value .)
    APPEND          reduce using rule 177 (logic_recu -> logic_op logic_value .)
    LEN             reduce using rule 177 (logic_recu -> logic_op logic_value .)
    COPY            reduce using rule 177 (logic_recu -> logic_op logic_value .)
    DELETE          reduce using rule 177 (logic_recu -> logic_op logic_value .)
    IF              reduce using rule 177 (logic_recu -> logic_op logic_value .)
    ELSE            reduce using rule 177 (logic_recu -> logic_op logic_value .)
    TYPE            reduce using rule 177 (logic_recu -> logic_op logic_value .)
    SWITCH          reduce using rule 177 (logic_recu -> logic_op logic_value .)
    VAR             reduce using rule 177 (logic_recu -> logic_op logic_value .)
    FUNC            reduce using rule 177 (logic_recu -> logic_op logic_value .)
    INTEGER         reduce using rule 177 (logic_recu -> logic_op logic_value .)
    FLOAT           reduce using rule 177 (logic_recu -> logic_op logic_value .)
    NOT             reduce using rule 177 (logic_recu -> logic_op logic_value .)
    $end            reduce using rule 177 (logic_recu -> logic_op logic_value .)
    RLLAVE          reduce using rule 177 (logic_recu -> logic_op logic_value .)
    INT32           reduce using rule 177 (logic_recu -> logic_op logic_value .)
    INT64           reduce using rule 177 (logic_recu -> logic_op logic_value .)
    FLOAT32         reduce using rule 177 (logic_recu -> logic_op logic_value .)
    FLOAT64         reduce using rule 177 (logic_recu -> logic_op logic_value .)
    BYTE            reduce using rule 177 (logic_recu -> logic_op logic_value .)
    WINT            reduce using rule 177 (logic_recu -> logic_op logic_value .)
    WFLOAT          reduce using rule 177 (logic_recu -> logic_op logic_value .)
    WSTRING         reduce using rule 177 (logic_recu -> logic_op logic_value .)
    BOOL            reduce using rule 177 (logic_recu -> logic_op logic_value .)
    DEFAULT         reduce using rule 177 (logic_recu -> logic_op logic_value .)
    CASE            reduce using rule 177 (logic_recu -> logic_op logic_value .)
    RETURN          reduce using rule 177 (logic_recu -> logic_op logic_value .)
    LLLAVE          reduce using rule 177 (logic_recu -> logic_op logic_value .)
    COLON           reduce using rule 177 (logic_recu -> logic_op logic_value .)
    RPAREN          reduce using rule 177 (logic_recu -> logic_op logic_value .)
    RCORCHE         reduce using rule 177 (logic_recu -> logic_op logic_value .)
    COMA            reduce using rule 177 (logic_recu -> logic_op logic_value .)
    AND             shift and go to state 101
    OR              shift and go to state 102

    logic_op                       shift and go to state 100
    logic_recu                     shift and go to state 239

state 170

    (179) logic_value -> negation .

    AND             reduce using rule 179 (logic_value -> negation .)
    OR              reduce using rule 179 (logic_value -> negation .)
    PRINT           reduce using rule 179 (logic_value -> negation .)
    SCAN            reduce using rule 179 (logic_value -> negation .)
    FOR             reduce using rule 179 (logic_value -> negation .)
    ID              reduce using rule 179 (logic_value -> negation .)
    APPEND          reduce using rule 179 (logic_value -> negation .)
    LEN             reduce using rule 179 (logic_value -> negation .)
    COPY            reduce using rule 179 (logic_value -> negation .)
    DELETE          reduce using rule 179 (logic_value -> negation .)
    IF              reduce using rule 179 (logic_value -> negation .)
    ELSE            reduce using rule 179 (logic_value -> negation .)
    TYPE            reduce using rule 179 (logic_value -> negation .)
    SWITCH          reduce using rule 179 (logic_value -> negation .)
    VAR             reduce using rule 179 (logic_value -> negation .)
    FUNC            reduce using rule 179 (logic_value -> negation .)
    INTEGER         reduce using rule 179 (logic_value -> negation .)
    FLOAT           reduce using rule 179 (logic_value -> negation .)
    NOT             reduce using rule 179 (logic_value -> negation .)
    $end            reduce using rule 179 (logic_value -> negation .)
    RLLAVE          reduce using rule 179 (logic_value -> negation .)
    INT32           reduce using rule 179 (logic_value -> negation .)
    INT64           reduce using rule 179 (logic_value -> negation .)
    FLOAT32         reduce using rule 179 (logic_value -> negation .)
    FLOAT64         reduce using rule 179 (logic_value -> negation .)
    BYTE            reduce using rule 179 (logic_value -> negation .)
    WINT            reduce using rule 179 (logic_value -> negation .)
    WFLOAT          reduce using rule 179 (logic_value -> negation .)
    WSTRING         reduce using rule 179 (logic_value -> negation .)
    BOOL            reduce using rule 179 (logic_value -> negation .)
    DEFAULT         reduce using rule 179 (logic_value -> negation .)
    CASE            reduce using rule 179 (logic_value -> negation .)
    RETURN          reduce using rule 179 (logic_value -> negation .)
    LLLAVE          reduce using rule 179 (logic_value -> negation .)
    COLON           reduce using rule 179 (logic_value -> negation .)
    RPAREN          reduce using rule 179 (logic_value -> negation .)
    RCORCHE         reduce using rule 179 (logic_value -> negation .)
    COMA            reduce using rule 179 (logic_value -> negation .)


state 171

    (180) logic_value -> comparison .

    AND             reduce using rule 180 (logic_value -> comparison .)
    OR              reduce using rule 180 (logic_value -> comparison .)
    PRINT           reduce using rule 180 (logic_value -> comparison .)
    SCAN            reduce using rule 180 (logic_value -> comparison .)
    FOR             reduce using rule 180 (logic_value -> comparison .)
    ID              reduce using rule 180 (logic_value -> comparison .)
    APPEND          reduce using rule 180 (logic_value -> comparison .)
    LEN             reduce using rule 180 (logic_value -> comparison .)
    COPY            reduce using rule 180 (logic_value -> comparison .)
    DELETE          reduce using rule 180 (logic_value -> comparison .)
    IF              reduce using rule 180 (logic_value -> comparison .)
    ELSE            reduce using rule 180 (logic_value -> comparison .)
    TYPE            reduce using rule 180 (logic_value -> comparison .)
    SWITCH          reduce using rule 180 (logic_value -> comparison .)
    VAR             reduce using rule 180 (logic_value -> comparison .)
    FUNC            reduce using rule 180 (logic_value -> comparison .)
    INTEGER         reduce using rule 180 (logic_value -> comparison .)
    FLOAT           reduce using rule 180 (logic_value -> comparison .)
    NOT             reduce using rule 180 (logic_value -> comparison .)
    $end            reduce using rule 180 (logic_value -> comparison .)
    RLLAVE          reduce using rule 180 (logic_value -> comparison .)
    INT32           reduce using rule 180 (logic_value -> comparison .)
    INT64           reduce using rule 180 (logic_value -> comparison .)
    FLOAT32         reduce using rule 180 (logic_value -> comparison .)
    FLOAT64         reduce using rule 180 (logic_value -> comparison .)
    BYTE            reduce using rule 180 (logic_value -> comparison .)
    WINT            reduce using rule 180 (logic_value -> comparison .)
    WFLOAT          reduce using rule 180 (logic_value -> comparison .)
    WSTRING         reduce using rule 180 (logic_value -> comparison .)
    BOOL            reduce using rule 180 (logic_value -> comparison .)
    DEFAULT         reduce using rule 180 (logic_value -> comparison .)
    CASE            reduce using rule 180 (logic_value -> comparison .)
    RETURN          reduce using rule 180 (logic_value -> comparison .)
    LLLAVE          reduce using rule 180 (logic_value -> comparison .)
    COLON           reduce using rule 180 (logic_value -> comparison .)
    RPAREN          reduce using rule 180 (logic_value -> comparison .)
    RCORCHE         reduce using rule 180 (logic_value -> comparison .)
    COMA            reduce using rule 180 (logic_value -> comparison .)


state 172

    (181) logic_value -> ID .
    (167) value -> ID .
    (228) something_ex -> ID .
    (196) array_var -> ID . LCORCHE index RCORCHE
    (202) map_var -> ID . LCORCHE key RCORCHE
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 167 (value -> ID .)
    AND             reduce using rule 181 (logic_value -> ID .)
    OR              reduce using rule 181 (logic_value -> ID .)
    PRINT           reduce using rule 181 (logic_value -> ID .)
    SCAN            reduce using rule 181 (logic_value -> ID .)
    FOR             reduce using rule 181 (logic_value -> ID .)
    ID              reduce using rule 181 (logic_value -> ID .)
    APPEND          reduce using rule 181 (logic_value -> ID .)
    LEN             reduce using rule 181 (logic_value -> ID .)
    COPY            reduce using rule 181 (logic_value -> ID .)
    DELETE          reduce using rule 181 (logic_value -> ID .)
    IF              reduce using rule 181 (logic_value -> ID .)
    ELSE            reduce using rule 181 (logic_value -> ID .)
    TYPE            reduce using rule 181 (logic_value -> ID .)
    SWITCH          reduce using rule 181 (logic_value -> ID .)
    VAR             reduce using rule 181 (logic_value -> ID .)
    FUNC            reduce using rule 181 (logic_value -> ID .)
    INTEGER         reduce using rule 181 (logic_value -> ID .)
    FLOAT           reduce using rule 181 (logic_value -> ID .)
    NOT             reduce using rule 181 (logic_value -> ID .)
    $end            reduce using rule 181 (logic_value -> ID .)
    RLLAVE          reduce using rule 181 (logic_value -> ID .)
    INT32           reduce using rule 181 (logic_value -> ID .)
    INT64           reduce using rule 181 (logic_value -> ID .)
    FLOAT32         reduce using rule 181 (logic_value -> ID .)
    FLOAT64         reduce using rule 181 (logic_value -> ID .)
    BYTE            reduce using rule 181 (logic_value -> ID .)
    WINT            reduce using rule 181 (logic_value -> ID .)
    WFLOAT          reduce using rule 181 (logic_value -> ID .)
    WSTRING         reduce using rule 181 (logic_value -> ID .)
    BOOL            reduce using rule 181 (logic_value -> ID .)
    DEFAULT         reduce using rule 181 (logic_value -> ID .)
    CASE            reduce using rule 181 (logic_value -> ID .)
    RETURN          reduce using rule 181 (logic_value -> ID .)
    LLLAVE          reduce using rule 181 (logic_value -> ID .)
    COLON           reduce using rule 181 (logic_value -> ID .)
    RPAREN          reduce using rule 181 (logic_value -> ID .)
    RCORCHE         reduce using rule 181 (logic_value -> ID .)
    COMA            reduce using rule 181 (logic_value -> ID .)
    GREATER         reduce using rule 167 (value -> ID .)
    SMALLER         reduce using rule 167 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 167 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 167 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 167 (value -> ID .)
    NOT_EQUAL       reduce using rule 167 (value -> ID .)
    PLUS            reduce using rule 167 (value -> ID .)
    TIMES           reduce using rule 167 (value -> ID .)
    DIVIDE          reduce using rule 167 (value -> ID .)
    MINUS           reduce using rule 167 (value -> ID .)
    LCORCHE         shift and go to state 167
    LPAREN          shift and go to state 106

  ! GREATER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 228 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 228 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 228 (something_ex -> ID .) ]


state 173

    (65) any -> ID .
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN
    (196) array_var -> ID . LCORCHE index RCORCHE
    (202) map_var -> ID . LCORCHE key RCORCHE
    (228) something_ex -> ID .
    (167) value -> ID .
    (181) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for PRINT resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for SCAN resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for FOR resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for ID resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for APPEND resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for LEN resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for COPY resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for DELETE resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for IF resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for ELSE resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for TYPE resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for SWITCH resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for VAR resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for FUNC resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for INTEGER resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for FLOAT resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for NOT resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for INT32 resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for INT64 resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for BYTE resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for WINT resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for WSTRING resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for BOOL resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 65 (any -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 167 (value -> ID .)
    COLON           reduce using rule 65 (any -> ID .)
    PRINT           reduce using rule 65 (any -> ID .)
    SCAN            reduce using rule 65 (any -> ID .)
    FOR             reduce using rule 65 (any -> ID .)
    ID              reduce using rule 65 (any -> ID .)
    APPEND          reduce using rule 65 (any -> ID .)
    LEN             reduce using rule 65 (any -> ID .)
    COPY            reduce using rule 65 (any -> ID .)
    DELETE          reduce using rule 65 (any -> ID .)
    IF              reduce using rule 65 (any -> ID .)
    ELSE            reduce using rule 65 (any -> ID .)
    TYPE            reduce using rule 65 (any -> ID .)
    SWITCH          reduce using rule 65 (any -> ID .)
    VAR             reduce using rule 65 (any -> ID .)
    FUNC            reduce using rule 65 (any -> ID .)
    INTEGER         reduce using rule 65 (any -> ID .)
    FLOAT           reduce using rule 65 (any -> ID .)
    NOT             reduce using rule 65 (any -> ID .)
    $end            reduce using rule 65 (any -> ID .)
    RLLAVE          reduce using rule 65 (any -> ID .)
    INT32           reduce using rule 65 (any -> ID .)
    INT64           reduce using rule 65 (any -> ID .)
    FLOAT32         reduce using rule 65 (any -> ID .)
    FLOAT64         reduce using rule 65 (any -> ID .)
    BYTE            reduce using rule 65 (any -> ID .)
    WINT            reduce using rule 65 (any -> ID .)
    WFLOAT          reduce using rule 65 (any -> ID .)
    WSTRING         reduce using rule 65 (any -> ID .)
    BOOL            reduce using rule 65 (any -> ID .)
    DEFAULT         reduce using rule 65 (any -> ID .)
    CASE            reduce using rule 65 (any -> ID .)
    RETURN          reduce using rule 65 (any -> ID .)
    LPAREN          shift and go to state 106
    LCORCHE         shift and go to state 167
    GREATER         reduce using rule 167 (value -> ID .)
    SMALLER         reduce using rule 167 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 167 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 167 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 167 (value -> ID .)
    NOT_EQUAL       reduce using rule 167 (value -> ID .)
    PLUS            reduce using rule 167 (value -> ID .)
    TIMES           reduce using rule 167 (value -> ID .)
    DIVIDE          reduce using rule 167 (value -> ID .)
    MINUS           reduce using rule 167 (value -> ID .)
    AND             reduce using rule 181 (logic_value -> ID .)
    OR              reduce using rule 181 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 228 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 228 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 228 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 228 (something_ex -> ID .) ]
  ! PRINT           [ reduce using rule 228 (something_ex -> ID .) ]
  ! SCAN            [ reduce using rule 228 (something_ex -> ID .) ]
  ! FOR             [ reduce using rule 228 (something_ex -> ID .) ]
  ! ID              [ reduce using rule 228 (something_ex -> ID .) ]
  ! APPEND          [ reduce using rule 228 (something_ex -> ID .) ]
  ! LEN             [ reduce using rule 228 (something_ex -> ID .) ]
  ! COPY            [ reduce using rule 228 (something_ex -> ID .) ]
  ! DELETE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! IF              [ reduce using rule 228 (something_ex -> ID .) ]
  ! ELSE            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TYPE            [ reduce using rule 228 (something_ex -> ID .) ]
  ! SWITCH          [ reduce using rule 228 (something_ex -> ID .) ]
  ! VAR             [ reduce using rule 228 (something_ex -> ID .) ]
  ! FUNC            [ reduce using rule 228 (something_ex -> ID .) ]
  ! INTEGER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! FLOAT           [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT             [ reduce using rule 228 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 228 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! INT32           [ reduce using rule 228 (something_ex -> ID .) ]
  ! INT64           [ reduce using rule 228 (something_ex -> ID .) ]
  ! FLOAT32         [ reduce using rule 228 (something_ex -> ID .) ]
  ! FLOAT64         [ reduce using rule 228 (something_ex -> ID .) ]
  ! BYTE            [ reduce using rule 228 (something_ex -> ID .) ]
  ! WINT            [ reduce using rule 228 (something_ex -> ID .) ]
  ! WFLOAT          [ reduce using rule 228 (something_ex -> ID .) ]
  ! WSTRING         [ reduce using rule 228 (something_ex -> ID .) ]
  ! BOOL            [ reduce using rule 228 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 228 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 228 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 228 (something_ex -> ID .) ]


state 174

    (62) var_asignation -> ID EQUAL any .

    COLON           reduce using rule 62 (var_asignation -> ID EQUAL any .)
    PRINT           reduce using rule 62 (var_asignation -> ID EQUAL any .)
    SCAN            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    FOR             reduce using rule 62 (var_asignation -> ID EQUAL any .)
    ID              reduce using rule 62 (var_asignation -> ID EQUAL any .)
    APPEND          reduce using rule 62 (var_asignation -> ID EQUAL any .)
    LEN             reduce using rule 62 (var_asignation -> ID EQUAL any .)
    COPY            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    DELETE          reduce using rule 62 (var_asignation -> ID EQUAL any .)
    IF              reduce using rule 62 (var_asignation -> ID EQUAL any .)
    ELSE            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    TYPE            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    SWITCH          reduce using rule 62 (var_asignation -> ID EQUAL any .)
    VAR             reduce using rule 62 (var_asignation -> ID EQUAL any .)
    FUNC            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    INTEGER         reduce using rule 62 (var_asignation -> ID EQUAL any .)
    FLOAT           reduce using rule 62 (var_asignation -> ID EQUAL any .)
    NOT             reduce using rule 62 (var_asignation -> ID EQUAL any .)
    $end            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    RLLAVE          reduce using rule 62 (var_asignation -> ID EQUAL any .)
    INT32           reduce using rule 62 (var_asignation -> ID EQUAL any .)
    INT64           reduce using rule 62 (var_asignation -> ID EQUAL any .)
    FLOAT32         reduce using rule 62 (var_asignation -> ID EQUAL any .)
    FLOAT64         reduce using rule 62 (var_asignation -> ID EQUAL any .)
    BYTE            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    WINT            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    WFLOAT          reduce using rule 62 (var_asignation -> ID EQUAL any .)
    WSTRING         reduce using rule 62 (var_asignation -> ID EQUAL any .)
    BOOL            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    DEFAULT         reduce using rule 62 (var_asignation -> ID EQUAL any .)
    CASE            reduce using rule 62 (var_asignation -> ID EQUAL any .)
    RETURN          reduce using rule 62 (var_asignation -> ID EQUAL any .)


state 175

    (63) any -> values .

    COLON           reduce using rule 63 (any -> values .)
    PRINT           reduce using rule 63 (any -> values .)
    SCAN            reduce using rule 63 (any -> values .)
    FOR             reduce using rule 63 (any -> values .)
    ID              reduce using rule 63 (any -> values .)
    APPEND          reduce using rule 63 (any -> values .)
    LEN             reduce using rule 63 (any -> values .)
    COPY            reduce using rule 63 (any -> values .)
    DELETE          reduce using rule 63 (any -> values .)
    IF              reduce using rule 63 (any -> values .)
    ELSE            reduce using rule 63 (any -> values .)
    TYPE            reduce using rule 63 (any -> values .)
    SWITCH          reduce using rule 63 (any -> values .)
    VAR             reduce using rule 63 (any -> values .)
    FUNC            reduce using rule 63 (any -> values .)
    INTEGER         reduce using rule 63 (any -> values .)
    FLOAT           reduce using rule 63 (any -> values .)
    NOT             reduce using rule 63 (any -> values .)
    $end            reduce using rule 63 (any -> values .)
    RLLAVE          reduce using rule 63 (any -> values .)
    INT32           reduce using rule 63 (any -> values .)
    INT64           reduce using rule 63 (any -> values .)
    FLOAT32         reduce using rule 63 (any -> values .)
    FLOAT64         reduce using rule 63 (any -> values .)
    BYTE            reduce using rule 63 (any -> values .)
    WINT            reduce using rule 63 (any -> values .)
    WFLOAT          reduce using rule 63 (any -> values .)
    WSTRING         reduce using rule 63 (any -> values .)
    BOOL            reduce using rule 63 (any -> values .)
    DEFAULT         reduce using rule 63 (any -> values .)
    CASE            reduce using rule 63 (any -> values .)
    RETURN          reduce using rule 63 (any -> values .)


state 176

    (64) any -> operations .

    COLON           reduce using rule 64 (any -> operations .)
    PRINT           reduce using rule 64 (any -> operations .)
    SCAN            reduce using rule 64 (any -> operations .)
    FOR             reduce using rule 64 (any -> operations .)
    ID              reduce using rule 64 (any -> operations .)
    APPEND          reduce using rule 64 (any -> operations .)
    LEN             reduce using rule 64 (any -> operations .)
    COPY            reduce using rule 64 (any -> operations .)
    DELETE          reduce using rule 64 (any -> operations .)
    IF              reduce using rule 64 (any -> operations .)
    ELSE            reduce using rule 64 (any -> operations .)
    TYPE            reduce using rule 64 (any -> operations .)
    SWITCH          reduce using rule 64 (any -> operations .)
    VAR             reduce using rule 64 (any -> operations .)
    FUNC            reduce using rule 64 (any -> operations .)
    INTEGER         reduce using rule 64 (any -> operations .)
    FLOAT           reduce using rule 64 (any -> operations .)
    NOT             reduce using rule 64 (any -> operations .)
    $end            reduce using rule 64 (any -> operations .)
    RLLAVE          reduce using rule 64 (any -> operations .)
    INT32           reduce using rule 64 (any -> operations .)
    INT64           reduce using rule 64 (any -> operations .)
    FLOAT32         reduce using rule 64 (any -> operations .)
    FLOAT64         reduce using rule 64 (any -> operations .)
    BYTE            reduce using rule 64 (any -> operations .)
    WINT            reduce using rule 64 (any -> operations .)
    WFLOAT          reduce using rule 64 (any -> operations .)
    WSTRING         reduce using rule 64 (any -> operations .)
    BOOL            reduce using rule 64 (any -> operations .)
    DEFAULT         reduce using rule 64 (any -> operations .)
    CASE            reduce using rule 64 (any -> operations .)
    RETURN          reduce using rule 64 (any -> operations .)


state 177

    (66) any -> data_structure .
    (231) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for PRINT resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for SCAN resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for FOR resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for ID resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for APPEND resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for LEN resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for COPY resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for DELETE resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for IF resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for ELSE resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for TYPE resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for SWITCH resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for VAR resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for FUNC resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for INTEGER resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for FLOAT resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for NOT resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for $end resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for INT32 resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for INT64 resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for BYTE resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for WINT resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for WSTRING resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for BOOL resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for CASE resolved using rule 66 (any -> data_structure .)
  ! reduce/reduce conflict for RETURN resolved using rule 66 (any -> data_structure .)
    COLON           reduce using rule 66 (any -> data_structure .)
    PRINT           reduce using rule 66 (any -> data_structure .)
    SCAN            reduce using rule 66 (any -> data_structure .)
    FOR             reduce using rule 66 (any -> data_structure .)
    ID              reduce using rule 66 (any -> data_structure .)
    APPEND          reduce using rule 66 (any -> data_structure .)
    LEN             reduce using rule 66 (any -> data_structure .)
    COPY            reduce using rule 66 (any -> data_structure .)
    DELETE          reduce using rule 66 (any -> data_structure .)
    IF              reduce using rule 66 (any -> data_structure .)
    ELSE            reduce using rule 66 (any -> data_structure .)
    TYPE            reduce using rule 66 (any -> data_structure .)
    SWITCH          reduce using rule 66 (any -> data_structure .)
    VAR             reduce using rule 66 (any -> data_structure .)
    FUNC            reduce using rule 66 (any -> data_structure .)
    INTEGER         reduce using rule 66 (any -> data_structure .)
    FLOAT           reduce using rule 66 (any -> data_structure .)
    NOT             reduce using rule 66 (any -> data_structure .)
    $end            reduce using rule 66 (any -> data_structure .)
    RLLAVE          reduce using rule 66 (any -> data_structure .)
    INT32           reduce using rule 66 (any -> data_structure .)
    INT64           reduce using rule 66 (any -> data_structure .)
    FLOAT32         reduce using rule 66 (any -> data_structure .)
    FLOAT64         reduce using rule 66 (any -> data_structure .)
    BYTE            reduce using rule 66 (any -> data_structure .)
    WINT            reduce using rule 66 (any -> data_structure .)
    WFLOAT          reduce using rule 66 (any -> data_structure .)
    WSTRING         reduce using rule 66 (any -> data_structure .)
    BOOL            reduce using rule 66 (any -> data_structure .)
    DEFAULT         reduce using rule 66 (any -> data_structure .)
    CASE            reduce using rule 66 (any -> data_structure .)
    RETURN          reduce using rule 66 (any -> data_structure .)
    GREATER         reduce using rule 231 (something_ex -> data_structure .)
    SMALLER         reduce using rule 231 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 231 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 231 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 231 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 231 (something_ex -> data_structure .)
    PLUS            reduce using rule 231 (something_ex -> data_structure .)
    TIMES           reduce using rule 231 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 231 (something_ex -> data_structure .)
    MINUS           reduce using rule 231 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! PRINT           [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! SCAN            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! FOR             [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! ID              [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! APPEND          [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! LEN             [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! COPY            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! DELETE          [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! IF              [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! ELSE            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! TYPE            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! SWITCH          [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! VAR             [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! FUNC            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! INTEGER         [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! FLOAT           [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! NOT             [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! $end            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! INT32           [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! INT64           [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! FLOAT32         [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! FLOAT64         [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! BYTE            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! WINT            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! WFLOAT          [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! WSTRING         [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! BOOL            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! DEFAULT         [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! CASE            [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! RETURN          [ reduce using rule 231 (something_ex -> data_structure .) ]


state 178

    (67) any -> funciones .
    (232) something_ex -> funciones .

  ! reduce/reduce conflict for COLON resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for PRINT resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for SCAN resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for FOR resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for ID resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for APPEND resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for LEN resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for COPY resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for DELETE resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for IF resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for ELSE resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for TYPE resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for SWITCH resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for VAR resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for FUNC resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for INTEGER resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for FLOAT resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for NOT resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for $end resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for INT32 resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for INT64 resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for BYTE resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for WINT resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for WSTRING resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for BOOL resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for CASE resolved using rule 67 (any -> funciones .)
  ! reduce/reduce conflict for RETURN resolved using rule 67 (any -> funciones .)
    COLON           reduce using rule 67 (any -> funciones .)
    PRINT           reduce using rule 67 (any -> funciones .)
    SCAN            reduce using rule 67 (any -> funciones .)
    FOR             reduce using rule 67 (any -> funciones .)
    ID              reduce using rule 67 (any -> funciones .)
    APPEND          reduce using rule 67 (any -> funciones .)
    LEN             reduce using rule 67 (any -> funciones .)
    COPY            reduce using rule 67 (any -> funciones .)
    DELETE          reduce using rule 67 (any -> funciones .)
    IF              reduce using rule 67 (any -> funciones .)
    ELSE            reduce using rule 67 (any -> funciones .)
    TYPE            reduce using rule 67 (any -> funciones .)
    SWITCH          reduce using rule 67 (any -> funciones .)
    VAR             reduce using rule 67 (any -> funciones .)
    FUNC            reduce using rule 67 (any -> funciones .)
    INTEGER         reduce using rule 67 (any -> funciones .)
    FLOAT           reduce using rule 67 (any -> funciones .)
    NOT             reduce using rule 67 (any -> funciones .)
    $end            reduce using rule 67 (any -> funciones .)
    RLLAVE          reduce using rule 67 (any -> funciones .)
    INT32           reduce using rule 67 (any -> funciones .)
    INT64           reduce using rule 67 (any -> funciones .)
    FLOAT32         reduce using rule 67 (any -> funciones .)
    FLOAT64         reduce using rule 67 (any -> funciones .)
    BYTE            reduce using rule 67 (any -> funciones .)
    WINT            reduce using rule 67 (any -> funciones .)
    WFLOAT          reduce using rule 67 (any -> funciones .)
    WSTRING         reduce using rule 67 (any -> funciones .)
    BOOL            reduce using rule 67 (any -> funciones .)
    DEFAULT         reduce using rule 67 (any -> funciones .)
    CASE            reduce using rule 67 (any -> funciones .)
    RETURN          reduce using rule 67 (any -> funciones .)
    GREATER         reduce using rule 232 (something_ex -> funciones .)
    SMALLER         reduce using rule 232 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 232 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 232 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 232 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 232 (something_ex -> funciones .)
    PLUS            reduce using rule 232 (something_ex -> funciones .)
    TIMES           reduce using rule 232 (something_ex -> funciones .)
    DIVIDE          reduce using rule 232 (something_ex -> funciones .)
    MINUS           reduce using rule 232 (something_ex -> funciones .)

  ! COLON           [ reduce using rule 232 (something_ex -> funciones .) ]
  ! PRINT           [ reduce using rule 232 (something_ex -> funciones .) ]
  ! SCAN            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! FOR             [ reduce using rule 232 (something_ex -> funciones .) ]
  ! ID              [ reduce using rule 232 (something_ex -> funciones .) ]
  ! APPEND          [ reduce using rule 232 (something_ex -> funciones .) ]
  ! LEN             [ reduce using rule 232 (something_ex -> funciones .) ]
  ! COPY            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! DELETE          [ reduce using rule 232 (something_ex -> funciones .) ]
  ! IF              [ reduce using rule 232 (something_ex -> funciones .) ]
  ! ELSE            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! TYPE            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! SWITCH          [ reduce using rule 232 (something_ex -> funciones .) ]
  ! VAR             [ reduce using rule 232 (something_ex -> funciones .) ]
  ! FUNC            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! INTEGER         [ reduce using rule 232 (something_ex -> funciones .) ]
  ! FLOAT           [ reduce using rule 232 (something_ex -> funciones .) ]
  ! NOT             [ reduce using rule 232 (something_ex -> funciones .) ]
  ! $end            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! RLLAVE          [ reduce using rule 232 (something_ex -> funciones .) ]
  ! INT32           [ reduce using rule 232 (something_ex -> funciones .) ]
  ! INT64           [ reduce using rule 232 (something_ex -> funciones .) ]
  ! FLOAT32         [ reduce using rule 232 (something_ex -> funciones .) ]
  ! FLOAT64         [ reduce using rule 232 (something_ex -> funciones .) ]
  ! BYTE            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! WINT            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! WFLOAT          [ reduce using rule 232 (something_ex -> funciones .) ]
  ! WSTRING         [ reduce using rule 232 (something_ex -> funciones .) ]
  ! BOOL            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! DEFAULT         [ reduce using rule 232 (something_ex -> funciones .) ]
  ! CASE            [ reduce using rule 232 (something_ex -> funciones .) ]
  ! RETURN          [ reduce using rule 232 (something_ex -> funciones .) ]


state 179

    (68) any -> call_func .
    (145) funciones -> call_func .

  ! reduce/reduce conflict for COLON resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for PRINT resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for SCAN resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for FOR resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for ID resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for APPEND resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for LEN resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for COPY resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for DELETE resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for IF resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for ELSE resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for TYPE resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for SWITCH resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for VAR resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for FUNC resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for INTEGER resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for FLOAT resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for NOT resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for $end resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for INT32 resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for INT64 resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for BYTE resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for WINT resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for WSTRING resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for BOOL resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for CASE resolved using rule 68 (any -> call_func .)
  ! reduce/reduce conflict for RETURN resolved using rule 68 (any -> call_func .)
    COLON           reduce using rule 68 (any -> call_func .)
    PRINT           reduce using rule 68 (any -> call_func .)
    SCAN            reduce using rule 68 (any -> call_func .)
    FOR             reduce using rule 68 (any -> call_func .)
    ID              reduce using rule 68 (any -> call_func .)
    APPEND          reduce using rule 68 (any -> call_func .)
    LEN             reduce using rule 68 (any -> call_func .)
    COPY            reduce using rule 68 (any -> call_func .)
    DELETE          reduce using rule 68 (any -> call_func .)
    IF              reduce using rule 68 (any -> call_func .)
    ELSE            reduce using rule 68 (any -> call_func .)
    TYPE            reduce using rule 68 (any -> call_func .)
    SWITCH          reduce using rule 68 (any -> call_func .)
    VAR             reduce using rule 68 (any -> call_func .)
    FUNC            reduce using rule 68 (any -> call_func .)
    INTEGER         reduce using rule 68 (any -> call_func .)
    FLOAT           reduce using rule 68 (any -> call_func .)
    NOT             reduce using rule 68 (any -> call_func .)
    $end            reduce using rule 68 (any -> call_func .)
    RLLAVE          reduce using rule 68 (any -> call_func .)
    INT32           reduce using rule 68 (any -> call_func .)
    INT64           reduce using rule 68 (any -> call_func .)
    FLOAT32         reduce using rule 68 (any -> call_func .)
    FLOAT64         reduce using rule 68 (any -> call_func .)
    BYTE            reduce using rule 68 (any -> call_func .)
    WINT            reduce using rule 68 (any -> call_func .)
    WFLOAT          reduce using rule 68 (any -> call_func .)
    WSTRING         reduce using rule 68 (any -> call_func .)
    BOOL            reduce using rule 68 (any -> call_func .)
    DEFAULT         reduce using rule 68 (any -> call_func .)
    CASE            reduce using rule 68 (any -> call_func .)
    RETURN          reduce using rule 68 (any -> call_func .)
    GREATER         reduce using rule 145 (funciones -> call_func .)
    SMALLER         reduce using rule 145 (funciones -> call_func .)
    GREATER_OR_EQUAL reduce using rule 145 (funciones -> call_func .)
    SMALLER_OR_EQUAL reduce using rule 145 (funciones -> call_func .)
    EQUAL_COMPARE   reduce using rule 145 (funciones -> call_func .)
    NOT_EQUAL       reduce using rule 145 (funciones -> call_func .)
    PLUS            reduce using rule 145 (funciones -> call_func .)
    TIMES           reduce using rule 145 (funciones -> call_func .)
    DIVIDE          reduce using rule 145 (funciones -> call_func .)
    MINUS           reduce using rule 145 (funciones -> call_func .)

  ! COLON           [ reduce using rule 145 (funciones -> call_func .) ]
  ! PRINT           [ reduce using rule 145 (funciones -> call_func .) ]
  ! SCAN            [ reduce using rule 145 (funciones -> call_func .) ]
  ! FOR             [ reduce using rule 145 (funciones -> call_func .) ]
  ! ID              [ reduce using rule 145 (funciones -> call_func .) ]
  ! APPEND          [ reduce using rule 145 (funciones -> call_func .) ]
  ! LEN             [ reduce using rule 145 (funciones -> call_func .) ]
  ! COPY            [ reduce using rule 145 (funciones -> call_func .) ]
  ! DELETE          [ reduce using rule 145 (funciones -> call_func .) ]
  ! IF              [ reduce using rule 145 (funciones -> call_func .) ]
  ! ELSE            [ reduce using rule 145 (funciones -> call_func .) ]
  ! TYPE            [ reduce using rule 145 (funciones -> call_func .) ]
  ! SWITCH          [ reduce using rule 145 (funciones -> call_func .) ]
  ! VAR             [ reduce using rule 145 (funciones -> call_func .) ]
  ! FUNC            [ reduce using rule 145 (funciones -> call_func .) ]
  ! INTEGER         [ reduce using rule 145 (funciones -> call_func .) ]
  ! FLOAT           [ reduce using rule 145 (funciones -> call_func .) ]
  ! NOT             [ reduce using rule 145 (funciones -> call_func .) ]
  ! $end            [ reduce using rule 145 (funciones -> call_func .) ]
  ! RLLAVE          [ reduce using rule 145 (funciones -> call_func .) ]
  ! INT32           [ reduce using rule 145 (funciones -> call_func .) ]
  ! INT64           [ reduce using rule 145 (funciones -> call_func .) ]
  ! FLOAT32         [ reduce using rule 145 (funciones -> call_func .) ]
  ! FLOAT64         [ reduce using rule 145 (funciones -> call_func .) ]
  ! BYTE            [ reduce using rule 145 (funciones -> call_func .) ]
  ! WINT            [ reduce using rule 145 (funciones -> call_func .) ]
  ! WFLOAT          [ reduce using rule 145 (funciones -> call_func .) ]
  ! WSTRING         [ reduce using rule 145 (funciones -> call_func .) ]
  ! BOOL            [ reduce using rule 145 (funciones -> call_func .) ]
  ! DEFAULT         [ reduce using rule 145 (funciones -> call_func .) ]
  ! CASE            [ reduce using rule 145 (funciones -> call_func .) ]
  ! RETURN          [ reduce using rule 145 (funciones -> call_func .) ]


state 180

    (159) cStruct -> ID DEQUAL ID . LLLAVE asignaciones RLLAVE

    LLLAVE          shift and go to state 240


state 181

    (124) slice_declaration -> ID DEQUAL funM .

    COLON           reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    PRINT           reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    SCAN            reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    FOR             reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    ID              reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    APPEND          reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    LEN             reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    COPY            reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    DELETE          reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    IF              reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    ELSE            reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    TYPE            reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    SWITCH          reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    VAR             reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    FUNC            reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    INTEGER         reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    FLOAT           reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    NOT             reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    $end            reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    RLLAVE          reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    INT32           reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    INT64           reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    FLOAT32         reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    FLOAT64         reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    BYTE            reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    WINT            reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    WFLOAT          reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    WSTRING         reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    BOOL            reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    DEFAULT         reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    CASE            reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)
    RETURN          reduce using rule 124 (slice_declaration -> ID DEQUAL funM .)


state 182

    (125) slice_declaration -> ID DEQUAL LCORCHE . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 241


state 183

    (120) dynamic -> ID DEQUAL values .

    COLON           reduce using rule 120 (dynamic -> ID DEQUAL values .)
    PRINT           reduce using rule 120 (dynamic -> ID DEQUAL values .)
    SCAN            reduce using rule 120 (dynamic -> ID DEQUAL values .)
    FOR             reduce using rule 120 (dynamic -> ID DEQUAL values .)
    ID              reduce using rule 120 (dynamic -> ID DEQUAL values .)
    APPEND          reduce using rule 120 (dynamic -> ID DEQUAL values .)
    LEN             reduce using rule 120 (dynamic -> ID DEQUAL values .)
    COPY            reduce using rule 120 (dynamic -> ID DEQUAL values .)
    DELETE          reduce using rule 120 (dynamic -> ID DEQUAL values .)
    IF              reduce using rule 120 (dynamic -> ID DEQUAL values .)
    ELSE            reduce using rule 120 (dynamic -> ID DEQUAL values .)
    TYPE            reduce using rule 120 (dynamic -> ID DEQUAL values .)
    SWITCH          reduce using rule 120 (dynamic -> ID DEQUAL values .)
    VAR             reduce using rule 120 (dynamic -> ID DEQUAL values .)
    FUNC            reduce using rule 120 (dynamic -> ID DEQUAL values .)
    INTEGER         reduce using rule 120 (dynamic -> ID DEQUAL values .)
    FLOAT           reduce using rule 120 (dynamic -> ID DEQUAL values .)
    NOT             reduce using rule 120 (dynamic -> ID DEQUAL values .)
    $end            reduce using rule 120 (dynamic -> ID DEQUAL values .)
    RLLAVE          reduce using rule 120 (dynamic -> ID DEQUAL values .)
    INT32           reduce using rule 120 (dynamic -> ID DEQUAL values .)
    INT64           reduce using rule 120 (dynamic -> ID DEQUAL values .)
    FLOAT32         reduce using rule 120 (dynamic -> ID DEQUAL values .)
    FLOAT64         reduce using rule 120 (dynamic -> ID DEQUAL values .)
    BYTE            reduce using rule 120 (dynamic -> ID DEQUAL values .)
    WINT            reduce using rule 120 (dynamic -> ID DEQUAL values .)
    WFLOAT          reduce using rule 120 (dynamic -> ID DEQUAL values .)
    WSTRING         reduce using rule 120 (dynamic -> ID DEQUAL values .)
    BOOL            reduce using rule 120 (dynamic -> ID DEQUAL values .)
    DEFAULT         reduce using rule 120 (dynamic -> ID DEQUAL values .)
    CASE            reduce using rule 120 (dynamic -> ID DEQUAL values .)
    RETURN          reduce using rule 120 (dynamic -> ID DEQUAL values .)


state 184

    (126) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (127) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LPAREN          shift and go to state 242


state 185

    (44) values -> INTEGER .

    COLON           reduce using rule 44 (values -> INTEGER .)
    PRINT           reduce using rule 44 (values -> INTEGER .)
    SCAN            reduce using rule 44 (values -> INTEGER .)
    FOR             reduce using rule 44 (values -> INTEGER .)
    ID              reduce using rule 44 (values -> INTEGER .)
    APPEND          reduce using rule 44 (values -> INTEGER .)
    LEN             reduce using rule 44 (values -> INTEGER .)
    COPY            reduce using rule 44 (values -> INTEGER .)
    DELETE          reduce using rule 44 (values -> INTEGER .)
    IF              reduce using rule 44 (values -> INTEGER .)
    ELSE            reduce using rule 44 (values -> INTEGER .)
    TYPE            reduce using rule 44 (values -> INTEGER .)
    SWITCH          reduce using rule 44 (values -> INTEGER .)
    VAR             reduce using rule 44 (values -> INTEGER .)
    FUNC            reduce using rule 44 (values -> INTEGER .)
    INTEGER         reduce using rule 44 (values -> INTEGER .)
    FLOAT           reduce using rule 44 (values -> INTEGER .)
    NOT             reduce using rule 44 (values -> INTEGER .)
    $end            reduce using rule 44 (values -> INTEGER .)
    RLLAVE          reduce using rule 44 (values -> INTEGER .)
    INT32           reduce using rule 44 (values -> INTEGER .)
    INT64           reduce using rule 44 (values -> INTEGER .)
    FLOAT32         reduce using rule 44 (values -> INTEGER .)
    FLOAT64         reduce using rule 44 (values -> INTEGER .)
    BYTE            reduce using rule 44 (values -> INTEGER .)
    WINT            reduce using rule 44 (values -> INTEGER .)
    WFLOAT          reduce using rule 44 (values -> INTEGER .)
    WSTRING         reduce using rule 44 (values -> INTEGER .)
    BOOL            reduce using rule 44 (values -> INTEGER .)
    DEFAULT         reduce using rule 44 (values -> INTEGER .)
    CASE            reduce using rule 44 (values -> INTEGER .)
    RETURN          reduce using rule 44 (values -> INTEGER .)
    RPAREN          reduce using rule 44 (values -> INTEGER .)
    POINTS          reduce using rule 44 (values -> INTEGER .)


state 186

    (45) values -> FLOAT .

    COLON           reduce using rule 45 (values -> FLOAT .)
    PRINT           reduce using rule 45 (values -> FLOAT .)
    SCAN            reduce using rule 45 (values -> FLOAT .)
    FOR             reduce using rule 45 (values -> FLOAT .)
    ID              reduce using rule 45 (values -> FLOAT .)
    APPEND          reduce using rule 45 (values -> FLOAT .)
    LEN             reduce using rule 45 (values -> FLOAT .)
    COPY            reduce using rule 45 (values -> FLOAT .)
    DELETE          reduce using rule 45 (values -> FLOAT .)
    IF              reduce using rule 45 (values -> FLOAT .)
    ELSE            reduce using rule 45 (values -> FLOAT .)
    TYPE            reduce using rule 45 (values -> FLOAT .)
    SWITCH          reduce using rule 45 (values -> FLOAT .)
    VAR             reduce using rule 45 (values -> FLOAT .)
    FUNC            reduce using rule 45 (values -> FLOAT .)
    INTEGER         reduce using rule 45 (values -> FLOAT .)
    FLOAT           reduce using rule 45 (values -> FLOAT .)
    NOT             reduce using rule 45 (values -> FLOAT .)
    $end            reduce using rule 45 (values -> FLOAT .)
    RLLAVE          reduce using rule 45 (values -> FLOAT .)
    INT32           reduce using rule 45 (values -> FLOAT .)
    INT64           reduce using rule 45 (values -> FLOAT .)
    FLOAT32         reduce using rule 45 (values -> FLOAT .)
    FLOAT64         reduce using rule 45 (values -> FLOAT .)
    BYTE            reduce using rule 45 (values -> FLOAT .)
    WINT            reduce using rule 45 (values -> FLOAT .)
    WFLOAT          reduce using rule 45 (values -> FLOAT .)
    WSTRING         reduce using rule 45 (values -> FLOAT .)
    BOOL            reduce using rule 45 (values -> FLOAT .)
    DEFAULT         reduce using rule 45 (values -> FLOAT .)
    CASE            reduce using rule 45 (values -> FLOAT .)
    RETURN          reduce using rule 45 (values -> FLOAT .)
    RPAREN          reduce using rule 45 (values -> FLOAT .)
    POINTS          reduce using rule 45 (values -> FLOAT .)


state 187

    (197) index -> ID .
    (132) index_s -> ID .
    (203) key -> ID .
    (228) something_ex -> ID .
    (167) value -> ID .
    (181) logic_value -> ID .
    (196) array_var -> ID . LCORCHE index RCORCHE
    (202) map_var -> ID . LCORCHE key RCORCHE
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for RCORCHE resolved using rule 132 (index_s -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 132 (index_s -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 132 (index_s -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 167 (value -> ID .)
    RCORCHE         reduce using rule 132 (index_s -> ID .)
    GREATER         reduce using rule 167 (value -> ID .)
    SMALLER         reduce using rule 167 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 167 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 167 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 167 (value -> ID .)
    NOT_EQUAL       reduce using rule 167 (value -> ID .)
    PLUS            reduce using rule 167 (value -> ID .)
    TIMES           reduce using rule 167 (value -> ID .)
    DIVIDE          reduce using rule 167 (value -> ID .)
    MINUS           reduce using rule 167 (value -> ID .)
    AND             reduce using rule 181 (logic_value -> ID .)
    OR              reduce using rule 181 (logic_value -> ID .)
    LCORCHE         shift and go to state 167
    LPAREN          shift and go to state 106

  ! RCORCHE         [ reduce using rule 197 (index -> ID .) ]
  ! RCORCHE         [ reduce using rule 203 (key -> ID .) ]
  ! GREATER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 228 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 228 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 228 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 228 (something_ex -> ID .) ]


state 188

    (196) array_var -> ID LCORCHE index . RCORCHE

    RCORCHE         shift and go to state 243


state 189

    (131) slice_var -> ID LCORCHE index_s . RCORCHE

    RCORCHE         shift and go to state 244


state 190

    (202) map_var -> ID LCORCHE key . RCORCHE

    RCORCHE         shift and go to state 245


state 191

    (198) index -> INTEGER .
    (133) index_s -> INTEGER .
    (44) values -> INTEGER .
    (229) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 133 (index_s -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 44 (values -> INTEGER .)
    RCORCHE         reduce using rule 44 (values -> INTEGER .)
    GREATER         reduce using rule 229 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 229 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 229 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 229 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 229 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 229 (something_ex -> INTEGER .)
    PLUS            reduce using rule 229 (something_ex -> INTEGER .)
    TIMES           reduce using rule 229 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 229 (something_ex -> INTEGER .)
    MINUS           reduce using rule 229 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 198 (index -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 133 (index_s -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 229 (something_ex -> INTEGER .) ]


state 192

    (199) index -> expression .
    (134) index_s -> expression .
    (57) operations -> expression .
    (168) value -> expression .

  ! reduce/reduce conflict for RCORCHE resolved using rule 134 (index_s -> expression .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 57 (operations -> expression .)
    RCORCHE         reduce using rule 57 (operations -> expression .)
    GREATER         reduce using rule 168 (value -> expression .)
    SMALLER         reduce using rule 168 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 168 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 168 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 168 (value -> expression .)
    NOT_EQUAL       reduce using rule 168 (value -> expression .)
    PLUS            reduce using rule 168 (value -> expression .)
    TIMES           reduce using rule 168 (value -> expression .)
    DIVIDE          reduce using rule 168 (value -> expression .)
    MINUS           reduce using rule 168 (value -> expression .)

  ! RCORCHE         [ reduce using rule 199 (index -> expression .) ]
  ! RCORCHE         [ reduce using rule 134 (index_s -> expression .) ]


state 193

    (204) key -> values .

    RCORCHE         reduce using rule 204 (key -> values .)


state 194

    (205) key -> operations .

    RCORCHE         reduce using rule 205 (key -> operations .)


state 195

    (83) list_params -> ID .
    (84) list_params -> ID . COMA more_p

    RPAREN          reduce using rule 83 (list_params -> ID .)
    COMA            shift and go to state 246


state 196

    (81) call_func -> ID LPAREN list_params . RPAREN

    RPAREN          shift and go to state 247


state 197

    (82) call_func -> ID LPAREN RPAREN .

    COLON           reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    PRINT           reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    SCAN            reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    FOR             reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    ID              reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    APPEND          reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    LEN             reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    COPY            reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    DELETE          reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    IF              reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    ELSE            reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    TYPE            reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    SWITCH          reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    VAR             reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    FUNC            reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    INTEGER         reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    FLOAT           reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    NOT             reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    $end            reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    GREATER         reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    SMALLER         reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    GREATER_OR_EQUAL reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    EQUAL_COMPARE   reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    NOT_EQUAL       reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    PLUS            reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    TIMES           reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    DIVIDE          reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    MINUS           reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    RLLAVE          reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    INT32           reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    INT64           reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    FLOAT32         reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    FLOAT64         reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    BYTE            reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    WINT            reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    WFLOAT          reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    WSTRING         reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    BOOL            reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    DEFAULT         reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    CASE            reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    RETURN          reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    RPAREN          reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    AND             reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    OR              reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    LLLAVE          reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    RCORCHE         reduce using rule 82 (call_func -> ID LPAREN RPAREN .)
    COMA            reduce using rule 82 (call_func -> ID LPAREN RPAREN .)


state 198

    (140) funciones -> APPEND LPAREN ID . COMA values RPAREN
    (141) funciones -> APPEND LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 248


state 199

    (142) funciones -> LEN LPAREN ID . RPAREN

    RPAREN          shift and go to state 249


state 200

    (143) funciones -> COPY LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 250


state 201

    (144) funciones -> DELETE LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 251


state 202

    (148) SenIF -> IF comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

    comparison                     shift and go to state 8
    codigo                         shift and go to state 252
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 203

    (149) SenIF -> IF TRUE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

    codigo                         shift and go to state 253
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 204

    (150) SenIF -> IF FALSE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

    codigo                         shift and go to state 254
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 205

    (151) SenElseIF -> ELSE IF comparison . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 255


state 206

    (152) SenElseIF -> ELSE IF TRUE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 256


state 207

    (153) SenElseIF -> ELSE IF FALSE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 257


state 208

    (154) SenElse -> ELSE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 258


state 209

    (155) SenStruct -> TYPE ID STRUCT . LLLAVE declaration RLLAVE

    LLLAVE          shift and go to state 259


state 210

    (186) switch_statement -> SWITCH ID LLLAVE . cases RLLAVE
    (187) cases -> . CASE values POINTS codigo
    (188) cases -> . CASE values POINTS codigo more

    CASE            shift and go to state 261

    cases                          shift and go to state 260

state 211

    (191) array_declaration -> VAR ID LCORCHE . capacity RCORCHE data_types
    (121) slice_declaration -> VAR ID LCORCHE . RCORCHE data_types
    (201) map_declaration -> VAR ID LCORCHE . data_types RCORCHE data_types
    (193) capacity -> . INTEGER
    (194) capacity -> . ID
    (195) capacity -> . expression
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    RCORCHE         shift and go to state 264
    INTEGER         shift and go to state 266
    ID              shift and go to state 262
    INT32           shift and go to state 126
    INT64           shift and go to state 127
    FLOAT32         shift and go to state 128
    FLOAT64         shift and go to state 129
    BYTE            shift and go to state 130
    WINT            shift and go to state 131
    WFLOAT          shift and go to state 132
    WSTRING         shift and go to state 133
    BOOL            shift and go to state 134
    FLOAT           shift and go to state 52
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    capacity                       shift and go to state 263
    data_types                     shift and go to state 265
    expression                     shift and go to state 267
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 212

    (100) single -> VAR ID data_types .
    (101) single -> VAR ID data_types . EQUAL funciones
    (102) single -> VAR ID data_types . EQUAL ID
    (103) single -> VAR ID data_types . EQUAL data_structure

    COLON           reduce using rule 100 (single -> VAR ID data_types .)
    PRINT           reduce using rule 100 (single -> VAR ID data_types .)
    SCAN            reduce using rule 100 (single -> VAR ID data_types .)
    FOR             reduce using rule 100 (single -> VAR ID data_types .)
    ID              reduce using rule 100 (single -> VAR ID data_types .)
    APPEND          reduce using rule 100 (single -> VAR ID data_types .)
    LEN             reduce using rule 100 (single -> VAR ID data_types .)
    COPY            reduce using rule 100 (single -> VAR ID data_types .)
    DELETE          reduce using rule 100 (single -> VAR ID data_types .)
    IF              reduce using rule 100 (single -> VAR ID data_types .)
    ELSE            reduce using rule 100 (single -> VAR ID data_types .)
    TYPE            reduce using rule 100 (single -> VAR ID data_types .)
    SWITCH          reduce using rule 100 (single -> VAR ID data_types .)
    VAR             reduce using rule 100 (single -> VAR ID data_types .)
    FUNC            reduce using rule 100 (single -> VAR ID data_types .)
    INTEGER         reduce using rule 100 (single -> VAR ID data_types .)
    FLOAT           reduce using rule 100 (single -> VAR ID data_types .)
    NOT             reduce using rule 100 (single -> VAR ID data_types .)
    $end            reduce using rule 100 (single -> VAR ID data_types .)
    RLLAVE          reduce using rule 100 (single -> VAR ID data_types .)
    INT32           reduce using rule 100 (single -> VAR ID data_types .)
    INT64           reduce using rule 100 (single -> VAR ID data_types .)
    FLOAT32         reduce using rule 100 (single -> VAR ID data_types .)
    FLOAT64         reduce using rule 100 (single -> VAR ID data_types .)
    BYTE            reduce using rule 100 (single -> VAR ID data_types .)
    WINT            reduce using rule 100 (single -> VAR ID data_types .)
    WFLOAT          reduce using rule 100 (single -> VAR ID data_types .)
    WSTRING         reduce using rule 100 (single -> VAR ID data_types .)
    BOOL            reduce using rule 100 (single -> VAR ID data_types .)
    DEFAULT         reduce using rule 100 (single -> VAR ID data_types .)
    CASE            reduce using rule 100 (single -> VAR ID data_types .)
    RETURN          reduce using rule 100 (single -> VAR ID data_types .)
    EQUAL           shift and go to state 268


state 213

    (192) array_declaration -> VAR ID EQUAL . LCORCHE capacity RCORCHE data_types arr_content
    (122) slice_declaration -> VAR ID EQUAL . LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> VAR ID EQUAL . funM
    (126) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (127) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LCORCHE         shift and go to state 269
    MAKE            shift and go to state 184

    funM                           shift and go to state 270

state 214

    (104) single -> VAR ID data_type_and_value .

    COLON           reduce using rule 104 (single -> VAR ID data_type_and_value .)
    PRINT           reduce using rule 104 (single -> VAR ID data_type_and_value .)
    SCAN            reduce using rule 104 (single -> VAR ID data_type_and_value .)
    FOR             reduce using rule 104 (single -> VAR ID data_type_and_value .)
    ID              reduce using rule 104 (single -> VAR ID data_type_and_value .)
    APPEND          reduce using rule 104 (single -> VAR ID data_type_and_value .)
    LEN             reduce using rule 104 (single -> VAR ID data_type_and_value .)
    COPY            reduce using rule 104 (single -> VAR ID data_type_and_value .)
    DELETE          reduce using rule 104 (single -> VAR ID data_type_and_value .)
    IF              reduce using rule 104 (single -> VAR ID data_type_and_value .)
    ELSE            reduce using rule 104 (single -> VAR ID data_type_and_value .)
    TYPE            reduce using rule 104 (single -> VAR ID data_type_and_value .)
    SWITCH          reduce using rule 104 (single -> VAR ID data_type_and_value .)
    VAR             reduce using rule 104 (single -> VAR ID data_type_and_value .)
    FUNC            reduce using rule 104 (single -> VAR ID data_type_and_value .)
    INTEGER         reduce using rule 104 (single -> VAR ID data_type_and_value .)
    FLOAT           reduce using rule 104 (single -> VAR ID data_type_and_value .)
    NOT             reduce using rule 104 (single -> VAR ID data_type_and_value .)
    $end            reduce using rule 104 (single -> VAR ID data_type_and_value .)
    RLLAVE          reduce using rule 104 (single -> VAR ID data_type_and_value .)
    INT32           reduce using rule 104 (single -> VAR ID data_type_and_value .)
    INT64           reduce using rule 104 (single -> VAR ID data_type_and_value .)
    FLOAT32         reduce using rule 104 (single -> VAR ID data_type_and_value .)
    FLOAT64         reduce using rule 104 (single -> VAR ID data_type_and_value .)
    BYTE            reduce using rule 104 (single -> VAR ID data_type_and_value .)
    WINT            reduce using rule 104 (single -> VAR ID data_type_and_value .)
    WFLOAT          reduce using rule 104 (single -> VAR ID data_type_and_value .)
    WSTRING         reduce using rule 104 (single -> VAR ID data_type_and_value .)
    BOOL            reduce using rule 104 (single -> VAR ID data_type_and_value .)
    DEFAULT         reduce using rule 104 (single -> VAR ID data_type_and_value .)
    CASE            reduce using rule 104 (single -> VAR ID data_type_and_value .)
    RETURN          reduce using rule 104 (single -> VAR ID data_type_and_value .)


state 215

    (97) list_var -> VAR ID COMA . more
    (98) more -> . ID
    (99) more -> . ID COMA more
    (189) more -> . cases
    (190) more -> . DEFAULT POINTS codigo
    (187) cases -> . CASE values POINTS codigo
    (188) cases -> . CASE values POINTS codigo more

    ID              shift and go to state 271
    DEFAULT         shift and go to state 274
    CASE            shift and go to state 261

    more                           shift and go to state 272
    cases                          shift and go to state 273

state 216

    (48) data_types -> INT32 .
    (107) data_type_and_value -> INT32 . EQUAL int_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 48 (data_types -> INT32 .)
    PRINT           reduce using rule 48 (data_types -> INT32 .)
    SCAN            reduce using rule 48 (data_types -> INT32 .)
    FOR             reduce using rule 48 (data_types -> INT32 .)
    ID              reduce using rule 48 (data_types -> INT32 .)
    APPEND          reduce using rule 48 (data_types -> INT32 .)
    LEN             reduce using rule 48 (data_types -> INT32 .)
    COPY            reduce using rule 48 (data_types -> INT32 .)
    DELETE          reduce using rule 48 (data_types -> INT32 .)
    IF              reduce using rule 48 (data_types -> INT32 .)
    ELSE            reduce using rule 48 (data_types -> INT32 .)
    TYPE            reduce using rule 48 (data_types -> INT32 .)
    SWITCH          reduce using rule 48 (data_types -> INT32 .)
    VAR             reduce using rule 48 (data_types -> INT32 .)
    FUNC            reduce using rule 48 (data_types -> INT32 .)
    INTEGER         reduce using rule 48 (data_types -> INT32 .)
    FLOAT           reduce using rule 48 (data_types -> INT32 .)
    NOT             reduce using rule 48 (data_types -> INT32 .)
    $end            reduce using rule 48 (data_types -> INT32 .)
    RLLAVE          reduce using rule 48 (data_types -> INT32 .)
    INT32           reduce using rule 48 (data_types -> INT32 .)
    INT64           reduce using rule 48 (data_types -> INT32 .)
    FLOAT32         reduce using rule 48 (data_types -> INT32 .)
    FLOAT64         reduce using rule 48 (data_types -> INT32 .)
    BYTE            reduce using rule 48 (data_types -> INT32 .)
    WINT            reduce using rule 48 (data_types -> INT32 .)
    WFLOAT          reduce using rule 48 (data_types -> INT32 .)
    WSTRING         reduce using rule 48 (data_types -> INT32 .)
    BOOL            reduce using rule 48 (data_types -> INT32 .)
    DEFAULT         reduce using rule 48 (data_types -> INT32 .)
    CASE            reduce using rule 48 (data_types -> INT32 .)
    RETURN          reduce using rule 48 (data_types -> INT32 .)
    EQUAL           shift and go to state 275

  ! EQUAL           [ reduce using rule 48 (data_types -> INT32 .) ]


state 217

    (49) data_types -> INT64 .
    (108) data_type_and_value -> INT64 . EQUAL int_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 49 (data_types -> INT64 .)
    PRINT           reduce using rule 49 (data_types -> INT64 .)
    SCAN            reduce using rule 49 (data_types -> INT64 .)
    FOR             reduce using rule 49 (data_types -> INT64 .)
    ID              reduce using rule 49 (data_types -> INT64 .)
    APPEND          reduce using rule 49 (data_types -> INT64 .)
    LEN             reduce using rule 49 (data_types -> INT64 .)
    COPY            reduce using rule 49 (data_types -> INT64 .)
    DELETE          reduce using rule 49 (data_types -> INT64 .)
    IF              reduce using rule 49 (data_types -> INT64 .)
    ELSE            reduce using rule 49 (data_types -> INT64 .)
    TYPE            reduce using rule 49 (data_types -> INT64 .)
    SWITCH          reduce using rule 49 (data_types -> INT64 .)
    VAR             reduce using rule 49 (data_types -> INT64 .)
    FUNC            reduce using rule 49 (data_types -> INT64 .)
    INTEGER         reduce using rule 49 (data_types -> INT64 .)
    FLOAT           reduce using rule 49 (data_types -> INT64 .)
    NOT             reduce using rule 49 (data_types -> INT64 .)
    $end            reduce using rule 49 (data_types -> INT64 .)
    RLLAVE          reduce using rule 49 (data_types -> INT64 .)
    INT32           reduce using rule 49 (data_types -> INT64 .)
    INT64           reduce using rule 49 (data_types -> INT64 .)
    FLOAT32         reduce using rule 49 (data_types -> INT64 .)
    FLOAT64         reduce using rule 49 (data_types -> INT64 .)
    BYTE            reduce using rule 49 (data_types -> INT64 .)
    WINT            reduce using rule 49 (data_types -> INT64 .)
    WFLOAT          reduce using rule 49 (data_types -> INT64 .)
    WSTRING         reduce using rule 49 (data_types -> INT64 .)
    BOOL            reduce using rule 49 (data_types -> INT64 .)
    DEFAULT         reduce using rule 49 (data_types -> INT64 .)
    CASE            reduce using rule 49 (data_types -> INT64 .)
    RETURN          reduce using rule 49 (data_types -> INT64 .)
    EQUAL           shift and go to state 276

  ! EQUAL           [ reduce using rule 49 (data_types -> INT64 .) ]


state 218

    (50) data_types -> FLOAT32 .
    (110) data_type_and_value -> FLOAT32 . EQUAL float_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 50 (data_types -> FLOAT32 .)
    PRINT           reduce using rule 50 (data_types -> FLOAT32 .)
    SCAN            reduce using rule 50 (data_types -> FLOAT32 .)
    FOR             reduce using rule 50 (data_types -> FLOAT32 .)
    ID              reduce using rule 50 (data_types -> FLOAT32 .)
    APPEND          reduce using rule 50 (data_types -> FLOAT32 .)
    LEN             reduce using rule 50 (data_types -> FLOAT32 .)
    COPY            reduce using rule 50 (data_types -> FLOAT32 .)
    DELETE          reduce using rule 50 (data_types -> FLOAT32 .)
    IF              reduce using rule 50 (data_types -> FLOAT32 .)
    ELSE            reduce using rule 50 (data_types -> FLOAT32 .)
    TYPE            reduce using rule 50 (data_types -> FLOAT32 .)
    SWITCH          reduce using rule 50 (data_types -> FLOAT32 .)
    VAR             reduce using rule 50 (data_types -> FLOAT32 .)
    FUNC            reduce using rule 50 (data_types -> FLOAT32 .)
    INTEGER         reduce using rule 50 (data_types -> FLOAT32 .)
    FLOAT           reduce using rule 50 (data_types -> FLOAT32 .)
    NOT             reduce using rule 50 (data_types -> FLOAT32 .)
    $end            reduce using rule 50 (data_types -> FLOAT32 .)
    RLLAVE          reduce using rule 50 (data_types -> FLOAT32 .)
    INT32           reduce using rule 50 (data_types -> FLOAT32 .)
    INT64           reduce using rule 50 (data_types -> FLOAT32 .)
    FLOAT32         reduce using rule 50 (data_types -> FLOAT32 .)
    FLOAT64         reduce using rule 50 (data_types -> FLOAT32 .)
    BYTE            reduce using rule 50 (data_types -> FLOAT32 .)
    WINT            reduce using rule 50 (data_types -> FLOAT32 .)
    WFLOAT          reduce using rule 50 (data_types -> FLOAT32 .)
    WSTRING         reduce using rule 50 (data_types -> FLOAT32 .)
    BOOL            reduce using rule 50 (data_types -> FLOAT32 .)
    DEFAULT         reduce using rule 50 (data_types -> FLOAT32 .)
    CASE            reduce using rule 50 (data_types -> FLOAT32 .)
    RETURN          reduce using rule 50 (data_types -> FLOAT32 .)
    EQUAL           shift and go to state 277

  ! EQUAL           [ reduce using rule 50 (data_types -> FLOAT32 .) ]


state 219

    (51) data_types -> FLOAT64 .
    (111) data_type_and_value -> FLOAT64 . EQUAL float_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 51 (data_types -> FLOAT64 .)
    PRINT           reduce using rule 51 (data_types -> FLOAT64 .)
    SCAN            reduce using rule 51 (data_types -> FLOAT64 .)
    FOR             reduce using rule 51 (data_types -> FLOAT64 .)
    ID              reduce using rule 51 (data_types -> FLOAT64 .)
    APPEND          reduce using rule 51 (data_types -> FLOAT64 .)
    LEN             reduce using rule 51 (data_types -> FLOAT64 .)
    COPY            reduce using rule 51 (data_types -> FLOAT64 .)
    DELETE          reduce using rule 51 (data_types -> FLOAT64 .)
    IF              reduce using rule 51 (data_types -> FLOAT64 .)
    ELSE            reduce using rule 51 (data_types -> FLOAT64 .)
    TYPE            reduce using rule 51 (data_types -> FLOAT64 .)
    SWITCH          reduce using rule 51 (data_types -> FLOAT64 .)
    VAR             reduce using rule 51 (data_types -> FLOAT64 .)
    FUNC            reduce using rule 51 (data_types -> FLOAT64 .)
    INTEGER         reduce using rule 51 (data_types -> FLOAT64 .)
    FLOAT           reduce using rule 51 (data_types -> FLOAT64 .)
    NOT             reduce using rule 51 (data_types -> FLOAT64 .)
    $end            reduce using rule 51 (data_types -> FLOAT64 .)
    RLLAVE          reduce using rule 51 (data_types -> FLOAT64 .)
    INT32           reduce using rule 51 (data_types -> FLOAT64 .)
    INT64           reduce using rule 51 (data_types -> FLOAT64 .)
    FLOAT32         reduce using rule 51 (data_types -> FLOAT64 .)
    FLOAT64         reduce using rule 51 (data_types -> FLOAT64 .)
    BYTE            reduce using rule 51 (data_types -> FLOAT64 .)
    WINT            reduce using rule 51 (data_types -> FLOAT64 .)
    WFLOAT          reduce using rule 51 (data_types -> FLOAT64 .)
    WSTRING         reduce using rule 51 (data_types -> FLOAT64 .)
    BOOL            reduce using rule 51 (data_types -> FLOAT64 .)
    DEFAULT         reduce using rule 51 (data_types -> FLOAT64 .)
    CASE            reduce using rule 51 (data_types -> FLOAT64 .)
    RETURN          reduce using rule 51 (data_types -> FLOAT64 .)
    EQUAL           shift and go to state 278

  ! EQUAL           [ reduce using rule 51 (data_types -> FLOAT64 .) ]


state 220

    (53) data_types -> WINT .
    (106) data_type_and_value -> WINT . EQUAL int_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 53 (data_types -> WINT .)
    PRINT           reduce using rule 53 (data_types -> WINT .)
    SCAN            reduce using rule 53 (data_types -> WINT .)
    FOR             reduce using rule 53 (data_types -> WINT .)
    ID              reduce using rule 53 (data_types -> WINT .)
    APPEND          reduce using rule 53 (data_types -> WINT .)
    LEN             reduce using rule 53 (data_types -> WINT .)
    COPY            reduce using rule 53 (data_types -> WINT .)
    DELETE          reduce using rule 53 (data_types -> WINT .)
    IF              reduce using rule 53 (data_types -> WINT .)
    ELSE            reduce using rule 53 (data_types -> WINT .)
    TYPE            reduce using rule 53 (data_types -> WINT .)
    SWITCH          reduce using rule 53 (data_types -> WINT .)
    VAR             reduce using rule 53 (data_types -> WINT .)
    FUNC            reduce using rule 53 (data_types -> WINT .)
    INTEGER         reduce using rule 53 (data_types -> WINT .)
    FLOAT           reduce using rule 53 (data_types -> WINT .)
    NOT             reduce using rule 53 (data_types -> WINT .)
    $end            reduce using rule 53 (data_types -> WINT .)
    RLLAVE          reduce using rule 53 (data_types -> WINT .)
    INT32           reduce using rule 53 (data_types -> WINT .)
    INT64           reduce using rule 53 (data_types -> WINT .)
    FLOAT32         reduce using rule 53 (data_types -> WINT .)
    FLOAT64         reduce using rule 53 (data_types -> WINT .)
    BYTE            reduce using rule 53 (data_types -> WINT .)
    WINT            reduce using rule 53 (data_types -> WINT .)
    WFLOAT          reduce using rule 53 (data_types -> WINT .)
    WSTRING         reduce using rule 53 (data_types -> WINT .)
    BOOL            reduce using rule 53 (data_types -> WINT .)
    DEFAULT         reduce using rule 53 (data_types -> WINT .)
    CASE            reduce using rule 53 (data_types -> WINT .)
    RETURN          reduce using rule 53 (data_types -> WINT .)
    EQUAL           shift and go to state 279

  ! EQUAL           [ reduce using rule 53 (data_types -> WINT .) ]


state 221

    (54) data_types -> WFLOAT .
    (109) data_type_and_value -> WFLOAT . EQUAL float_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 54 (data_types -> WFLOAT .)
    PRINT           reduce using rule 54 (data_types -> WFLOAT .)
    SCAN            reduce using rule 54 (data_types -> WFLOAT .)
    FOR             reduce using rule 54 (data_types -> WFLOAT .)
    ID              reduce using rule 54 (data_types -> WFLOAT .)
    APPEND          reduce using rule 54 (data_types -> WFLOAT .)
    LEN             reduce using rule 54 (data_types -> WFLOAT .)
    COPY            reduce using rule 54 (data_types -> WFLOAT .)
    DELETE          reduce using rule 54 (data_types -> WFLOAT .)
    IF              reduce using rule 54 (data_types -> WFLOAT .)
    ELSE            reduce using rule 54 (data_types -> WFLOAT .)
    TYPE            reduce using rule 54 (data_types -> WFLOAT .)
    SWITCH          reduce using rule 54 (data_types -> WFLOAT .)
    VAR             reduce using rule 54 (data_types -> WFLOAT .)
    FUNC            reduce using rule 54 (data_types -> WFLOAT .)
    INTEGER         reduce using rule 54 (data_types -> WFLOAT .)
    FLOAT           reduce using rule 54 (data_types -> WFLOAT .)
    NOT             reduce using rule 54 (data_types -> WFLOAT .)
    $end            reduce using rule 54 (data_types -> WFLOAT .)
    RLLAVE          reduce using rule 54 (data_types -> WFLOAT .)
    INT32           reduce using rule 54 (data_types -> WFLOAT .)
    INT64           reduce using rule 54 (data_types -> WFLOAT .)
    FLOAT32         reduce using rule 54 (data_types -> WFLOAT .)
    FLOAT64         reduce using rule 54 (data_types -> WFLOAT .)
    BYTE            reduce using rule 54 (data_types -> WFLOAT .)
    WINT            reduce using rule 54 (data_types -> WFLOAT .)
    WFLOAT          reduce using rule 54 (data_types -> WFLOAT .)
    WSTRING         reduce using rule 54 (data_types -> WFLOAT .)
    BOOL            reduce using rule 54 (data_types -> WFLOAT .)
    DEFAULT         reduce using rule 54 (data_types -> WFLOAT .)
    CASE            reduce using rule 54 (data_types -> WFLOAT .)
    RETURN          reduce using rule 54 (data_types -> WFLOAT .)
    EQUAL           shift and go to state 280

  ! EQUAL           [ reduce using rule 54 (data_types -> WFLOAT .) ]


state 222

    (55) data_types -> WSTRING .
    (105) data_type_and_value -> WSTRING . EQUAL STRING

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 55 (data_types -> WSTRING .)
    PRINT           reduce using rule 55 (data_types -> WSTRING .)
    SCAN            reduce using rule 55 (data_types -> WSTRING .)
    FOR             reduce using rule 55 (data_types -> WSTRING .)
    ID              reduce using rule 55 (data_types -> WSTRING .)
    APPEND          reduce using rule 55 (data_types -> WSTRING .)
    LEN             reduce using rule 55 (data_types -> WSTRING .)
    COPY            reduce using rule 55 (data_types -> WSTRING .)
    DELETE          reduce using rule 55 (data_types -> WSTRING .)
    IF              reduce using rule 55 (data_types -> WSTRING .)
    ELSE            reduce using rule 55 (data_types -> WSTRING .)
    TYPE            reduce using rule 55 (data_types -> WSTRING .)
    SWITCH          reduce using rule 55 (data_types -> WSTRING .)
    VAR             reduce using rule 55 (data_types -> WSTRING .)
    FUNC            reduce using rule 55 (data_types -> WSTRING .)
    INTEGER         reduce using rule 55 (data_types -> WSTRING .)
    FLOAT           reduce using rule 55 (data_types -> WSTRING .)
    NOT             reduce using rule 55 (data_types -> WSTRING .)
    $end            reduce using rule 55 (data_types -> WSTRING .)
    RLLAVE          reduce using rule 55 (data_types -> WSTRING .)
    INT32           reduce using rule 55 (data_types -> WSTRING .)
    INT64           reduce using rule 55 (data_types -> WSTRING .)
    FLOAT32         reduce using rule 55 (data_types -> WSTRING .)
    FLOAT64         reduce using rule 55 (data_types -> WSTRING .)
    BYTE            reduce using rule 55 (data_types -> WSTRING .)
    WINT            reduce using rule 55 (data_types -> WSTRING .)
    WFLOAT          reduce using rule 55 (data_types -> WSTRING .)
    WSTRING         reduce using rule 55 (data_types -> WSTRING .)
    BOOL            reduce using rule 55 (data_types -> WSTRING .)
    DEFAULT         reduce using rule 55 (data_types -> WSTRING .)
    CASE            reduce using rule 55 (data_types -> WSTRING .)
    RETURN          reduce using rule 55 (data_types -> WSTRING .)
    EQUAL           shift and go to state 281

  ! EQUAL           [ reduce using rule 55 (data_types -> WSTRING .) ]


state 223

    (56) data_types -> BOOL .
    (112) data_type_and_value -> BOOL . EQUAL bool_value

  ! shift/reduce conflict for EQUAL resolved as shift
    COLON           reduce using rule 56 (data_types -> BOOL .)
    PRINT           reduce using rule 56 (data_types -> BOOL .)
    SCAN            reduce using rule 56 (data_types -> BOOL .)
    FOR             reduce using rule 56 (data_types -> BOOL .)
    ID              reduce using rule 56 (data_types -> BOOL .)
    APPEND          reduce using rule 56 (data_types -> BOOL .)
    LEN             reduce using rule 56 (data_types -> BOOL .)
    COPY            reduce using rule 56 (data_types -> BOOL .)
    DELETE          reduce using rule 56 (data_types -> BOOL .)
    IF              reduce using rule 56 (data_types -> BOOL .)
    ELSE            reduce using rule 56 (data_types -> BOOL .)
    TYPE            reduce using rule 56 (data_types -> BOOL .)
    SWITCH          reduce using rule 56 (data_types -> BOOL .)
    VAR             reduce using rule 56 (data_types -> BOOL .)
    FUNC            reduce using rule 56 (data_types -> BOOL .)
    INTEGER         reduce using rule 56 (data_types -> BOOL .)
    FLOAT           reduce using rule 56 (data_types -> BOOL .)
    NOT             reduce using rule 56 (data_types -> BOOL .)
    $end            reduce using rule 56 (data_types -> BOOL .)
    RLLAVE          reduce using rule 56 (data_types -> BOOL .)
    INT32           reduce using rule 56 (data_types -> BOOL .)
    INT64           reduce using rule 56 (data_types -> BOOL .)
    FLOAT32         reduce using rule 56 (data_types -> BOOL .)
    FLOAT64         reduce using rule 56 (data_types -> BOOL .)
    BYTE            reduce using rule 56 (data_types -> BOOL .)
    WINT            reduce using rule 56 (data_types -> BOOL .)
    WFLOAT          reduce using rule 56 (data_types -> BOOL .)
    WSTRING         reduce using rule 56 (data_types -> BOOL .)
    BOOL            reduce using rule 56 (data_types -> BOOL .)
    DEFAULT         reduce using rule 56 (data_types -> BOOL .)
    CASE            reduce using rule 56 (data_types -> BOOL .)
    RETURN          reduce using rule 56 (data_types -> BOOL .)
    EQUAL           shift and go to state 282

  ! EQUAL           [ reduce using rule 56 (data_types -> BOOL .) ]


state 224

    (206) map_assignment -> map_var EQUAL something .

    COLON           reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    PRINT           reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    SCAN            reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    FOR             reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    ID              reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    APPEND          reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    LEN             reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    COPY            reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    DELETE          reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    IF              reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    ELSE            reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    TYPE            reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    SWITCH          reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    VAR             reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    FUNC            reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    INTEGER         reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    FLOAT           reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    NOT             reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    $end            reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    RLLAVE          reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    INT32           reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    INT64           reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    FLOAT32         reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    FLOAT64         reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    BYTE            reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    WINT            reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    WFLOAT          reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    WSTRING         reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    BOOL            reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    DEFAULT         reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    CASE            reduce using rule 206 (map_assignment -> map_var EQUAL something .)
    RETURN          reduce using rule 206 (map_assignment -> map_var EQUAL something .)


state 225

    (207) func_declaration -> FUNC ID LPAREN . params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> FUNC ID LPAREN . params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (215) params -> . ID data_types
    (216) params -> . more_params
    (217) more_params -> . ID data_types COMA params

    ID              shift and go to state 283

    params                         shift and go to state 284
    more_params                    shift and go to state 285

state 226

    (79) main_func -> FUNC MAIN LPAREN . RPAREN LLLAVE codigo RLLAVE

    RPAREN          shift and go to state 286


state 227

    (218) impresion -> PRINT LPAREN content RPAREN .

    COLON           reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    PRINT           reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    SCAN            reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    FOR             reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    ID              reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    APPEND          reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    LEN             reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    COPY            reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    DELETE          reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    IF              reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    ELSE            reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    TYPE            reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    SWITCH          reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    VAR             reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    FUNC            reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    INTEGER         reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    FLOAT           reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    NOT             reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    $end            reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    RLLAVE          reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    INT32           reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    INT64           reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    FLOAT32         reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    FLOAT64         reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    BYTE            reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    WINT            reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    WFLOAT          reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    WSTRING         reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    BOOL            reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    DEFAULT         reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    CASE            reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)
    RETURN          reduce using rule 218 (impresion -> PRINT LPAREN content RPAREN .)


state 228

    (80) scan_func -> SCAN LPAREN POINTER RPAREN .

    COLON           reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    PRINT           reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    SCAN            reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FOR             reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    ID              reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    APPEND          reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    LEN             reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    COPY            reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    DELETE          reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    IF              reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    ELSE            reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    TYPE            reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    SWITCH          reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    VAR             reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FUNC            reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    INTEGER         reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FLOAT           reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    NOT             reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    $end            reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    RLLAVE          reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    INT32           reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    INT64           reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FLOAT32         reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    FLOAT64         reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    BYTE            reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    WINT            reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    WFLOAT          reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    WSTRING         reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    BOOL            reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    DEFAULT         reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    CASE            reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    RETURN          reduce using rule 80 (scan_func -> SCAN LPAREN POINTER RPAREN .)


state 229

    (227) adicionaEx -> op something_ex adicionaEx .

    COLON           reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    PRINT           reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    SCAN            reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    FOR             reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    ID              reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    APPEND          reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    LEN             reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    COPY            reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    DELETE          reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    IF              reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    ELSE            reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    TYPE            reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    SWITCH          reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    VAR             reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    FUNC            reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    INTEGER         reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    FLOAT           reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    NOT             reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    $end            reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    GREATER         reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    SMALLER         reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    GREATER_OR_EQUAL reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    SMALLER_OR_EQUAL reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    EQUAL_COMPARE   reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    NOT_EQUAL       reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    PLUS            reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    TIMES           reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    DIVIDE          reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    MINUS           reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    RLLAVE          reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    INT32           reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    INT64           reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    FLOAT32         reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    FLOAT64         reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    BYTE            reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    WINT            reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    WFLOAT          reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    WSTRING         reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    BOOL            reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    DEFAULT         reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    CASE            reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    RETURN          reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    RPAREN          reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    AND             reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    OR              reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    LLLAVE          reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    RCORCHE         reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)
    COMA            reduce using rule 227 (adicionaEx -> op something_ex adicionaEx .)


state 230

    (86) cicloFor -> FOR LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    ID              reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    IF              reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    $end            reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 86 (cicloFor -> FOR LLLAVE codigo RLLAVE .)


state 231

    (87) cicloFor -> FOR comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 287


state 232

    (88) cicloFor -> FOR logic_operation LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 288


state 233

    (89) cicloFor -> FOR decVarOne COLON comparison . COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 289


state 234

    (146) decVarOne -> ID DEQUAL ID .

    COLON           reduce using rule 146 (decVarOne -> ID DEQUAL ID .)


state 235

    (147) decVarOne -> ID DEQUAL INTEGER .

    COLON           reduce using rule 147 (decVarOne -> ID DEQUAL INTEGER .)


state 236

    (197) index -> ID .
    (203) key -> ID .
    (228) something_ex -> ID .
    (167) value -> ID .
    (181) logic_value -> ID .
    (196) array_var -> ID . LCORCHE index RCORCHE
    (202) map_var -> ID . LCORCHE key RCORCHE
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for RCORCHE resolved using rule 197 (index -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 197 (index -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 167 (value -> ID .)
    RCORCHE         reduce using rule 197 (index -> ID .)
    GREATER         reduce using rule 167 (value -> ID .)
    SMALLER         reduce using rule 167 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 167 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 167 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 167 (value -> ID .)
    NOT_EQUAL       reduce using rule 167 (value -> ID .)
    PLUS            reduce using rule 167 (value -> ID .)
    TIMES           reduce using rule 167 (value -> ID .)
    DIVIDE          reduce using rule 167 (value -> ID .)
    MINUS           reduce using rule 167 (value -> ID .)
    AND             reduce using rule 181 (logic_value -> ID .)
    OR              reduce using rule 181 (logic_value -> ID .)
    LCORCHE         shift and go to state 167
    LPAREN          shift and go to state 106

  ! RCORCHE         [ reduce using rule 203 (key -> ID .) ]
  ! GREATER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 228 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 228 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 228 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 228 (something_ex -> ID .) ]


state 237

    (198) index -> INTEGER .
    (44) values -> INTEGER .
    (229) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 44 (values -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 44 (values -> INTEGER .)
    RCORCHE         reduce using rule 44 (values -> INTEGER .)
    GREATER         reduce using rule 229 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 229 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 229 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 229 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 229 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 229 (something_ex -> INTEGER .)
    PLUS            reduce using rule 229 (something_ex -> INTEGER .)
    TIMES           reduce using rule 229 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 229 (something_ex -> INTEGER .)
    MINUS           reduce using rule 229 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 198 (index -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 229 (something_ex -> INTEGER .) ]


state 238

    (199) index -> expression .
    (57) operations -> expression .
    (168) value -> expression .

  ! reduce/reduce conflict for RCORCHE resolved using rule 57 (operations -> expression .)
    RCORCHE         reduce using rule 57 (operations -> expression .)
    GREATER         reduce using rule 168 (value -> expression .)
    SMALLER         reduce using rule 168 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 168 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 168 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 168 (value -> expression .)
    NOT_EQUAL       reduce using rule 168 (value -> expression .)
    PLUS            reduce using rule 168 (value -> expression .)
    TIMES           reduce using rule 168 (value -> expression .)
    DIVIDE          reduce using rule 168 (value -> expression .)
    MINUS           reduce using rule 168 (value -> expression .)

  ! RCORCHE         [ reduce using rule 199 (index -> expression .) ]


state 239

    (178) logic_recu -> logic_op logic_value logic_recu .

    PRINT           reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    SCAN            reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    FOR             reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    ID              reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    APPEND          reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    LEN             reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    COPY            reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    DELETE          reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    IF              reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    ELSE            reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    TYPE            reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    SWITCH          reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    VAR             reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    FUNC            reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    INTEGER         reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    FLOAT           reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    NOT             reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    $end            reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    RLLAVE          reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    INT32           reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    INT64           reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    FLOAT32         reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    FLOAT64         reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    BYTE            reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    WINT            reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    WFLOAT          reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    WSTRING         reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    BOOL            reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    DEFAULT         reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    CASE            reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    RETURN          reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    LLLAVE          reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    COLON           reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    RPAREN          reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    RCORCHE         reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)
    COMA            reduce using rule 178 (logic_recu -> logic_op logic_value logic_recu .)


state 240

    (159) cStruct -> ID DEQUAL ID LLLAVE . asignaciones RLLAVE
    (160) asignaciones -> . ID POINTS valor
    (161) asignaciones -> . ID POINTS valor COMA asignaciones

    ID              shift and go to state 290

    asignaciones                   shift and go to state 291

state 241

    (125) slice_declaration -> ID DEQUAL LCORCHE RCORCHE . data_types arr_content
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 126
    INT64           shift and go to state 127
    FLOAT32         shift and go to state 128
    FLOAT64         shift and go to state 129
    BYTE            shift and go to state 130
    WINT            shift and go to state 131
    WFLOAT          shift and go to state 132
    WSTRING         shift and go to state 133
    BOOL            shift and go to state 134

    data_types                     shift and go to state 292

state 242

    (126) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap RPAREN
    (127) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LCORCHE         shift and go to state 293


state 243

    (196) array_var -> ID LCORCHE index RCORCHE .

    COLON           reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    EQUAL           reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    PRINT           reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    SCAN            reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    FOR             reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    ID              reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    APPEND          reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    LEN             reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    COPY            reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    DELETE          reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    IF              reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    ELSE            reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    TYPE            reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    SWITCH          reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    VAR             reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    FUNC            reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    INTEGER         reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    FLOAT           reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    NOT             reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    $end            reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    GREATER         reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    SMALLER         reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    GREATER_OR_EQUAL reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    SMALLER_OR_EQUAL reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    EQUAL_COMPARE   reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    NOT_EQUAL       reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    PLUS            reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    TIMES           reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    DIVIDE          reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    MINUS           reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    RLLAVE          reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    INT32           reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    INT64           reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    FLOAT32         reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    FLOAT64         reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    BYTE            reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    WINT            reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    WFLOAT          reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    WSTRING         reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    BOOL            reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    DEFAULT         reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    CASE            reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    RETURN          reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    RPAREN          reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    AND             reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    OR              reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    LLLAVE          reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    RCORCHE         reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)
    COMA            reduce using rule 196 (array_var -> ID LCORCHE index RCORCHE .)


state 244

    (131) slice_var -> ID LCORCHE index_s RCORCHE .

    COLON           reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    EQUAL           reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    PRINT           reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    SCAN            reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FOR             reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    ID              reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    APPEND          reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    LEN             reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    COPY            reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    DELETE          reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    IF              reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    ELSE            reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    TYPE            reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    SWITCH          reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    VAR             reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FUNC            reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    INTEGER         reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FLOAT           reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    NOT             reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    $end            reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    RLLAVE          reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    INT32           reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    INT64           reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FLOAT32         reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    FLOAT64         reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    BYTE            reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    WINT            reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    WFLOAT          reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    WSTRING         reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    BOOL            reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    DEFAULT         reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    CASE            reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)
    RETURN          reduce using rule 131 (slice_var -> ID LCORCHE index_s RCORCHE .)


state 245

    (202) map_var -> ID LCORCHE key RCORCHE .

    EQUAL           reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    GREATER         reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    SMALLER         reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    GREATER_OR_EQUAL reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    SMALLER_OR_EQUAL reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    EQUAL_COMPARE   reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    NOT_EQUAL       reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    PLUS            reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    TIMES           reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    DIVIDE          reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    MINUS           reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    COLON           reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    PRINT           reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    SCAN            reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    FOR             reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    ID              reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    APPEND          reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    LEN             reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    COPY            reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    DELETE          reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    IF              reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    ELSE            reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    TYPE            reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    SWITCH          reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    VAR             reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    FUNC            reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    INTEGER         reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    FLOAT           reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    NOT             reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    $end            reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    RLLAVE          reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    INT32           reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    INT64           reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    FLOAT32         reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    FLOAT64         reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    BYTE            reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    WINT            reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    WFLOAT          reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    WSTRING         reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    BOOL            reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    DEFAULT         reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    CASE            reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    RETURN          reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    RPAREN          reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    AND             reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    OR              reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    LLLAVE          reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    RCORCHE         reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)
    COMA            reduce using rule 202 (map_var -> ID LCORCHE key RCORCHE .)


state 246

    (84) list_params -> ID COMA . more_p
    (85) more_p -> . list_params
    (83) list_params -> . ID
    (84) list_params -> . ID COMA more_p

    ID              shift and go to state 195

    more_p                         shift and go to state 294
    list_params                    shift and go to state 295

state 247

    (81) call_func -> ID LPAREN list_params RPAREN .

    COLON           reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    PRINT           reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    SCAN            reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    FOR             reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    ID              reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    APPEND          reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    LEN             reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    COPY            reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    DELETE          reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    IF              reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    ELSE            reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    TYPE            reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    SWITCH          reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    VAR             reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    FUNC            reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    INTEGER         reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    FLOAT           reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    NOT             reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    $end            reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    GREATER         reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    SMALLER         reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    GREATER_OR_EQUAL reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    EQUAL_COMPARE   reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    NOT_EQUAL       reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    PLUS            reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    TIMES           reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    DIVIDE          reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    MINUS           reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    RLLAVE          reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    INT32           reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    INT64           reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    FLOAT32         reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    FLOAT64         reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    BYTE            reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    WINT            reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    WFLOAT          reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    WSTRING         reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    BOOL            reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    DEFAULT         reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    CASE            reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    RETURN          reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    RPAREN          reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    AND             reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    OR              reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    LLLAVE          reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    RCORCHE         reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)
    COMA            reduce using rule 81 (call_func -> ID LPAREN list_params RPAREN .)


state 248

    (140) funciones -> APPEND LPAREN ID COMA . values RPAREN
    (141) funciones -> APPEND LPAREN ID COMA . ID RPAREN
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE

    ID              shift and go to state 296
    STRING          shift and go to state 140
    INTEGER         shift and go to state 185
    FLOAT           shift and go to state 186
    TRUE            shift and go to state 143
    FALSE           shift and go to state 144

    values                         shift and go to state 297

state 249

    (142) funciones -> LEN LPAREN ID RPAREN .

    COLON           reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    PRINT           reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    SCAN            reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    FOR             reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    ID              reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    APPEND          reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    LEN             reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    COPY            reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    DELETE          reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    IF              reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    ELSE            reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    TYPE            reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    SWITCH          reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    VAR             reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    FUNC            reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    INTEGER         reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    FLOAT           reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    NOT             reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    $end            reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    GREATER         reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    SMALLER         reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    NOT_EQUAL       reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    PLUS            reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    TIMES           reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    DIVIDE          reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    MINUS           reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    RLLAVE          reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    INT32           reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    INT64           reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    FLOAT32         reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    FLOAT64         reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    BYTE            reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    WINT            reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    WFLOAT          reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    WSTRING         reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    BOOL            reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    DEFAULT         reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    CASE            reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    RETURN          reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    RPAREN          reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    AND             reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    OR              reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    LLLAVE          reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    RCORCHE         reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)
    COMA            reduce using rule 142 (funciones -> LEN LPAREN ID RPAREN .)


state 250

    (143) funciones -> COPY LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 298


state 251

    (144) funciones -> DELETE LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 299


state 252

    (148) SenIF -> IF comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 300


state 253

    (149) SenIF -> IF TRUE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 301


state 254

    (150) SenIF -> IF FALSE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 302


state 255

    (151) SenElseIF -> ELSE IF comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

    comparison                     shift and go to state 8
    codigo                         shift and go to state 303
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 256

    (152) SenElseIF -> ELSE IF TRUE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

    codigo                         shift and go to state 304
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 257

    (153) SenElseIF -> ELSE IF FALSE LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

    codigo                         shift and go to state 305
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 258

    (154) SenElse -> ELSE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 154 (SenElse -> ELSE LLLAVE codigo RLLAVE .)


state 259

    (155) SenStruct -> TYPE ID STRUCT LLLAVE . declaration RLLAVE
    (156) declaration -> . variable data_types
    (157) declaration -> . declaration variable data_types
    (158) variable -> . ID

    ID              shift and go to state 306

    declaration                    shift and go to state 307
    variable                       shift and go to state 308

state 260

    (186) switch_statement -> SWITCH ID LLLAVE cases . RLLAVE

    RLLAVE          shift and go to state 309


state 261

    (187) cases -> CASE . values POINTS codigo
    (188) cases -> CASE . values POINTS codigo more
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE

    STRING          shift and go to state 140
    INTEGER         shift and go to state 185
    FLOAT           shift and go to state 186
    TRUE            shift and go to state 143
    FALSE           shift and go to state 144

    values                         shift and go to state 310

state 262

    (194) capacity -> ID .
    (228) something_ex -> ID .
    (196) array_var -> ID . LCORCHE index RCORCHE
    (202) map_var -> ID . LCORCHE key RCORCHE
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for RCORCHE resolved using rule 194 (capacity -> ID .)
    RCORCHE         reduce using rule 194 (capacity -> ID .)
    GREATER         reduce using rule 228 (something_ex -> ID .)
    SMALLER         reduce using rule 228 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 228 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 228 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 228 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 228 (something_ex -> ID .)
    PLUS            reduce using rule 228 (something_ex -> ID .)
    TIMES           reduce using rule 228 (something_ex -> ID .)
    DIVIDE          reduce using rule 228 (something_ex -> ID .)
    MINUS           reduce using rule 228 (something_ex -> ID .)
    LCORCHE         shift and go to state 167
    LPAREN          shift and go to state 106

  ! RCORCHE         [ reduce using rule 228 (something_ex -> ID .) ]


state 263

    (191) array_declaration -> VAR ID LCORCHE capacity . RCORCHE data_types

    RCORCHE         shift and go to state 311


state 264

    (121) slice_declaration -> VAR ID LCORCHE RCORCHE . data_types
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 126
    INT64           shift and go to state 127
    FLOAT32         shift and go to state 128
    FLOAT64         shift and go to state 129
    BYTE            shift and go to state 130
    WINT            shift and go to state 131
    WFLOAT          shift and go to state 132
    WSTRING         shift and go to state 133
    BOOL            shift and go to state 134

    data_types                     shift and go to state 312

state 265

    (201) map_declaration -> VAR ID LCORCHE data_types . RCORCHE data_types

    RCORCHE         shift and go to state 313


state 266

    (193) capacity -> INTEGER .
    (229) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 193 (capacity -> INTEGER .)
    RCORCHE         reduce using rule 193 (capacity -> INTEGER .)
    GREATER         reduce using rule 229 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 229 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 229 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 229 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 229 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 229 (something_ex -> INTEGER .)
    PLUS            reduce using rule 229 (something_ex -> INTEGER .)
    TIMES           reduce using rule 229 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 229 (something_ex -> INTEGER .)
    MINUS           reduce using rule 229 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 229 (something_ex -> INTEGER .) ]


state 267

    (195) capacity -> expression .

    RCORCHE         reduce using rule 195 (capacity -> expression .)


state 268

    (101) single -> VAR ID data_types EQUAL . funciones
    (102) single -> VAR ID data_types EQUAL . ID
    (103) single -> VAR ID data_types EQUAL . data_structure
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 314
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    funciones                      shift and go to state 315
    data_structure                 shift and go to state 316
    call_func                      shift and go to state 43
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97

state 269

    (192) array_declaration -> VAR ID EQUAL LCORCHE . capacity RCORCHE data_types arr_content
    (122) slice_declaration -> VAR ID EQUAL LCORCHE . RCORCHE data_types arr_content
    (193) capacity -> . INTEGER
    (194) capacity -> . ID
    (195) capacity -> . expression
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    RCORCHE         shift and go to state 318
    INTEGER         shift and go to state 266
    ID              shift and go to state 262
    FLOAT           shift and go to state 52
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    capacity                       shift and go to state 317
    expression                     shift and go to state 267
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 270

    (123) slice_declaration -> VAR ID EQUAL funM .

    COLON           reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    PRINT           reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    SCAN            reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    FOR             reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    ID              reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    APPEND          reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    LEN             reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    COPY            reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    DELETE          reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    IF              reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    ELSE            reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    TYPE            reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    SWITCH          reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    VAR             reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    FUNC            reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    INTEGER         reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    FLOAT           reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    NOT             reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    $end            reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    RLLAVE          reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    INT32           reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    INT64           reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    FLOAT32         reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    FLOAT64         reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    BYTE            reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    WINT            reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    WFLOAT          reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    WSTRING         reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    BOOL            reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    DEFAULT         reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    CASE            reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)
    RETURN          reduce using rule 123 (slice_declaration -> VAR ID EQUAL funM .)


state 271

    (98) more -> ID .
    (99) more -> ID . COMA more

    INT32           reduce using rule 98 (more -> ID .)
    INT64           reduce using rule 98 (more -> ID .)
    FLOAT32         reduce using rule 98 (more -> ID .)
    FLOAT64         reduce using rule 98 (more -> ID .)
    BYTE            reduce using rule 98 (more -> ID .)
    WINT            reduce using rule 98 (more -> ID .)
    WFLOAT          reduce using rule 98 (more -> ID .)
    WSTRING         reduce using rule 98 (more -> ID .)
    BOOL            reduce using rule 98 (more -> ID .)
    RLLAVE          reduce using rule 98 (more -> ID .)
    COMA            shift and go to state 319


state 272

    (97) list_var -> VAR ID COMA more .

    INT32           reduce using rule 97 (list_var -> VAR ID COMA more .)
    INT64           reduce using rule 97 (list_var -> VAR ID COMA more .)
    FLOAT32         reduce using rule 97 (list_var -> VAR ID COMA more .)
    FLOAT64         reduce using rule 97 (list_var -> VAR ID COMA more .)
    BYTE            reduce using rule 97 (list_var -> VAR ID COMA more .)
    WINT            reduce using rule 97 (list_var -> VAR ID COMA more .)
    WFLOAT          reduce using rule 97 (list_var -> VAR ID COMA more .)
    WSTRING         reduce using rule 97 (list_var -> VAR ID COMA more .)
    BOOL            reduce using rule 97 (list_var -> VAR ID COMA more .)


state 273

    (189) more -> cases .

    INT32           reduce using rule 189 (more -> cases .)
    INT64           reduce using rule 189 (more -> cases .)
    FLOAT32         reduce using rule 189 (more -> cases .)
    FLOAT64         reduce using rule 189 (more -> cases .)
    BYTE            reduce using rule 189 (more -> cases .)
    WINT            reduce using rule 189 (more -> cases .)
    WFLOAT          reduce using rule 189 (more -> cases .)
    WSTRING         reduce using rule 189 (more -> cases .)
    BOOL            reduce using rule 189 (more -> cases .)
    RLLAVE          reduce using rule 189 (more -> cases .)


state 274

    (190) more -> DEFAULT . POINTS codigo

    POINTS          shift and go to state 320


state 275

    (107) data_type_and_value -> INT32 EQUAL . int_value
    (113) int_value -> . INTEGER
    (114) int_value -> . expression
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 322
    ID              shift and go to state 161
    FLOAT           shift and go to state 52
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    int_value                      shift and go to state 321
    expression                     shift and go to state 323
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 276

    (108) data_type_and_value -> INT64 EQUAL . int_value
    (113) int_value -> . INTEGER
    (114) int_value -> . expression
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 322
    ID              shift and go to state 161
    FLOAT           shift and go to state 52
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    int_value                      shift and go to state 324
    expression                     shift and go to state 323
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 277

    (110) data_type_and_value -> FLOAT32 EQUAL . float_value
    (119) float_value -> . FLOAT

    FLOAT           shift and go to state 326

    float_value                    shift and go to state 325

state 278

    (111) data_type_and_value -> FLOAT64 EQUAL . float_value
    (119) float_value -> . FLOAT

    FLOAT           shift and go to state 326

    float_value                    shift and go to state 327

state 279

    (106) data_type_and_value -> WINT EQUAL . int_value
    (113) int_value -> . INTEGER
    (114) int_value -> . expression
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 322
    ID              shift and go to state 161
    FLOAT           shift and go to state 52
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    int_value                      shift and go to state 328
    expression                     shift and go to state 323
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 280

    (109) data_type_and_value -> WFLOAT EQUAL . float_value
    (119) float_value -> . FLOAT

    FLOAT           shift and go to state 326

    float_value                    shift and go to state 329

state 281

    (105) data_type_and_value -> WSTRING EQUAL . STRING

    STRING          shift and go to state 330


state 282

    (112) data_type_and_value -> BOOL EQUAL . bool_value
    (115) bool_value -> . TRUE
    (116) bool_value -> . FALSE
    (117) bool_value -> . comparison
    (118) bool_value -> . logic_operation
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    TRUE            shift and go to state 332
    FALSE           shift and go to state 333
    ID              shift and go to state 336
    NOT             shift and go to state 54
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    bool_value                     shift and go to state 331
    comparison                     shift and go to state 334
    logic_operation                shift and go to state 335
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    expression                     shift and go to state 94
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 283

    (215) params -> ID . data_types
    (217) more_params -> ID . data_types COMA params
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 126
    INT64           shift and go to state 127
    FLOAT32         shift and go to state 128
    FLOAT64         shift and go to state 129
    BYTE            shift and go to state 130
    WINT            shift and go to state 131
    WFLOAT          shift and go to state 132
    WSTRING         shift and go to state 133
    BOOL            shift and go to state 134

    data_types                     shift and go to state 337

state 284

    (207) func_declaration -> FUNC ID LPAREN params . RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> FUNC ID LPAREN params . RPAREN data_types LLLAVE RETURN return_value RLLAVE

    RPAREN          shift and go to state 338


state 285

    (216) params -> more_params .

    RPAREN          reduce using rule 216 (params -> more_params .)


state 286

    (79) main_func -> FUNC MAIN LPAREN RPAREN . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 339


state 287

    (87) cicloFor -> FOR comparison LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    ID              reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    IF              reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    $end            reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 87 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)


state 288

    (88) cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    ID              reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    IF              reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    $end            reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 88 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)


state 289

    (89) cicloFor -> FOR decVarOne COLON comparison COLON . incre LLLAVE codigo RLLAVE
    (90) incre -> . ID INCREASE
    (91) incre -> . ID DECREASE

    ID              shift and go to state 341

    incre                          shift and go to state 340

state 290

    (160) asignaciones -> ID . POINTS valor
    (161) asignaciones -> ID . POINTS valor COMA asignaciones

    POINTS          shift and go to state 342


state 291

    (159) cStruct -> ID DEQUAL ID LLLAVE asignaciones . RLLAVE

    RLLAVE          shift and go to state 343


state 292

    (125) slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types . arr_content
    (69) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (70) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 345

    arr_content                    shift and go to state 344

state 293

    (126) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap RPAREN
    (127) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap COMA cap RPAREN

    RCORCHE         shift and go to state 346


state 294

    (84) list_params -> ID COMA more_p .

    RPAREN          reduce using rule 84 (list_params -> ID COMA more_p .)


state 295

    (85) more_p -> list_params .

    RPAREN          reduce using rule 85 (more_p -> list_params .)


state 296

    (141) funciones -> APPEND LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 347


state 297

    (140) funciones -> APPEND LPAREN ID COMA values . RPAREN

    RPAREN          shift and go to state 348


state 298

    (143) funciones -> COPY LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 349


state 299

    (144) funciones -> DELETE LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 350


state 300

    (148) SenIF -> IF comparison LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    ID              reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    IF              reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    $end            reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 148 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)


state 301

    (149) SenIF -> IF TRUE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 149 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)


state 302

    (150) SenIF -> IF FALSE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 150 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)


state 303

    (151) SenElseIF -> ELSE IF comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 351


state 304

    (152) SenElseIF -> ELSE IF TRUE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 352


state 305

    (153) SenElseIF -> ELSE IF FALSE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 353


state 306

    (158) variable -> ID .

    INT32           reduce using rule 158 (variable -> ID .)
    INT64           reduce using rule 158 (variable -> ID .)
    FLOAT32         reduce using rule 158 (variable -> ID .)
    FLOAT64         reduce using rule 158 (variable -> ID .)
    BYTE            reduce using rule 158 (variable -> ID .)
    WINT            reduce using rule 158 (variable -> ID .)
    WFLOAT          reduce using rule 158 (variable -> ID .)
    WSTRING         reduce using rule 158 (variable -> ID .)
    BOOL            reduce using rule 158 (variable -> ID .)


state 307

    (155) SenStruct -> TYPE ID STRUCT LLLAVE declaration . RLLAVE
    (157) declaration -> declaration . variable data_types
    (158) variable -> . ID

    RLLAVE          shift and go to state 354
    ID              shift and go to state 306

    variable                       shift and go to state 355

state 308

    (156) declaration -> variable . data_types
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 126
    INT64           shift and go to state 127
    FLOAT32         shift and go to state 128
    FLOAT64         shift and go to state 129
    BYTE            shift and go to state 130
    WINT            shift and go to state 131
    WFLOAT          shift and go to state 132
    WSTRING         shift and go to state 133
    BOOL            shift and go to state 134

    data_types                     shift and go to state 356

state 309

    (186) switch_statement -> SWITCH ID LLLAVE cases RLLAVE .

    PRINT           reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    SCAN            reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FOR             reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    ID              reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    APPEND          reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    LEN             reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    COPY            reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    DELETE          reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    IF              reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    ELSE            reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    TYPE            reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    SWITCH          reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    VAR             reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FUNC            reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    INTEGER         reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FLOAT           reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    NOT             reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    $end            reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RLLAVE          reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    INT32           reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    INT64           reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FLOAT32         reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    FLOAT64         reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    BYTE            reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    WINT            reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    WFLOAT          reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    WSTRING         reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    BOOL            reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    DEFAULT         reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    CASE            reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RETURN          reduce using rule 186 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)


state 310

    (187) cases -> CASE values . POINTS codigo
    (188) cases -> CASE values . POINTS codigo more

    POINTS          shift and go to state 357


state 311

    (191) array_declaration -> VAR ID LCORCHE capacity RCORCHE . data_types
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 126
    INT64           shift and go to state 127
    FLOAT32         shift and go to state 128
    FLOAT64         shift and go to state 129
    BYTE            shift and go to state 130
    WINT            shift and go to state 131
    WFLOAT          shift and go to state 132
    WSTRING         shift and go to state 133
    BOOL            shift and go to state 134

    data_types                     shift and go to state 358

state 312

    (121) slice_declaration -> VAR ID LCORCHE RCORCHE data_types .

    COLON           reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    PRINT           reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    SCAN            reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FOR             reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    ID              reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    APPEND          reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    LEN             reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    COPY            reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    DELETE          reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    IF              reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    ELSE            reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    TYPE            reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    SWITCH          reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    VAR             reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FUNC            reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    INTEGER         reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FLOAT           reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    NOT             reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    $end            reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    RLLAVE          reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    INT32           reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    INT64           reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FLOAT32         reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    FLOAT64         reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    BYTE            reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    WINT            reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    WFLOAT          reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    WSTRING         reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    BOOL            reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    DEFAULT         reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    CASE            reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    RETURN          reduce using rule 121 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)


state 313

    (201) map_declaration -> VAR ID LCORCHE data_types RCORCHE . data_types
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 126
    INT64           shift and go to state 127
    FLOAT32         shift and go to state 128
    FLOAT64         shift and go to state 129
    BYTE            shift and go to state 130
    WINT            shift and go to state 131
    WFLOAT          shift and go to state 132
    WSTRING         shift and go to state 133
    BOOL            shift and go to state 134

    data_types                     shift and go to state 359

state 314

    (102) single -> VAR ID data_types EQUAL ID .
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN
    (196) array_var -> ID . LCORCHE index RCORCHE
    (202) map_var -> ID . LCORCHE key RCORCHE

    COLON           reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    PRINT           reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    SCAN            reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    FOR             reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    ID              reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    APPEND          reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    LEN             reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    COPY            reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    DELETE          reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    IF              reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    ELSE            reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    TYPE            reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    SWITCH          reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    VAR             reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    FUNC            reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    INTEGER         reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    FLOAT           reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    NOT             reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    $end            reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    RLLAVE          reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    INT32           reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    INT64           reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    FLOAT32         reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    FLOAT64         reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    BYTE            reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    WINT            reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    WFLOAT          reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    WSTRING         reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    BOOL            reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    DEFAULT         reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    CASE            reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    RETURN          reduce using rule 102 (single -> VAR ID data_types EQUAL ID .)
    LPAREN          shift and go to state 106
    LCORCHE         shift and go to state 167


state 315

    (101) single -> VAR ID data_types EQUAL funciones .

    COLON           reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    PRINT           reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    SCAN            reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    FOR             reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    ID              reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    APPEND          reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    LEN             reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    COPY            reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    DELETE          reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    IF              reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    ELSE            reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    TYPE            reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    SWITCH          reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    VAR             reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    FUNC            reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    INTEGER         reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    FLOAT           reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    NOT             reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    $end            reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    RLLAVE          reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    INT32           reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    INT64           reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    FLOAT32         reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    FLOAT64         reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    BYTE            reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    WINT            reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    WFLOAT          reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    WSTRING         reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    BOOL            reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    DEFAULT         reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    CASE            reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)
    RETURN          reduce using rule 101 (single -> VAR ID data_types EQUAL funciones .)


state 316

    (103) single -> VAR ID data_types EQUAL data_structure .

    COLON           reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    PRINT           reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    SCAN            reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    FOR             reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    ID              reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    APPEND          reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    LEN             reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    COPY            reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    DELETE          reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    IF              reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    ELSE            reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    TYPE            reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    SWITCH          reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    VAR             reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    FUNC            reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    INTEGER         reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    FLOAT           reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    NOT             reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    $end            reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    RLLAVE          reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    INT32           reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    INT64           reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    FLOAT32         reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    FLOAT64         reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    BYTE            reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    WINT            reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    WFLOAT          reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    WSTRING         reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    BOOL            reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    DEFAULT         reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    CASE            reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)
    RETURN          reduce using rule 103 (single -> VAR ID data_types EQUAL data_structure .)


state 317

    (192) array_declaration -> VAR ID EQUAL LCORCHE capacity . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 360


state 318

    (122) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE . data_types arr_content
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 126
    INT64           shift and go to state 127
    FLOAT32         shift and go to state 128
    FLOAT64         shift and go to state 129
    BYTE            shift and go to state 130
    WINT            shift and go to state 131
    WFLOAT          shift and go to state 132
    WSTRING         shift and go to state 133
    BOOL            shift and go to state 134

    data_types                     shift and go to state 361

state 319

    (99) more -> ID COMA . more
    (98) more -> . ID
    (99) more -> . ID COMA more
    (189) more -> . cases
    (190) more -> . DEFAULT POINTS codigo
    (187) cases -> . CASE values POINTS codigo
    (188) cases -> . CASE values POINTS codigo more

    ID              shift and go to state 271
    DEFAULT         shift and go to state 274
    CASE            shift and go to state 261

    more                           shift and go to state 362
    cases                          shift and go to state 273

state 320

    (190) more -> DEFAULT POINTS . codigo
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

    codigo                         shift and go to state 363
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 321

    (107) data_type_and_value -> INT32 EQUAL int_value .

    COLON           reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    PRINT           reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    SCAN            reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    FOR             reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    ID              reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    APPEND          reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    LEN             reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    COPY            reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    DELETE          reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    IF              reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    ELSE            reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    TYPE            reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    SWITCH          reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    VAR             reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    FUNC            reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    INTEGER         reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    FLOAT           reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    NOT             reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    $end            reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    RLLAVE          reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    INT32           reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    INT64           reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    FLOAT32         reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    FLOAT64         reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    BYTE            reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    WINT            reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    WFLOAT          reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    WSTRING         reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    BOOL            reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    DEFAULT         reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    CASE            reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)
    RETURN          reduce using rule 107 (data_type_and_value -> INT32 EQUAL int_value .)


state 322

    (113) int_value -> INTEGER .
    (229) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for PRINT resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for SCAN resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for FOR resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for ID resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for APPEND resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for LEN resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for COPY resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for DELETE resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for IF resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for ELSE resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for TYPE resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for SWITCH resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for VAR resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for FUNC resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for INTEGER resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for FLOAT resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for NOT resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for INT32 resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for INT64 resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for FLOAT32 resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for FLOAT64 resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for BYTE resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for WINT resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for WFLOAT resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for WSTRING resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for BOOL resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 113 (int_value -> INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 113 (int_value -> INTEGER .)
    COLON           reduce using rule 113 (int_value -> INTEGER .)
    PRINT           reduce using rule 113 (int_value -> INTEGER .)
    SCAN            reduce using rule 113 (int_value -> INTEGER .)
    FOR             reduce using rule 113 (int_value -> INTEGER .)
    ID              reduce using rule 113 (int_value -> INTEGER .)
    APPEND          reduce using rule 113 (int_value -> INTEGER .)
    LEN             reduce using rule 113 (int_value -> INTEGER .)
    COPY            reduce using rule 113 (int_value -> INTEGER .)
    DELETE          reduce using rule 113 (int_value -> INTEGER .)
    IF              reduce using rule 113 (int_value -> INTEGER .)
    ELSE            reduce using rule 113 (int_value -> INTEGER .)
    TYPE            reduce using rule 113 (int_value -> INTEGER .)
    SWITCH          reduce using rule 113 (int_value -> INTEGER .)
    VAR             reduce using rule 113 (int_value -> INTEGER .)
    FUNC            reduce using rule 113 (int_value -> INTEGER .)
    INTEGER         reduce using rule 113 (int_value -> INTEGER .)
    FLOAT           reduce using rule 113 (int_value -> INTEGER .)
    NOT             reduce using rule 113 (int_value -> INTEGER .)
    $end            reduce using rule 113 (int_value -> INTEGER .)
    RLLAVE          reduce using rule 113 (int_value -> INTEGER .)
    INT32           reduce using rule 113 (int_value -> INTEGER .)
    INT64           reduce using rule 113 (int_value -> INTEGER .)
    FLOAT32         reduce using rule 113 (int_value -> INTEGER .)
    FLOAT64         reduce using rule 113 (int_value -> INTEGER .)
    BYTE            reduce using rule 113 (int_value -> INTEGER .)
    WINT            reduce using rule 113 (int_value -> INTEGER .)
    WFLOAT          reduce using rule 113 (int_value -> INTEGER .)
    WSTRING         reduce using rule 113 (int_value -> INTEGER .)
    BOOL            reduce using rule 113 (int_value -> INTEGER .)
    DEFAULT         reduce using rule 113 (int_value -> INTEGER .)
    CASE            reduce using rule 113 (int_value -> INTEGER .)
    RETURN          reduce using rule 113 (int_value -> INTEGER .)
    GREATER         reduce using rule 229 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 229 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 229 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 229 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 229 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 229 (something_ex -> INTEGER .)
    PLUS            reduce using rule 229 (something_ex -> INTEGER .)
    TIMES           reduce using rule 229 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 229 (something_ex -> INTEGER .)
    MINUS           reduce using rule 229 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! PRINT           [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! SCAN            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! FOR             [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! ID              [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! APPEND          [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! LEN             [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! COPY            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! DELETE          [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! IF              [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! ELSE            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! TYPE            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! SWITCH          [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! VAR             [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! FUNC            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! INTEGER         [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! FLOAT           [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! NOT             [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! INT32           [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! INT64           [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! FLOAT32         [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! FLOAT64         [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! BYTE            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! WINT            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! WFLOAT          [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! WSTRING         [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! BOOL            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 229 (something_ex -> INTEGER .) ]


state 323

    (114) int_value -> expression .

    COLON           reduce using rule 114 (int_value -> expression .)
    PRINT           reduce using rule 114 (int_value -> expression .)
    SCAN            reduce using rule 114 (int_value -> expression .)
    FOR             reduce using rule 114 (int_value -> expression .)
    ID              reduce using rule 114 (int_value -> expression .)
    APPEND          reduce using rule 114 (int_value -> expression .)
    LEN             reduce using rule 114 (int_value -> expression .)
    COPY            reduce using rule 114 (int_value -> expression .)
    DELETE          reduce using rule 114 (int_value -> expression .)
    IF              reduce using rule 114 (int_value -> expression .)
    ELSE            reduce using rule 114 (int_value -> expression .)
    TYPE            reduce using rule 114 (int_value -> expression .)
    SWITCH          reduce using rule 114 (int_value -> expression .)
    VAR             reduce using rule 114 (int_value -> expression .)
    FUNC            reduce using rule 114 (int_value -> expression .)
    INTEGER         reduce using rule 114 (int_value -> expression .)
    FLOAT           reduce using rule 114 (int_value -> expression .)
    NOT             reduce using rule 114 (int_value -> expression .)
    $end            reduce using rule 114 (int_value -> expression .)
    RLLAVE          reduce using rule 114 (int_value -> expression .)
    INT32           reduce using rule 114 (int_value -> expression .)
    INT64           reduce using rule 114 (int_value -> expression .)
    FLOAT32         reduce using rule 114 (int_value -> expression .)
    FLOAT64         reduce using rule 114 (int_value -> expression .)
    BYTE            reduce using rule 114 (int_value -> expression .)
    WINT            reduce using rule 114 (int_value -> expression .)
    WFLOAT          reduce using rule 114 (int_value -> expression .)
    WSTRING         reduce using rule 114 (int_value -> expression .)
    BOOL            reduce using rule 114 (int_value -> expression .)
    DEFAULT         reduce using rule 114 (int_value -> expression .)
    CASE            reduce using rule 114 (int_value -> expression .)
    RETURN          reduce using rule 114 (int_value -> expression .)


state 324

    (108) data_type_and_value -> INT64 EQUAL int_value .

    COLON           reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    PRINT           reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    SCAN            reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    FOR             reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    ID              reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    APPEND          reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    LEN             reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    COPY            reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    DELETE          reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    IF              reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    ELSE            reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    TYPE            reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    SWITCH          reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    VAR             reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    FUNC            reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    INTEGER         reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    FLOAT           reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    NOT             reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    $end            reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    RLLAVE          reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    INT32           reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    INT64           reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    FLOAT32         reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    FLOAT64         reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    BYTE            reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    WINT            reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    WFLOAT          reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    WSTRING         reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    BOOL            reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    DEFAULT         reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    CASE            reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)
    RETURN          reduce using rule 108 (data_type_and_value -> INT64 EQUAL int_value .)


state 325

    (110) data_type_and_value -> FLOAT32 EQUAL float_value .

    COLON           reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    PRINT           reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    SCAN            reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    FOR             reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    ID              reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    APPEND          reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    LEN             reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    COPY            reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    DELETE          reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    IF              reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    ELSE            reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    TYPE            reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    SWITCH          reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    VAR             reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    FUNC            reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    INTEGER         reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    FLOAT           reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    NOT             reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    $end            reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    RLLAVE          reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    INT32           reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    INT64           reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    FLOAT32         reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    FLOAT64         reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    BYTE            reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    WINT            reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    WFLOAT          reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    WSTRING         reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    BOOL            reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    DEFAULT         reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    CASE            reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)
    RETURN          reduce using rule 110 (data_type_and_value -> FLOAT32 EQUAL float_value .)


state 326

    (119) float_value -> FLOAT .

    COLON           reduce using rule 119 (float_value -> FLOAT .)
    PRINT           reduce using rule 119 (float_value -> FLOAT .)
    SCAN            reduce using rule 119 (float_value -> FLOAT .)
    FOR             reduce using rule 119 (float_value -> FLOAT .)
    ID              reduce using rule 119 (float_value -> FLOAT .)
    APPEND          reduce using rule 119 (float_value -> FLOAT .)
    LEN             reduce using rule 119 (float_value -> FLOAT .)
    COPY            reduce using rule 119 (float_value -> FLOAT .)
    DELETE          reduce using rule 119 (float_value -> FLOAT .)
    IF              reduce using rule 119 (float_value -> FLOAT .)
    ELSE            reduce using rule 119 (float_value -> FLOAT .)
    TYPE            reduce using rule 119 (float_value -> FLOAT .)
    SWITCH          reduce using rule 119 (float_value -> FLOAT .)
    VAR             reduce using rule 119 (float_value -> FLOAT .)
    FUNC            reduce using rule 119 (float_value -> FLOAT .)
    INTEGER         reduce using rule 119 (float_value -> FLOAT .)
    FLOAT           reduce using rule 119 (float_value -> FLOAT .)
    NOT             reduce using rule 119 (float_value -> FLOAT .)
    $end            reduce using rule 119 (float_value -> FLOAT .)
    RLLAVE          reduce using rule 119 (float_value -> FLOAT .)
    INT32           reduce using rule 119 (float_value -> FLOAT .)
    INT64           reduce using rule 119 (float_value -> FLOAT .)
    FLOAT32         reduce using rule 119 (float_value -> FLOAT .)
    FLOAT64         reduce using rule 119 (float_value -> FLOAT .)
    BYTE            reduce using rule 119 (float_value -> FLOAT .)
    WINT            reduce using rule 119 (float_value -> FLOAT .)
    WFLOAT          reduce using rule 119 (float_value -> FLOAT .)
    WSTRING         reduce using rule 119 (float_value -> FLOAT .)
    BOOL            reduce using rule 119 (float_value -> FLOAT .)
    DEFAULT         reduce using rule 119 (float_value -> FLOAT .)
    CASE            reduce using rule 119 (float_value -> FLOAT .)
    RETURN          reduce using rule 119 (float_value -> FLOAT .)


state 327

    (111) data_type_and_value -> FLOAT64 EQUAL float_value .

    COLON           reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    PRINT           reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    SCAN            reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    FOR             reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    ID              reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    APPEND          reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    LEN             reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    COPY            reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    DELETE          reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    IF              reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    ELSE            reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    TYPE            reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    SWITCH          reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    VAR             reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    FUNC            reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    INTEGER         reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    FLOAT           reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    NOT             reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    $end            reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    RLLAVE          reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    INT32           reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    INT64           reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    FLOAT32         reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    FLOAT64         reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    BYTE            reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    WINT            reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    WFLOAT          reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    WSTRING         reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    BOOL            reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    DEFAULT         reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    CASE            reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)
    RETURN          reduce using rule 111 (data_type_and_value -> FLOAT64 EQUAL float_value .)


state 328

    (106) data_type_and_value -> WINT EQUAL int_value .

    COLON           reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    PRINT           reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    SCAN            reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    FOR             reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    ID              reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    APPEND          reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    LEN             reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    COPY            reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    DELETE          reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    IF              reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    ELSE            reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    TYPE            reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    SWITCH          reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    VAR             reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    FUNC            reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    INTEGER         reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    FLOAT           reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    NOT             reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    $end            reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    RLLAVE          reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    INT32           reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    INT64           reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    FLOAT32         reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    FLOAT64         reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    BYTE            reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    WINT            reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    WFLOAT          reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    WSTRING         reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    BOOL            reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    DEFAULT         reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    CASE            reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)
    RETURN          reduce using rule 106 (data_type_and_value -> WINT EQUAL int_value .)


state 329

    (109) data_type_and_value -> WFLOAT EQUAL float_value .

    COLON           reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    PRINT           reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    SCAN            reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    FOR             reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    ID              reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    APPEND          reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    LEN             reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    COPY            reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    DELETE          reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    IF              reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    ELSE            reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    TYPE            reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    SWITCH          reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    VAR             reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    FUNC            reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    INTEGER         reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    FLOAT           reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    NOT             reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    $end            reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    RLLAVE          reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    INT32           reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    INT64           reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    FLOAT32         reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    FLOAT64         reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    BYTE            reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    WINT            reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    WFLOAT          reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    WSTRING         reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    BOOL            reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    DEFAULT         reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    CASE            reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)
    RETURN          reduce using rule 109 (data_type_and_value -> WFLOAT EQUAL float_value .)


state 330

    (105) data_type_and_value -> WSTRING EQUAL STRING .

    COLON           reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    PRINT           reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    SCAN            reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    FOR             reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    ID              reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    APPEND          reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    LEN             reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    COPY            reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    DELETE          reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    IF              reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    ELSE            reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    TYPE            reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    SWITCH          reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    VAR             reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    FUNC            reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    INTEGER         reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    FLOAT           reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    NOT             reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    $end            reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    RLLAVE          reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    INT32           reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    INT64           reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    FLOAT32         reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    FLOAT64         reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    BYTE            reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    WINT            reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    WFLOAT          reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    WSTRING         reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    BOOL            reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    DEFAULT         reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    CASE            reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)
    RETURN          reduce using rule 105 (data_type_and_value -> WSTRING EQUAL STRING .)


state 331

    (112) data_type_and_value -> BOOL EQUAL bool_value .

    COLON           reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    PRINT           reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    SCAN            reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    FOR             reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    ID              reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    APPEND          reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    LEN             reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    COPY            reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    DELETE          reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    IF              reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    ELSE            reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    TYPE            reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    SWITCH          reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    VAR             reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    FUNC            reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    INTEGER         reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    FLOAT           reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    NOT             reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    $end            reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    RLLAVE          reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    INT32           reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    INT64           reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    FLOAT32         reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    FLOAT64         reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    BYTE            reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    WINT            reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    WFLOAT          reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    WSTRING         reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    BOOL            reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    DEFAULT         reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    CASE            reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)
    RETURN          reduce using rule 112 (data_type_and_value -> BOOL EQUAL bool_value .)


state 332

    (115) bool_value -> TRUE .

    COLON           reduce using rule 115 (bool_value -> TRUE .)
    PRINT           reduce using rule 115 (bool_value -> TRUE .)
    SCAN            reduce using rule 115 (bool_value -> TRUE .)
    FOR             reduce using rule 115 (bool_value -> TRUE .)
    ID              reduce using rule 115 (bool_value -> TRUE .)
    APPEND          reduce using rule 115 (bool_value -> TRUE .)
    LEN             reduce using rule 115 (bool_value -> TRUE .)
    COPY            reduce using rule 115 (bool_value -> TRUE .)
    DELETE          reduce using rule 115 (bool_value -> TRUE .)
    IF              reduce using rule 115 (bool_value -> TRUE .)
    ELSE            reduce using rule 115 (bool_value -> TRUE .)
    TYPE            reduce using rule 115 (bool_value -> TRUE .)
    SWITCH          reduce using rule 115 (bool_value -> TRUE .)
    VAR             reduce using rule 115 (bool_value -> TRUE .)
    FUNC            reduce using rule 115 (bool_value -> TRUE .)
    INTEGER         reduce using rule 115 (bool_value -> TRUE .)
    FLOAT           reduce using rule 115 (bool_value -> TRUE .)
    NOT             reduce using rule 115 (bool_value -> TRUE .)
    $end            reduce using rule 115 (bool_value -> TRUE .)
    RLLAVE          reduce using rule 115 (bool_value -> TRUE .)
    INT32           reduce using rule 115 (bool_value -> TRUE .)
    INT64           reduce using rule 115 (bool_value -> TRUE .)
    FLOAT32         reduce using rule 115 (bool_value -> TRUE .)
    FLOAT64         reduce using rule 115 (bool_value -> TRUE .)
    BYTE            reduce using rule 115 (bool_value -> TRUE .)
    WINT            reduce using rule 115 (bool_value -> TRUE .)
    WFLOAT          reduce using rule 115 (bool_value -> TRUE .)
    WSTRING         reduce using rule 115 (bool_value -> TRUE .)
    BOOL            reduce using rule 115 (bool_value -> TRUE .)
    DEFAULT         reduce using rule 115 (bool_value -> TRUE .)
    CASE            reduce using rule 115 (bool_value -> TRUE .)
    RETURN          reduce using rule 115 (bool_value -> TRUE .)


state 333

    (116) bool_value -> FALSE .

    COLON           reduce using rule 116 (bool_value -> FALSE .)
    PRINT           reduce using rule 116 (bool_value -> FALSE .)
    SCAN            reduce using rule 116 (bool_value -> FALSE .)
    FOR             reduce using rule 116 (bool_value -> FALSE .)
    ID              reduce using rule 116 (bool_value -> FALSE .)
    APPEND          reduce using rule 116 (bool_value -> FALSE .)
    LEN             reduce using rule 116 (bool_value -> FALSE .)
    COPY            reduce using rule 116 (bool_value -> FALSE .)
    DELETE          reduce using rule 116 (bool_value -> FALSE .)
    IF              reduce using rule 116 (bool_value -> FALSE .)
    ELSE            reduce using rule 116 (bool_value -> FALSE .)
    TYPE            reduce using rule 116 (bool_value -> FALSE .)
    SWITCH          reduce using rule 116 (bool_value -> FALSE .)
    VAR             reduce using rule 116 (bool_value -> FALSE .)
    FUNC            reduce using rule 116 (bool_value -> FALSE .)
    INTEGER         reduce using rule 116 (bool_value -> FALSE .)
    FLOAT           reduce using rule 116 (bool_value -> FALSE .)
    NOT             reduce using rule 116 (bool_value -> FALSE .)
    $end            reduce using rule 116 (bool_value -> FALSE .)
    RLLAVE          reduce using rule 116 (bool_value -> FALSE .)
    INT32           reduce using rule 116 (bool_value -> FALSE .)
    INT64           reduce using rule 116 (bool_value -> FALSE .)
    FLOAT32         reduce using rule 116 (bool_value -> FALSE .)
    FLOAT64         reduce using rule 116 (bool_value -> FALSE .)
    BYTE            reduce using rule 116 (bool_value -> FALSE .)
    WINT            reduce using rule 116 (bool_value -> FALSE .)
    WFLOAT          reduce using rule 116 (bool_value -> FALSE .)
    WSTRING         reduce using rule 116 (bool_value -> FALSE .)
    BOOL            reduce using rule 116 (bool_value -> FALSE .)
    DEFAULT         reduce using rule 116 (bool_value -> FALSE .)
    CASE            reduce using rule 116 (bool_value -> FALSE .)
    RETURN          reduce using rule 116 (bool_value -> FALSE .)


state 334

    (117) bool_value -> comparison .
    (180) logic_value -> comparison .

    COLON           reduce using rule 117 (bool_value -> comparison .)
    PRINT           reduce using rule 117 (bool_value -> comparison .)
    SCAN            reduce using rule 117 (bool_value -> comparison .)
    FOR             reduce using rule 117 (bool_value -> comparison .)
    ID              reduce using rule 117 (bool_value -> comparison .)
    APPEND          reduce using rule 117 (bool_value -> comparison .)
    LEN             reduce using rule 117 (bool_value -> comparison .)
    COPY            reduce using rule 117 (bool_value -> comparison .)
    DELETE          reduce using rule 117 (bool_value -> comparison .)
    IF              reduce using rule 117 (bool_value -> comparison .)
    ELSE            reduce using rule 117 (bool_value -> comparison .)
    TYPE            reduce using rule 117 (bool_value -> comparison .)
    SWITCH          reduce using rule 117 (bool_value -> comparison .)
    VAR             reduce using rule 117 (bool_value -> comparison .)
    FUNC            reduce using rule 117 (bool_value -> comparison .)
    INTEGER         reduce using rule 117 (bool_value -> comparison .)
    FLOAT           reduce using rule 117 (bool_value -> comparison .)
    NOT             reduce using rule 117 (bool_value -> comparison .)
    $end            reduce using rule 117 (bool_value -> comparison .)
    RLLAVE          reduce using rule 117 (bool_value -> comparison .)
    INT32           reduce using rule 117 (bool_value -> comparison .)
    INT64           reduce using rule 117 (bool_value -> comparison .)
    FLOAT32         reduce using rule 117 (bool_value -> comparison .)
    FLOAT64         reduce using rule 117 (bool_value -> comparison .)
    BYTE            reduce using rule 117 (bool_value -> comparison .)
    WINT            reduce using rule 117 (bool_value -> comparison .)
    WFLOAT          reduce using rule 117 (bool_value -> comparison .)
    WSTRING         reduce using rule 117 (bool_value -> comparison .)
    BOOL            reduce using rule 117 (bool_value -> comparison .)
    DEFAULT         reduce using rule 117 (bool_value -> comparison .)
    CASE            reduce using rule 117 (bool_value -> comparison .)
    RETURN          reduce using rule 117 (bool_value -> comparison .)
    AND             reduce using rule 180 (logic_value -> comparison .)
    OR              reduce using rule 180 (logic_value -> comparison .)


state 335

    (118) bool_value -> logic_operation .

    COLON           reduce using rule 118 (bool_value -> logic_operation .)
    PRINT           reduce using rule 118 (bool_value -> logic_operation .)
    SCAN            reduce using rule 118 (bool_value -> logic_operation .)
    FOR             reduce using rule 118 (bool_value -> logic_operation .)
    ID              reduce using rule 118 (bool_value -> logic_operation .)
    APPEND          reduce using rule 118 (bool_value -> logic_operation .)
    LEN             reduce using rule 118 (bool_value -> logic_operation .)
    COPY            reduce using rule 118 (bool_value -> logic_operation .)
    DELETE          reduce using rule 118 (bool_value -> logic_operation .)
    IF              reduce using rule 118 (bool_value -> logic_operation .)
    ELSE            reduce using rule 118 (bool_value -> logic_operation .)
    TYPE            reduce using rule 118 (bool_value -> logic_operation .)
    SWITCH          reduce using rule 118 (bool_value -> logic_operation .)
    VAR             reduce using rule 118 (bool_value -> logic_operation .)
    FUNC            reduce using rule 118 (bool_value -> logic_operation .)
    INTEGER         reduce using rule 118 (bool_value -> logic_operation .)
    FLOAT           reduce using rule 118 (bool_value -> logic_operation .)
    NOT             reduce using rule 118 (bool_value -> logic_operation .)
    $end            reduce using rule 118 (bool_value -> logic_operation .)
    RLLAVE          reduce using rule 118 (bool_value -> logic_operation .)
    INT32           reduce using rule 118 (bool_value -> logic_operation .)
    INT64           reduce using rule 118 (bool_value -> logic_operation .)
    FLOAT32         reduce using rule 118 (bool_value -> logic_operation .)
    FLOAT64         reduce using rule 118 (bool_value -> logic_operation .)
    BYTE            reduce using rule 118 (bool_value -> logic_operation .)
    WINT            reduce using rule 118 (bool_value -> logic_operation .)
    WFLOAT          reduce using rule 118 (bool_value -> logic_operation .)
    WSTRING         reduce using rule 118 (bool_value -> logic_operation .)
    BOOL            reduce using rule 118 (bool_value -> logic_operation .)
    DEFAULT         reduce using rule 118 (bool_value -> logic_operation .)
    CASE            reduce using rule 118 (bool_value -> logic_operation .)
    RETURN          reduce using rule 118 (bool_value -> logic_operation .)


state 336

    (167) value -> ID .
    (181) logic_value -> ID .
    (228) something_ex -> ID .
    (196) array_var -> ID . LCORCHE index RCORCHE
    (202) map_var -> ID . LCORCHE key RCORCHE
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 167 (value -> ID .)
    GREATER         reduce using rule 167 (value -> ID .)
    SMALLER         reduce using rule 167 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 167 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 167 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 167 (value -> ID .)
    NOT_EQUAL       reduce using rule 167 (value -> ID .)
    PLUS            reduce using rule 167 (value -> ID .)
    TIMES           reduce using rule 167 (value -> ID .)
    DIVIDE          reduce using rule 167 (value -> ID .)
    MINUS           reduce using rule 167 (value -> ID .)
    AND             reduce using rule 181 (logic_value -> ID .)
    OR              reduce using rule 181 (logic_value -> ID .)
    LCORCHE         shift and go to state 167
    LPAREN          shift and go to state 106

  ! GREATER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 228 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 228 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 228 (something_ex -> ID .) ]


state 337

    (215) params -> ID data_types .
    (217) more_params -> ID data_types . COMA params

    RPAREN          reduce using rule 215 (params -> ID data_types .)
    COMA            shift and go to state 364


state 338

    (207) func_declaration -> FUNC ID LPAREN params RPAREN . data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> FUNC ID LPAREN params RPAREN . data_types LLLAVE RETURN return_value RLLAVE
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 126
    INT64           shift and go to state 127
    FLOAT32         shift and go to state 128
    FLOAT64         shift and go to state 129
    BYTE            shift and go to state 130
    WINT            shift and go to state 131
    WFLOAT          shift and go to state 132
    WSTRING         shift and go to state 133
    BOOL            shift and go to state 134

    data_types                     shift and go to state 365

state 339

    (79) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

    codigo                         shift and go to state 366
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 340

    (89) cicloFor -> FOR decVarOne COLON comparison COLON incre . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 367


state 341

    (90) incre -> ID . INCREASE
    (91) incre -> ID . DECREASE

    INCREASE        shift and go to state 368
    DECREASE        shift and go to state 369


state 342

    (160) asignaciones -> ID POINTS . valor
    (161) asignaciones -> ID POINTS . valor COMA asignaciones
    (162) valor -> . ID
    (163) valor -> . INTEGER
    (164) valor -> . TRUE
    (165) valor -> . FALSE

    ID              shift and go to state 370
    INTEGER         shift and go to state 372
    TRUE            shift and go to state 373
    FALSE           shift and go to state 374

    valor                          shift and go to state 371

state 343

    (159) cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .

    PRINT           reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    SCAN            reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FOR             reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    ID              reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    APPEND          reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    LEN             reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    COPY            reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    DELETE          reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    IF              reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    ELSE            reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    TYPE            reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    SWITCH          reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    VAR             reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FUNC            reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    INTEGER         reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FLOAT           reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    NOT             reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    $end            reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    RLLAVE          reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    INT32           reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    INT64           reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FLOAT32         reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    FLOAT64         reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    BYTE            reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    WINT            reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    WFLOAT          reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    WSTRING         reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    BOOL            reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    DEFAULT         reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    CASE            reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    RETURN          reduce using rule 159 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)


state 344

    (125) slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .

    COLON           reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    PRINT           reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    SCAN            reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FOR             reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    ID              reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    APPEND          reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    LEN             reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    COPY            reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    DELETE          reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    IF              reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    ELSE            reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    TYPE            reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    SWITCH          reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    VAR             reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FUNC            reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    INTEGER         reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT           reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    NOT             reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    $end            reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    INT32           reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    INT64           reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT32         reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT64         reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    BYTE            reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    WINT            reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    WFLOAT          reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    WSTRING         reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    BOOL            reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    CASE            reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RETURN          reduce using rule 125 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)


state 345

    (69) arr_content -> LLLAVE . items COMA more_items RLLAVE
    (70) arr_content -> LLLAVE . items RLLAVE
    (73) items -> . values
    (74) items -> . operations
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    STRING          shift and go to state 140
    INTEGER         shift and go to state 141
    FLOAT           shift and go to state 142
    TRUE            shift and go to state 143
    FALSE           shift and go to state 144
    ID              shift and go to state 378
    NOT             shift and go to state 54
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    items                          shift and go to state 375
    values                         shift and go to state 376
    operations                     shift and go to state 377
    expression                     shift and go to state 145
    comparison                     shift and go to state 146
    logic_operation                shift and go to state 147
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 346

    (126) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap RPAREN
    (127) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap COMA cap RPAREN
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 126
    INT64           shift and go to state 127
    FLOAT32         shift and go to state 128
    FLOAT64         shift and go to state 129
    BYTE            shift and go to state 130
    WINT            shift and go to state 131
    WFLOAT          shift and go to state 132
    WSTRING         shift and go to state 133
    BOOL            shift and go to state 134

    data_types                     shift and go to state 379

state 347

    (141) funciones -> APPEND LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    PRINT           reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SCAN            reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FOR             reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    ID              reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    APPEND          reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    LEN             reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    COPY            reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DELETE          reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    IF              reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    ELSE            reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    TYPE            reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SWITCH          reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    VAR             reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FUNC            reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    INTEGER         reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FLOAT           reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    NOT             reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    INT32           reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    INT64           reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FLOAT32         reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    FLOAT64         reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    BYTE            reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    WINT            reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    WFLOAT          reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    WSTRING         reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    BOOL            reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 141 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)


state 348

    (140) funciones -> APPEND LPAREN ID COMA values RPAREN .

    COLON           reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    PRINT           reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SCAN            reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FOR             reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    ID              reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    APPEND          reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    LEN             reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    COPY            reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DELETE          reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    IF              reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    ELSE            reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    TYPE            reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SWITCH          reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    VAR             reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FUNC            reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    INTEGER         reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FLOAT           reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    NOT             reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    $end            reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    GREATER         reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SMALLER         reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    GREATER_OR_EQUAL reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    EQUAL_COMPARE   reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    NOT_EQUAL       reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    PLUS            reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    TIMES           reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DIVIDE          reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    MINUS           reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RLLAVE          reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    INT32           reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    INT64           reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FLOAT32         reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    FLOAT64         reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    BYTE            reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    WINT            reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    WFLOAT          reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    WSTRING         reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    BOOL            reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DEFAULT         reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    CASE            reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RETURN          reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RPAREN          reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    AND             reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    OR              reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    LLLAVE          reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RCORCHE         reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    COMA            reduce using rule 140 (funciones -> APPEND LPAREN ID COMA values RPAREN .)


state 349

    (143) funciones -> COPY LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    PRINT           reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SCAN            reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FOR             reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    ID              reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    APPEND          reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    LEN             reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    COPY            reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DELETE          reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    IF              reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    ELSE            reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    TYPE            reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SWITCH          reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    VAR             reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FUNC            reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    INTEGER         reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FLOAT           reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    NOT             reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    INT32           reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    INT64           reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FLOAT32         reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    FLOAT64         reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    BYTE            reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    WINT            reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    WFLOAT          reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    WSTRING         reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    BOOL            reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 143 (funciones -> COPY LPAREN ID COMA ID RPAREN .)


state 350

    (144) funciones -> DELETE LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    PRINT           reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SCAN            reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FOR             reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    ID              reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    APPEND          reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    LEN             reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    COPY            reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DELETE          reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    IF              reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    ELSE            reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    TYPE            reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SWITCH          reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    VAR             reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FUNC            reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    INTEGER         reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FLOAT           reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    NOT             reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    INT32           reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    INT64           reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FLOAT32         reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    FLOAT64         reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    BYTE            reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    WINT            reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    WFLOAT          reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    WSTRING         reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    BOOL            reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 144 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)


state 351

    (151) SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    ID              reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    IF              reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    $end            reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 151 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)


state 352

    (152) SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 152 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)


state 353

    (153) SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    ID              reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    IF              reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    $end            reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 153 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)


state 354

    (155) SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .

    PRINT           reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    SCAN            reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FOR             reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    ID              reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    APPEND          reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    LEN             reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    COPY            reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    DELETE          reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    IF              reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    ELSE            reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    TYPE            reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    SWITCH          reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    VAR             reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FUNC            reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    INTEGER         reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FLOAT           reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    NOT             reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    $end            reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RLLAVE          reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    INT32           reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    INT64           reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FLOAT32         reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    FLOAT64         reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    BYTE            reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    WINT            reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    WFLOAT          reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    WSTRING         reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    BOOL            reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    DEFAULT         reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    CASE            reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RETURN          reduce using rule 155 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)


state 355

    (157) declaration -> declaration variable . data_types
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 126
    INT64           shift and go to state 127
    FLOAT32         shift and go to state 128
    FLOAT64         shift and go to state 129
    BYTE            shift and go to state 130
    WINT            shift and go to state 131
    WFLOAT          shift and go to state 132
    WSTRING         shift and go to state 133
    BOOL            shift and go to state 134

    data_types                     shift and go to state 380

state 356

    (156) declaration -> variable data_types .

    RLLAVE          reduce using rule 156 (declaration -> variable data_types .)
    ID              reduce using rule 156 (declaration -> variable data_types .)


state 357

    (187) cases -> CASE values POINTS . codigo
    (188) cases -> CASE values POINTS . codigo more
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

    codigo                         shift and go to state 381
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 358

    (191) array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .

    COLON           reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    PRINT           reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    SCAN            reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FOR             reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    ID              reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    APPEND          reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    LEN             reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    COPY            reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    DELETE          reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    IF              reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    ELSE            reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    TYPE            reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    SWITCH          reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    VAR             reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FUNC            reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    INTEGER         reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FLOAT           reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    NOT             reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    $end            reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RLLAVE          reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    INT32           reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    INT64           reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FLOAT32         reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    FLOAT64         reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    BYTE            reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    WINT            reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    WFLOAT          reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    WSTRING         reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    BOOL            reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    DEFAULT         reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    CASE            reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RETURN          reduce using rule 191 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)


state 359

    (201) map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .

    COLON           reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    PRINT           reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    SCAN            reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FOR             reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    ID              reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    APPEND          reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    LEN             reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    COPY            reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    DELETE          reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    IF              reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    ELSE            reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    TYPE            reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    SWITCH          reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    VAR             reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FUNC            reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    INTEGER         reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FLOAT           reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    NOT             reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    $end            reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    RLLAVE          reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    INT32           reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    INT64           reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FLOAT32         reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    FLOAT64         reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    BYTE            reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    WINT            reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    WFLOAT          reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    WSTRING         reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    BOOL            reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    DEFAULT         reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    CASE            reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    RETURN          reduce using rule 201 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)


state 360

    (192) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE . data_types arr_content
    (48) data_types -> . INT32
    (49) data_types -> . INT64
    (50) data_types -> . FLOAT32
    (51) data_types -> . FLOAT64
    (52) data_types -> . BYTE
    (53) data_types -> . WINT
    (54) data_types -> . WFLOAT
    (55) data_types -> . WSTRING
    (56) data_types -> . BOOL

    INT32           shift and go to state 126
    INT64           shift and go to state 127
    FLOAT32         shift and go to state 128
    FLOAT64         shift and go to state 129
    BYTE            shift and go to state 130
    WINT            shift and go to state 131
    WFLOAT          shift and go to state 132
    WSTRING         shift and go to state 133
    BOOL            shift and go to state 134

    data_types                     shift and go to state 382

state 361

    (122) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types . arr_content
    (69) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (70) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 345

    arr_content                    shift and go to state 383

state 362

    (99) more -> ID COMA more .

    INT32           reduce using rule 99 (more -> ID COMA more .)
    INT64           reduce using rule 99 (more -> ID COMA more .)
    FLOAT32         reduce using rule 99 (more -> ID COMA more .)
    FLOAT64         reduce using rule 99 (more -> ID COMA more .)
    BYTE            reduce using rule 99 (more -> ID COMA more .)
    WINT            reduce using rule 99 (more -> ID COMA more .)
    WFLOAT          reduce using rule 99 (more -> ID COMA more .)
    WSTRING         reduce using rule 99 (more -> ID COMA more .)
    BOOL            reduce using rule 99 (more -> ID COMA more .)
    RLLAVE          reduce using rule 99 (more -> ID COMA more .)


state 363

    (190) more -> DEFAULT POINTS codigo .

    INT32           reduce using rule 190 (more -> DEFAULT POINTS codigo .)
    INT64           reduce using rule 190 (more -> DEFAULT POINTS codigo .)
    FLOAT32         reduce using rule 190 (more -> DEFAULT POINTS codigo .)
    FLOAT64         reduce using rule 190 (more -> DEFAULT POINTS codigo .)
    BYTE            reduce using rule 190 (more -> DEFAULT POINTS codigo .)
    WINT            reduce using rule 190 (more -> DEFAULT POINTS codigo .)
    WFLOAT          reduce using rule 190 (more -> DEFAULT POINTS codigo .)
    WSTRING         reduce using rule 190 (more -> DEFAULT POINTS codigo .)
    BOOL            reduce using rule 190 (more -> DEFAULT POINTS codigo .)
    RLLAVE          reduce using rule 190 (more -> DEFAULT POINTS codigo .)


state 364

    (217) more_params -> ID data_types COMA . params
    (215) params -> . ID data_types
    (216) params -> . more_params
    (217) more_params -> . ID data_types COMA params

    ID              shift and go to state 283

    params                         shift and go to state 384
    more_params                    shift and go to state 285

state 365

    (207) func_declaration -> FUNC ID LPAREN params RPAREN data_types . LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> FUNC ID LPAREN params RPAREN data_types . LLLAVE RETURN return_value RLLAVE

    LLLAVE          shift and go to state 385


state 366

    (79) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 386


state 367

    (89) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE . codigo RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

    comparison                     shift and go to state 8
    codigo                         shift and go to state 387
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 368

    (90) incre -> ID INCREASE .

    LLLAVE          reduce using rule 90 (incre -> ID INCREASE .)


state 369

    (91) incre -> ID DECREASE .

    LLLAVE          reduce using rule 91 (incre -> ID DECREASE .)


state 370

    (162) valor -> ID .

    COMA            reduce using rule 162 (valor -> ID .)
    RLLAVE          reduce using rule 162 (valor -> ID .)


state 371

    (160) asignaciones -> ID POINTS valor .
    (161) asignaciones -> ID POINTS valor . COMA asignaciones

    RLLAVE          reduce using rule 160 (asignaciones -> ID POINTS valor .)
    COMA            shift and go to state 388


state 372

    (163) valor -> INTEGER .

    COMA            reduce using rule 163 (valor -> INTEGER .)
    RLLAVE          reduce using rule 163 (valor -> INTEGER .)


state 373

    (164) valor -> TRUE .

    COMA            reduce using rule 164 (valor -> TRUE .)
    RLLAVE          reduce using rule 164 (valor -> TRUE .)


state 374

    (165) valor -> FALSE .

    COMA            reduce using rule 165 (valor -> FALSE .)
    RLLAVE          reduce using rule 165 (valor -> FALSE .)


state 375

    (69) arr_content -> LLLAVE items . COMA more_items RLLAVE
    (70) arr_content -> LLLAVE items . RLLAVE

    COMA            shift and go to state 389
    RLLAVE          shift and go to state 390


state 376

    (73) items -> values .

    COMA            reduce using rule 73 (items -> values .)
    RLLAVE          reduce using rule 73 (items -> values .)


state 377

    (74) items -> operations .

    COMA            reduce using rule 74 (items -> operations .)
    RLLAVE          reduce using rule 74 (items -> operations .)


state 378

    (228) something_ex -> ID .
    (167) value -> ID .
    (181) logic_value -> ID .
    (196) array_var -> ID . LCORCHE index RCORCHE
    (202) map_var -> ID . LCORCHE key RCORCHE
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for GREATER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 167 (value -> ID .)
    COMA            reduce using rule 228 (something_ex -> ID .)
    RLLAVE          reduce using rule 228 (something_ex -> ID .)
    GREATER         reduce using rule 167 (value -> ID .)
    SMALLER         reduce using rule 167 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 167 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 167 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 167 (value -> ID .)
    NOT_EQUAL       reduce using rule 167 (value -> ID .)
    PLUS            reduce using rule 167 (value -> ID .)
    TIMES           reduce using rule 167 (value -> ID .)
    DIVIDE          reduce using rule 167 (value -> ID .)
    MINUS           reduce using rule 167 (value -> ID .)
    AND             reduce using rule 181 (logic_value -> ID .)
    OR              reduce using rule 181 (logic_value -> ID .)
    LCORCHE         shift and go to state 167
    LPAREN          shift and go to state 106

  ! GREATER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 228 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 228 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 228 (something_ex -> ID .) ]


state 379

    (126) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap RPAREN
    (127) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap COMA cap RPAREN

    COMA            shift and go to state 391


state 380

    (157) declaration -> declaration variable data_types .

    RLLAVE          reduce using rule 157 (declaration -> declaration variable data_types .)
    ID              reduce using rule 157 (declaration -> declaration variable data_types .)


state 381

    (187) cases -> CASE values POINTS codigo .
    (188) cases -> CASE values POINTS codigo . more
    (98) more -> . ID
    (99) more -> . ID COMA more
    (189) more -> . cases
    (190) more -> . DEFAULT POINTS codigo
    (187) cases -> . CASE values POINTS codigo
    (188) cases -> . CASE values POINTS codigo more

    RLLAVE          reduce using rule 187 (cases -> CASE values POINTS codigo .)
    INT32           reduce using rule 187 (cases -> CASE values POINTS codigo .)
    INT64           reduce using rule 187 (cases -> CASE values POINTS codigo .)
    FLOAT32         reduce using rule 187 (cases -> CASE values POINTS codigo .)
    FLOAT64         reduce using rule 187 (cases -> CASE values POINTS codigo .)
    BYTE            reduce using rule 187 (cases -> CASE values POINTS codigo .)
    WINT            reduce using rule 187 (cases -> CASE values POINTS codigo .)
    WFLOAT          reduce using rule 187 (cases -> CASE values POINTS codigo .)
    WSTRING         reduce using rule 187 (cases -> CASE values POINTS codigo .)
    BOOL            reduce using rule 187 (cases -> CASE values POINTS codigo .)
    ID              shift and go to state 271
    DEFAULT         shift and go to state 274
    CASE            shift and go to state 261

    more                           shift and go to state 392
    cases                          shift and go to state 273

state 382

    (192) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types . arr_content
    (69) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (70) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 345

    arr_content                    shift and go to state 393

state 383

    (122) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .

    COLON           reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    PRINT           reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    SCAN            reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FOR             reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    ID              reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    APPEND          reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    LEN             reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    COPY            reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    DELETE          reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    IF              reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    ELSE            reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    TYPE            reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    SWITCH          reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    VAR             reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FUNC            reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    INTEGER         reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT           reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    NOT             reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    $end            reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    INT32           reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    INT64           reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT32         reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    FLOAT64         reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    BYTE            reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    WINT            reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    WFLOAT          reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    WSTRING         reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    BOOL            reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    CASE            reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    RETURN          reduce using rule 122 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)


state 384

    (217) more_params -> ID data_types COMA params .

    RPAREN          reduce using rule 217 (more_params -> ID data_types COMA params .)


state 385

    (207) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE . codigo RETURN retorno RLLAVE
    (208) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE . RETURN return_value RLLAVE
    (1) codigo -> . rule
    (2) codigo -> . more_rules
    (4) rule -> . impresion COLON
    (5) rule -> . impresion
    (6) rule -> . scan_func COLON
    (7) rule -> . scan_func
    (8) rule -> . expression COLON
    (9) rule -> . expression
    (10) rule -> . cicloFor
    (11) rule -> . comparison
    (12) rule -> . logic_operation
    (13) rule -> . decVar COLON
    (14) rule -> . decVar
    (15) rule -> . var_asignation
    (16) rule -> . var_asignation COLON
    (17) rule -> . funciones
    (18) rule -> . funciones COLON
    (19) rule -> . SenIF
    (20) rule -> . SenElseIF
    (21) rule -> . SenElse
    (22) rule -> . SenStruct
    (23) rule -> . cStruct
    (24) rule -> . switch_statement
    (25) rule -> . array_declaration COLON
    (26) rule -> . array_declaration
    (27) rule -> . array_var COLON
    (28) rule -> . array_var
    (29) rule -> . array_assignment COLON
    (30) rule -> . array_assignment
    (31) rule -> . slice_declaration COLON
    (32) rule -> . slice_declaration
    (33) rule -> . slice_var COLON
    (34) rule -> . slice_var
    (35) rule -> . slice_assignment COLON
    (36) rule -> . slice_assignment
    (37) rule -> . map_declaration COLON
    (38) rule -> . map_declaration
    (39) rule -> . map_assignment COLON
    (40) rule -> . map_assignment
    (41) rule -> . func_declaration
    (42) rule -> . main_func
    (3) more_rules -> . rule codigo
    (218) impresion -> . PRINT LPAREN content RPAREN
    (80) scan_func -> . SCAN LPAREN POINTER RPAREN
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (86) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (87) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (88) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (89) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (92) decVar -> . static
    (93) decVar -> . dynamic
    (62) var_asignation -> . ID EQUAL any
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (148) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (149) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (150) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (151) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (152) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (153) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (154) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (155) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (159) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (186) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (191) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (192) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (196) array_var -> . ID LCORCHE index RCORCHE
    (200) array_assignment -> . array_var EQUAL something
    (121) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (122) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (123) slice_declaration -> . VAR ID EQUAL funM
    (124) slice_declaration -> . ID DEQUAL funM
    (125) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (131) slice_var -> . ID LCORCHE index_s RCORCHE
    (135) slice_assignment -> . slice_var EQUAL something_s
    (201) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (206) map_assignment -> . map_var EQUAL something
    (207) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (208) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (79) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (94) static -> . single
    (95) static -> . multiple
    (120) dynamic -> . ID DEQUAL values
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN
    (202) map_var -> . ID LCORCHE key RCORCHE
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (100) single -> . VAR ID data_types
    (101) single -> . VAR ID data_types EQUAL funciones
    (102) single -> . VAR ID data_types EQUAL ID
    (103) single -> . VAR ID data_types EQUAL data_structure
    (104) single -> . VAR ID data_type_and_value
    (96) multiple -> . list_var data_types
    (97) list_var -> . VAR ID COMA more

    RETURN          shift and go to state 395
    PRINT           shift and go to state 29
    SCAN            shift and go to state 30
    FOR             shift and go to state 32
    ID              shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 44
    ELSE            shift and go to state 45
    TYPE            shift and go to state 46
    SWITCH          shift and go to state 47
    VAR             shift and go to state 48
    FUNC            shift and go to state 50
    INTEGER         shift and go to state 51
    FLOAT           shift and go to state 52
    NOT             shift and go to state 54

    codigo                         shift and go to state 394
    rule                           shift and go to state 2
    more_rules                     shift and go to state 3
    impresion                      shift and go to state 4
    scan_func                      shift and go to state 5
    expression                     shift and go to state 6
    cicloFor                       shift and go to state 7
    comparison                     shift and go to state 8
    logic_operation                shift and go to state 9
    decVar                         shift and go to state 10
    var_asignation                 shift and go to state 11
    funciones                      shift and go to state 12
    SenIF                          shift and go to state 13
    SenElseIF                      shift and go to state 14
    SenElse                        shift and go to state 15
    SenStruct                      shift and go to state 16
    cStruct                        shift and go to state 17
    switch_statement               shift and go to state 18
    array_declaration              shift and go to state 19
    array_var                      shift and go to state 20
    array_assignment               shift and go to state 21
    slice_declaration              shift and go to state 22
    slice_var                      shift and go to state 23
    slice_assignment               shift and go to state 24
    map_declaration                shift and go to state 25
    map_assignment                 shift and go to state 26
    func_declaration               shift and go to state 27
    main_func                      shift and go to state 28
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    static                         shift and go to state 36
    dynamic                        shift and go to state 37
    call_func                      shift and go to state 43
    map_var                        shift and go to state 49
    data_structure                 shift and go to state 53
    single                         shift and go to state 55
    multiple                       shift and go to state 56
    list_var                       shift and go to state 57

state 386

    (79) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    ID              reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    IF              reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    $end            reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 79 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)


state 387

    (89) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 396


state 388

    (161) asignaciones -> ID POINTS valor COMA . asignaciones
    (160) asignaciones -> . ID POINTS valor
    (161) asignaciones -> . ID POINTS valor COMA asignaciones

    ID              shift and go to state 290

    asignaciones                   shift and go to state 397

state 389

    (69) arr_content -> LLLAVE items COMA . more_items RLLAVE
    (71) more_items -> . items COMA more_items
    (72) more_items -> . items
    (73) items -> . values
    (74) items -> . operations
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    STRING          shift and go to state 140
    INTEGER         shift and go to state 141
    FLOAT           shift and go to state 142
    TRUE            shift and go to state 143
    FALSE           shift and go to state 144
    ID              shift and go to state 378
    NOT             shift and go to state 54
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    items                          shift and go to state 398
    more_items                     shift and go to state 399
    values                         shift and go to state 376
    operations                     shift and go to state 377
    expression                     shift and go to state 145
    comparison                     shift and go to state 146
    logic_operation                shift and go to state 147
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 390

    (70) arr_content -> LLLAVE items RLLAVE .

    COLON           reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    PRINT           reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    SCAN            reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    FOR             reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    ID              reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    APPEND          reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    LEN             reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    COPY            reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    DELETE          reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    IF              reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    ELSE            reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    TYPE            reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    SWITCH          reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    VAR             reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    FUNC            reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    INTEGER         reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    FLOAT           reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    NOT             reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    $end            reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    RLLAVE          reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    INT32           reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    INT64           reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    FLOAT32         reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    FLOAT64         reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    BYTE            reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    WINT            reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    WFLOAT          reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    WSTRING         reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    BOOL            reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    DEFAULT         reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    CASE            reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)
    RETURN          reduce using rule 70 (arr_content -> LLLAVE items RLLAVE .)


state 391

    (126) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap RPAREN
    (127) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap COMA cap RPAREN
    (128) cap -> . INTEGER
    (129) cap -> . ID
    (130) cap -> . expression
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 401
    ID              shift and go to state 402
    FLOAT           shift and go to state 52
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    cap                            shift and go to state 400
    expression                     shift and go to state 403
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 392

    (188) cases -> CASE values POINTS codigo more .

    RLLAVE          reduce using rule 188 (cases -> CASE values POINTS codigo more .)
    INT32           reduce using rule 188 (cases -> CASE values POINTS codigo more .)
    INT64           reduce using rule 188 (cases -> CASE values POINTS codigo more .)
    FLOAT32         reduce using rule 188 (cases -> CASE values POINTS codigo more .)
    FLOAT64         reduce using rule 188 (cases -> CASE values POINTS codigo more .)
    BYTE            reduce using rule 188 (cases -> CASE values POINTS codigo more .)
    WINT            reduce using rule 188 (cases -> CASE values POINTS codigo more .)
    WFLOAT          reduce using rule 188 (cases -> CASE values POINTS codigo more .)
    WSTRING         reduce using rule 188 (cases -> CASE values POINTS codigo more .)
    BOOL            reduce using rule 188 (cases -> CASE values POINTS codigo more .)


state 393

    (192) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .

    COLON           reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    PRINT           reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    SCAN            reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FOR             reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    ID              reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    APPEND          reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    LEN             reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    COPY            reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    DELETE          reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    IF              reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    ELSE            reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    TYPE            reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    SWITCH          reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    VAR             reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FUNC            reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    INTEGER         reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FLOAT           reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    NOT             reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    $end            reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    INT32           reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    INT64           reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FLOAT32         reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    FLOAT64         reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    BYTE            reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    WINT            reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    WFLOAT          reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    WSTRING         reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    BOOL            reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    CASE            reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RETURN          reduce using rule 192 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)


state 394

    (207) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo . RETURN retorno RLLAVE

    RETURN          shift and go to state 404


state 395

    (208) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN . return_value RLLAVE
    (209) return_value -> . retorno COLON
    (210) return_value -> . retorno
    (211) retorno -> . ID
    (212) retorno -> . values
    (213) retorno -> . operations
    (214) retorno -> . data_structure
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 405
    STRING          shift and go to state 140
    INTEGER         shift and go to state 141
    FLOAT           shift and go to state 142
    TRUE            shift and go to state 143
    FALSE           shift and go to state 144
    NOT             shift and go to state 54
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    return_value                   shift and go to state 406
    retorno                        shift and go to state 407
    values                         shift and go to state 408
    operations                     shift and go to state 409
    data_structure                 shift and go to state 410
    expression                     shift and go to state 145
    comparison                     shift and go to state 146
    logic_operation                shift and go to state 147
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    funciones                      shift and go to state 95
    call_func                      shift and go to state 43

state 396

    (89) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .

    PRINT           reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    SCAN            reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FOR             reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    ID              reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    APPEND          reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    LEN             reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    COPY            reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    DELETE          reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    IF              reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    ELSE            reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    TYPE            reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    SWITCH          reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    VAR             reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FUNC            reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    INTEGER         reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FLOAT           reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    NOT             reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    $end            reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    INT32           reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    INT64           reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FLOAT32         reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    FLOAT64         reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    BYTE            reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    WINT            reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    WFLOAT          reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    WSTRING         reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    BOOL            reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 89 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)


state 397

    (161) asignaciones -> ID POINTS valor COMA asignaciones .

    RLLAVE          reduce using rule 161 (asignaciones -> ID POINTS valor COMA asignaciones .)


state 398

    (71) more_items -> items . COMA more_items
    (72) more_items -> items .

    COMA            shift and go to state 411
    RLLAVE          reduce using rule 72 (more_items -> items .)


state 399

    (69) arr_content -> LLLAVE items COMA more_items . RLLAVE

    RLLAVE          shift and go to state 412


state 400

    (126) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . RPAREN
    (127) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . COMA cap RPAREN

    RPAREN          shift and go to state 414
    COMA            shift and go to state 413


state 401

    (128) cap -> INTEGER .
    (229) something_ex -> INTEGER .

  ! reduce/reduce conflict for RPAREN resolved using rule 128 (cap -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 128 (cap -> INTEGER .)
    RPAREN          reduce using rule 128 (cap -> INTEGER .)
    COMA            reduce using rule 128 (cap -> INTEGER .)
    GREATER         reduce using rule 229 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 229 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 229 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 229 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 229 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 229 (something_ex -> INTEGER .)
    PLUS            reduce using rule 229 (something_ex -> INTEGER .)
    TIMES           reduce using rule 229 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 229 (something_ex -> INTEGER .)
    MINUS           reduce using rule 229 (something_ex -> INTEGER .)

  ! RPAREN          [ reduce using rule 229 (something_ex -> INTEGER .) ]
  ! COMA            [ reduce using rule 229 (something_ex -> INTEGER .) ]


state 402

    (129) cap -> ID .
    (228) something_ex -> ID .
    (196) array_var -> ID . LCORCHE index RCORCHE
    (202) map_var -> ID . LCORCHE key RCORCHE
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for RPAREN resolved using rule 129 (cap -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 129 (cap -> ID .)
    RPAREN          reduce using rule 129 (cap -> ID .)
    COMA            reduce using rule 129 (cap -> ID .)
    GREATER         reduce using rule 228 (something_ex -> ID .)
    SMALLER         reduce using rule 228 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 228 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 228 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 228 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 228 (something_ex -> ID .)
    PLUS            reduce using rule 228 (something_ex -> ID .)
    TIMES           reduce using rule 228 (something_ex -> ID .)
    DIVIDE          reduce using rule 228 (something_ex -> ID .)
    MINUS           reduce using rule 228 (something_ex -> ID .)
    LCORCHE         shift and go to state 167
    LPAREN          shift and go to state 106

  ! RPAREN          [ reduce using rule 228 (something_ex -> ID .) ]
  ! COMA            [ reduce using rule 228 (something_ex -> ID .) ]


state 403

    (130) cap -> expression .

    RPAREN          reduce using rule 130 (cap -> expression .)
    COMA            reduce using rule 130 (cap -> expression .)


state 404

    (207) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN . retorno RLLAVE
    (211) retorno -> . ID
    (212) retorno -> . values
    (213) retorno -> . operations
    (214) retorno -> . data_structure
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    ID              shift and go to state 405
    STRING          shift and go to state 140
    INTEGER         shift and go to state 141
    FLOAT           shift and go to state 142
    TRUE            shift and go to state 143
    FALSE           shift and go to state 144
    NOT             shift and go to state 54
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    retorno                        shift and go to state 415
    values                         shift and go to state 408
    operations                     shift and go to state 409
    data_structure                 shift and go to state 410
    expression                     shift and go to state 145
    comparison                     shift and go to state 146
    logic_operation                shift and go to state 147
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    funciones                      shift and go to state 95
    call_func                      shift and go to state 43

state 405

    (211) retorno -> ID .
    (196) array_var -> ID . LCORCHE index RCORCHE
    (202) map_var -> ID . LCORCHE key RCORCHE
    (228) something_ex -> ID .
    (167) value -> ID .
    (181) logic_value -> ID .
    (81) call_func -> ID . LPAREN list_params RPAREN
    (82) call_func -> ID . LPAREN RPAREN

  ! reduce/reduce conflict for COLON resolved using rule 211 (retorno -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 211 (retorno -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 167 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 167 (value -> ID .)
    COLON           reduce using rule 211 (retorno -> ID .)
    RLLAVE          reduce using rule 211 (retorno -> ID .)
    LCORCHE         shift and go to state 167
    GREATER         reduce using rule 167 (value -> ID .)
    SMALLER         reduce using rule 167 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 167 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 167 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 167 (value -> ID .)
    NOT_EQUAL       reduce using rule 167 (value -> ID .)
    PLUS            reduce using rule 167 (value -> ID .)
    TIMES           reduce using rule 167 (value -> ID .)
    DIVIDE          reduce using rule 167 (value -> ID .)
    MINUS           reduce using rule 167 (value -> ID .)
    AND             reduce using rule 181 (logic_value -> ID .)
    OR              reduce using rule 181 (logic_value -> ID .)
    LPAREN          shift and go to state 106

  ! GREATER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 228 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 228 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 228 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 228 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 228 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 228 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 228 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 228 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 228 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 228 (something_ex -> ID .) ]


state 406

    (208) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value . RLLAVE

    RLLAVE          shift and go to state 416


state 407

    (209) return_value -> retorno . COLON
    (210) return_value -> retorno .

    COLON           shift and go to state 417
    RLLAVE          reduce using rule 210 (return_value -> retorno .)


state 408

    (212) retorno -> values .

    COLON           reduce using rule 212 (retorno -> values .)
    RLLAVE          reduce using rule 212 (retorno -> values .)


state 409

    (213) retorno -> operations .

    COLON           reduce using rule 213 (retorno -> operations .)
    RLLAVE          reduce using rule 213 (retorno -> operations .)


state 410

    (214) retorno -> data_structure .
    (231) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 214 (retorno -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 214 (retorno -> data_structure .)
    COLON           reduce using rule 214 (retorno -> data_structure .)
    RLLAVE          reduce using rule 214 (retorno -> data_structure .)
    GREATER         reduce using rule 231 (something_ex -> data_structure .)
    SMALLER         reduce using rule 231 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 231 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 231 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 231 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 231 (something_ex -> data_structure .)
    PLUS            reduce using rule 231 (something_ex -> data_structure .)
    TIMES           reduce using rule 231 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 231 (something_ex -> data_structure .)
    MINUS           reduce using rule 231 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 231 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 231 (something_ex -> data_structure .) ]


state 411

    (71) more_items -> items COMA . more_items
    (71) more_items -> . items COMA more_items
    (72) more_items -> . items
    (73) items -> . values
    (74) items -> . operations
    (43) values -> . STRING
    (44) values -> . INTEGER
    (45) values -> . FLOAT
    (46) values -> . TRUE
    (47) values -> . FALSE
    (57) operations -> . expression
    (58) operations -> . comparison
    (59) operations -> . logic_operation
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (166) comparison -> . value op value
    (175) logic_operation -> . logic_value logic_recu
    (176) logic_operation -> . negation
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (167) value -> . ID
    (168) value -> . expression
    (179) logic_value -> . negation
    (180) logic_value -> . comparison
    (181) logic_value -> . ID
    (182) negation -> . NOT comparison
    (183) negation -> . NOT ID
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    STRING          shift and go to state 140
    INTEGER         shift and go to state 141
    FLOAT           shift and go to state 142
    TRUE            shift and go to state 143
    FALSE           shift and go to state 144
    ID              shift and go to state 378
    NOT             shift and go to state 54
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    items                          shift and go to state 398
    more_items                     shift and go to state 418
    values                         shift and go to state 376
    operations                     shift and go to state 377
    expression                     shift and go to state 145
    comparison                     shift and go to state 146
    logic_operation                shift and go to state 147
    something_ex                   shift and go to state 31
    value                          shift and go to state 33
    logic_value                    shift and go to state 34
    negation                       shift and go to state 35
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 412

    (69) arr_content -> LLLAVE items COMA more_items RLLAVE .

    COLON           reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    PRINT           reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    SCAN            reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FOR             reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    ID              reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    APPEND          reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    LEN             reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    COPY            reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    DELETE          reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    IF              reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    ELSE            reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    TYPE            reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    SWITCH          reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    VAR             reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FUNC            reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    INTEGER         reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FLOAT           reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    NOT             reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    $end            reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RLLAVE          reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    INT32           reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    INT64           reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FLOAT32         reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    FLOAT64         reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    BYTE            reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    WINT            reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    WFLOAT          reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    WSTRING         reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    BOOL            reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    DEFAULT         reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    CASE            reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RETURN          reduce using rule 69 (arr_content -> LLLAVE items COMA more_items RLLAVE .)


state 413

    (127) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA . cap RPAREN
    (128) cap -> . INTEGER
    (129) cap -> . ID
    (130) cap -> . expression
    (224) expression -> . something_ex
    (225) expression -> . something_ex adicionaEx
    (228) something_ex -> . ID
    (229) something_ex -> . INTEGER
    (230) something_ex -> . FLOAT
    (231) something_ex -> . data_structure
    (232) something_ex -> . funciones
    (60) data_structure -> . array_var
    (61) data_structure -> . map_var
    (140) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (141) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (142) funciones -> . LEN LPAREN ID RPAREN
    (143) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (144) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (145) funciones -> . call_func
    (196) array_var -> . ID LCORCHE index RCORCHE
    (202) map_var -> . ID LCORCHE key RCORCHE
    (81) call_func -> . ID LPAREN list_params RPAREN
    (82) call_func -> . ID LPAREN RPAREN

    INTEGER         shift and go to state 401
    ID              shift and go to state 402
    FLOAT           shift and go to state 52
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    cap                            shift and go to state 419
    expression                     shift and go to state 403
    something_ex                   shift and go to state 31
    data_structure                 shift and go to state 53
    funciones                      shift and go to state 95
    array_var                      shift and go to state 96
    map_var                        shift and go to state 97
    call_func                      shift and go to state 43

state 414

    (126) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .

    COLON           reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    PRINT           reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    SCAN            reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FOR             reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    ID              reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    APPEND          reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    LEN             reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    COPY            reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    DELETE          reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    IF              reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    ELSE            reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    TYPE            reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    SWITCH          reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    VAR             reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FUNC            reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    INTEGER         reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FLOAT           reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    NOT             reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    $end            reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RLLAVE          reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    INT32           reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    INT64           reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FLOAT32         reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    FLOAT64         reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    BYTE            reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    WINT            reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    WFLOAT          reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    WSTRING         reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    BOOL            reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    DEFAULT         reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    CASE            reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RETURN          reduce using rule 126 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)


state 415

    (207) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno . RLLAVE

    RLLAVE          shift and go to state 420


state 416

    (208) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .

    PRINT           reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    SCAN            reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    FOR             reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    ID              reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    APPEND          reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    LEN             reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    COPY            reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    DELETE          reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    IF              reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    ELSE            reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    TYPE            reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    SWITCH          reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    VAR             reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    FUNC            reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    INTEGER         reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    FLOAT           reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    NOT             reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    $end            reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    RLLAVE          reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    INT32           reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    INT64           reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    FLOAT32         reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    FLOAT64         reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    BYTE            reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    WINT            reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    WFLOAT          reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    WSTRING         reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    BOOL            reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    DEFAULT         reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    CASE            reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    RETURN          reduce using rule 208 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)


state 417

    (209) return_value -> retorno COLON .

    RLLAVE          reduce using rule 209 (return_value -> retorno COLON .)


state 418

    (71) more_items -> items COMA more_items .

    RLLAVE          reduce using rule 71 (more_items -> items COMA more_items .)


state 419

    (127) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap . RPAREN

    RPAREN          shift and go to state 421


state 420

    (207) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .

    PRINT           reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    SCAN            reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FOR             reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    ID              reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    APPEND          reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    LEN             reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    COPY            reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    DELETE          reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    IF              reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    ELSE            reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    TYPE            reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    SWITCH          reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    VAR             reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FUNC            reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    INTEGER         reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FLOAT           reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    NOT             reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    $end            reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    RLLAVE          reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    INT32           reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    INT64           reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FLOAT32         reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    FLOAT64         reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    BYTE            reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    WINT            reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    WFLOAT          reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    WSTRING         reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    BOOL            reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    DEFAULT         reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    CASE            reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    RETURN          reduce using rule 207 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)


state 421

    (127) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .

    COLON           reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    PRINT           reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    SCAN            reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FOR             reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    ID              reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    APPEND          reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    LEN             reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    COPY            reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    DELETE          reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    IF              reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    ELSE            reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    TYPE            reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    SWITCH          reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    VAR             reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FUNC            reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    INTEGER         reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FLOAT           reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    NOT             reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    $end            reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RLLAVE          reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    INT32           reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    INT64           reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FLOAT32         reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    FLOAT64         reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    BYTE            reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    WINT            reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    WFLOAT          reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    WSTRING         reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    BOOL            reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    DEFAULT         reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    CASE            reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RETURN          reduce using rule 127 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ID in state 2 resolved as shift
WARNING: shift/reduce conflict for COLON in state 12 resolved as shift
WARNING: shift/reduce conflict for COLON in state 20 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 31 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 31 resolved as shift
WARNING: shift/reduce conflict for GREATER_OR_EQUAL in state 31 resolved as shift
WARNING: shift/reduce conflict for SMALLER_OR_EQUAL in state 31 resolved as shift
WARNING: shift/reduce conflict for EQUAL_COMPARE in state 31 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 31 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 31 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 31 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 31 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 31 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 160 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 160 resolved as shift
WARNING: shift/reduce conflict for GREATER_OR_EQUAL in state 160 resolved as shift
WARNING: shift/reduce conflict for SMALLER_OR_EQUAL in state 160 resolved as shift
WARNING: shift/reduce conflict for EQUAL_COMPARE in state 160 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 160 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 160 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 160 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 160 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 160 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 216 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 217 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 218 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 219 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 220 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 221 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 222 resolved as shift
WARNING: shift/reduce conflict for EQUAL in state 223 resolved as shift
WARNING: reduce/reduce conflict in state 12 resolved using rule (rule -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 12
WARNING: reduce/reduce conflict in state 20 resolved using rule (rule -> array_var)
WARNING: rejected rule (data_structure -> array_var) in state 20
WARNING: reduce/reduce conflict in state 38 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 38
WARNING: reduce/reduce conflict in state 93 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 93
WARNING: reduce/reduce conflict in state 114 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 114
WARNING: reduce/reduce conflict in state 124 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 124
WARNING: reduce/reduce conflict in state 136 resolved using rule (something -> ID)
WARNING: rejected rule (something_ex -> ID) in state 136
WARNING: reduce/reduce conflict in state 136 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 136
WARNING: reduce/reduce conflict in state 137 resolved using rule (something -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 137
WARNING: reduce/reduce conflict in state 141 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 141
WARNING: reduce/reduce conflict in state 142 resolved using rule (values -> FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 142
WARNING: reduce/reduce conflict in state 149 resolved using rule (something_s -> ID)
WARNING: rejected rule (something_ex -> ID) in state 149
WARNING: reduce/reduce conflict in state 149 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 149
WARNING: reduce/reduce conflict in state 150 resolved using rule (data_structure -> array_var)
WARNING: rejected rule (something_s -> array_var) in state 150
WARNING: reduce/reduce conflict in state 156 resolved using rule (content -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 156
WARNING: reduce/reduce conflict in state 157 resolved using rule (content -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 157
WARNING: reduce/reduce conflict in state 158 resolved using rule (content -> ID)
WARNING: rejected rule (something_ex -> ID) in state 158
WARNING: reduce/reduce conflict in state 158 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 158
WARNING: reduce/reduce conflict in state 172 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 172
WARNING: reduce/reduce conflict in state 173 resolved using rule (any -> ID)
WARNING: rejected rule (something_ex -> ID) in state 173
WARNING: reduce/reduce conflict in state 173 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 173
WARNING: reduce/reduce conflict in state 177 resolved using rule (any -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 177
WARNING: reduce/reduce conflict in state 178 resolved using rule (any -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 178
WARNING: reduce/reduce conflict in state 179 resolved using rule (any -> call_func)
WARNING: rejected rule (funciones -> call_func) in state 179
WARNING: reduce/reduce conflict in state 187 resolved using rule (index_s -> ID)
WARNING: rejected rule (index -> ID) in state 187
WARNING: reduce/reduce conflict in state 187 resolved using rule (index_s -> ID)
WARNING: rejected rule (key -> ID) in state 187
WARNING: reduce/reduce conflict in state 187 resolved using rule (index_s -> ID)
WARNING: rejected rule (something_ex -> ID) in state 187
WARNING: reduce/reduce conflict in state 187 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 187
WARNING: reduce/reduce conflict in state 191 resolved using rule (index_s -> INTEGER)
WARNING: rejected rule (index -> INTEGER) in state 191
WARNING: reduce/reduce conflict in state 191 resolved using rule (values -> INTEGER)
WARNING: rejected rule (index_s -> INTEGER) in state 191
WARNING: reduce/reduce conflict in state 191 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 191
WARNING: reduce/reduce conflict in state 192 resolved using rule (index_s -> expression)
WARNING: rejected rule (index -> expression) in state 192
WARNING: reduce/reduce conflict in state 192 resolved using rule (operations -> expression)
WARNING: rejected rule (index_s -> expression) in state 192
WARNING: reduce/reduce conflict in state 236 resolved using rule (index -> ID)
WARNING: rejected rule (key -> ID) in state 236
WARNING: reduce/reduce conflict in state 236 resolved using rule (index -> ID)
WARNING: rejected rule (something_ex -> ID) in state 236
WARNING: reduce/reduce conflict in state 236 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 236
WARNING: reduce/reduce conflict in state 237 resolved using rule (values -> INTEGER)
WARNING: rejected rule (index -> INTEGER) in state 237
WARNING: reduce/reduce conflict in state 237 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 237
WARNING: reduce/reduce conflict in state 238 resolved using rule (operations -> expression)
WARNING: rejected rule (index -> expression) in state 238
WARNING: reduce/reduce conflict in state 262 resolved using rule (capacity -> ID)
WARNING: rejected rule (something_ex -> ID) in state 262
WARNING: reduce/reduce conflict in state 266 resolved using rule (capacity -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 266
WARNING: reduce/reduce conflict in state 322 resolved using rule (int_value -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 322
WARNING: reduce/reduce conflict in state 336 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 336
WARNING: reduce/reduce conflict in state 378 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 378
WARNING: reduce/reduce conflict in state 401 resolved using rule (cap -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 401
WARNING: reduce/reduce conflict in state 402 resolved using rule (cap -> ID)
WARNING: rejected rule (something_ex -> ID) in state 402
WARNING: reduce/reduce conflict in state 405 resolved using rule (retorno -> ID)
WARNING: rejected rule (something_ex -> ID) in state 405
WARNING: reduce/reduce conflict in state 405 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 405
WARNING: reduce/reduce conflict in state 410 resolved using rule (retorno -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 410
WARNING: Rule (something_s -> array_var) is never reduced
WARNING: Rule (key -> ID) is never reduced
WARNING: Rule (index -> INTEGER) is never reduced
WARNING: Rule (index_s -> INTEGER) is never reduced
WARNING: Rule (index -> expression) is never reduced
WARNING: Rule (index_s -> expression) is never reduced
