Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    CAP
    CASE
    COMMENT
    CONST
    ELSE
    FALSE
    FUNC
    INTERFACE
    JOIN
    MAIN
    MAP
    MOD
    MULTI_COMMENT
    PACKAGE
    POINTER
    SCAN
    SWITCH
    TRUE

Grammar

Rule 0     S' -> codigo
Rule 1     codigo -> impresion COLON
Rule 2     codigo -> impresion
Rule 3     codigo -> expression COLON
Rule 4     codigo -> expression
Rule 5     codigo -> cicloFor
Rule 6     codigo -> comparison
Rule 7     codigo -> logic_operation
Rule 8     codigo -> decVar COLON
Rule 9     codigo -> decVar
Rule 10    codigo -> funciones
Rule 11    codigo -> agrupaciones
Rule 12    codigo -> SenIF
Rule 13    codigo -> SenStruct
Rule 14    cicloFor -> FOR LLLAVE codigo RLLAVE
Rule 15    cicloFor -> FOR comparison LLLAVE codigo RLLAVE
Rule 16    cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE
Rule 17    cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
Rule 18    incre -> ID INCREASE
Rule 19    incre -> ID DECREASE
Rule 20    decVar -> decVarOne
Rule 21    decVar -> VAR ID EQUAL INTEGER
Rule 22    decVar -> VAR ID EQUAL ID
Rule 23    decVar -> VAR ID EQUAL FLOAT
Rule 24    decVar -> VAR ID EQUAL expression
Rule 25    decVar -> VAR ID EQUAL logic_operation
Rule 26    decVar -> VAR ID EQUAL comparison
Rule 27    decVar -> sliceC
Rule 28    decVar -> VAR ID EQUAL STRING
Rule 29    decVar -> ID DEQUAL STRING
Rule 30    decVar -> ID DEQUAL FLOAT
Rule 31    decVar -> ID DEQUAL expression
Rule 32    decVar -> ID DEQUAL logic_operation
Rule 33    decVar -> ID DEQUAL comparison
Rule 34    sliceC -> VAR ID LCORCHE RCORCHE type
Rule 35    sliceC -> ID DEQUAL funM
Rule 36    sliceC -> ID DEQUAL LCORCHE RCORCHE type agrupaciones
Rule 37    funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER RPAREN
Rule 38    funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER COMA INTEGER RPAREN
Rule 39    type -> INT32
Rule 40    type -> INT64
Rule 41    type -> FLOAT32
Rule 42    type -> FLOAT64
Rule 43    type -> BYTE
Rule 44    type -> WINT
Rule 45    type -> WFLOAT
Rule 46    type -> WSTRING
Rule 47    agrupaciones -> LLLAVE INTEGER RLLAVE
Rule 48    agrupaciones -> LLLAVE INTEGER enteros RLLAVE
Rule 49    agrupaciones -> LLLAVE FLOAT RLLAVE
Rule 50    agrupaciones -> LLLAVE FLOAT flotantes RLLAVE
Rule 51    agrupaciones -> LLLAVE STRING RLLAVE
Rule 52    agrupaciones -> LLLAVE STRING palabras RLLAVE
Rule 53    enteros -> COMA INTEGER
Rule 54    enteros -> COMA INTEGER enteros
Rule 55    flotantes -> COMA FLOAT
Rule 56    flotantes -> COMA FLOAT flotantes
Rule 57    palabras -> COMA STRING
Rule 58    palabras -> COMA STRING palabras
Rule 59    funciones -> APPEND LPAREN ID COMA INTEGER RPAREN
Rule 60    funciones -> APPEND LPAREN ID COMA FLOAT RPAREN
Rule 61    funciones -> APPEND LPAREN ID COMA STRING RPAREN
Rule 62    funciones -> APPEND LPAREN ID COMA ID RPAREN
Rule 63    funciones -> LEN LPAREN ID RPAREN
Rule 64    funciones -> COPY LPAREN ID COMA ID RPAREN
Rule 65    decVarOne -> ID DEQUAL ID
Rule 66    decVarOne -> ID DEQUAL INTEGER
Rule 67    SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
Rule 68    SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE
Rule 69    declaration -> tipo variable
Rule 70    tipo -> INT32
Rule 71    tipo -> INT64
Rule 72    tipo -> FLOAT32
Rule 73    tipo -> FLOAT64
Rule 74    tipo -> WSTRING
Rule 75    tipo -> BOOL
Rule 76    variable -> ID
Rule 77    comparison -> value op value
Rule 78    value -> ID
Rule 79    value -> expression
Rule 80    op -> GREATER
Rule 81    op -> SMALLER
Rule 82    op -> GREATER_OR_EQUAL
Rule 83    op -> SMALLER_OR_EQUAL
Rule 84    op -> EQUAL_COMPARE
Rule 85    op -> NOT_EQUAL
Rule 86    logic_operation -> logic_value logic_op logic_value
Rule 87    logic_operation -> negation
Rule 88    logic_value -> negation
Rule 89    logic_value -> comparison
Rule 90    logic_value -> ID
Rule 91    negation -> NOT comparison
Rule 92    negation -> NOT ID
Rule 93    logic_op -> AND
Rule 94    logic_op -> OR
Rule 95    impresion -> PRINT LPAREN expression RPAREN
Rule 96    expression -> expression PLUS term
Rule 97    expression -> expression MINUS term
Rule 98    expression -> term
Rule 99    term -> term TIMES factor
Rule 100   term -> term DIVIDE factor
Rule 101   term -> factor
Rule 102   factor -> INTEGER
Rule 103   factor -> ID
Rule 104   factor -> LPAREN expression RPAREN

Terminals, with rules where they appear

AND                  : 93
APPEND               : 59 60 61 62
ARRAY                : 
BOOL                 : 75
BYTE                 : 43
CAP                  : 
CASE                 : 
COLON                : 1 3 8 17 17
COMA                 : 37 38 38 53 54 55 56 57 58 59 60 61 62 64
COMMENT              : 
CONST                : 
COPY                 : 64
DECREASE             : 19
DEQUAL               : 29 30 31 32 33 35 36 65 66
DIVIDE               : 100
ELSE                 : 
EQUAL                : 21 22 23 24 25 26 28
EQUAL_COMPARE        : 84
FALSE                : 
FLOAT                : 23 30 49 50 55 56 60
FLOAT32              : 41 72
FLOAT64              : 42 73
FOR                  : 14 15 16 17
FUNC                 : 
GREATER              : 80
GREATER_OR_EQUAL     : 82
ID                   : 18 19 21 22 22 23 24 25 26 28 29 30 31 32 33 34 35 36 59 60 61 62 62 63 64 64 65 65 66 68 76 78 90 92 103
IF                   : 67
INCREASE             : 18
INT32                : 39 70
INT64                : 40 71
INTEGER              : 21 37 38 38 47 48 53 54 59 66 102
INTERFACE            : 
JOIN                 : 
LCORCHE              : 34 36 37 38
LEN                  : 63
LLLAVE               : 14 15 16 17 47 48 49 50 51 52 67 68
LPAREN               : 37 38 59 60 61 62 63 64 67 95 104
MAIN                 : 
MAKE                 : 37 38
MAP                  : 
MINUS                : 97
MOD                  : 
MULTI_COMMENT        : 
NOT                  : 91 92
NOT_EQUAL            : 85
OR                   : 94
PACKAGE              : 
PLUS                 : 96
POINTER              : 
PRINT                : 95
RCORCHE              : 34 36 37 38
RLLAVE               : 14 15 16 17 47 48 49 50 51 52 67 68
RPAREN               : 37 38 59 60 61 62 63 64 67 95 104
SCAN                 : 
SMALLER              : 81
SMALLER_OR_EQUAL     : 83
STRING               : 28 29 51 52 57 58 61
STRUCT               : 68
SWITCH               : 
TIMES                : 99
TRUE                 : 
TYPE                 : 68
VAR                  : 21 22 23 24 25 26 28 34
WFLOAT               : 45
WINT                 : 44
WSTRING              : 46 74
error                : 

Nonterminals, with rules where they appear

SenIF                : 12
SenStruct            : 13
agrupaciones         : 11 36
cicloFor             : 5
codigo               : 14 15 16 17 67 0
comparison           : 6 15 17 26 33 67 89 91
decVar               : 8 9
decVarOne            : 17 20
declaration          : 68
enteros              : 48 54
expression           : 3 4 24 31 79 95 96 97 104
factor               : 99 100 101
flotantes            : 50 56
funM                 : 35
funciones            : 10
impresion            : 1 2
incre                : 17
logic_op             : 86
logic_operation      : 7 16 25 32
logic_value          : 86 86
negation             : 87 88
op                   : 77
palabras             : 52 58
sliceC               : 27
term                 : 96 97 98 99 100
tipo                 : 69
type                 : 34 36 37 38
value                : 77 77
variable             : 69

Parsing method: LALR

state 0

    (0) S' -> . codigo
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . agrupaciones
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (95) impresion -> . PRINT LPAREN expression RPAREN
    (96) expression -> . expression PLUS term
    (97) expression -> . expression MINUS term
    (98) expression -> . term
    (14) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (15) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (16) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (17) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (77) comparison -> . value op value
    (86) logic_operation -> . logic_value logic_op logic_value
    (87) logic_operation -> . negation
    (20) decVar -> . decVarOne
    (21) decVar -> . VAR ID EQUAL INTEGER
    (22) decVar -> . VAR ID EQUAL ID
    (23) decVar -> . VAR ID EQUAL FLOAT
    (24) decVar -> . VAR ID EQUAL expression
    (25) decVar -> . VAR ID EQUAL logic_operation
    (26) decVar -> . VAR ID EQUAL comparison
    (27) decVar -> . sliceC
    (28) decVar -> . VAR ID EQUAL STRING
    (29) decVar -> . ID DEQUAL STRING
    (30) decVar -> . ID DEQUAL FLOAT
    (31) decVar -> . ID DEQUAL expression
    (32) decVar -> . ID DEQUAL logic_operation
    (33) decVar -> . ID DEQUAL comparison
    (59) funciones -> . APPEND LPAREN ID COMA INTEGER RPAREN
    (60) funciones -> . APPEND LPAREN ID COMA FLOAT RPAREN
    (61) funciones -> . APPEND LPAREN ID COMA STRING RPAREN
    (62) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (63) funciones -> . LEN LPAREN ID RPAREN
    (64) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (47) agrupaciones -> . LLLAVE INTEGER RLLAVE
    (48) agrupaciones -> . LLLAVE INTEGER enteros RLLAVE
    (49) agrupaciones -> . LLLAVE FLOAT RLLAVE
    (50) agrupaciones -> . LLLAVE FLOAT flotantes RLLAVE
    (51) agrupaciones -> . LLLAVE STRING RLLAVE
    (52) agrupaciones -> . LLLAVE STRING palabras RLLAVE
    (67) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (68) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (78) value -> . ID
    (79) value -> . expression
    (88) logic_value -> . negation
    (89) logic_value -> . comparison
    (90) logic_value -> . ID
    (91) negation -> . NOT comparison
    (92) negation -> . NOT ID
    (65) decVarOne -> . ID DEQUAL ID
    (66) decVarOne -> . ID DEQUAL INTEGER
    (34) sliceC -> . VAR ID LCORCHE RCORCHE type
    (35) sliceC -> . ID DEQUAL funM
    (36) sliceC -> . ID DEQUAL LCORCHE RCORCHE type agrupaciones
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 12
    FOR             shift and go to state 15
    VAR             shift and go to state 21
    ID              shift and go to state 22
    APPEND          shift and go to state 25
    LEN             shift and go to state 26
    COPY            shift and go to state 27
    LLLAVE          shift and go to state 16
    IF              shift and go to state 28
    TYPE            shift and go to state 29
    NOT             shift and go to state 31
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    codigo                         shift and go to state 1
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    agrupaciones                   shift and go to state 9
    SenIF                          shift and go to state 10
    SenStruct                      shift and go to state 11
    term                           shift and go to state 14
    decVarOne                      shift and go to state 17
    value                          shift and go to state 18
    logic_value                    shift and go to state 19
    negation                       shift and go to state 20
    sliceC                         shift and go to state 24
    factor                         shift and go to state 30

state 1

    (0) S' -> codigo .



state 2

    (1) codigo -> impresion . COLON
    (2) codigo -> impresion .

    COLON           shift and go to state 32
    $end            reduce using rule 2 (codigo -> impresion .)
    RLLAVE          reduce using rule 2 (codigo -> impresion .)


state 3

    (3) codigo -> expression . COLON
    (4) codigo -> expression .
    (96) expression -> expression . PLUS term
    (97) expression -> expression . MINUS term
    (79) value -> expression .

    COLON           shift and go to state 33
    $end            reduce using rule 4 (codigo -> expression .)
    RLLAVE          reduce using rule 4 (codigo -> expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    GREATER         reduce using rule 79 (value -> expression .)
    SMALLER         reduce using rule 79 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 79 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 79 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 79 (value -> expression .)
    NOT_EQUAL       reduce using rule 79 (value -> expression .)


state 4

    (5) codigo -> cicloFor .

    $end            reduce using rule 5 (codigo -> cicloFor .)
    RLLAVE          reduce using rule 5 (codigo -> cicloFor .)


state 5

    (6) codigo -> comparison .
    (89) logic_value -> comparison .

    $end            reduce using rule 6 (codigo -> comparison .)
    RLLAVE          reduce using rule 6 (codigo -> comparison .)
    AND             reduce using rule 89 (logic_value -> comparison .)
    OR              reduce using rule 89 (logic_value -> comparison .)


state 6

    (7) codigo -> logic_operation .

    $end            reduce using rule 7 (codigo -> logic_operation .)
    RLLAVE          reduce using rule 7 (codigo -> logic_operation .)


state 7

    (8) codigo -> decVar . COLON
    (9) codigo -> decVar .

    COLON           shift and go to state 36
    $end            reduce using rule 9 (codigo -> decVar .)
    RLLAVE          reduce using rule 9 (codigo -> decVar .)


state 8

    (10) codigo -> funciones .

    $end            reduce using rule 10 (codigo -> funciones .)
    RLLAVE          reduce using rule 10 (codigo -> funciones .)


state 9

    (11) codigo -> agrupaciones .

    $end            reduce using rule 11 (codigo -> agrupaciones .)
    RLLAVE          reduce using rule 11 (codigo -> agrupaciones .)


state 10

    (12) codigo -> SenIF .

    $end            reduce using rule 12 (codigo -> SenIF .)
    RLLAVE          reduce using rule 12 (codigo -> SenIF .)


state 11

    (13) codigo -> SenStruct .

    $end            reduce using rule 13 (codigo -> SenStruct .)
    RLLAVE          reduce using rule 13 (codigo -> SenStruct .)


state 12

    (95) impresion -> PRINT . LPAREN expression RPAREN

    LPAREN          shift and go to state 37


state 13

    (104) factor -> LPAREN . expression RPAREN
    (96) expression -> . expression PLUS term
    (97) expression -> . expression MINUS term
    (98) expression -> . term
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 23
    ID              shift and go to state 39
    LPAREN          shift and go to state 13

    expression                     shift and go to state 38
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 14

    (98) expression -> term .
    (99) term -> term . TIMES factor
    (100) term -> term . DIVIDE factor

    COLON           reduce using rule 98 (expression -> term .)
    PLUS            reduce using rule 98 (expression -> term .)
    MINUS           reduce using rule 98 (expression -> term .)
    $end            reduce using rule 98 (expression -> term .)
    GREATER         reduce using rule 98 (expression -> term .)
    SMALLER         reduce using rule 98 (expression -> term .)
    GREATER_OR_EQUAL reduce using rule 98 (expression -> term .)
    SMALLER_OR_EQUAL reduce using rule 98 (expression -> term .)
    EQUAL_COMPARE   reduce using rule 98 (expression -> term .)
    NOT_EQUAL       reduce using rule 98 (expression -> term .)
    RPAREN          reduce using rule 98 (expression -> term .)
    RLLAVE          reduce using rule 98 (expression -> term .)
    AND             reduce using rule 98 (expression -> term .)
    OR              reduce using rule 98 (expression -> term .)
    LLLAVE          reduce using rule 98 (expression -> term .)
    TIMES           shift and go to state 40
    DIVIDE          shift and go to state 41


state 15

    (14) cicloFor -> FOR . LLLAVE codigo RLLAVE
    (15) cicloFor -> FOR . comparison LLLAVE codigo RLLAVE
    (16) cicloFor -> FOR . logic_operation LLLAVE codigo RLLAVE
    (17) cicloFor -> FOR . decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (77) comparison -> . value op value
    (86) logic_operation -> . logic_value logic_op logic_value
    (87) logic_operation -> . negation
    (65) decVarOne -> . ID DEQUAL ID
    (66) decVarOne -> . ID DEQUAL INTEGER
    (78) value -> . ID
    (79) value -> . expression
    (88) logic_value -> . negation
    (89) logic_value -> . comparison
    (90) logic_value -> . ID
    (91) negation -> . NOT comparison
    (92) negation -> . NOT ID
    (96) expression -> . expression PLUS term
    (97) expression -> . expression MINUS term
    (98) expression -> . term
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    LLLAVE          shift and go to state 42
    ID              shift and go to state 46
    NOT             shift and go to state 31
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    comparison                     shift and go to state 43
    logic_operation                shift and go to state 44
    decVarOne                      shift and go to state 45
    value                          shift and go to state 18
    logic_value                    shift and go to state 19
    negation                       shift and go to state 20
    expression                     shift and go to state 47
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 16

    (47) agrupaciones -> LLLAVE . INTEGER RLLAVE
    (48) agrupaciones -> LLLAVE . INTEGER enteros RLLAVE
    (49) agrupaciones -> LLLAVE . FLOAT RLLAVE
    (50) agrupaciones -> LLLAVE . FLOAT flotantes RLLAVE
    (51) agrupaciones -> LLLAVE . STRING RLLAVE
    (52) agrupaciones -> LLLAVE . STRING palabras RLLAVE

    INTEGER         shift and go to state 48
    FLOAT           shift and go to state 49
    STRING          shift and go to state 50


state 17

    (20) decVar -> decVarOne .

    COLON           reduce using rule 20 (decVar -> decVarOne .)
    $end            reduce using rule 20 (decVar -> decVarOne .)
    RLLAVE          reduce using rule 20 (decVar -> decVarOne .)


state 18

    (77) comparison -> value . op value
    (80) op -> . GREATER
    (81) op -> . SMALLER
    (82) op -> . GREATER_OR_EQUAL
    (83) op -> . SMALLER_OR_EQUAL
    (84) op -> . EQUAL_COMPARE
    (85) op -> . NOT_EQUAL

    GREATER         shift and go to state 52
    SMALLER         shift and go to state 53
    GREATER_OR_EQUAL shift and go to state 54
    SMALLER_OR_EQUAL shift and go to state 55
    EQUAL_COMPARE   shift and go to state 56
    NOT_EQUAL       shift and go to state 57

    op                             shift and go to state 51

state 19

    (86) logic_operation -> logic_value . logic_op logic_value
    (93) logic_op -> . AND
    (94) logic_op -> . OR

    AND             shift and go to state 59
    OR              shift and go to state 60

    logic_op                       shift and go to state 58

state 20

    (87) logic_operation -> negation .
    (88) logic_value -> negation .

    $end            reduce using rule 87 (logic_operation -> negation .)
    LLLAVE          reduce using rule 87 (logic_operation -> negation .)
    RLLAVE          reduce using rule 87 (logic_operation -> negation .)
    COLON           reduce using rule 87 (logic_operation -> negation .)
    AND             reduce using rule 88 (logic_value -> negation .)
    OR              reduce using rule 88 (logic_value -> negation .)


state 21

    (21) decVar -> VAR . ID EQUAL INTEGER
    (22) decVar -> VAR . ID EQUAL ID
    (23) decVar -> VAR . ID EQUAL FLOAT
    (24) decVar -> VAR . ID EQUAL expression
    (25) decVar -> VAR . ID EQUAL logic_operation
    (26) decVar -> VAR . ID EQUAL comparison
    (28) decVar -> VAR . ID EQUAL STRING
    (34) sliceC -> VAR . ID LCORCHE RCORCHE type

    ID              shift and go to state 61


state 22

    (29) decVar -> ID . DEQUAL STRING
    (30) decVar -> ID . DEQUAL FLOAT
    (31) decVar -> ID . DEQUAL expression
    (32) decVar -> ID . DEQUAL logic_operation
    (33) decVar -> ID . DEQUAL comparison
    (78) value -> ID .
    (90) logic_value -> ID .
    (65) decVarOne -> ID . DEQUAL ID
    (66) decVarOne -> ID . DEQUAL INTEGER
    (35) sliceC -> ID . DEQUAL funM
    (36) sliceC -> ID . DEQUAL LCORCHE RCORCHE type agrupaciones
    (103) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 78 (value -> ID .)
    DEQUAL          shift and go to state 62
    GREATER         reduce using rule 78 (value -> ID .)
    SMALLER         reduce using rule 78 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 78 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 78 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 78 (value -> ID .)
    NOT_EQUAL       reduce using rule 78 (value -> ID .)
    AND             reduce using rule 90 (logic_value -> ID .)
    OR              reduce using rule 90 (logic_value -> ID .)
    TIMES           reduce using rule 103 (factor -> ID .)
    DIVIDE          reduce using rule 103 (factor -> ID .)
    COLON           reduce using rule 103 (factor -> ID .)
    PLUS            reduce using rule 103 (factor -> ID .)
    MINUS           reduce using rule 103 (factor -> ID .)
    $end            reduce using rule 103 (factor -> ID .)
    RLLAVE          reduce using rule 103 (factor -> ID .)

  ! GREATER         [ reduce using rule 103 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 103 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 103 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 103 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 103 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 103 (factor -> ID .) ]


state 23

    (102) factor -> INTEGER .

    TIMES           reduce using rule 102 (factor -> INTEGER .)
    DIVIDE          reduce using rule 102 (factor -> INTEGER .)
    COLON           reduce using rule 102 (factor -> INTEGER .)
    PLUS            reduce using rule 102 (factor -> INTEGER .)
    MINUS           reduce using rule 102 (factor -> INTEGER .)
    $end            reduce using rule 102 (factor -> INTEGER .)
    GREATER         reduce using rule 102 (factor -> INTEGER .)
    SMALLER         reduce using rule 102 (factor -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 102 (factor -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 102 (factor -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 102 (factor -> INTEGER .)
    NOT_EQUAL       reduce using rule 102 (factor -> INTEGER .)
    RPAREN          reduce using rule 102 (factor -> INTEGER .)
    RLLAVE          reduce using rule 102 (factor -> INTEGER .)
    AND             reduce using rule 102 (factor -> INTEGER .)
    OR              reduce using rule 102 (factor -> INTEGER .)
    LLLAVE          reduce using rule 102 (factor -> INTEGER .)


state 24

    (27) decVar -> sliceC .

    COLON           reduce using rule 27 (decVar -> sliceC .)
    $end            reduce using rule 27 (decVar -> sliceC .)
    RLLAVE          reduce using rule 27 (decVar -> sliceC .)


state 25

    (59) funciones -> APPEND . LPAREN ID COMA INTEGER RPAREN
    (60) funciones -> APPEND . LPAREN ID COMA FLOAT RPAREN
    (61) funciones -> APPEND . LPAREN ID COMA STRING RPAREN
    (62) funciones -> APPEND . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 63


state 26

    (63) funciones -> LEN . LPAREN ID RPAREN

    LPAREN          shift and go to state 64


state 27

    (64) funciones -> COPY . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 65


state 28

    (67) SenIF -> IF . LPAREN comparison RPAREN LLLAVE codigo RLLAVE

    LPAREN          shift and go to state 66


state 29

    (68) SenStruct -> TYPE . ID STRUCT LLLAVE declaration RLLAVE

    ID              shift and go to state 67


state 30

    (101) term -> factor .

    TIMES           reduce using rule 101 (term -> factor .)
    DIVIDE          reduce using rule 101 (term -> factor .)
    COLON           reduce using rule 101 (term -> factor .)
    PLUS            reduce using rule 101 (term -> factor .)
    MINUS           reduce using rule 101 (term -> factor .)
    $end            reduce using rule 101 (term -> factor .)
    GREATER         reduce using rule 101 (term -> factor .)
    SMALLER         reduce using rule 101 (term -> factor .)
    GREATER_OR_EQUAL reduce using rule 101 (term -> factor .)
    SMALLER_OR_EQUAL reduce using rule 101 (term -> factor .)
    EQUAL_COMPARE   reduce using rule 101 (term -> factor .)
    NOT_EQUAL       reduce using rule 101 (term -> factor .)
    RPAREN          reduce using rule 101 (term -> factor .)
    RLLAVE          reduce using rule 101 (term -> factor .)
    AND             reduce using rule 101 (term -> factor .)
    OR              reduce using rule 101 (term -> factor .)
    LLLAVE          reduce using rule 101 (term -> factor .)


state 31

    (91) negation -> NOT . comparison
    (92) negation -> NOT . ID
    (77) comparison -> . value op value
    (78) value -> . ID
    (79) value -> . expression
    (96) expression -> . expression PLUS term
    (97) expression -> . expression MINUS term
    (98) expression -> . term
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 69
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    comparison                     shift and go to state 68
    value                          shift and go to state 18
    expression                     shift and go to state 47
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 32

    (1) codigo -> impresion COLON .

    $end            reduce using rule 1 (codigo -> impresion COLON .)
    RLLAVE          reduce using rule 1 (codigo -> impresion COLON .)


state 33

    (3) codigo -> expression COLON .

    $end            reduce using rule 3 (codigo -> expression COLON .)
    RLLAVE          reduce using rule 3 (codigo -> expression COLON .)


state 34

    (96) expression -> expression PLUS . term
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 23
    ID              shift and go to state 39
    LPAREN          shift and go to state 13

    term                           shift and go to state 70
    factor                         shift and go to state 30

state 35

    (97) expression -> expression MINUS . term
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 23
    ID              shift and go to state 39
    LPAREN          shift and go to state 13

    term                           shift and go to state 71
    factor                         shift and go to state 30

state 36

    (8) codigo -> decVar COLON .

    $end            reduce using rule 8 (codigo -> decVar COLON .)
    RLLAVE          reduce using rule 8 (codigo -> decVar COLON .)


state 37

    (95) impresion -> PRINT LPAREN . expression RPAREN
    (96) expression -> . expression PLUS term
    (97) expression -> . expression MINUS term
    (98) expression -> . term
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 23
    ID              shift and go to state 39
    LPAREN          shift and go to state 13

    expression                     shift and go to state 72
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 38

    (104) factor -> LPAREN expression . RPAREN
    (96) expression -> expression . PLUS term
    (97) expression -> expression . MINUS term

    RPAREN          shift and go to state 73
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35


state 39

    (103) factor -> ID .

    TIMES           reduce using rule 103 (factor -> ID .)
    DIVIDE          reduce using rule 103 (factor -> ID .)
    RPAREN          reduce using rule 103 (factor -> ID .)
    PLUS            reduce using rule 103 (factor -> ID .)
    MINUS           reduce using rule 103 (factor -> ID .)
    COLON           reduce using rule 103 (factor -> ID .)
    $end            reduce using rule 103 (factor -> ID .)
    GREATER         reduce using rule 103 (factor -> ID .)
    SMALLER         reduce using rule 103 (factor -> ID .)
    GREATER_OR_EQUAL reduce using rule 103 (factor -> ID .)
    SMALLER_OR_EQUAL reduce using rule 103 (factor -> ID .)
    EQUAL_COMPARE   reduce using rule 103 (factor -> ID .)
    NOT_EQUAL       reduce using rule 103 (factor -> ID .)
    RLLAVE          reduce using rule 103 (factor -> ID .)
    AND             reduce using rule 103 (factor -> ID .)
    OR              reduce using rule 103 (factor -> ID .)
    LLLAVE          reduce using rule 103 (factor -> ID .)


state 40

    (99) term -> term TIMES . factor
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 23
    ID              shift and go to state 39
    LPAREN          shift and go to state 13

    factor                         shift and go to state 74

state 41

    (100) term -> term DIVIDE . factor
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 23
    ID              shift and go to state 39
    LPAREN          shift and go to state 13

    factor                         shift and go to state 75

state 42

    (14) cicloFor -> FOR LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . agrupaciones
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (95) impresion -> . PRINT LPAREN expression RPAREN
    (96) expression -> . expression PLUS term
    (97) expression -> . expression MINUS term
    (98) expression -> . term
    (14) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (15) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (16) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (17) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (77) comparison -> . value op value
    (86) logic_operation -> . logic_value logic_op logic_value
    (87) logic_operation -> . negation
    (20) decVar -> . decVarOne
    (21) decVar -> . VAR ID EQUAL INTEGER
    (22) decVar -> . VAR ID EQUAL ID
    (23) decVar -> . VAR ID EQUAL FLOAT
    (24) decVar -> . VAR ID EQUAL expression
    (25) decVar -> . VAR ID EQUAL logic_operation
    (26) decVar -> . VAR ID EQUAL comparison
    (27) decVar -> . sliceC
    (28) decVar -> . VAR ID EQUAL STRING
    (29) decVar -> . ID DEQUAL STRING
    (30) decVar -> . ID DEQUAL FLOAT
    (31) decVar -> . ID DEQUAL expression
    (32) decVar -> . ID DEQUAL logic_operation
    (33) decVar -> . ID DEQUAL comparison
    (59) funciones -> . APPEND LPAREN ID COMA INTEGER RPAREN
    (60) funciones -> . APPEND LPAREN ID COMA FLOAT RPAREN
    (61) funciones -> . APPEND LPAREN ID COMA STRING RPAREN
    (62) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (63) funciones -> . LEN LPAREN ID RPAREN
    (64) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (47) agrupaciones -> . LLLAVE INTEGER RLLAVE
    (48) agrupaciones -> . LLLAVE INTEGER enteros RLLAVE
    (49) agrupaciones -> . LLLAVE FLOAT RLLAVE
    (50) agrupaciones -> . LLLAVE FLOAT flotantes RLLAVE
    (51) agrupaciones -> . LLLAVE STRING RLLAVE
    (52) agrupaciones -> . LLLAVE STRING palabras RLLAVE
    (67) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (68) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (78) value -> . ID
    (79) value -> . expression
    (88) logic_value -> . negation
    (89) logic_value -> . comparison
    (90) logic_value -> . ID
    (91) negation -> . NOT comparison
    (92) negation -> . NOT ID
    (65) decVarOne -> . ID DEQUAL ID
    (66) decVarOne -> . ID DEQUAL INTEGER
    (34) sliceC -> . VAR ID LCORCHE RCORCHE type
    (35) sliceC -> . ID DEQUAL funM
    (36) sliceC -> . ID DEQUAL LCORCHE RCORCHE type agrupaciones
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 12
    FOR             shift and go to state 15
    VAR             shift and go to state 21
    ID              shift and go to state 22
    APPEND          shift and go to state 25
    LEN             shift and go to state 26
    COPY            shift and go to state 27
    LLLAVE          shift and go to state 16
    IF              shift and go to state 28
    TYPE            shift and go to state 29
    NOT             shift and go to state 31
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    codigo                         shift and go to state 76
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    agrupaciones                   shift and go to state 9
    SenIF                          shift and go to state 10
    SenStruct                      shift and go to state 11
    term                           shift and go to state 14
    decVarOne                      shift and go to state 17
    value                          shift and go to state 18
    logic_value                    shift and go to state 19
    negation                       shift and go to state 20
    sliceC                         shift and go to state 24
    factor                         shift and go to state 30

state 43

    (15) cicloFor -> FOR comparison . LLLAVE codigo RLLAVE
    (89) logic_value -> comparison .

    LLLAVE          shift and go to state 77
    AND             reduce using rule 89 (logic_value -> comparison .)
    OR              reduce using rule 89 (logic_value -> comparison .)


state 44

    (16) cicloFor -> FOR logic_operation . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 78


state 45

    (17) cicloFor -> FOR decVarOne . COLON comparison COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 79


state 46

    (65) decVarOne -> ID . DEQUAL ID
    (66) decVarOne -> ID . DEQUAL INTEGER
    (78) value -> ID .
    (90) logic_value -> ID .
    (103) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 78 (value -> ID .)
    DEQUAL          shift and go to state 80
    GREATER         reduce using rule 78 (value -> ID .)
    SMALLER         reduce using rule 78 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 78 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 78 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 78 (value -> ID .)
    NOT_EQUAL       reduce using rule 78 (value -> ID .)
    AND             reduce using rule 90 (logic_value -> ID .)
    OR              reduce using rule 90 (logic_value -> ID .)
    TIMES           reduce using rule 103 (factor -> ID .)
    DIVIDE          reduce using rule 103 (factor -> ID .)
    PLUS            reduce using rule 103 (factor -> ID .)
    MINUS           reduce using rule 103 (factor -> ID .)

  ! GREATER         [ reduce using rule 103 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 103 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 103 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 103 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 103 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 103 (factor -> ID .) ]


state 47

    (79) value -> expression .
    (96) expression -> expression . PLUS term
    (97) expression -> expression . MINUS term

    GREATER         reduce using rule 79 (value -> expression .)
    SMALLER         reduce using rule 79 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 79 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 79 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 79 (value -> expression .)
    NOT_EQUAL       reduce using rule 79 (value -> expression .)
    $end            reduce using rule 79 (value -> expression .)
    AND             reduce using rule 79 (value -> expression .)
    OR              reduce using rule 79 (value -> expression .)
    LLLAVE          reduce using rule 79 (value -> expression .)
    RLLAVE          reduce using rule 79 (value -> expression .)
    COLON           reduce using rule 79 (value -> expression .)
    RPAREN          reduce using rule 79 (value -> expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35


state 48

    (47) agrupaciones -> LLLAVE INTEGER . RLLAVE
    (48) agrupaciones -> LLLAVE INTEGER . enteros RLLAVE
    (53) enteros -> . COMA INTEGER
    (54) enteros -> . COMA INTEGER enteros

    RLLAVE          shift and go to state 81
    COMA            shift and go to state 83

    enteros                        shift and go to state 82

state 49

    (49) agrupaciones -> LLLAVE FLOAT . RLLAVE
    (50) agrupaciones -> LLLAVE FLOAT . flotantes RLLAVE
    (55) flotantes -> . COMA FLOAT
    (56) flotantes -> . COMA FLOAT flotantes

    RLLAVE          shift and go to state 84
    COMA            shift and go to state 86

    flotantes                      shift and go to state 85

state 50

    (51) agrupaciones -> LLLAVE STRING . RLLAVE
    (52) agrupaciones -> LLLAVE STRING . palabras RLLAVE
    (57) palabras -> . COMA STRING
    (58) palabras -> . COMA STRING palabras

    RLLAVE          shift and go to state 87
    COMA            shift and go to state 89

    palabras                       shift and go to state 88

state 51

    (77) comparison -> value op . value
    (78) value -> . ID
    (79) value -> . expression
    (96) expression -> . expression PLUS term
    (97) expression -> . expression MINUS term
    (98) expression -> . term
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 91
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    value                          shift and go to state 90
    expression                     shift and go to state 47
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 52

    (80) op -> GREATER .

    ID              reduce using rule 80 (op -> GREATER .)
    INTEGER         reduce using rule 80 (op -> GREATER .)
    LPAREN          reduce using rule 80 (op -> GREATER .)


state 53

    (81) op -> SMALLER .

    ID              reduce using rule 81 (op -> SMALLER .)
    INTEGER         reduce using rule 81 (op -> SMALLER .)
    LPAREN          reduce using rule 81 (op -> SMALLER .)


state 54

    (82) op -> GREATER_OR_EQUAL .

    ID              reduce using rule 82 (op -> GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 82 (op -> GREATER_OR_EQUAL .)
    LPAREN          reduce using rule 82 (op -> GREATER_OR_EQUAL .)


state 55

    (83) op -> SMALLER_OR_EQUAL .

    ID              reduce using rule 83 (op -> SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 83 (op -> SMALLER_OR_EQUAL .)
    LPAREN          reduce using rule 83 (op -> SMALLER_OR_EQUAL .)


state 56

    (84) op -> EQUAL_COMPARE .

    ID              reduce using rule 84 (op -> EQUAL_COMPARE .)
    INTEGER         reduce using rule 84 (op -> EQUAL_COMPARE .)
    LPAREN          reduce using rule 84 (op -> EQUAL_COMPARE .)


state 57

    (85) op -> NOT_EQUAL .

    ID              reduce using rule 85 (op -> NOT_EQUAL .)
    INTEGER         reduce using rule 85 (op -> NOT_EQUAL .)
    LPAREN          reduce using rule 85 (op -> NOT_EQUAL .)


state 58

    (86) logic_operation -> logic_value logic_op . logic_value
    (88) logic_value -> . negation
    (89) logic_value -> . comparison
    (90) logic_value -> . ID
    (91) negation -> . NOT comparison
    (92) negation -> . NOT ID
    (77) comparison -> . value op value
    (78) value -> . ID
    (79) value -> . expression
    (96) expression -> . expression PLUS term
    (97) expression -> . expression MINUS term
    (98) expression -> . term
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 95
    NOT             shift and go to state 31
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    logic_value                    shift and go to state 92
    negation                       shift and go to state 93
    comparison                     shift and go to state 94
    value                          shift and go to state 18
    expression                     shift and go to state 47
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 59

    (93) logic_op -> AND .

    ID              reduce using rule 93 (logic_op -> AND .)
    NOT             reduce using rule 93 (logic_op -> AND .)
    INTEGER         reduce using rule 93 (logic_op -> AND .)
    LPAREN          reduce using rule 93 (logic_op -> AND .)


state 60

    (94) logic_op -> OR .

    ID              reduce using rule 94 (logic_op -> OR .)
    NOT             reduce using rule 94 (logic_op -> OR .)
    INTEGER         reduce using rule 94 (logic_op -> OR .)
    LPAREN          reduce using rule 94 (logic_op -> OR .)


state 61

    (21) decVar -> VAR ID . EQUAL INTEGER
    (22) decVar -> VAR ID . EQUAL ID
    (23) decVar -> VAR ID . EQUAL FLOAT
    (24) decVar -> VAR ID . EQUAL expression
    (25) decVar -> VAR ID . EQUAL logic_operation
    (26) decVar -> VAR ID . EQUAL comparison
    (28) decVar -> VAR ID . EQUAL STRING
    (34) sliceC -> VAR ID . LCORCHE RCORCHE type

    EQUAL           shift and go to state 96
    LCORCHE         shift and go to state 97


state 62

    (29) decVar -> ID DEQUAL . STRING
    (30) decVar -> ID DEQUAL . FLOAT
    (31) decVar -> ID DEQUAL . expression
    (32) decVar -> ID DEQUAL . logic_operation
    (33) decVar -> ID DEQUAL . comparison
    (65) decVarOne -> ID DEQUAL . ID
    (66) decVarOne -> ID DEQUAL . INTEGER
    (35) sliceC -> ID DEQUAL . funM
    (36) sliceC -> ID DEQUAL . LCORCHE RCORCHE type agrupaciones
    (96) expression -> . expression PLUS term
    (97) expression -> . expression MINUS term
    (98) expression -> . term
    (86) logic_operation -> . logic_value logic_op logic_value
    (87) logic_operation -> . negation
    (77) comparison -> . value op value
    (37) funM -> . MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER RPAREN
    (38) funM -> . MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER COMA INTEGER RPAREN
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (88) logic_value -> . negation
    (89) logic_value -> . comparison
    (90) logic_value -> . ID
    (91) negation -> . NOT comparison
    (92) negation -> . NOT ID
    (78) value -> . ID
    (79) value -> . expression
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    STRING          shift and go to state 99
    FLOAT           shift and go to state 100
    ID              shift and go to state 98
    INTEGER         shift and go to state 104
    LCORCHE         shift and go to state 106
    MAKE            shift and go to state 107
    NOT             shift and go to state 31
    LPAREN          shift and go to state 13

    expression                     shift and go to state 101
    logic_operation                shift and go to state 102
    comparison                     shift and go to state 103
    funM                           shift and go to state 105
    term                           shift and go to state 14
    logic_value                    shift and go to state 19
    negation                       shift and go to state 20
    value                          shift and go to state 18
    factor                         shift and go to state 30

state 63

    (59) funciones -> APPEND LPAREN . ID COMA INTEGER RPAREN
    (60) funciones -> APPEND LPAREN . ID COMA FLOAT RPAREN
    (61) funciones -> APPEND LPAREN . ID COMA STRING RPAREN
    (62) funciones -> APPEND LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 108


state 64

    (63) funciones -> LEN LPAREN . ID RPAREN

    ID              shift and go to state 109


state 65

    (64) funciones -> COPY LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 110


state 66

    (67) SenIF -> IF LPAREN . comparison RPAREN LLLAVE codigo RLLAVE
    (77) comparison -> . value op value
    (78) value -> . ID
    (79) value -> . expression
    (96) expression -> . expression PLUS term
    (97) expression -> . expression MINUS term
    (98) expression -> . term
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 91
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    comparison                     shift and go to state 111
    value                          shift and go to state 18
    expression                     shift and go to state 47
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 67

    (68) SenStruct -> TYPE ID . STRUCT LLLAVE declaration RLLAVE

    STRUCT          shift and go to state 112


state 68

    (91) negation -> NOT comparison .

    $end            reduce using rule 91 (negation -> NOT comparison .)
    AND             reduce using rule 91 (negation -> NOT comparison .)
    OR              reduce using rule 91 (negation -> NOT comparison .)
    LLLAVE          reduce using rule 91 (negation -> NOT comparison .)
    RLLAVE          reduce using rule 91 (negation -> NOT comparison .)
    COLON           reduce using rule 91 (negation -> NOT comparison .)


state 69

    (92) negation -> NOT ID .
    (78) value -> ID .
    (103) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 78 (value -> ID .)
    $end            reduce using rule 92 (negation -> NOT ID .)
    AND             reduce using rule 92 (negation -> NOT ID .)
    OR              reduce using rule 92 (negation -> NOT ID .)
    LLLAVE          reduce using rule 92 (negation -> NOT ID .)
    RLLAVE          reduce using rule 92 (negation -> NOT ID .)
    COLON           reduce using rule 92 (negation -> NOT ID .)
    GREATER         reduce using rule 78 (value -> ID .)
    SMALLER         reduce using rule 78 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 78 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 78 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 78 (value -> ID .)
    NOT_EQUAL       reduce using rule 78 (value -> ID .)
    TIMES           reduce using rule 103 (factor -> ID .)
    DIVIDE          reduce using rule 103 (factor -> ID .)
    PLUS            reduce using rule 103 (factor -> ID .)
    MINUS           reduce using rule 103 (factor -> ID .)

  ! GREATER         [ reduce using rule 103 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 103 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 103 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 103 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 103 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 103 (factor -> ID .) ]


state 70

    (96) expression -> expression PLUS term .
    (99) term -> term . TIMES factor
    (100) term -> term . DIVIDE factor

    COLON           reduce using rule 96 (expression -> expression PLUS term .)
    PLUS            reduce using rule 96 (expression -> expression PLUS term .)
    MINUS           reduce using rule 96 (expression -> expression PLUS term .)
    $end            reduce using rule 96 (expression -> expression PLUS term .)
    GREATER         reduce using rule 96 (expression -> expression PLUS term .)
    SMALLER         reduce using rule 96 (expression -> expression PLUS term .)
    GREATER_OR_EQUAL reduce using rule 96 (expression -> expression PLUS term .)
    SMALLER_OR_EQUAL reduce using rule 96 (expression -> expression PLUS term .)
    EQUAL_COMPARE   reduce using rule 96 (expression -> expression PLUS term .)
    NOT_EQUAL       reduce using rule 96 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 96 (expression -> expression PLUS term .)
    RLLAVE          reduce using rule 96 (expression -> expression PLUS term .)
    AND             reduce using rule 96 (expression -> expression PLUS term .)
    OR              reduce using rule 96 (expression -> expression PLUS term .)
    LLLAVE          reduce using rule 96 (expression -> expression PLUS term .)
    TIMES           shift and go to state 40
    DIVIDE          shift and go to state 41


state 71

    (97) expression -> expression MINUS term .
    (99) term -> term . TIMES factor
    (100) term -> term . DIVIDE factor

    COLON           reduce using rule 97 (expression -> expression MINUS term .)
    PLUS            reduce using rule 97 (expression -> expression MINUS term .)
    MINUS           reduce using rule 97 (expression -> expression MINUS term .)
    $end            reduce using rule 97 (expression -> expression MINUS term .)
    GREATER         reduce using rule 97 (expression -> expression MINUS term .)
    SMALLER         reduce using rule 97 (expression -> expression MINUS term .)
    GREATER_OR_EQUAL reduce using rule 97 (expression -> expression MINUS term .)
    SMALLER_OR_EQUAL reduce using rule 97 (expression -> expression MINUS term .)
    EQUAL_COMPARE   reduce using rule 97 (expression -> expression MINUS term .)
    NOT_EQUAL       reduce using rule 97 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 97 (expression -> expression MINUS term .)
    RLLAVE          reduce using rule 97 (expression -> expression MINUS term .)
    AND             reduce using rule 97 (expression -> expression MINUS term .)
    OR              reduce using rule 97 (expression -> expression MINUS term .)
    LLLAVE          reduce using rule 97 (expression -> expression MINUS term .)
    TIMES           shift and go to state 40
    DIVIDE          shift and go to state 41


state 72

    (95) impresion -> PRINT LPAREN expression . RPAREN
    (96) expression -> expression . PLUS term
    (97) expression -> expression . MINUS term

    RPAREN          shift and go to state 113
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35


state 73

    (104) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 104 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 104 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 104 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 104 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 104 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 104 (factor -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 104 (factor -> LPAREN expression RPAREN .)
    SMALLER         reduce using rule 104 (factor -> LPAREN expression RPAREN .)
    GREATER_OR_EQUAL reduce using rule 104 (factor -> LPAREN expression RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 104 (factor -> LPAREN expression RPAREN .)
    EQUAL_COMPARE   reduce using rule 104 (factor -> LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 104 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 104 (factor -> LPAREN expression RPAREN .)
    RLLAVE          reduce using rule 104 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 104 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 104 (factor -> LPAREN expression RPAREN .)
    LLLAVE          reduce using rule 104 (factor -> LPAREN expression RPAREN .)


state 74

    (99) term -> term TIMES factor .

    TIMES           reduce using rule 99 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 99 (term -> term TIMES factor .)
    COLON           reduce using rule 99 (term -> term TIMES factor .)
    PLUS            reduce using rule 99 (term -> term TIMES factor .)
    MINUS           reduce using rule 99 (term -> term TIMES factor .)
    $end            reduce using rule 99 (term -> term TIMES factor .)
    GREATER         reduce using rule 99 (term -> term TIMES factor .)
    SMALLER         reduce using rule 99 (term -> term TIMES factor .)
    GREATER_OR_EQUAL reduce using rule 99 (term -> term TIMES factor .)
    SMALLER_OR_EQUAL reduce using rule 99 (term -> term TIMES factor .)
    EQUAL_COMPARE   reduce using rule 99 (term -> term TIMES factor .)
    NOT_EQUAL       reduce using rule 99 (term -> term TIMES factor .)
    RPAREN          reduce using rule 99 (term -> term TIMES factor .)
    RLLAVE          reduce using rule 99 (term -> term TIMES factor .)
    AND             reduce using rule 99 (term -> term TIMES factor .)
    OR              reduce using rule 99 (term -> term TIMES factor .)
    LLLAVE          reduce using rule 99 (term -> term TIMES factor .)


state 75

    (100) term -> term DIVIDE factor .

    TIMES           reduce using rule 100 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 100 (term -> term DIVIDE factor .)
    COLON           reduce using rule 100 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 100 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 100 (term -> term DIVIDE factor .)
    $end            reduce using rule 100 (term -> term DIVIDE factor .)
    GREATER         reduce using rule 100 (term -> term DIVIDE factor .)
    SMALLER         reduce using rule 100 (term -> term DIVIDE factor .)
    GREATER_OR_EQUAL reduce using rule 100 (term -> term DIVIDE factor .)
    SMALLER_OR_EQUAL reduce using rule 100 (term -> term DIVIDE factor .)
    EQUAL_COMPARE   reduce using rule 100 (term -> term DIVIDE factor .)
    NOT_EQUAL       reduce using rule 100 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 100 (term -> term DIVIDE factor .)
    RLLAVE          reduce using rule 100 (term -> term DIVIDE factor .)
    AND             reduce using rule 100 (term -> term DIVIDE factor .)
    OR              reduce using rule 100 (term -> term DIVIDE factor .)
    LLLAVE          reduce using rule 100 (term -> term DIVIDE factor .)


state 76

    (14) cicloFor -> FOR LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 114


state 77

    (15) cicloFor -> FOR comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . agrupaciones
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (95) impresion -> . PRINT LPAREN expression RPAREN
    (96) expression -> . expression PLUS term
    (97) expression -> . expression MINUS term
    (98) expression -> . term
    (14) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (15) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (16) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (17) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (77) comparison -> . value op value
    (86) logic_operation -> . logic_value logic_op logic_value
    (87) logic_operation -> . negation
    (20) decVar -> . decVarOne
    (21) decVar -> . VAR ID EQUAL INTEGER
    (22) decVar -> . VAR ID EQUAL ID
    (23) decVar -> . VAR ID EQUAL FLOAT
    (24) decVar -> . VAR ID EQUAL expression
    (25) decVar -> . VAR ID EQUAL logic_operation
    (26) decVar -> . VAR ID EQUAL comparison
    (27) decVar -> . sliceC
    (28) decVar -> . VAR ID EQUAL STRING
    (29) decVar -> . ID DEQUAL STRING
    (30) decVar -> . ID DEQUAL FLOAT
    (31) decVar -> . ID DEQUAL expression
    (32) decVar -> . ID DEQUAL logic_operation
    (33) decVar -> . ID DEQUAL comparison
    (59) funciones -> . APPEND LPAREN ID COMA INTEGER RPAREN
    (60) funciones -> . APPEND LPAREN ID COMA FLOAT RPAREN
    (61) funciones -> . APPEND LPAREN ID COMA STRING RPAREN
    (62) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (63) funciones -> . LEN LPAREN ID RPAREN
    (64) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (47) agrupaciones -> . LLLAVE INTEGER RLLAVE
    (48) agrupaciones -> . LLLAVE INTEGER enteros RLLAVE
    (49) agrupaciones -> . LLLAVE FLOAT RLLAVE
    (50) agrupaciones -> . LLLAVE FLOAT flotantes RLLAVE
    (51) agrupaciones -> . LLLAVE STRING RLLAVE
    (52) agrupaciones -> . LLLAVE STRING palabras RLLAVE
    (67) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (68) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (78) value -> . ID
    (79) value -> . expression
    (88) logic_value -> . negation
    (89) logic_value -> . comparison
    (90) logic_value -> . ID
    (91) negation -> . NOT comparison
    (92) negation -> . NOT ID
    (65) decVarOne -> . ID DEQUAL ID
    (66) decVarOne -> . ID DEQUAL INTEGER
    (34) sliceC -> . VAR ID LCORCHE RCORCHE type
    (35) sliceC -> . ID DEQUAL funM
    (36) sliceC -> . ID DEQUAL LCORCHE RCORCHE type agrupaciones
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 12
    FOR             shift and go to state 15
    VAR             shift and go to state 21
    ID              shift and go to state 22
    APPEND          shift and go to state 25
    LEN             shift and go to state 26
    COPY            shift and go to state 27
    LLLAVE          shift and go to state 16
    IF              shift and go to state 28
    TYPE            shift and go to state 29
    NOT             shift and go to state 31
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    comparison                     shift and go to state 5
    codigo                         shift and go to state 115
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    agrupaciones                   shift and go to state 9
    SenIF                          shift and go to state 10
    SenStruct                      shift and go to state 11
    term                           shift and go to state 14
    decVarOne                      shift and go to state 17
    value                          shift and go to state 18
    logic_value                    shift and go to state 19
    negation                       shift and go to state 20
    sliceC                         shift and go to state 24
    factor                         shift and go to state 30

state 78

    (16) cicloFor -> FOR logic_operation LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . agrupaciones
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (95) impresion -> . PRINT LPAREN expression RPAREN
    (96) expression -> . expression PLUS term
    (97) expression -> . expression MINUS term
    (98) expression -> . term
    (14) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (15) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (16) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (17) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (77) comparison -> . value op value
    (86) logic_operation -> . logic_value logic_op logic_value
    (87) logic_operation -> . negation
    (20) decVar -> . decVarOne
    (21) decVar -> . VAR ID EQUAL INTEGER
    (22) decVar -> . VAR ID EQUAL ID
    (23) decVar -> . VAR ID EQUAL FLOAT
    (24) decVar -> . VAR ID EQUAL expression
    (25) decVar -> . VAR ID EQUAL logic_operation
    (26) decVar -> . VAR ID EQUAL comparison
    (27) decVar -> . sliceC
    (28) decVar -> . VAR ID EQUAL STRING
    (29) decVar -> . ID DEQUAL STRING
    (30) decVar -> . ID DEQUAL FLOAT
    (31) decVar -> . ID DEQUAL expression
    (32) decVar -> . ID DEQUAL logic_operation
    (33) decVar -> . ID DEQUAL comparison
    (59) funciones -> . APPEND LPAREN ID COMA INTEGER RPAREN
    (60) funciones -> . APPEND LPAREN ID COMA FLOAT RPAREN
    (61) funciones -> . APPEND LPAREN ID COMA STRING RPAREN
    (62) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (63) funciones -> . LEN LPAREN ID RPAREN
    (64) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (47) agrupaciones -> . LLLAVE INTEGER RLLAVE
    (48) agrupaciones -> . LLLAVE INTEGER enteros RLLAVE
    (49) agrupaciones -> . LLLAVE FLOAT RLLAVE
    (50) agrupaciones -> . LLLAVE FLOAT flotantes RLLAVE
    (51) agrupaciones -> . LLLAVE STRING RLLAVE
    (52) agrupaciones -> . LLLAVE STRING palabras RLLAVE
    (67) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (68) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (78) value -> . ID
    (79) value -> . expression
    (88) logic_value -> . negation
    (89) logic_value -> . comparison
    (90) logic_value -> . ID
    (91) negation -> . NOT comparison
    (92) negation -> . NOT ID
    (65) decVarOne -> . ID DEQUAL ID
    (66) decVarOne -> . ID DEQUAL INTEGER
    (34) sliceC -> . VAR ID LCORCHE RCORCHE type
    (35) sliceC -> . ID DEQUAL funM
    (36) sliceC -> . ID DEQUAL LCORCHE RCORCHE type agrupaciones
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 12
    FOR             shift and go to state 15
    VAR             shift and go to state 21
    ID              shift and go to state 22
    APPEND          shift and go to state 25
    LEN             shift and go to state 26
    COPY            shift and go to state 27
    LLLAVE          shift and go to state 16
    IF              shift and go to state 28
    TYPE            shift and go to state 29
    NOT             shift and go to state 31
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    logic_operation                shift and go to state 6
    codigo                         shift and go to state 116
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    agrupaciones                   shift and go to state 9
    SenIF                          shift and go to state 10
    SenStruct                      shift and go to state 11
    term                           shift and go to state 14
    decVarOne                      shift and go to state 17
    value                          shift and go to state 18
    logic_value                    shift and go to state 19
    negation                       shift and go to state 20
    sliceC                         shift and go to state 24
    factor                         shift and go to state 30

state 79

    (17) cicloFor -> FOR decVarOne COLON . comparison COLON incre LLLAVE codigo RLLAVE
    (77) comparison -> . value op value
    (78) value -> . ID
    (79) value -> . expression
    (96) expression -> . expression PLUS term
    (97) expression -> . expression MINUS term
    (98) expression -> . term
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 91
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    comparison                     shift and go to state 117
    value                          shift and go to state 18
    expression                     shift and go to state 47
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 80

    (65) decVarOne -> ID DEQUAL . ID
    (66) decVarOne -> ID DEQUAL . INTEGER

    ID              shift and go to state 118
    INTEGER         shift and go to state 119


state 81

    (47) agrupaciones -> LLLAVE INTEGER RLLAVE .

    $end            reduce using rule 47 (agrupaciones -> LLLAVE INTEGER RLLAVE .)
    RLLAVE          reduce using rule 47 (agrupaciones -> LLLAVE INTEGER RLLAVE .)
    COLON           reduce using rule 47 (agrupaciones -> LLLAVE INTEGER RLLAVE .)


state 82

    (48) agrupaciones -> LLLAVE INTEGER enteros . RLLAVE

    RLLAVE          shift and go to state 120


state 83

    (53) enteros -> COMA . INTEGER
    (54) enteros -> COMA . INTEGER enteros

    INTEGER         shift and go to state 121


state 84

    (49) agrupaciones -> LLLAVE FLOAT RLLAVE .

    $end            reduce using rule 49 (agrupaciones -> LLLAVE FLOAT RLLAVE .)
    RLLAVE          reduce using rule 49 (agrupaciones -> LLLAVE FLOAT RLLAVE .)
    COLON           reduce using rule 49 (agrupaciones -> LLLAVE FLOAT RLLAVE .)


state 85

    (50) agrupaciones -> LLLAVE FLOAT flotantes . RLLAVE

    RLLAVE          shift and go to state 122


state 86

    (55) flotantes -> COMA . FLOAT
    (56) flotantes -> COMA . FLOAT flotantes

    FLOAT           shift and go to state 123


state 87

    (51) agrupaciones -> LLLAVE STRING RLLAVE .

    $end            reduce using rule 51 (agrupaciones -> LLLAVE STRING RLLAVE .)
    RLLAVE          reduce using rule 51 (agrupaciones -> LLLAVE STRING RLLAVE .)
    COLON           reduce using rule 51 (agrupaciones -> LLLAVE STRING RLLAVE .)


state 88

    (52) agrupaciones -> LLLAVE STRING palabras . RLLAVE

    RLLAVE          shift and go to state 124


state 89

    (57) palabras -> COMA . STRING
    (58) palabras -> COMA . STRING palabras

    STRING          shift and go to state 125


state 90

    (77) comparison -> value op value .

    $end            reduce using rule 77 (comparison -> value op value .)
    AND             reduce using rule 77 (comparison -> value op value .)
    OR              reduce using rule 77 (comparison -> value op value .)
    LLLAVE          reduce using rule 77 (comparison -> value op value .)
    RLLAVE          reduce using rule 77 (comparison -> value op value .)
    COLON           reduce using rule 77 (comparison -> value op value .)
    RPAREN          reduce using rule 77 (comparison -> value op value .)


state 91

    (78) value -> ID .
    (103) factor -> ID .

  ! reduce/reduce conflict for $end resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for LLLAVE resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 78 (value -> ID .)
    $end            reduce using rule 78 (value -> ID .)
    AND             reduce using rule 78 (value -> ID .)
    OR              reduce using rule 78 (value -> ID .)
    LLLAVE          reduce using rule 78 (value -> ID .)
    RLLAVE          reduce using rule 78 (value -> ID .)
    COLON           reduce using rule 78 (value -> ID .)
    RPAREN          reduce using rule 78 (value -> ID .)
    GREATER         reduce using rule 78 (value -> ID .)
    SMALLER         reduce using rule 78 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 78 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 78 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 78 (value -> ID .)
    NOT_EQUAL       reduce using rule 78 (value -> ID .)
    TIMES           reduce using rule 103 (factor -> ID .)
    DIVIDE          reduce using rule 103 (factor -> ID .)
    PLUS            reduce using rule 103 (factor -> ID .)
    MINUS           reduce using rule 103 (factor -> ID .)

  ! $end            [ reduce using rule 103 (factor -> ID .) ]
  ! AND             [ reduce using rule 103 (factor -> ID .) ]
  ! OR              [ reduce using rule 103 (factor -> ID .) ]
  ! LLLAVE          [ reduce using rule 103 (factor -> ID .) ]
  ! RLLAVE          [ reduce using rule 103 (factor -> ID .) ]
  ! COLON           [ reduce using rule 103 (factor -> ID .) ]
  ! RPAREN          [ reduce using rule 103 (factor -> ID .) ]
  ! GREATER         [ reduce using rule 103 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 103 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 103 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 103 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 103 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 103 (factor -> ID .) ]


state 92

    (86) logic_operation -> logic_value logic_op logic_value .

    $end            reduce using rule 86 (logic_operation -> logic_value logic_op logic_value .)
    LLLAVE          reduce using rule 86 (logic_operation -> logic_value logic_op logic_value .)
    RLLAVE          reduce using rule 86 (logic_operation -> logic_value logic_op logic_value .)
    COLON           reduce using rule 86 (logic_operation -> logic_value logic_op logic_value .)


state 93

    (88) logic_value -> negation .

    $end            reduce using rule 88 (logic_value -> negation .)
    LLLAVE          reduce using rule 88 (logic_value -> negation .)
    RLLAVE          reduce using rule 88 (logic_value -> negation .)
    COLON           reduce using rule 88 (logic_value -> negation .)


state 94

    (89) logic_value -> comparison .

    $end            reduce using rule 89 (logic_value -> comparison .)
    LLLAVE          reduce using rule 89 (logic_value -> comparison .)
    RLLAVE          reduce using rule 89 (logic_value -> comparison .)
    COLON           reduce using rule 89 (logic_value -> comparison .)


state 95

    (90) logic_value -> ID .
    (78) value -> ID .
    (103) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 78 (value -> ID .)
    $end            reduce using rule 90 (logic_value -> ID .)
    LLLAVE          reduce using rule 90 (logic_value -> ID .)
    RLLAVE          reduce using rule 90 (logic_value -> ID .)
    COLON           reduce using rule 90 (logic_value -> ID .)
    GREATER         reduce using rule 78 (value -> ID .)
    SMALLER         reduce using rule 78 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 78 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 78 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 78 (value -> ID .)
    NOT_EQUAL       reduce using rule 78 (value -> ID .)
    TIMES           reduce using rule 103 (factor -> ID .)
    DIVIDE          reduce using rule 103 (factor -> ID .)
    PLUS            reduce using rule 103 (factor -> ID .)
    MINUS           reduce using rule 103 (factor -> ID .)

  ! GREATER         [ reduce using rule 103 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 103 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 103 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 103 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 103 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 103 (factor -> ID .) ]


state 96

    (21) decVar -> VAR ID EQUAL . INTEGER
    (22) decVar -> VAR ID EQUAL . ID
    (23) decVar -> VAR ID EQUAL . FLOAT
    (24) decVar -> VAR ID EQUAL . expression
    (25) decVar -> VAR ID EQUAL . logic_operation
    (26) decVar -> VAR ID EQUAL . comparison
    (28) decVar -> VAR ID EQUAL . STRING
    (96) expression -> . expression PLUS term
    (97) expression -> . expression MINUS term
    (98) expression -> . term
    (86) logic_operation -> . logic_value logic_op logic_value
    (87) logic_operation -> . negation
    (77) comparison -> . value op value
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (88) logic_value -> . negation
    (89) logic_value -> . comparison
    (90) logic_value -> . ID
    (91) negation -> . NOT comparison
    (92) negation -> . NOT ID
    (78) value -> . ID
    (79) value -> . expression
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 127
    ID              shift and go to state 126
    FLOAT           shift and go to state 128
    STRING          shift and go to state 132
    NOT             shift and go to state 31
    LPAREN          shift and go to state 13

    expression                     shift and go to state 129
    logic_operation                shift and go to state 130
    comparison                     shift and go to state 131
    term                           shift and go to state 14
    logic_value                    shift and go to state 19
    negation                       shift and go to state 20
    value                          shift and go to state 18
    factor                         shift and go to state 30

state 97

    (34) sliceC -> VAR ID LCORCHE . RCORCHE type

    RCORCHE         shift and go to state 133


state 98

    (65) decVarOne -> ID DEQUAL ID .
    (90) logic_value -> ID .
    (78) value -> ID .
    (103) factor -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 65 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for $end resolved using rule 65 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 65 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 78 (value -> ID .)
    COLON           reduce using rule 65 (decVarOne -> ID DEQUAL ID .)
    $end            reduce using rule 65 (decVarOne -> ID DEQUAL ID .)
    RLLAVE          reduce using rule 65 (decVarOne -> ID DEQUAL ID .)
    AND             reduce using rule 90 (logic_value -> ID .)
    OR              reduce using rule 90 (logic_value -> ID .)
    GREATER         reduce using rule 78 (value -> ID .)
    SMALLER         reduce using rule 78 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 78 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 78 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 78 (value -> ID .)
    NOT_EQUAL       reduce using rule 78 (value -> ID .)
    TIMES           reduce using rule 103 (factor -> ID .)
    DIVIDE          reduce using rule 103 (factor -> ID .)
    PLUS            reduce using rule 103 (factor -> ID .)
    MINUS           reduce using rule 103 (factor -> ID .)

  ! COLON           [ reduce using rule 103 (factor -> ID .) ]
  ! $end            [ reduce using rule 103 (factor -> ID .) ]
  ! RLLAVE          [ reduce using rule 103 (factor -> ID .) ]
  ! GREATER         [ reduce using rule 103 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 103 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 103 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 103 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 103 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 103 (factor -> ID .) ]


state 99

    (29) decVar -> ID DEQUAL STRING .

    COLON           reduce using rule 29 (decVar -> ID DEQUAL STRING .)
    $end            reduce using rule 29 (decVar -> ID DEQUAL STRING .)
    RLLAVE          reduce using rule 29 (decVar -> ID DEQUAL STRING .)


state 100

    (30) decVar -> ID DEQUAL FLOAT .

    COLON           reduce using rule 30 (decVar -> ID DEQUAL FLOAT .)
    $end            reduce using rule 30 (decVar -> ID DEQUAL FLOAT .)
    RLLAVE          reduce using rule 30 (decVar -> ID DEQUAL FLOAT .)


state 101

    (31) decVar -> ID DEQUAL expression .
    (96) expression -> expression . PLUS term
    (97) expression -> expression . MINUS term
    (79) value -> expression .

    COLON           reduce using rule 31 (decVar -> ID DEQUAL expression .)
    $end            reduce using rule 31 (decVar -> ID DEQUAL expression .)
    RLLAVE          reduce using rule 31 (decVar -> ID DEQUAL expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    GREATER         reduce using rule 79 (value -> expression .)
    SMALLER         reduce using rule 79 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 79 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 79 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 79 (value -> expression .)
    NOT_EQUAL       reduce using rule 79 (value -> expression .)


state 102

    (32) decVar -> ID DEQUAL logic_operation .

    COLON           reduce using rule 32 (decVar -> ID DEQUAL logic_operation .)
    $end            reduce using rule 32 (decVar -> ID DEQUAL logic_operation .)
    RLLAVE          reduce using rule 32 (decVar -> ID DEQUAL logic_operation .)


state 103

    (33) decVar -> ID DEQUAL comparison .
    (89) logic_value -> comparison .

    COLON           reduce using rule 33 (decVar -> ID DEQUAL comparison .)
    $end            reduce using rule 33 (decVar -> ID DEQUAL comparison .)
    RLLAVE          reduce using rule 33 (decVar -> ID DEQUAL comparison .)
    AND             reduce using rule 89 (logic_value -> comparison .)
    OR              reduce using rule 89 (logic_value -> comparison .)


state 104

    (66) decVarOne -> ID DEQUAL INTEGER .
    (102) factor -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 66 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 66 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 66 (decVarOne -> ID DEQUAL INTEGER .)
    COLON           reduce using rule 66 (decVarOne -> ID DEQUAL INTEGER .)
    $end            reduce using rule 66 (decVarOne -> ID DEQUAL INTEGER .)
    RLLAVE          reduce using rule 66 (decVarOne -> ID DEQUAL INTEGER .)
    TIMES           reduce using rule 102 (factor -> INTEGER .)
    DIVIDE          reduce using rule 102 (factor -> INTEGER .)
    PLUS            reduce using rule 102 (factor -> INTEGER .)
    MINUS           reduce using rule 102 (factor -> INTEGER .)
    GREATER         reduce using rule 102 (factor -> INTEGER .)
    SMALLER         reduce using rule 102 (factor -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 102 (factor -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 102 (factor -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 102 (factor -> INTEGER .)
    NOT_EQUAL       reduce using rule 102 (factor -> INTEGER .)

  ! COLON           [ reduce using rule 102 (factor -> INTEGER .) ]
  ! $end            [ reduce using rule 102 (factor -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 102 (factor -> INTEGER .) ]


state 105

    (35) sliceC -> ID DEQUAL funM .

    COLON           reduce using rule 35 (sliceC -> ID DEQUAL funM .)
    $end            reduce using rule 35 (sliceC -> ID DEQUAL funM .)
    RLLAVE          reduce using rule 35 (sliceC -> ID DEQUAL funM .)


state 106

    (36) sliceC -> ID DEQUAL LCORCHE . RCORCHE type agrupaciones

    RCORCHE         shift and go to state 134


state 107

    (37) funM -> MAKE . LPAREN LCORCHE RCORCHE type COMA INTEGER RPAREN
    (38) funM -> MAKE . LPAREN LCORCHE RCORCHE type COMA INTEGER COMA INTEGER RPAREN

    LPAREN          shift and go to state 135


state 108

    (59) funciones -> APPEND LPAREN ID . COMA INTEGER RPAREN
    (60) funciones -> APPEND LPAREN ID . COMA FLOAT RPAREN
    (61) funciones -> APPEND LPAREN ID . COMA STRING RPAREN
    (62) funciones -> APPEND LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 136


state 109

    (63) funciones -> LEN LPAREN ID . RPAREN

    RPAREN          shift and go to state 137


state 110

    (64) funciones -> COPY LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 138


state 111

    (67) SenIF -> IF LPAREN comparison . RPAREN LLLAVE codigo RLLAVE

    RPAREN          shift and go to state 139


state 112

    (68) SenStruct -> TYPE ID STRUCT . LLLAVE declaration RLLAVE

    LLLAVE          shift and go to state 140


state 113

    (95) impresion -> PRINT LPAREN expression RPAREN .

    COLON           reduce using rule 95 (impresion -> PRINT LPAREN expression RPAREN .)
    $end            reduce using rule 95 (impresion -> PRINT LPAREN expression RPAREN .)
    RLLAVE          reduce using rule 95 (impresion -> PRINT LPAREN expression RPAREN .)


state 114

    (14) cicloFor -> FOR LLLAVE codigo RLLAVE .

    $end            reduce using rule 14 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 14 (cicloFor -> FOR LLLAVE codigo RLLAVE .)


state 115

    (15) cicloFor -> FOR comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 141


state 116

    (16) cicloFor -> FOR logic_operation LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 142


state 117

    (17) cicloFor -> FOR decVarOne COLON comparison . COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 143


state 118

    (65) decVarOne -> ID DEQUAL ID .

    COLON           reduce using rule 65 (decVarOne -> ID DEQUAL ID .)


state 119

    (66) decVarOne -> ID DEQUAL INTEGER .

    COLON           reduce using rule 66 (decVarOne -> ID DEQUAL INTEGER .)


state 120

    (48) agrupaciones -> LLLAVE INTEGER enteros RLLAVE .

    $end            reduce using rule 48 (agrupaciones -> LLLAVE INTEGER enteros RLLAVE .)
    RLLAVE          reduce using rule 48 (agrupaciones -> LLLAVE INTEGER enteros RLLAVE .)
    COLON           reduce using rule 48 (agrupaciones -> LLLAVE INTEGER enteros RLLAVE .)


state 121

    (53) enteros -> COMA INTEGER .
    (54) enteros -> COMA INTEGER . enteros
    (53) enteros -> . COMA INTEGER
    (54) enteros -> . COMA INTEGER enteros

    RLLAVE          reduce using rule 53 (enteros -> COMA INTEGER .)
    COMA            shift and go to state 83

    enteros                        shift and go to state 144

state 122

    (50) agrupaciones -> LLLAVE FLOAT flotantes RLLAVE .

    $end            reduce using rule 50 (agrupaciones -> LLLAVE FLOAT flotantes RLLAVE .)
    RLLAVE          reduce using rule 50 (agrupaciones -> LLLAVE FLOAT flotantes RLLAVE .)
    COLON           reduce using rule 50 (agrupaciones -> LLLAVE FLOAT flotantes RLLAVE .)


state 123

    (55) flotantes -> COMA FLOAT .
    (56) flotantes -> COMA FLOAT . flotantes
    (55) flotantes -> . COMA FLOAT
    (56) flotantes -> . COMA FLOAT flotantes

    RLLAVE          reduce using rule 55 (flotantes -> COMA FLOAT .)
    COMA            shift and go to state 86

    flotantes                      shift and go to state 145

state 124

    (52) agrupaciones -> LLLAVE STRING palabras RLLAVE .

    $end            reduce using rule 52 (agrupaciones -> LLLAVE STRING palabras RLLAVE .)
    RLLAVE          reduce using rule 52 (agrupaciones -> LLLAVE STRING palabras RLLAVE .)
    COLON           reduce using rule 52 (agrupaciones -> LLLAVE STRING palabras RLLAVE .)


state 125

    (57) palabras -> COMA STRING .
    (58) palabras -> COMA STRING . palabras
    (57) palabras -> . COMA STRING
    (58) palabras -> . COMA STRING palabras

    RLLAVE          reduce using rule 57 (palabras -> COMA STRING .)
    COMA            shift and go to state 89

    palabras                       shift and go to state 146

state 126

    (22) decVar -> VAR ID EQUAL ID .
    (90) logic_value -> ID .
    (78) value -> ID .
    (103) factor -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 22 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for $end resolved using rule 22 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 22 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 78 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 78 (value -> ID .)
    COLON           reduce using rule 22 (decVar -> VAR ID EQUAL ID .)
    $end            reduce using rule 22 (decVar -> VAR ID EQUAL ID .)
    RLLAVE          reduce using rule 22 (decVar -> VAR ID EQUAL ID .)
    AND             reduce using rule 90 (logic_value -> ID .)
    OR              reduce using rule 90 (logic_value -> ID .)
    GREATER         reduce using rule 78 (value -> ID .)
    SMALLER         reduce using rule 78 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 78 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 78 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 78 (value -> ID .)
    NOT_EQUAL       reduce using rule 78 (value -> ID .)
    TIMES           reduce using rule 103 (factor -> ID .)
    DIVIDE          reduce using rule 103 (factor -> ID .)
    PLUS            reduce using rule 103 (factor -> ID .)
    MINUS           reduce using rule 103 (factor -> ID .)

  ! COLON           [ reduce using rule 103 (factor -> ID .) ]
  ! $end            [ reduce using rule 103 (factor -> ID .) ]
  ! RLLAVE          [ reduce using rule 103 (factor -> ID .) ]
  ! GREATER         [ reduce using rule 103 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 103 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 103 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 103 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 103 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 103 (factor -> ID .) ]


state 127

    (21) decVar -> VAR ID EQUAL INTEGER .
    (102) factor -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 21 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 21 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 21 (decVar -> VAR ID EQUAL INTEGER .)
    COLON           reduce using rule 21 (decVar -> VAR ID EQUAL INTEGER .)
    $end            reduce using rule 21 (decVar -> VAR ID EQUAL INTEGER .)
    RLLAVE          reduce using rule 21 (decVar -> VAR ID EQUAL INTEGER .)
    TIMES           reduce using rule 102 (factor -> INTEGER .)
    DIVIDE          reduce using rule 102 (factor -> INTEGER .)
    PLUS            reduce using rule 102 (factor -> INTEGER .)
    MINUS           reduce using rule 102 (factor -> INTEGER .)
    GREATER         reduce using rule 102 (factor -> INTEGER .)
    SMALLER         reduce using rule 102 (factor -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 102 (factor -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 102 (factor -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 102 (factor -> INTEGER .)
    NOT_EQUAL       reduce using rule 102 (factor -> INTEGER .)

  ! COLON           [ reduce using rule 102 (factor -> INTEGER .) ]
  ! $end            [ reduce using rule 102 (factor -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 102 (factor -> INTEGER .) ]


state 128

    (23) decVar -> VAR ID EQUAL FLOAT .

    COLON           reduce using rule 23 (decVar -> VAR ID EQUAL FLOAT .)
    $end            reduce using rule 23 (decVar -> VAR ID EQUAL FLOAT .)
    RLLAVE          reduce using rule 23 (decVar -> VAR ID EQUAL FLOAT .)


state 129

    (24) decVar -> VAR ID EQUAL expression .
    (96) expression -> expression . PLUS term
    (97) expression -> expression . MINUS term
    (79) value -> expression .

    COLON           reduce using rule 24 (decVar -> VAR ID EQUAL expression .)
    $end            reduce using rule 24 (decVar -> VAR ID EQUAL expression .)
    RLLAVE          reduce using rule 24 (decVar -> VAR ID EQUAL expression .)
    PLUS            shift and go to state 34
    MINUS           shift and go to state 35
    GREATER         reduce using rule 79 (value -> expression .)
    SMALLER         reduce using rule 79 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 79 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 79 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 79 (value -> expression .)
    NOT_EQUAL       reduce using rule 79 (value -> expression .)


state 130

    (25) decVar -> VAR ID EQUAL logic_operation .

    COLON           reduce using rule 25 (decVar -> VAR ID EQUAL logic_operation .)
    $end            reduce using rule 25 (decVar -> VAR ID EQUAL logic_operation .)
    RLLAVE          reduce using rule 25 (decVar -> VAR ID EQUAL logic_operation .)


state 131

    (26) decVar -> VAR ID EQUAL comparison .
    (89) logic_value -> comparison .

    COLON           reduce using rule 26 (decVar -> VAR ID EQUAL comparison .)
    $end            reduce using rule 26 (decVar -> VAR ID EQUAL comparison .)
    RLLAVE          reduce using rule 26 (decVar -> VAR ID EQUAL comparison .)
    AND             reduce using rule 89 (logic_value -> comparison .)
    OR              reduce using rule 89 (logic_value -> comparison .)


state 132

    (28) decVar -> VAR ID EQUAL STRING .

    COLON           reduce using rule 28 (decVar -> VAR ID EQUAL STRING .)
    $end            reduce using rule 28 (decVar -> VAR ID EQUAL STRING .)
    RLLAVE          reduce using rule 28 (decVar -> VAR ID EQUAL STRING .)


state 133

    (34) sliceC -> VAR ID LCORCHE RCORCHE . type
    (39) type -> . INT32
    (40) type -> . INT64
    (41) type -> . FLOAT32
    (42) type -> . FLOAT64
    (43) type -> . BYTE
    (44) type -> . WINT
    (45) type -> . WFLOAT
    (46) type -> . WSTRING

    INT32           shift and go to state 148
    INT64           shift and go to state 149
    FLOAT32         shift and go to state 150
    FLOAT64         shift and go to state 151
    BYTE            shift and go to state 152
    WINT            shift and go to state 153
    WFLOAT          shift and go to state 154
    WSTRING         shift and go to state 155

    type                           shift and go to state 147

state 134

    (36) sliceC -> ID DEQUAL LCORCHE RCORCHE . type agrupaciones
    (39) type -> . INT32
    (40) type -> . INT64
    (41) type -> . FLOAT32
    (42) type -> . FLOAT64
    (43) type -> . BYTE
    (44) type -> . WINT
    (45) type -> . WFLOAT
    (46) type -> . WSTRING

    INT32           shift and go to state 148
    INT64           shift and go to state 149
    FLOAT32         shift and go to state 150
    FLOAT64         shift and go to state 151
    BYTE            shift and go to state 152
    WINT            shift and go to state 153
    WFLOAT          shift and go to state 154
    WSTRING         shift and go to state 155

    type                           shift and go to state 156

state 135

    (37) funM -> MAKE LPAREN . LCORCHE RCORCHE type COMA INTEGER RPAREN
    (38) funM -> MAKE LPAREN . LCORCHE RCORCHE type COMA INTEGER COMA INTEGER RPAREN

    LCORCHE         shift and go to state 157


state 136

    (59) funciones -> APPEND LPAREN ID COMA . INTEGER RPAREN
    (60) funciones -> APPEND LPAREN ID COMA . FLOAT RPAREN
    (61) funciones -> APPEND LPAREN ID COMA . STRING RPAREN
    (62) funciones -> APPEND LPAREN ID COMA . ID RPAREN

    INTEGER         shift and go to state 159
    FLOAT           shift and go to state 160
    STRING          shift and go to state 161
    ID              shift and go to state 158


state 137

    (63) funciones -> LEN LPAREN ID RPAREN .

    $end            reduce using rule 63 (funciones -> LEN LPAREN ID RPAREN .)
    RLLAVE          reduce using rule 63 (funciones -> LEN LPAREN ID RPAREN .)


state 138

    (64) funciones -> COPY LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 162


state 139

    (67) SenIF -> IF LPAREN comparison RPAREN . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 163


state 140

    (68) SenStruct -> TYPE ID STRUCT LLLAVE . declaration RLLAVE
    (69) declaration -> . tipo variable
    (70) tipo -> . INT32
    (71) tipo -> . INT64
    (72) tipo -> . FLOAT32
    (73) tipo -> . FLOAT64
    (74) tipo -> . WSTRING
    (75) tipo -> . BOOL

    INT32           shift and go to state 166
    INT64           shift and go to state 167
    FLOAT32         shift and go to state 168
    FLOAT64         shift and go to state 169
    WSTRING         shift and go to state 170
    BOOL            shift and go to state 171

    declaration                    shift and go to state 164
    tipo                           shift and go to state 165

state 141

    (15) cicloFor -> FOR comparison LLLAVE codigo RLLAVE .

    $end            reduce using rule 15 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 15 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)


state 142

    (16) cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .

    $end            reduce using rule 16 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 16 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)


state 143

    (17) cicloFor -> FOR decVarOne COLON comparison COLON . incre LLLAVE codigo RLLAVE
    (18) incre -> . ID INCREASE
    (19) incre -> . ID DECREASE

    ID              shift and go to state 173

    incre                          shift and go to state 172

state 144

    (54) enteros -> COMA INTEGER enteros .

    RLLAVE          reduce using rule 54 (enteros -> COMA INTEGER enteros .)


state 145

    (56) flotantes -> COMA FLOAT flotantes .

    RLLAVE          reduce using rule 56 (flotantes -> COMA FLOAT flotantes .)


state 146

    (58) palabras -> COMA STRING palabras .

    RLLAVE          reduce using rule 58 (palabras -> COMA STRING palabras .)


state 147

    (34) sliceC -> VAR ID LCORCHE RCORCHE type .

    COLON           reduce using rule 34 (sliceC -> VAR ID LCORCHE RCORCHE type .)
    $end            reduce using rule 34 (sliceC -> VAR ID LCORCHE RCORCHE type .)
    RLLAVE          reduce using rule 34 (sliceC -> VAR ID LCORCHE RCORCHE type .)


state 148

    (39) type -> INT32 .

    COLON           reduce using rule 39 (type -> INT32 .)
    $end            reduce using rule 39 (type -> INT32 .)
    RLLAVE          reduce using rule 39 (type -> INT32 .)
    LLLAVE          reduce using rule 39 (type -> INT32 .)
    COMA            reduce using rule 39 (type -> INT32 .)


state 149

    (40) type -> INT64 .

    COLON           reduce using rule 40 (type -> INT64 .)
    $end            reduce using rule 40 (type -> INT64 .)
    RLLAVE          reduce using rule 40 (type -> INT64 .)
    LLLAVE          reduce using rule 40 (type -> INT64 .)
    COMA            reduce using rule 40 (type -> INT64 .)


state 150

    (41) type -> FLOAT32 .

    COLON           reduce using rule 41 (type -> FLOAT32 .)
    $end            reduce using rule 41 (type -> FLOAT32 .)
    RLLAVE          reduce using rule 41 (type -> FLOAT32 .)
    LLLAVE          reduce using rule 41 (type -> FLOAT32 .)
    COMA            reduce using rule 41 (type -> FLOAT32 .)


state 151

    (42) type -> FLOAT64 .

    COLON           reduce using rule 42 (type -> FLOAT64 .)
    $end            reduce using rule 42 (type -> FLOAT64 .)
    RLLAVE          reduce using rule 42 (type -> FLOAT64 .)
    LLLAVE          reduce using rule 42 (type -> FLOAT64 .)
    COMA            reduce using rule 42 (type -> FLOAT64 .)


state 152

    (43) type -> BYTE .

    COLON           reduce using rule 43 (type -> BYTE .)
    $end            reduce using rule 43 (type -> BYTE .)
    RLLAVE          reduce using rule 43 (type -> BYTE .)
    LLLAVE          reduce using rule 43 (type -> BYTE .)
    COMA            reduce using rule 43 (type -> BYTE .)


state 153

    (44) type -> WINT .

    COLON           reduce using rule 44 (type -> WINT .)
    $end            reduce using rule 44 (type -> WINT .)
    RLLAVE          reduce using rule 44 (type -> WINT .)
    LLLAVE          reduce using rule 44 (type -> WINT .)
    COMA            reduce using rule 44 (type -> WINT .)


state 154

    (45) type -> WFLOAT .

    COLON           reduce using rule 45 (type -> WFLOAT .)
    $end            reduce using rule 45 (type -> WFLOAT .)
    RLLAVE          reduce using rule 45 (type -> WFLOAT .)
    LLLAVE          reduce using rule 45 (type -> WFLOAT .)
    COMA            reduce using rule 45 (type -> WFLOAT .)


state 155

    (46) type -> WSTRING .

    COLON           reduce using rule 46 (type -> WSTRING .)
    $end            reduce using rule 46 (type -> WSTRING .)
    RLLAVE          reduce using rule 46 (type -> WSTRING .)
    LLLAVE          reduce using rule 46 (type -> WSTRING .)
    COMA            reduce using rule 46 (type -> WSTRING .)


state 156

    (36) sliceC -> ID DEQUAL LCORCHE RCORCHE type . agrupaciones
    (47) agrupaciones -> . LLLAVE INTEGER RLLAVE
    (48) agrupaciones -> . LLLAVE INTEGER enteros RLLAVE
    (49) agrupaciones -> . LLLAVE FLOAT RLLAVE
    (50) agrupaciones -> . LLLAVE FLOAT flotantes RLLAVE
    (51) agrupaciones -> . LLLAVE STRING RLLAVE
    (52) agrupaciones -> . LLLAVE STRING palabras RLLAVE

    LLLAVE          shift and go to state 16

    agrupaciones                   shift and go to state 174

state 157

    (37) funM -> MAKE LPAREN LCORCHE . RCORCHE type COMA INTEGER RPAREN
    (38) funM -> MAKE LPAREN LCORCHE . RCORCHE type COMA INTEGER COMA INTEGER RPAREN

    RCORCHE         shift and go to state 175


state 158

    (62) funciones -> APPEND LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 176


state 159

    (59) funciones -> APPEND LPAREN ID COMA INTEGER . RPAREN

    RPAREN          shift and go to state 177


state 160

    (60) funciones -> APPEND LPAREN ID COMA FLOAT . RPAREN

    RPAREN          shift and go to state 178


state 161

    (61) funciones -> APPEND LPAREN ID COMA STRING . RPAREN

    RPAREN          shift and go to state 179


state 162

    (64) funciones -> COPY LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 180


state 163

    (67) SenIF -> IF LPAREN comparison RPAREN LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . agrupaciones
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (95) impresion -> . PRINT LPAREN expression RPAREN
    (96) expression -> . expression PLUS term
    (97) expression -> . expression MINUS term
    (98) expression -> . term
    (14) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (15) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (16) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (17) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (77) comparison -> . value op value
    (86) logic_operation -> . logic_value logic_op logic_value
    (87) logic_operation -> . negation
    (20) decVar -> . decVarOne
    (21) decVar -> . VAR ID EQUAL INTEGER
    (22) decVar -> . VAR ID EQUAL ID
    (23) decVar -> . VAR ID EQUAL FLOAT
    (24) decVar -> . VAR ID EQUAL expression
    (25) decVar -> . VAR ID EQUAL logic_operation
    (26) decVar -> . VAR ID EQUAL comparison
    (27) decVar -> . sliceC
    (28) decVar -> . VAR ID EQUAL STRING
    (29) decVar -> . ID DEQUAL STRING
    (30) decVar -> . ID DEQUAL FLOAT
    (31) decVar -> . ID DEQUAL expression
    (32) decVar -> . ID DEQUAL logic_operation
    (33) decVar -> . ID DEQUAL comparison
    (59) funciones -> . APPEND LPAREN ID COMA INTEGER RPAREN
    (60) funciones -> . APPEND LPAREN ID COMA FLOAT RPAREN
    (61) funciones -> . APPEND LPAREN ID COMA STRING RPAREN
    (62) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (63) funciones -> . LEN LPAREN ID RPAREN
    (64) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (47) agrupaciones -> . LLLAVE INTEGER RLLAVE
    (48) agrupaciones -> . LLLAVE INTEGER enteros RLLAVE
    (49) agrupaciones -> . LLLAVE FLOAT RLLAVE
    (50) agrupaciones -> . LLLAVE FLOAT flotantes RLLAVE
    (51) agrupaciones -> . LLLAVE STRING RLLAVE
    (52) agrupaciones -> . LLLAVE STRING palabras RLLAVE
    (67) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (68) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (78) value -> . ID
    (79) value -> . expression
    (88) logic_value -> . negation
    (89) logic_value -> . comparison
    (90) logic_value -> . ID
    (91) negation -> . NOT comparison
    (92) negation -> . NOT ID
    (65) decVarOne -> . ID DEQUAL ID
    (66) decVarOne -> . ID DEQUAL INTEGER
    (34) sliceC -> . VAR ID LCORCHE RCORCHE type
    (35) sliceC -> . ID DEQUAL funM
    (36) sliceC -> . ID DEQUAL LCORCHE RCORCHE type agrupaciones
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 12
    FOR             shift and go to state 15
    VAR             shift and go to state 21
    ID              shift and go to state 22
    APPEND          shift and go to state 25
    LEN             shift and go to state 26
    COPY            shift and go to state 27
    LLLAVE          shift and go to state 16
    IF              shift and go to state 28
    TYPE            shift and go to state 29
    NOT             shift and go to state 31
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    comparison                     shift and go to state 5
    codigo                         shift and go to state 181
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    agrupaciones                   shift and go to state 9
    SenIF                          shift and go to state 10
    SenStruct                      shift and go to state 11
    term                           shift and go to state 14
    decVarOne                      shift and go to state 17
    value                          shift and go to state 18
    logic_value                    shift and go to state 19
    negation                       shift and go to state 20
    sliceC                         shift and go to state 24
    factor                         shift and go to state 30

state 164

    (68) SenStruct -> TYPE ID STRUCT LLLAVE declaration . RLLAVE

    RLLAVE          shift and go to state 182


state 165

    (69) declaration -> tipo . variable
    (76) variable -> . ID

    ID              shift and go to state 184

    variable                       shift and go to state 183

state 166

    (70) tipo -> INT32 .

    ID              reduce using rule 70 (tipo -> INT32 .)


state 167

    (71) tipo -> INT64 .

    ID              reduce using rule 71 (tipo -> INT64 .)


state 168

    (72) tipo -> FLOAT32 .

    ID              reduce using rule 72 (tipo -> FLOAT32 .)


state 169

    (73) tipo -> FLOAT64 .

    ID              reduce using rule 73 (tipo -> FLOAT64 .)


state 170

    (74) tipo -> WSTRING .

    ID              reduce using rule 74 (tipo -> WSTRING .)


state 171

    (75) tipo -> BOOL .

    ID              reduce using rule 75 (tipo -> BOOL .)


state 172

    (17) cicloFor -> FOR decVarOne COLON comparison COLON incre . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 185


state 173

    (18) incre -> ID . INCREASE
    (19) incre -> ID . DECREASE

    INCREASE        shift and go to state 186
    DECREASE        shift and go to state 187


state 174

    (36) sliceC -> ID DEQUAL LCORCHE RCORCHE type agrupaciones .

    COLON           reduce using rule 36 (sliceC -> ID DEQUAL LCORCHE RCORCHE type agrupaciones .)
    $end            reduce using rule 36 (sliceC -> ID DEQUAL LCORCHE RCORCHE type agrupaciones .)
    RLLAVE          reduce using rule 36 (sliceC -> ID DEQUAL LCORCHE RCORCHE type agrupaciones .)


state 175

    (37) funM -> MAKE LPAREN LCORCHE RCORCHE . type COMA INTEGER RPAREN
    (38) funM -> MAKE LPAREN LCORCHE RCORCHE . type COMA INTEGER COMA INTEGER RPAREN
    (39) type -> . INT32
    (40) type -> . INT64
    (41) type -> . FLOAT32
    (42) type -> . FLOAT64
    (43) type -> . BYTE
    (44) type -> . WINT
    (45) type -> . WFLOAT
    (46) type -> . WSTRING

    INT32           shift and go to state 148
    INT64           shift and go to state 149
    FLOAT32         shift and go to state 150
    FLOAT64         shift and go to state 151
    BYTE            shift and go to state 152
    WINT            shift and go to state 153
    WFLOAT          shift and go to state 154
    WSTRING         shift and go to state 155

    type                           shift and go to state 188

state 176

    (62) funciones -> APPEND LPAREN ID COMA ID RPAREN .

    $end            reduce using rule 62 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 62 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)


state 177

    (59) funciones -> APPEND LPAREN ID COMA INTEGER RPAREN .

    $end            reduce using rule 59 (funciones -> APPEND LPAREN ID COMA INTEGER RPAREN .)
    RLLAVE          reduce using rule 59 (funciones -> APPEND LPAREN ID COMA INTEGER RPAREN .)


state 178

    (60) funciones -> APPEND LPAREN ID COMA FLOAT RPAREN .

    $end            reduce using rule 60 (funciones -> APPEND LPAREN ID COMA FLOAT RPAREN .)
    RLLAVE          reduce using rule 60 (funciones -> APPEND LPAREN ID COMA FLOAT RPAREN .)


state 179

    (61) funciones -> APPEND LPAREN ID COMA STRING RPAREN .

    $end            reduce using rule 61 (funciones -> APPEND LPAREN ID COMA STRING RPAREN .)
    RLLAVE          reduce using rule 61 (funciones -> APPEND LPAREN ID COMA STRING RPAREN .)


state 180

    (64) funciones -> COPY LPAREN ID COMA ID RPAREN .

    $end            reduce using rule 64 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 64 (funciones -> COPY LPAREN ID COMA ID RPAREN .)


state 181

    (67) SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 189


state 182

    (68) SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .

    $end            reduce using rule 68 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RLLAVE          reduce using rule 68 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)


state 183

    (69) declaration -> tipo variable .

    RLLAVE          reduce using rule 69 (declaration -> tipo variable .)


state 184

    (76) variable -> ID .

    RLLAVE          reduce using rule 76 (variable -> ID .)


state 185

    (17) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . agrupaciones
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (95) impresion -> . PRINT LPAREN expression RPAREN
    (96) expression -> . expression PLUS term
    (97) expression -> . expression MINUS term
    (98) expression -> . term
    (14) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (15) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (16) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (17) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (77) comparison -> . value op value
    (86) logic_operation -> . logic_value logic_op logic_value
    (87) logic_operation -> . negation
    (20) decVar -> . decVarOne
    (21) decVar -> . VAR ID EQUAL INTEGER
    (22) decVar -> . VAR ID EQUAL ID
    (23) decVar -> . VAR ID EQUAL FLOAT
    (24) decVar -> . VAR ID EQUAL expression
    (25) decVar -> . VAR ID EQUAL logic_operation
    (26) decVar -> . VAR ID EQUAL comparison
    (27) decVar -> . sliceC
    (28) decVar -> . VAR ID EQUAL STRING
    (29) decVar -> . ID DEQUAL STRING
    (30) decVar -> . ID DEQUAL FLOAT
    (31) decVar -> . ID DEQUAL expression
    (32) decVar -> . ID DEQUAL logic_operation
    (33) decVar -> . ID DEQUAL comparison
    (59) funciones -> . APPEND LPAREN ID COMA INTEGER RPAREN
    (60) funciones -> . APPEND LPAREN ID COMA FLOAT RPAREN
    (61) funciones -> . APPEND LPAREN ID COMA STRING RPAREN
    (62) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (63) funciones -> . LEN LPAREN ID RPAREN
    (64) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (47) agrupaciones -> . LLLAVE INTEGER RLLAVE
    (48) agrupaciones -> . LLLAVE INTEGER enteros RLLAVE
    (49) agrupaciones -> . LLLAVE FLOAT RLLAVE
    (50) agrupaciones -> . LLLAVE FLOAT flotantes RLLAVE
    (51) agrupaciones -> . LLLAVE STRING RLLAVE
    (52) agrupaciones -> . LLLAVE STRING palabras RLLAVE
    (67) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (68) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (99) term -> . term TIMES factor
    (100) term -> . term DIVIDE factor
    (101) term -> . factor
    (78) value -> . ID
    (79) value -> . expression
    (88) logic_value -> . negation
    (89) logic_value -> . comparison
    (90) logic_value -> . ID
    (91) negation -> . NOT comparison
    (92) negation -> . NOT ID
    (65) decVarOne -> . ID DEQUAL ID
    (66) decVarOne -> . ID DEQUAL INTEGER
    (34) sliceC -> . VAR ID LCORCHE RCORCHE type
    (35) sliceC -> . ID DEQUAL funM
    (36) sliceC -> . ID DEQUAL LCORCHE RCORCHE type agrupaciones
    (102) factor -> . INTEGER
    (103) factor -> . ID
    (104) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 12
    FOR             shift and go to state 15
    VAR             shift and go to state 21
    ID              shift and go to state 22
    APPEND          shift and go to state 25
    LEN             shift and go to state 26
    COPY            shift and go to state 27
    LLLAVE          shift and go to state 16
    IF              shift and go to state 28
    TYPE            shift and go to state 29
    NOT             shift and go to state 31
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    decVarOne                      shift and go to state 17
    comparison                     shift and go to state 5
    codigo                         shift and go to state 190
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    agrupaciones                   shift and go to state 9
    SenIF                          shift and go to state 10
    SenStruct                      shift and go to state 11
    term                           shift and go to state 14
    value                          shift and go to state 18
    logic_value                    shift and go to state 19
    negation                       shift and go to state 20
    sliceC                         shift and go to state 24
    factor                         shift and go to state 30

state 186

    (18) incre -> ID INCREASE .

    LLLAVE          reduce using rule 18 (incre -> ID INCREASE .)


state 187

    (19) incre -> ID DECREASE .

    LLLAVE          reduce using rule 19 (incre -> ID DECREASE .)


state 188

    (37) funM -> MAKE LPAREN LCORCHE RCORCHE type . COMA INTEGER RPAREN
    (38) funM -> MAKE LPAREN LCORCHE RCORCHE type . COMA INTEGER COMA INTEGER RPAREN

    COMA            shift and go to state 191


state 189

    (67) SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .

    $end            reduce using rule 67 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 67 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)


state 190

    (17) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 192


state 191

    (37) funM -> MAKE LPAREN LCORCHE RCORCHE type COMA . INTEGER RPAREN
    (38) funM -> MAKE LPAREN LCORCHE RCORCHE type COMA . INTEGER COMA INTEGER RPAREN

    INTEGER         shift and go to state 193


state 192

    (17) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .

    $end            reduce using rule 17 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 17 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)


state 193

    (37) funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER . RPAREN
    (38) funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER . COMA INTEGER RPAREN

    RPAREN          shift and go to state 195
    COMA            shift and go to state 194


state 194

    (38) funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER COMA . INTEGER RPAREN

    INTEGER         shift and go to state 196


state 195

    (37) funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER RPAREN .

    COLON           reduce using rule 37 (funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER RPAREN .)
    $end            reduce using rule 37 (funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER RPAREN .)
    RLLAVE          reduce using rule 37 (funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER RPAREN .)


state 196

    (38) funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER COMA INTEGER . RPAREN

    RPAREN          shift and go to state 197


state 197

    (38) funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER COMA INTEGER RPAREN .

    COLON           reduce using rule 38 (funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER COMA INTEGER RPAREN .)
    $end            reduce using rule 38 (funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER COMA INTEGER RPAREN .)
    RLLAVE          reduce using rule 38 (funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER COMA INTEGER RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 22 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 22
WARNING: reduce/reduce conflict in state 46 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 46
WARNING: reduce/reduce conflict in state 69 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 69
WARNING: reduce/reduce conflict in state 91 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 91
WARNING: reduce/reduce conflict in state 95 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 95
WARNING: reduce/reduce conflict in state 98 resolved using rule (decVarOne -> ID DEQUAL ID)
WARNING: rejected rule (factor -> ID) in state 98
WARNING: reduce/reduce conflict in state 98 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 98
WARNING: reduce/reduce conflict in state 104 resolved using rule (decVarOne -> ID DEQUAL INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 104
WARNING: reduce/reduce conflict in state 126 resolved using rule (decVar -> VAR ID EQUAL ID)
WARNING: rejected rule (factor -> ID) in state 126
WARNING: reduce/reduce conflict in state 126 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 126
WARNING: reduce/reduce conflict in state 127 resolved using rule (decVar -> VAR ID EQUAL INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 127
