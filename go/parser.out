Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    CAP
    COMMENT
    CONST
    ELSE
    FUNC
    INTERFACE
    JOIN
    MAIN
    MAP
    MOD
    MULTI_COMMENT
    PACKAGE
    POINTER
    SCAN

Grammar

Rule 0     S' -> codigo
Rule 1     codigo -> impresion COLON
Rule 2     codigo -> impresion
Rule 3     codigo -> expression COLON
Rule 4     codigo -> expression
Rule 5     codigo -> cicloFor
Rule 6     codigo -> comparison
Rule 7     codigo -> logic_operation
Rule 8     codigo -> decVar COLON
Rule 9     codigo -> decVar
Rule 10    codigo -> funciones
Rule 11    codigo -> funciones COLON
Rule 12    codigo -> SenIF
Rule 13    codigo -> SenStruct
Rule 14    codigo -> switch_statement
Rule 15    codigo -> array_declaration COLON
Rule 16    codigo -> array_declaration
Rule 17    codigo -> array_var COLON
Rule 18    codigo -> array_var
Rule 19    codigo -> array_assignment COLON
Rule 20    codigo -> array_assignment
Rule 21    values -> STRING
Rule 22    values -> INTEGER
Rule 23    values -> FLOAT
Rule 24    values -> TRUE
Rule 25    values -> FALSE
Rule 26    data_types -> INT32
Rule 27    data_types -> INT64
Rule 28    data_types -> FLOAT32
Rule 29    data_types -> FLOAT64
Rule 30    data_types -> BYTE
Rule 31    data_types -> WINT
Rule 32    data_types -> WFLOAT
Rule 33    data_types -> WSTRING
Rule 34    data_types -> BOOL
Rule 35    operations -> expression
Rule 36    operations -> comparison
Rule 37    operations -> logic_operation
Rule 38    data_structure -> array_var
Rule 39    arr_content -> LLLAVE items COMA more_items RLLAVE
Rule 40    arr_content -> LLLAVE items RLLAVE
Rule 41    more_items -> items COMA more_items
Rule 42    more_items -> items
Rule 43    items -> values
Rule 44    items -> operations
Rule 45    cicloFor -> FOR LLLAVE codigo RLLAVE
Rule 46    cicloFor -> FOR comparison LLLAVE codigo RLLAVE
Rule 47    cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE
Rule 48    cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
Rule 49    incre -> ID INCREASE
Rule 50    incre -> ID DECREASE
Rule 51    decVar -> decVarOne
Rule 52    decVar -> VAR ID EQUAL INTEGER
Rule 53    decVar -> VAR ID EQUAL ID
Rule 54    decVar -> VAR ID EQUAL FLOAT
Rule 55    decVar -> VAR ID EQUAL expression
Rule 56    decVar -> VAR ID EQUAL logic_operation
Rule 57    decVar -> VAR ID EQUAL comparison
Rule 58    decVar -> sliceC
Rule 59    decVar -> VAR ID EQUAL STRING
Rule 60    decVar -> ID DEQUAL STRING
Rule 61    decVar -> ID DEQUAL FLOAT
Rule 62    decVar -> ID DEQUAL expression
Rule 63    decVar -> ID DEQUAL logic_operation
Rule 64    decVar -> ID DEQUAL comparison
Rule 65    sliceC -> VAR ID LCORCHE RCORCHE data_types
Rule 66    sliceC -> ID DEQUAL funM
Rule 67    sliceC -> ID DEQUAL LCORCHE RCORCHE data_types arr_content
Rule 68    funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
Rule 69    funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
Rule 70    cap -> INTEGER
Rule 71    cap -> ID
Rule 72    cap -> expression
Rule 73    funciones -> APPEND LPAREN ID COMA values RPAREN
Rule 74    funciones -> APPEND LPAREN ID COMA ID RPAREN
Rule 75    funciones -> LEN LPAREN ID RPAREN
Rule 76    funciones -> COPY LPAREN ID COMA ID RPAREN
Rule 77    funciones -> DELETE LPAREN ID COMA ID RPAREN
Rule 78    decVarOne -> ID DEQUAL ID
Rule 79    decVarOne -> ID DEQUAL INTEGER
Rule 80    SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
Rule 81    SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE
Rule 82    declaration -> variable data_types
Rule 83    variable -> ID
Rule 84    comparison -> value op value
Rule 85    value -> ID
Rule 86    value -> expression
Rule 87    op -> GREATER
Rule 88    op -> SMALLER
Rule 89    op -> GREATER_OR_EQUAL
Rule 90    op -> SMALLER_OR_EQUAL
Rule 91    op -> EQUAL_COMPARE
Rule 92    op -> NOT_EQUAL
Rule 93    logic_operation -> logic_value logic_op logic_value
Rule 94    logic_operation -> negation
Rule 95    logic_value -> negation
Rule 96    logic_value -> comparison
Rule 97    logic_value -> ID
Rule 98    negation -> NOT comparison
Rule 99    negation -> NOT ID
Rule 100   logic_op -> AND
Rule 101   logic_op -> OR
Rule 102   switch_statement -> SWITCH ID LLLAVE cases RLLAVE
Rule 103   cases -> CASE values POINTS codigo
Rule 104   cases -> CASE values POINTS codigo more
Rule 105   more -> cases
Rule 106   more -> DEFAULT POINTS codigo
Rule 107   array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types
Rule 108   array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
Rule 109   capacity -> INTEGER
Rule 110   capacity -> ID
Rule 111   capacity -> expression
Rule 112   array_var -> ID LCORCHE index RCORCHE
Rule 113   index -> ID
Rule 114   index -> INTEGER
Rule 115   index -> expression
Rule 116   array_assignment -> array_var EQUAL something
Rule 117   something -> ID
Rule 118   something -> array_var
Rule 119   something -> values
Rule 120   something -> operations
Rule 121   impresion -> PRINT LPAREN expression RPAREN
Rule 122   expression -> expression PLUS term
Rule 123   expression -> expression MINUS term
Rule 124   expression -> term
Rule 125   term -> term TIMES factor
Rule 126   term -> term DIVIDE factor
Rule 127   term -> factor
Rule 128   factor -> INTEGER
Rule 129   factor -> ID
Rule 130   factor -> LPAREN expression RPAREN

Terminals, with rules where they appear

AND                  : 100
APPEND               : 73 74
ARRAY                : 
BOOL                 : 34
BYTE                 : 30
CAP                  : 
CASE                 : 103 104
COLON                : 1 3 8 11 15 17 19 48 48
COMA                 : 39 41 68 69 69 73 74 76 77
COMMENT              : 
CONST                : 
COPY                 : 76
DECREASE             : 50
DEFAULT              : 106
DELETE               : 77
DEQUAL               : 60 61 62 63 64 66 67 78 79
DIVIDE               : 126
ELSE                 : 
EQUAL                : 52 53 54 55 56 57 59 108 116
EQUAL_COMPARE        : 91
FALSE                : 25
FLOAT                : 23 54 61
FLOAT32              : 28
FLOAT64              : 29
FOR                  : 45 46 47 48
FUNC                 : 
GREATER              : 87
GREATER_OR_EQUAL     : 89
ID                   : 49 50 52 53 53 54 55 56 57 59 60 61 62 63 64 65 66 67 71 73 74 74 75 76 76 77 77 78 78 79 81 83 85 97 99 102 107 108 110 112 113 117 129
IF                   : 80
INCREASE             : 49
INT32                : 26
INT64                : 27
INTEGER              : 22 52 70 79 109 114 128
INTERFACE            : 
JOIN                 : 
LCORCHE              : 65 67 68 69 107 108 112
LEN                  : 75
LLLAVE               : 39 40 45 46 47 48 80 81 102
LPAREN               : 68 69 73 74 75 76 77 80 121 130
MAIN                 : 
MAKE                 : 68 69
MAP                  : 
MINUS                : 123
MOD                  : 
MULTI_COMMENT        : 
NOT                  : 98 99
NOT_EQUAL            : 92
OR                   : 101
PACKAGE              : 
PLUS                 : 122
POINTER              : 
POINTS               : 103 104 106
PRINT                : 121
RCORCHE              : 65 67 68 69 107 108 112
RLLAVE               : 39 40 45 46 47 48 80 81 102
RPAREN               : 68 69 73 74 75 76 77 80 121 130
SCAN                 : 
SMALLER              : 88
SMALLER_OR_EQUAL     : 90
STRING               : 21 59 60
STRUCT               : 81
SWITCH               : 102
TIMES                : 125
TRUE                 : 24
TYPE                 : 81
VAR                  : 52 53 54 55 56 57 59 65 107 108
WFLOAT               : 32
WINT                 : 31
WSTRING              : 33
error                : 

Nonterminals, with rules where they appear

SenIF                : 12
SenStruct            : 13
arr_content          : 67 108
array_assignment     : 19 20
array_declaration    : 15 16
array_var            : 17 18 38 116 118
cap                  : 68 69 69
capacity             : 107 108
cases                : 102 105
cicloFor             : 5
codigo               : 45 46 47 48 80 103 104 106 0
comparison           : 6 36 46 48 57 64 80 96 98
data_structure       : 
data_types           : 65 67 68 69 82 107 108
decVar               : 8 9
decVarOne            : 48 51
declaration          : 81
expression           : 3 4 35 55 62 72 86 111 115 121 122 123 130
factor               : 125 126 127
funM                 : 66
funciones            : 10 11
impresion            : 1 2
incre                : 48
index                : 112
items                : 39 40 41 42
logic_op             : 93
logic_operation      : 7 37 47 56 63
logic_value          : 93 93
more                 : 104
more_items           : 39 41
negation             : 94 95
op                   : 84
operations           : 44 120
sliceC               : 58
something            : 116
switch_statement     : 14
term                 : 122 123 124 125 126
value                : 84 84
values               : 43 73 103 104 119
variable             : 82

Parsing method: LALR

state 0

    (0) S' -> . codigo
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (121) impresion -> . PRINT LPAREN expression RPAREN
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (45) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (46) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (47) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (48) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (84) comparison -> . value op value
    (93) logic_operation -> . logic_value logic_op logic_value
    (94) logic_operation -> . negation
    (51) decVar -> . decVarOne
    (52) decVar -> . VAR ID EQUAL INTEGER
    (53) decVar -> . VAR ID EQUAL ID
    (54) decVar -> . VAR ID EQUAL FLOAT
    (55) decVar -> . VAR ID EQUAL expression
    (56) decVar -> . VAR ID EQUAL logic_operation
    (57) decVar -> . VAR ID EQUAL comparison
    (58) decVar -> . sliceC
    (59) decVar -> . VAR ID EQUAL STRING
    (60) decVar -> . ID DEQUAL STRING
    (61) decVar -> . ID DEQUAL FLOAT
    (62) decVar -> . ID DEQUAL expression
    (63) decVar -> . ID DEQUAL logic_operation
    (64) decVar -> . ID DEQUAL comparison
    (73) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (74) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (75) funciones -> . LEN LPAREN ID RPAREN
    (76) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (77) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (80) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (81) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (102) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (107) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (108) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (112) array_var -> . ID LCORCHE index RCORCHE
    (116) array_assignment -> . array_var EQUAL something
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (85) value -> . ID
    (86) value -> . expression
    (95) logic_value -> . negation
    (96) logic_value -> . comparison
    (97) logic_value -> . ID
    (98) negation -> . NOT comparison
    (99) negation -> . NOT ID
    (78) decVarOne -> . ID DEQUAL ID
    (79) decVarOne -> . ID DEQUAL INTEGER
    (65) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (66) sliceC -> . ID DEQUAL funM
    (67) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 15
    FOR             shift and go to state 18
    VAR             shift and go to state 23
    ID              shift and go to state 24
    APPEND          shift and go to state 27
    LEN             shift and go to state 28
    COPY            shift and go to state 29
    DELETE          shift and go to state 30
    IF              shift and go to state 31
    TYPE            shift and go to state 32
    SWITCH          shift and go to state 33
    NOT             shift and go to state 35
    INTEGER         shift and go to state 25
    LPAREN          shift and go to state 16

    codigo                         shift and go to state 1
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    term                           shift and go to state 17
    decVarOne                      shift and go to state 19
    value                          shift and go to state 20
    logic_value                    shift and go to state 21
    negation                       shift and go to state 22
    sliceC                         shift and go to state 26
    factor                         shift and go to state 34

state 1

    (0) S' -> codigo .



state 2

    (1) codigo -> impresion . COLON
    (2) codigo -> impresion .

    COLON           shift and go to state 36
    $end            reduce using rule 2 (codigo -> impresion .)
    RLLAVE          reduce using rule 2 (codigo -> impresion .)
    DEFAULT         reduce using rule 2 (codigo -> impresion .)
    CASE            reduce using rule 2 (codigo -> impresion .)


state 3

    (3) codigo -> expression . COLON
    (4) codigo -> expression .
    (122) expression -> expression . PLUS term
    (123) expression -> expression . MINUS term
    (86) value -> expression .

    COLON           shift and go to state 37
    $end            reduce using rule 4 (codigo -> expression .)
    RLLAVE          reduce using rule 4 (codigo -> expression .)
    DEFAULT         reduce using rule 4 (codigo -> expression .)
    CASE            reduce using rule 4 (codigo -> expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    GREATER         reduce using rule 86 (value -> expression .)
    SMALLER         reduce using rule 86 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 86 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 86 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 86 (value -> expression .)
    NOT_EQUAL       reduce using rule 86 (value -> expression .)


state 4

    (5) codigo -> cicloFor .

    $end            reduce using rule 5 (codigo -> cicloFor .)
    RLLAVE          reduce using rule 5 (codigo -> cicloFor .)
    DEFAULT         reduce using rule 5 (codigo -> cicloFor .)
    CASE            reduce using rule 5 (codigo -> cicloFor .)


state 5

    (6) codigo -> comparison .
    (96) logic_value -> comparison .

    $end            reduce using rule 6 (codigo -> comparison .)
    RLLAVE          reduce using rule 6 (codigo -> comparison .)
    DEFAULT         reduce using rule 6 (codigo -> comparison .)
    CASE            reduce using rule 6 (codigo -> comparison .)
    AND             reduce using rule 96 (logic_value -> comparison .)
    OR              reduce using rule 96 (logic_value -> comparison .)


state 6

    (7) codigo -> logic_operation .

    $end            reduce using rule 7 (codigo -> logic_operation .)
    RLLAVE          reduce using rule 7 (codigo -> logic_operation .)
    DEFAULT         reduce using rule 7 (codigo -> logic_operation .)
    CASE            reduce using rule 7 (codigo -> logic_operation .)


state 7

    (8) codigo -> decVar . COLON
    (9) codigo -> decVar .

    COLON           shift and go to state 40
    $end            reduce using rule 9 (codigo -> decVar .)
    RLLAVE          reduce using rule 9 (codigo -> decVar .)
    DEFAULT         reduce using rule 9 (codigo -> decVar .)
    CASE            reduce using rule 9 (codigo -> decVar .)


state 8

    (10) codigo -> funciones .
    (11) codigo -> funciones . COLON

    $end            reduce using rule 10 (codigo -> funciones .)
    RLLAVE          reduce using rule 10 (codigo -> funciones .)
    DEFAULT         reduce using rule 10 (codigo -> funciones .)
    CASE            reduce using rule 10 (codigo -> funciones .)
    COLON           shift and go to state 41


state 9

    (12) codigo -> SenIF .

    $end            reduce using rule 12 (codigo -> SenIF .)
    RLLAVE          reduce using rule 12 (codigo -> SenIF .)
    DEFAULT         reduce using rule 12 (codigo -> SenIF .)
    CASE            reduce using rule 12 (codigo -> SenIF .)


state 10

    (13) codigo -> SenStruct .

    $end            reduce using rule 13 (codigo -> SenStruct .)
    RLLAVE          reduce using rule 13 (codigo -> SenStruct .)
    DEFAULT         reduce using rule 13 (codigo -> SenStruct .)
    CASE            reduce using rule 13 (codigo -> SenStruct .)


state 11

    (14) codigo -> switch_statement .

    $end            reduce using rule 14 (codigo -> switch_statement .)
    RLLAVE          reduce using rule 14 (codigo -> switch_statement .)
    DEFAULT         reduce using rule 14 (codigo -> switch_statement .)
    CASE            reduce using rule 14 (codigo -> switch_statement .)


state 12

    (15) codigo -> array_declaration . COLON
    (16) codigo -> array_declaration .

    COLON           shift and go to state 42
    $end            reduce using rule 16 (codigo -> array_declaration .)
    RLLAVE          reduce using rule 16 (codigo -> array_declaration .)
    DEFAULT         reduce using rule 16 (codigo -> array_declaration .)
    CASE            reduce using rule 16 (codigo -> array_declaration .)


state 13

    (17) codigo -> array_var . COLON
    (18) codigo -> array_var .
    (116) array_assignment -> array_var . EQUAL something

    COLON           shift and go to state 43
    $end            reduce using rule 18 (codigo -> array_var .)
    RLLAVE          reduce using rule 18 (codigo -> array_var .)
    DEFAULT         reduce using rule 18 (codigo -> array_var .)
    CASE            reduce using rule 18 (codigo -> array_var .)
    EQUAL           shift and go to state 44


state 14

    (19) codigo -> array_assignment . COLON
    (20) codigo -> array_assignment .

    COLON           shift and go to state 45
    $end            reduce using rule 20 (codigo -> array_assignment .)
    RLLAVE          reduce using rule 20 (codigo -> array_assignment .)
    DEFAULT         reduce using rule 20 (codigo -> array_assignment .)
    CASE            reduce using rule 20 (codigo -> array_assignment .)


state 15

    (121) impresion -> PRINT . LPAREN expression RPAREN

    LPAREN          shift and go to state 46


state 16

    (130) factor -> LPAREN . expression RPAREN
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 25
    ID              shift and go to state 48
    LPAREN          shift and go to state 16

    expression                     shift and go to state 47
    term                           shift and go to state 17
    factor                         shift and go to state 34

state 17

    (124) expression -> term .
    (125) term -> term . TIMES factor
    (126) term -> term . DIVIDE factor

    COLON           reduce using rule 124 (expression -> term .)
    PLUS            reduce using rule 124 (expression -> term .)
    MINUS           reduce using rule 124 (expression -> term .)
    $end            reduce using rule 124 (expression -> term .)
    GREATER         reduce using rule 124 (expression -> term .)
    SMALLER         reduce using rule 124 (expression -> term .)
    GREATER_OR_EQUAL reduce using rule 124 (expression -> term .)
    SMALLER_OR_EQUAL reduce using rule 124 (expression -> term .)
    EQUAL_COMPARE   reduce using rule 124 (expression -> term .)
    NOT_EQUAL       reduce using rule 124 (expression -> term .)
    RPAREN          reduce using rule 124 (expression -> term .)
    RLLAVE          reduce using rule 124 (expression -> term .)
    DEFAULT         reduce using rule 124 (expression -> term .)
    CASE            reduce using rule 124 (expression -> term .)
    AND             reduce using rule 124 (expression -> term .)
    OR              reduce using rule 124 (expression -> term .)
    LLLAVE          reduce using rule 124 (expression -> term .)
    COMA            reduce using rule 124 (expression -> term .)
    RCORCHE         reduce using rule 124 (expression -> term .)
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50


state 18

    (45) cicloFor -> FOR . LLLAVE codigo RLLAVE
    (46) cicloFor -> FOR . comparison LLLAVE codigo RLLAVE
    (47) cicloFor -> FOR . logic_operation LLLAVE codigo RLLAVE
    (48) cicloFor -> FOR . decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (84) comparison -> . value op value
    (93) logic_operation -> . logic_value logic_op logic_value
    (94) logic_operation -> . negation
    (78) decVarOne -> . ID DEQUAL ID
    (79) decVarOne -> . ID DEQUAL INTEGER
    (85) value -> . ID
    (86) value -> . expression
    (95) logic_value -> . negation
    (96) logic_value -> . comparison
    (97) logic_value -> . ID
    (98) negation -> . NOT comparison
    (99) negation -> . NOT ID
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    LLLAVE          shift and go to state 51
    ID              shift and go to state 55
    NOT             shift and go to state 35
    INTEGER         shift and go to state 25
    LPAREN          shift and go to state 16

    comparison                     shift and go to state 52
    logic_operation                shift and go to state 53
    decVarOne                      shift and go to state 54
    value                          shift and go to state 20
    logic_value                    shift and go to state 21
    negation                       shift and go to state 22
    expression                     shift and go to state 56
    term                           shift and go to state 17
    factor                         shift and go to state 34

state 19

    (51) decVar -> decVarOne .

    COLON           reduce using rule 51 (decVar -> decVarOne .)
    $end            reduce using rule 51 (decVar -> decVarOne .)
    RLLAVE          reduce using rule 51 (decVar -> decVarOne .)
    DEFAULT         reduce using rule 51 (decVar -> decVarOne .)
    CASE            reduce using rule 51 (decVar -> decVarOne .)


state 20

    (84) comparison -> value . op value
    (87) op -> . GREATER
    (88) op -> . SMALLER
    (89) op -> . GREATER_OR_EQUAL
    (90) op -> . SMALLER_OR_EQUAL
    (91) op -> . EQUAL_COMPARE
    (92) op -> . NOT_EQUAL

    GREATER         shift and go to state 58
    SMALLER         shift and go to state 59
    GREATER_OR_EQUAL shift and go to state 60
    SMALLER_OR_EQUAL shift and go to state 61
    EQUAL_COMPARE   shift and go to state 62
    NOT_EQUAL       shift and go to state 63

    op                             shift and go to state 57

state 21

    (93) logic_operation -> logic_value . logic_op logic_value
    (100) logic_op -> . AND
    (101) logic_op -> . OR

    AND             shift and go to state 65
    OR              shift and go to state 66

    logic_op                       shift and go to state 64

state 22

    (94) logic_operation -> negation .
    (95) logic_value -> negation .

    $end            reduce using rule 94 (logic_operation -> negation .)
    LLLAVE          reduce using rule 94 (logic_operation -> negation .)
    COLON           reduce using rule 94 (logic_operation -> negation .)
    RLLAVE          reduce using rule 94 (logic_operation -> negation .)
    DEFAULT         reduce using rule 94 (logic_operation -> negation .)
    CASE            reduce using rule 94 (logic_operation -> negation .)
    COMA            reduce using rule 94 (logic_operation -> negation .)
    AND             reduce using rule 95 (logic_value -> negation .)
    OR              reduce using rule 95 (logic_value -> negation .)


state 23

    (52) decVar -> VAR . ID EQUAL INTEGER
    (53) decVar -> VAR . ID EQUAL ID
    (54) decVar -> VAR . ID EQUAL FLOAT
    (55) decVar -> VAR . ID EQUAL expression
    (56) decVar -> VAR . ID EQUAL logic_operation
    (57) decVar -> VAR . ID EQUAL comparison
    (59) decVar -> VAR . ID EQUAL STRING
    (107) array_declaration -> VAR . ID LCORCHE capacity RCORCHE data_types
    (108) array_declaration -> VAR . ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (65) sliceC -> VAR . ID LCORCHE RCORCHE data_types

    ID              shift and go to state 67


state 24

    (60) decVar -> ID . DEQUAL STRING
    (61) decVar -> ID . DEQUAL FLOAT
    (62) decVar -> ID . DEQUAL expression
    (63) decVar -> ID . DEQUAL logic_operation
    (64) decVar -> ID . DEQUAL comparison
    (112) array_var -> ID . LCORCHE index RCORCHE
    (85) value -> ID .
    (97) logic_value -> ID .
    (78) decVarOne -> ID . DEQUAL ID
    (79) decVarOne -> ID . DEQUAL INTEGER
    (66) sliceC -> ID . DEQUAL funM
    (67) sliceC -> ID . DEQUAL LCORCHE RCORCHE data_types arr_content
    (129) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 85 (value -> ID .)
    DEQUAL          shift and go to state 68
    LCORCHE         shift and go to state 69
    GREATER         reduce using rule 85 (value -> ID .)
    SMALLER         reduce using rule 85 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 85 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 85 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 85 (value -> ID .)
    NOT_EQUAL       reduce using rule 85 (value -> ID .)
    AND             reduce using rule 97 (logic_value -> ID .)
    OR              reduce using rule 97 (logic_value -> ID .)
    TIMES           reduce using rule 129 (factor -> ID .)
    DIVIDE          reduce using rule 129 (factor -> ID .)
    COLON           reduce using rule 129 (factor -> ID .)
    PLUS            reduce using rule 129 (factor -> ID .)
    MINUS           reduce using rule 129 (factor -> ID .)
    $end            reduce using rule 129 (factor -> ID .)
    RLLAVE          reduce using rule 129 (factor -> ID .)
    DEFAULT         reduce using rule 129 (factor -> ID .)
    CASE            reduce using rule 129 (factor -> ID .)

  ! GREATER         [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 129 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 129 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 129 (factor -> ID .) ]


state 25

    (128) factor -> INTEGER .

    TIMES           reduce using rule 128 (factor -> INTEGER .)
    DIVIDE          reduce using rule 128 (factor -> INTEGER .)
    COLON           reduce using rule 128 (factor -> INTEGER .)
    PLUS            reduce using rule 128 (factor -> INTEGER .)
    MINUS           reduce using rule 128 (factor -> INTEGER .)
    $end            reduce using rule 128 (factor -> INTEGER .)
    GREATER         reduce using rule 128 (factor -> INTEGER .)
    SMALLER         reduce using rule 128 (factor -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 128 (factor -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 128 (factor -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 128 (factor -> INTEGER .)
    NOT_EQUAL       reduce using rule 128 (factor -> INTEGER .)
    RPAREN          reduce using rule 128 (factor -> INTEGER .)
    RLLAVE          reduce using rule 128 (factor -> INTEGER .)
    DEFAULT         reduce using rule 128 (factor -> INTEGER .)
    CASE            reduce using rule 128 (factor -> INTEGER .)
    AND             reduce using rule 128 (factor -> INTEGER .)
    OR              reduce using rule 128 (factor -> INTEGER .)
    LLLAVE          reduce using rule 128 (factor -> INTEGER .)
    COMA            reduce using rule 128 (factor -> INTEGER .)
    RCORCHE         reduce using rule 128 (factor -> INTEGER .)


state 26

    (58) decVar -> sliceC .

    COLON           reduce using rule 58 (decVar -> sliceC .)
    $end            reduce using rule 58 (decVar -> sliceC .)
    RLLAVE          reduce using rule 58 (decVar -> sliceC .)
    DEFAULT         reduce using rule 58 (decVar -> sliceC .)
    CASE            reduce using rule 58 (decVar -> sliceC .)


state 27

    (73) funciones -> APPEND . LPAREN ID COMA values RPAREN
    (74) funciones -> APPEND . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 70


state 28

    (75) funciones -> LEN . LPAREN ID RPAREN

    LPAREN          shift and go to state 71


state 29

    (76) funciones -> COPY . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 72


state 30

    (77) funciones -> DELETE . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 73


state 31

    (80) SenIF -> IF . LPAREN comparison RPAREN LLLAVE codigo RLLAVE

    LPAREN          shift and go to state 74


state 32

    (81) SenStruct -> TYPE . ID STRUCT LLLAVE declaration RLLAVE

    ID              shift and go to state 75


state 33

    (102) switch_statement -> SWITCH . ID LLLAVE cases RLLAVE

    ID              shift and go to state 76


state 34

    (127) term -> factor .

    TIMES           reduce using rule 127 (term -> factor .)
    DIVIDE          reduce using rule 127 (term -> factor .)
    COLON           reduce using rule 127 (term -> factor .)
    PLUS            reduce using rule 127 (term -> factor .)
    MINUS           reduce using rule 127 (term -> factor .)
    $end            reduce using rule 127 (term -> factor .)
    GREATER         reduce using rule 127 (term -> factor .)
    SMALLER         reduce using rule 127 (term -> factor .)
    GREATER_OR_EQUAL reduce using rule 127 (term -> factor .)
    SMALLER_OR_EQUAL reduce using rule 127 (term -> factor .)
    EQUAL_COMPARE   reduce using rule 127 (term -> factor .)
    NOT_EQUAL       reduce using rule 127 (term -> factor .)
    RPAREN          reduce using rule 127 (term -> factor .)
    RLLAVE          reduce using rule 127 (term -> factor .)
    DEFAULT         reduce using rule 127 (term -> factor .)
    CASE            reduce using rule 127 (term -> factor .)
    AND             reduce using rule 127 (term -> factor .)
    OR              reduce using rule 127 (term -> factor .)
    LLLAVE          reduce using rule 127 (term -> factor .)
    COMA            reduce using rule 127 (term -> factor .)
    RCORCHE         reduce using rule 127 (term -> factor .)


state 35

    (98) negation -> NOT . comparison
    (99) negation -> NOT . ID
    (84) comparison -> . value op value
    (85) value -> . ID
    (86) value -> . expression
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 78
    INTEGER         shift and go to state 25
    LPAREN          shift and go to state 16

    comparison                     shift and go to state 77
    value                          shift and go to state 20
    expression                     shift and go to state 56
    term                           shift and go to state 17
    factor                         shift and go to state 34

state 36

    (1) codigo -> impresion COLON .

    $end            reduce using rule 1 (codigo -> impresion COLON .)
    RLLAVE          reduce using rule 1 (codigo -> impresion COLON .)
    DEFAULT         reduce using rule 1 (codigo -> impresion COLON .)
    CASE            reduce using rule 1 (codigo -> impresion COLON .)


state 37

    (3) codigo -> expression COLON .

    $end            reduce using rule 3 (codigo -> expression COLON .)
    RLLAVE          reduce using rule 3 (codigo -> expression COLON .)
    DEFAULT         reduce using rule 3 (codigo -> expression COLON .)
    CASE            reduce using rule 3 (codigo -> expression COLON .)


state 38

    (122) expression -> expression PLUS . term
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 25
    ID              shift and go to state 48
    LPAREN          shift and go to state 16

    term                           shift and go to state 79
    factor                         shift and go to state 34

state 39

    (123) expression -> expression MINUS . term
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 25
    ID              shift and go to state 48
    LPAREN          shift and go to state 16

    term                           shift and go to state 80
    factor                         shift and go to state 34

state 40

    (8) codigo -> decVar COLON .

    $end            reduce using rule 8 (codigo -> decVar COLON .)
    RLLAVE          reduce using rule 8 (codigo -> decVar COLON .)
    DEFAULT         reduce using rule 8 (codigo -> decVar COLON .)
    CASE            reduce using rule 8 (codigo -> decVar COLON .)


state 41

    (11) codigo -> funciones COLON .

    $end            reduce using rule 11 (codigo -> funciones COLON .)
    RLLAVE          reduce using rule 11 (codigo -> funciones COLON .)
    DEFAULT         reduce using rule 11 (codigo -> funciones COLON .)
    CASE            reduce using rule 11 (codigo -> funciones COLON .)


state 42

    (15) codigo -> array_declaration COLON .

    $end            reduce using rule 15 (codigo -> array_declaration COLON .)
    RLLAVE          reduce using rule 15 (codigo -> array_declaration COLON .)
    DEFAULT         reduce using rule 15 (codigo -> array_declaration COLON .)
    CASE            reduce using rule 15 (codigo -> array_declaration COLON .)


state 43

    (17) codigo -> array_var COLON .

    $end            reduce using rule 17 (codigo -> array_var COLON .)
    RLLAVE          reduce using rule 17 (codigo -> array_var COLON .)
    DEFAULT         reduce using rule 17 (codigo -> array_var COLON .)
    CASE            reduce using rule 17 (codigo -> array_var COLON .)


state 44

    (116) array_assignment -> array_var EQUAL . something
    (117) something -> . ID
    (118) something -> . array_var
    (119) something -> . values
    (120) something -> . operations
    (112) array_var -> . ID LCORCHE index RCORCHE
    (21) values -> . STRING
    (22) values -> . INTEGER
    (23) values -> . FLOAT
    (24) values -> . TRUE
    (25) values -> . FALSE
    (35) operations -> . expression
    (36) operations -> . comparison
    (37) operations -> . logic_operation
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (84) comparison -> . value op value
    (93) logic_operation -> . logic_value logic_op logic_value
    (94) logic_operation -> . negation
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (85) value -> . ID
    (86) value -> . expression
    (95) logic_value -> . negation
    (96) logic_value -> . comparison
    (97) logic_value -> . ID
    (98) negation -> . NOT comparison
    (99) negation -> . NOT ID
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 83
    STRING          shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    TRUE            shift and go to state 89
    FALSE           shift and go to state 90
    NOT             shift and go to state 35
    LPAREN          shift and go to state 16

    array_var                      shift and go to state 81
    something                      shift and go to state 82
    values                         shift and go to state 84
    operations                     shift and go to state 85
    expression                     shift and go to state 91
    comparison                     shift and go to state 92
    logic_operation                shift and go to state 93
    term                           shift and go to state 17
    value                          shift and go to state 20
    logic_value                    shift and go to state 21
    negation                       shift and go to state 22
    factor                         shift and go to state 34

state 45

    (19) codigo -> array_assignment COLON .

    $end            reduce using rule 19 (codigo -> array_assignment COLON .)
    RLLAVE          reduce using rule 19 (codigo -> array_assignment COLON .)
    DEFAULT         reduce using rule 19 (codigo -> array_assignment COLON .)
    CASE            reduce using rule 19 (codigo -> array_assignment COLON .)


state 46

    (121) impresion -> PRINT LPAREN . expression RPAREN
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 25
    ID              shift and go to state 48
    LPAREN          shift and go to state 16

    expression                     shift and go to state 94
    term                           shift and go to state 17
    factor                         shift and go to state 34

state 47

    (130) factor -> LPAREN expression . RPAREN
    (122) expression -> expression . PLUS term
    (123) expression -> expression . MINUS term

    RPAREN          shift and go to state 95
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39


state 48

    (129) factor -> ID .

    TIMES           reduce using rule 129 (factor -> ID .)
    DIVIDE          reduce using rule 129 (factor -> ID .)
    RPAREN          reduce using rule 129 (factor -> ID .)
    PLUS            reduce using rule 129 (factor -> ID .)
    MINUS           reduce using rule 129 (factor -> ID .)
    COLON           reduce using rule 129 (factor -> ID .)
    $end            reduce using rule 129 (factor -> ID .)
    GREATER         reduce using rule 129 (factor -> ID .)
    SMALLER         reduce using rule 129 (factor -> ID .)
    GREATER_OR_EQUAL reduce using rule 129 (factor -> ID .)
    SMALLER_OR_EQUAL reduce using rule 129 (factor -> ID .)
    EQUAL_COMPARE   reduce using rule 129 (factor -> ID .)
    NOT_EQUAL       reduce using rule 129 (factor -> ID .)
    RLLAVE          reduce using rule 129 (factor -> ID .)
    DEFAULT         reduce using rule 129 (factor -> ID .)
    CASE            reduce using rule 129 (factor -> ID .)
    AND             reduce using rule 129 (factor -> ID .)
    OR              reduce using rule 129 (factor -> ID .)
    LLLAVE          reduce using rule 129 (factor -> ID .)
    COMA            reduce using rule 129 (factor -> ID .)
    RCORCHE         reduce using rule 129 (factor -> ID .)


state 49

    (125) term -> term TIMES . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 25
    ID              shift and go to state 48
    LPAREN          shift and go to state 16

    factor                         shift and go to state 96

state 50

    (126) term -> term DIVIDE . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 25
    ID              shift and go to state 48
    LPAREN          shift and go to state 16

    factor                         shift and go to state 97

state 51

    (45) cicloFor -> FOR LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (121) impresion -> . PRINT LPAREN expression RPAREN
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (45) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (46) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (47) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (48) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (84) comparison -> . value op value
    (93) logic_operation -> . logic_value logic_op logic_value
    (94) logic_operation -> . negation
    (51) decVar -> . decVarOne
    (52) decVar -> . VAR ID EQUAL INTEGER
    (53) decVar -> . VAR ID EQUAL ID
    (54) decVar -> . VAR ID EQUAL FLOAT
    (55) decVar -> . VAR ID EQUAL expression
    (56) decVar -> . VAR ID EQUAL logic_operation
    (57) decVar -> . VAR ID EQUAL comparison
    (58) decVar -> . sliceC
    (59) decVar -> . VAR ID EQUAL STRING
    (60) decVar -> . ID DEQUAL STRING
    (61) decVar -> . ID DEQUAL FLOAT
    (62) decVar -> . ID DEQUAL expression
    (63) decVar -> . ID DEQUAL logic_operation
    (64) decVar -> . ID DEQUAL comparison
    (73) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (74) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (75) funciones -> . LEN LPAREN ID RPAREN
    (76) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (77) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (80) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (81) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (102) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (107) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (108) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (112) array_var -> . ID LCORCHE index RCORCHE
    (116) array_assignment -> . array_var EQUAL something
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (85) value -> . ID
    (86) value -> . expression
    (95) logic_value -> . negation
    (96) logic_value -> . comparison
    (97) logic_value -> . ID
    (98) negation -> . NOT comparison
    (99) negation -> . NOT ID
    (78) decVarOne -> . ID DEQUAL ID
    (79) decVarOne -> . ID DEQUAL INTEGER
    (65) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (66) sliceC -> . ID DEQUAL funM
    (67) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 15
    FOR             shift and go to state 18
    VAR             shift and go to state 23
    ID              shift and go to state 24
    APPEND          shift and go to state 27
    LEN             shift and go to state 28
    COPY            shift and go to state 29
    DELETE          shift and go to state 30
    IF              shift and go to state 31
    TYPE            shift and go to state 32
    SWITCH          shift and go to state 33
    NOT             shift and go to state 35
    INTEGER         shift and go to state 25
    LPAREN          shift and go to state 16

    codigo                         shift and go to state 98
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    term                           shift and go to state 17
    decVarOne                      shift and go to state 19
    value                          shift and go to state 20
    logic_value                    shift and go to state 21
    negation                       shift and go to state 22
    sliceC                         shift and go to state 26
    factor                         shift and go to state 34

state 52

    (46) cicloFor -> FOR comparison . LLLAVE codigo RLLAVE
    (96) logic_value -> comparison .

    LLLAVE          shift and go to state 99
    AND             reduce using rule 96 (logic_value -> comparison .)
    OR              reduce using rule 96 (logic_value -> comparison .)


state 53

    (47) cicloFor -> FOR logic_operation . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 100


state 54

    (48) cicloFor -> FOR decVarOne . COLON comparison COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 101


state 55

    (78) decVarOne -> ID . DEQUAL ID
    (79) decVarOne -> ID . DEQUAL INTEGER
    (85) value -> ID .
    (97) logic_value -> ID .
    (129) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 85 (value -> ID .)
    DEQUAL          shift and go to state 102
    GREATER         reduce using rule 85 (value -> ID .)
    SMALLER         reduce using rule 85 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 85 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 85 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 85 (value -> ID .)
    NOT_EQUAL       reduce using rule 85 (value -> ID .)
    AND             reduce using rule 97 (logic_value -> ID .)
    OR              reduce using rule 97 (logic_value -> ID .)
    TIMES           reduce using rule 129 (factor -> ID .)
    DIVIDE          reduce using rule 129 (factor -> ID .)
    PLUS            reduce using rule 129 (factor -> ID .)
    MINUS           reduce using rule 129 (factor -> ID .)

  ! GREATER         [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 129 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 129 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 129 (factor -> ID .) ]


state 56

    (86) value -> expression .
    (122) expression -> expression . PLUS term
    (123) expression -> expression . MINUS term

    GREATER         reduce using rule 86 (value -> expression .)
    SMALLER         reduce using rule 86 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 86 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 86 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 86 (value -> expression .)
    NOT_EQUAL       reduce using rule 86 (value -> expression .)
    $end            reduce using rule 86 (value -> expression .)
    AND             reduce using rule 86 (value -> expression .)
    OR              reduce using rule 86 (value -> expression .)
    LLLAVE          reduce using rule 86 (value -> expression .)
    COLON           reduce using rule 86 (value -> expression .)
    RLLAVE          reduce using rule 86 (value -> expression .)
    DEFAULT         reduce using rule 86 (value -> expression .)
    CASE            reduce using rule 86 (value -> expression .)
    COMA            reduce using rule 86 (value -> expression .)
    RPAREN          reduce using rule 86 (value -> expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39


state 57

    (84) comparison -> value op . value
    (85) value -> . ID
    (86) value -> . expression
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 104
    INTEGER         shift and go to state 25
    LPAREN          shift and go to state 16

    value                          shift and go to state 103
    expression                     shift and go to state 56
    term                           shift and go to state 17
    factor                         shift and go to state 34

state 58

    (87) op -> GREATER .

    ID              reduce using rule 87 (op -> GREATER .)
    INTEGER         reduce using rule 87 (op -> GREATER .)
    LPAREN          reduce using rule 87 (op -> GREATER .)


state 59

    (88) op -> SMALLER .

    ID              reduce using rule 88 (op -> SMALLER .)
    INTEGER         reduce using rule 88 (op -> SMALLER .)
    LPAREN          reduce using rule 88 (op -> SMALLER .)


state 60

    (89) op -> GREATER_OR_EQUAL .

    ID              reduce using rule 89 (op -> GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 89 (op -> GREATER_OR_EQUAL .)
    LPAREN          reduce using rule 89 (op -> GREATER_OR_EQUAL .)


state 61

    (90) op -> SMALLER_OR_EQUAL .

    ID              reduce using rule 90 (op -> SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 90 (op -> SMALLER_OR_EQUAL .)
    LPAREN          reduce using rule 90 (op -> SMALLER_OR_EQUAL .)


state 62

    (91) op -> EQUAL_COMPARE .

    ID              reduce using rule 91 (op -> EQUAL_COMPARE .)
    INTEGER         reduce using rule 91 (op -> EQUAL_COMPARE .)
    LPAREN          reduce using rule 91 (op -> EQUAL_COMPARE .)


state 63

    (92) op -> NOT_EQUAL .

    ID              reduce using rule 92 (op -> NOT_EQUAL .)
    INTEGER         reduce using rule 92 (op -> NOT_EQUAL .)
    LPAREN          reduce using rule 92 (op -> NOT_EQUAL .)


state 64

    (93) logic_operation -> logic_value logic_op . logic_value
    (95) logic_value -> . negation
    (96) logic_value -> . comparison
    (97) logic_value -> . ID
    (98) negation -> . NOT comparison
    (99) negation -> . NOT ID
    (84) comparison -> . value op value
    (85) value -> . ID
    (86) value -> . expression
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 108
    NOT             shift and go to state 35
    INTEGER         shift and go to state 25
    LPAREN          shift and go to state 16

    logic_value                    shift and go to state 105
    negation                       shift and go to state 106
    comparison                     shift and go to state 107
    value                          shift and go to state 20
    expression                     shift and go to state 56
    term                           shift and go to state 17
    factor                         shift and go to state 34

state 65

    (100) logic_op -> AND .

    ID              reduce using rule 100 (logic_op -> AND .)
    NOT             reduce using rule 100 (logic_op -> AND .)
    INTEGER         reduce using rule 100 (logic_op -> AND .)
    LPAREN          reduce using rule 100 (logic_op -> AND .)


state 66

    (101) logic_op -> OR .

    ID              reduce using rule 101 (logic_op -> OR .)
    NOT             reduce using rule 101 (logic_op -> OR .)
    INTEGER         reduce using rule 101 (logic_op -> OR .)
    LPAREN          reduce using rule 101 (logic_op -> OR .)


state 67

    (52) decVar -> VAR ID . EQUAL INTEGER
    (53) decVar -> VAR ID . EQUAL ID
    (54) decVar -> VAR ID . EQUAL FLOAT
    (55) decVar -> VAR ID . EQUAL expression
    (56) decVar -> VAR ID . EQUAL logic_operation
    (57) decVar -> VAR ID . EQUAL comparison
    (59) decVar -> VAR ID . EQUAL STRING
    (107) array_declaration -> VAR ID . LCORCHE capacity RCORCHE data_types
    (108) array_declaration -> VAR ID . EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (65) sliceC -> VAR ID . LCORCHE RCORCHE data_types

    EQUAL           shift and go to state 109
    LCORCHE         shift and go to state 110


state 68

    (60) decVar -> ID DEQUAL . STRING
    (61) decVar -> ID DEQUAL . FLOAT
    (62) decVar -> ID DEQUAL . expression
    (63) decVar -> ID DEQUAL . logic_operation
    (64) decVar -> ID DEQUAL . comparison
    (78) decVarOne -> ID DEQUAL . ID
    (79) decVarOne -> ID DEQUAL . INTEGER
    (66) sliceC -> ID DEQUAL . funM
    (67) sliceC -> ID DEQUAL . LCORCHE RCORCHE data_types arr_content
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (93) logic_operation -> . logic_value logic_op logic_value
    (94) logic_operation -> . negation
    (84) comparison -> . value op value
    (68) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (69) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (95) logic_value -> . negation
    (96) logic_value -> . comparison
    (97) logic_value -> . ID
    (98) negation -> . NOT comparison
    (99) negation -> . NOT ID
    (85) value -> . ID
    (86) value -> . expression
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    STRING          shift and go to state 112
    FLOAT           shift and go to state 113
    ID              shift and go to state 111
    INTEGER         shift and go to state 117
    LCORCHE         shift and go to state 119
    MAKE            shift and go to state 120
    NOT             shift and go to state 35
    LPAREN          shift and go to state 16

    expression                     shift and go to state 114
    logic_operation                shift and go to state 115
    comparison                     shift and go to state 116
    funM                           shift and go to state 118
    term                           shift and go to state 17
    logic_value                    shift and go to state 21
    negation                       shift and go to state 22
    value                          shift and go to state 20
    factor                         shift and go to state 34

state 69

    (112) array_var -> ID LCORCHE . index RCORCHE
    (113) index -> . ID
    (114) index -> . INTEGER
    (115) index -> . expression
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 121
    INTEGER         shift and go to state 123
    LPAREN          shift and go to state 16

    index                          shift and go to state 122
    expression                     shift and go to state 124
    term                           shift and go to state 17
    factor                         shift and go to state 34

state 70

    (73) funciones -> APPEND LPAREN . ID COMA values RPAREN
    (74) funciones -> APPEND LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 125


state 71

    (75) funciones -> LEN LPAREN . ID RPAREN

    ID              shift and go to state 126


state 72

    (76) funciones -> COPY LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 127


state 73

    (77) funciones -> DELETE LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 128


state 74

    (80) SenIF -> IF LPAREN . comparison RPAREN LLLAVE codigo RLLAVE
    (84) comparison -> . value op value
    (85) value -> . ID
    (86) value -> . expression
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 104
    INTEGER         shift and go to state 25
    LPAREN          shift and go to state 16

    comparison                     shift and go to state 129
    value                          shift and go to state 20
    expression                     shift and go to state 56
    term                           shift and go to state 17
    factor                         shift and go to state 34

state 75

    (81) SenStruct -> TYPE ID . STRUCT LLLAVE declaration RLLAVE

    STRUCT          shift and go to state 130


state 76

    (102) switch_statement -> SWITCH ID . LLLAVE cases RLLAVE

    LLLAVE          shift and go to state 131


state 77

    (98) negation -> NOT comparison .

    $end            reduce using rule 98 (negation -> NOT comparison .)
    AND             reduce using rule 98 (negation -> NOT comparison .)
    OR              reduce using rule 98 (negation -> NOT comparison .)
    LLLAVE          reduce using rule 98 (negation -> NOT comparison .)
    COLON           reduce using rule 98 (negation -> NOT comparison .)
    RLLAVE          reduce using rule 98 (negation -> NOT comparison .)
    DEFAULT         reduce using rule 98 (negation -> NOT comparison .)
    CASE            reduce using rule 98 (negation -> NOT comparison .)
    COMA            reduce using rule 98 (negation -> NOT comparison .)


state 78

    (99) negation -> NOT ID .
    (85) value -> ID .
    (129) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 85 (value -> ID .)
    $end            reduce using rule 99 (negation -> NOT ID .)
    AND             reduce using rule 99 (negation -> NOT ID .)
    OR              reduce using rule 99 (negation -> NOT ID .)
    LLLAVE          reduce using rule 99 (negation -> NOT ID .)
    COLON           reduce using rule 99 (negation -> NOT ID .)
    RLLAVE          reduce using rule 99 (negation -> NOT ID .)
    DEFAULT         reduce using rule 99 (negation -> NOT ID .)
    CASE            reduce using rule 99 (negation -> NOT ID .)
    COMA            reduce using rule 99 (negation -> NOT ID .)
    GREATER         reduce using rule 85 (value -> ID .)
    SMALLER         reduce using rule 85 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 85 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 85 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 85 (value -> ID .)
    NOT_EQUAL       reduce using rule 85 (value -> ID .)
    TIMES           reduce using rule 129 (factor -> ID .)
    DIVIDE          reduce using rule 129 (factor -> ID .)
    PLUS            reduce using rule 129 (factor -> ID .)
    MINUS           reduce using rule 129 (factor -> ID .)

  ! GREATER         [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 129 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 129 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 129 (factor -> ID .) ]


state 79

    (122) expression -> expression PLUS term .
    (125) term -> term . TIMES factor
    (126) term -> term . DIVIDE factor

    COLON           reduce using rule 122 (expression -> expression PLUS term .)
    PLUS            reduce using rule 122 (expression -> expression PLUS term .)
    MINUS           reduce using rule 122 (expression -> expression PLUS term .)
    $end            reduce using rule 122 (expression -> expression PLUS term .)
    GREATER         reduce using rule 122 (expression -> expression PLUS term .)
    SMALLER         reduce using rule 122 (expression -> expression PLUS term .)
    GREATER_OR_EQUAL reduce using rule 122 (expression -> expression PLUS term .)
    SMALLER_OR_EQUAL reduce using rule 122 (expression -> expression PLUS term .)
    EQUAL_COMPARE   reduce using rule 122 (expression -> expression PLUS term .)
    NOT_EQUAL       reduce using rule 122 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 122 (expression -> expression PLUS term .)
    RLLAVE          reduce using rule 122 (expression -> expression PLUS term .)
    DEFAULT         reduce using rule 122 (expression -> expression PLUS term .)
    CASE            reduce using rule 122 (expression -> expression PLUS term .)
    AND             reduce using rule 122 (expression -> expression PLUS term .)
    OR              reduce using rule 122 (expression -> expression PLUS term .)
    LLLAVE          reduce using rule 122 (expression -> expression PLUS term .)
    COMA            reduce using rule 122 (expression -> expression PLUS term .)
    RCORCHE         reduce using rule 122 (expression -> expression PLUS term .)
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50


state 80

    (123) expression -> expression MINUS term .
    (125) term -> term . TIMES factor
    (126) term -> term . DIVIDE factor

    COLON           reduce using rule 123 (expression -> expression MINUS term .)
    PLUS            reduce using rule 123 (expression -> expression MINUS term .)
    MINUS           reduce using rule 123 (expression -> expression MINUS term .)
    $end            reduce using rule 123 (expression -> expression MINUS term .)
    GREATER         reduce using rule 123 (expression -> expression MINUS term .)
    SMALLER         reduce using rule 123 (expression -> expression MINUS term .)
    GREATER_OR_EQUAL reduce using rule 123 (expression -> expression MINUS term .)
    SMALLER_OR_EQUAL reduce using rule 123 (expression -> expression MINUS term .)
    EQUAL_COMPARE   reduce using rule 123 (expression -> expression MINUS term .)
    NOT_EQUAL       reduce using rule 123 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 123 (expression -> expression MINUS term .)
    RLLAVE          reduce using rule 123 (expression -> expression MINUS term .)
    DEFAULT         reduce using rule 123 (expression -> expression MINUS term .)
    CASE            reduce using rule 123 (expression -> expression MINUS term .)
    AND             reduce using rule 123 (expression -> expression MINUS term .)
    OR              reduce using rule 123 (expression -> expression MINUS term .)
    LLLAVE          reduce using rule 123 (expression -> expression MINUS term .)
    COMA            reduce using rule 123 (expression -> expression MINUS term .)
    RCORCHE         reduce using rule 123 (expression -> expression MINUS term .)
    TIMES           shift and go to state 49
    DIVIDE          shift and go to state 50


state 81

    (118) something -> array_var .

    COLON           reduce using rule 118 (something -> array_var .)
    $end            reduce using rule 118 (something -> array_var .)
    RLLAVE          reduce using rule 118 (something -> array_var .)
    DEFAULT         reduce using rule 118 (something -> array_var .)
    CASE            reduce using rule 118 (something -> array_var .)


state 82

    (116) array_assignment -> array_var EQUAL something .

    COLON           reduce using rule 116 (array_assignment -> array_var EQUAL something .)
    $end            reduce using rule 116 (array_assignment -> array_var EQUAL something .)
    RLLAVE          reduce using rule 116 (array_assignment -> array_var EQUAL something .)
    DEFAULT         reduce using rule 116 (array_assignment -> array_var EQUAL something .)
    CASE            reduce using rule 116 (array_assignment -> array_var EQUAL something .)


state 83

    (117) something -> ID .
    (112) array_var -> ID . LCORCHE index RCORCHE
    (85) value -> ID .
    (97) logic_value -> ID .
    (129) factor -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 117 (something -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 117 (something -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 117 (something -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 117 (something -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 117 (something -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 85 (value -> ID .)
    COLON           reduce using rule 117 (something -> ID .)
    $end            reduce using rule 117 (something -> ID .)
    RLLAVE          reduce using rule 117 (something -> ID .)
    DEFAULT         reduce using rule 117 (something -> ID .)
    CASE            reduce using rule 117 (something -> ID .)
    LCORCHE         shift and go to state 69
    GREATER         reduce using rule 85 (value -> ID .)
    SMALLER         reduce using rule 85 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 85 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 85 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 85 (value -> ID .)
    NOT_EQUAL       reduce using rule 85 (value -> ID .)
    AND             reduce using rule 97 (logic_value -> ID .)
    OR              reduce using rule 97 (logic_value -> ID .)
    TIMES           reduce using rule 129 (factor -> ID .)
    DIVIDE          reduce using rule 129 (factor -> ID .)
    PLUS            reduce using rule 129 (factor -> ID .)
    MINUS           reduce using rule 129 (factor -> ID .)

  ! COLON           [ reduce using rule 129 (factor -> ID .) ]
  ! $end            [ reduce using rule 129 (factor -> ID .) ]
  ! RLLAVE          [ reduce using rule 129 (factor -> ID .) ]
  ! DEFAULT         [ reduce using rule 129 (factor -> ID .) ]
  ! CASE            [ reduce using rule 129 (factor -> ID .) ]
  ! GREATER         [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 129 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 129 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 129 (factor -> ID .) ]


state 84

    (119) something -> values .

    COLON           reduce using rule 119 (something -> values .)
    $end            reduce using rule 119 (something -> values .)
    RLLAVE          reduce using rule 119 (something -> values .)
    DEFAULT         reduce using rule 119 (something -> values .)
    CASE            reduce using rule 119 (something -> values .)


state 85

    (120) something -> operations .

    COLON           reduce using rule 120 (something -> operations .)
    $end            reduce using rule 120 (something -> operations .)
    RLLAVE          reduce using rule 120 (something -> operations .)
    DEFAULT         reduce using rule 120 (something -> operations .)
    CASE            reduce using rule 120 (something -> operations .)


state 86

    (21) values -> STRING .

    COLON           reduce using rule 21 (values -> STRING .)
    $end            reduce using rule 21 (values -> STRING .)
    RLLAVE          reduce using rule 21 (values -> STRING .)
    DEFAULT         reduce using rule 21 (values -> STRING .)
    CASE            reduce using rule 21 (values -> STRING .)
    RPAREN          reduce using rule 21 (values -> STRING .)
    POINTS          reduce using rule 21 (values -> STRING .)
    COMA            reduce using rule 21 (values -> STRING .)


state 87

    (22) values -> INTEGER .
    (128) factor -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 22 (values -> INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 22 (values -> INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 22 (values -> INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 22 (values -> INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 22 (values -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 22 (values -> INTEGER .)
    COLON           reduce using rule 22 (values -> INTEGER .)
    $end            reduce using rule 22 (values -> INTEGER .)
    RLLAVE          reduce using rule 22 (values -> INTEGER .)
    DEFAULT         reduce using rule 22 (values -> INTEGER .)
    CASE            reduce using rule 22 (values -> INTEGER .)
    COMA            reduce using rule 22 (values -> INTEGER .)
    TIMES           reduce using rule 128 (factor -> INTEGER .)
    DIVIDE          reduce using rule 128 (factor -> INTEGER .)
    PLUS            reduce using rule 128 (factor -> INTEGER .)
    MINUS           reduce using rule 128 (factor -> INTEGER .)
    GREATER         reduce using rule 128 (factor -> INTEGER .)
    SMALLER         reduce using rule 128 (factor -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 128 (factor -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 128 (factor -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 128 (factor -> INTEGER .)
    NOT_EQUAL       reduce using rule 128 (factor -> INTEGER .)

  ! COLON           [ reduce using rule 128 (factor -> INTEGER .) ]
  ! $end            [ reduce using rule 128 (factor -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 128 (factor -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 128 (factor -> INTEGER .) ]
  ! CASE            [ reduce using rule 128 (factor -> INTEGER .) ]
  ! COMA            [ reduce using rule 128 (factor -> INTEGER .) ]


state 88

    (23) values -> FLOAT .

    COLON           reduce using rule 23 (values -> FLOAT .)
    $end            reduce using rule 23 (values -> FLOAT .)
    RLLAVE          reduce using rule 23 (values -> FLOAT .)
    DEFAULT         reduce using rule 23 (values -> FLOAT .)
    CASE            reduce using rule 23 (values -> FLOAT .)
    RPAREN          reduce using rule 23 (values -> FLOAT .)
    POINTS          reduce using rule 23 (values -> FLOAT .)
    COMA            reduce using rule 23 (values -> FLOAT .)


state 89

    (24) values -> TRUE .

    COLON           reduce using rule 24 (values -> TRUE .)
    $end            reduce using rule 24 (values -> TRUE .)
    RLLAVE          reduce using rule 24 (values -> TRUE .)
    DEFAULT         reduce using rule 24 (values -> TRUE .)
    CASE            reduce using rule 24 (values -> TRUE .)
    RPAREN          reduce using rule 24 (values -> TRUE .)
    POINTS          reduce using rule 24 (values -> TRUE .)
    COMA            reduce using rule 24 (values -> TRUE .)


state 90

    (25) values -> FALSE .

    COLON           reduce using rule 25 (values -> FALSE .)
    $end            reduce using rule 25 (values -> FALSE .)
    RLLAVE          reduce using rule 25 (values -> FALSE .)
    DEFAULT         reduce using rule 25 (values -> FALSE .)
    CASE            reduce using rule 25 (values -> FALSE .)
    RPAREN          reduce using rule 25 (values -> FALSE .)
    POINTS          reduce using rule 25 (values -> FALSE .)
    COMA            reduce using rule 25 (values -> FALSE .)


state 91

    (35) operations -> expression .
    (122) expression -> expression . PLUS term
    (123) expression -> expression . MINUS term
    (86) value -> expression .

    COLON           reduce using rule 35 (operations -> expression .)
    $end            reduce using rule 35 (operations -> expression .)
    RLLAVE          reduce using rule 35 (operations -> expression .)
    DEFAULT         reduce using rule 35 (operations -> expression .)
    CASE            reduce using rule 35 (operations -> expression .)
    COMA            reduce using rule 35 (operations -> expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    GREATER         reduce using rule 86 (value -> expression .)
    SMALLER         reduce using rule 86 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 86 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 86 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 86 (value -> expression .)
    NOT_EQUAL       reduce using rule 86 (value -> expression .)


state 92

    (36) operations -> comparison .
    (96) logic_value -> comparison .

    COLON           reduce using rule 36 (operations -> comparison .)
    $end            reduce using rule 36 (operations -> comparison .)
    RLLAVE          reduce using rule 36 (operations -> comparison .)
    DEFAULT         reduce using rule 36 (operations -> comparison .)
    CASE            reduce using rule 36 (operations -> comparison .)
    COMA            reduce using rule 36 (operations -> comparison .)
    AND             reduce using rule 96 (logic_value -> comparison .)
    OR              reduce using rule 96 (logic_value -> comparison .)


state 93

    (37) operations -> logic_operation .

    COLON           reduce using rule 37 (operations -> logic_operation .)
    $end            reduce using rule 37 (operations -> logic_operation .)
    RLLAVE          reduce using rule 37 (operations -> logic_operation .)
    DEFAULT         reduce using rule 37 (operations -> logic_operation .)
    CASE            reduce using rule 37 (operations -> logic_operation .)
    COMA            reduce using rule 37 (operations -> logic_operation .)


state 94

    (121) impresion -> PRINT LPAREN expression . RPAREN
    (122) expression -> expression . PLUS term
    (123) expression -> expression . MINUS term

    RPAREN          shift and go to state 132
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39


state 95

    (130) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    SMALLER         reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    GREATER_OR_EQUAL reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    EQUAL_COMPARE   reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    RLLAVE          reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    CASE            reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    LLLAVE          reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    COMA            reduce using rule 130 (factor -> LPAREN expression RPAREN .)
    RCORCHE         reduce using rule 130 (factor -> LPAREN expression RPAREN .)


state 96

    (125) term -> term TIMES factor .

    TIMES           reduce using rule 125 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 125 (term -> term TIMES factor .)
    COLON           reduce using rule 125 (term -> term TIMES factor .)
    PLUS            reduce using rule 125 (term -> term TIMES factor .)
    MINUS           reduce using rule 125 (term -> term TIMES factor .)
    $end            reduce using rule 125 (term -> term TIMES factor .)
    GREATER         reduce using rule 125 (term -> term TIMES factor .)
    SMALLER         reduce using rule 125 (term -> term TIMES factor .)
    GREATER_OR_EQUAL reduce using rule 125 (term -> term TIMES factor .)
    SMALLER_OR_EQUAL reduce using rule 125 (term -> term TIMES factor .)
    EQUAL_COMPARE   reduce using rule 125 (term -> term TIMES factor .)
    NOT_EQUAL       reduce using rule 125 (term -> term TIMES factor .)
    RPAREN          reduce using rule 125 (term -> term TIMES factor .)
    RLLAVE          reduce using rule 125 (term -> term TIMES factor .)
    DEFAULT         reduce using rule 125 (term -> term TIMES factor .)
    CASE            reduce using rule 125 (term -> term TIMES factor .)
    AND             reduce using rule 125 (term -> term TIMES factor .)
    OR              reduce using rule 125 (term -> term TIMES factor .)
    LLLAVE          reduce using rule 125 (term -> term TIMES factor .)
    COMA            reduce using rule 125 (term -> term TIMES factor .)
    RCORCHE         reduce using rule 125 (term -> term TIMES factor .)


state 97

    (126) term -> term DIVIDE factor .

    TIMES           reduce using rule 126 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 126 (term -> term DIVIDE factor .)
    COLON           reduce using rule 126 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 126 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 126 (term -> term DIVIDE factor .)
    $end            reduce using rule 126 (term -> term DIVIDE factor .)
    GREATER         reduce using rule 126 (term -> term DIVIDE factor .)
    SMALLER         reduce using rule 126 (term -> term DIVIDE factor .)
    GREATER_OR_EQUAL reduce using rule 126 (term -> term DIVIDE factor .)
    SMALLER_OR_EQUAL reduce using rule 126 (term -> term DIVIDE factor .)
    EQUAL_COMPARE   reduce using rule 126 (term -> term DIVIDE factor .)
    NOT_EQUAL       reduce using rule 126 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 126 (term -> term DIVIDE factor .)
    RLLAVE          reduce using rule 126 (term -> term DIVIDE factor .)
    DEFAULT         reduce using rule 126 (term -> term DIVIDE factor .)
    CASE            reduce using rule 126 (term -> term DIVIDE factor .)
    AND             reduce using rule 126 (term -> term DIVIDE factor .)
    OR              reduce using rule 126 (term -> term DIVIDE factor .)
    LLLAVE          reduce using rule 126 (term -> term DIVIDE factor .)
    COMA            reduce using rule 126 (term -> term DIVIDE factor .)
    RCORCHE         reduce using rule 126 (term -> term DIVIDE factor .)


state 98

    (45) cicloFor -> FOR LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 133


state 99

    (46) cicloFor -> FOR comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (121) impresion -> . PRINT LPAREN expression RPAREN
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (45) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (46) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (47) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (48) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (84) comparison -> . value op value
    (93) logic_operation -> . logic_value logic_op logic_value
    (94) logic_operation -> . negation
    (51) decVar -> . decVarOne
    (52) decVar -> . VAR ID EQUAL INTEGER
    (53) decVar -> . VAR ID EQUAL ID
    (54) decVar -> . VAR ID EQUAL FLOAT
    (55) decVar -> . VAR ID EQUAL expression
    (56) decVar -> . VAR ID EQUAL logic_operation
    (57) decVar -> . VAR ID EQUAL comparison
    (58) decVar -> . sliceC
    (59) decVar -> . VAR ID EQUAL STRING
    (60) decVar -> . ID DEQUAL STRING
    (61) decVar -> . ID DEQUAL FLOAT
    (62) decVar -> . ID DEQUAL expression
    (63) decVar -> . ID DEQUAL logic_operation
    (64) decVar -> . ID DEQUAL comparison
    (73) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (74) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (75) funciones -> . LEN LPAREN ID RPAREN
    (76) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (77) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (80) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (81) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (102) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (107) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (108) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (112) array_var -> . ID LCORCHE index RCORCHE
    (116) array_assignment -> . array_var EQUAL something
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (85) value -> . ID
    (86) value -> . expression
    (95) logic_value -> . negation
    (96) logic_value -> . comparison
    (97) logic_value -> . ID
    (98) negation -> . NOT comparison
    (99) negation -> . NOT ID
    (78) decVarOne -> . ID DEQUAL ID
    (79) decVarOne -> . ID DEQUAL INTEGER
    (65) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (66) sliceC -> . ID DEQUAL funM
    (67) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 15
    FOR             shift and go to state 18
    VAR             shift and go to state 23
    ID              shift and go to state 24
    APPEND          shift and go to state 27
    LEN             shift and go to state 28
    COPY            shift and go to state 29
    DELETE          shift and go to state 30
    IF              shift and go to state 31
    TYPE            shift and go to state 32
    SWITCH          shift and go to state 33
    NOT             shift and go to state 35
    INTEGER         shift and go to state 25
    LPAREN          shift and go to state 16

    comparison                     shift and go to state 5
    codigo                         shift and go to state 134
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    term                           shift and go to state 17
    decVarOne                      shift and go to state 19
    value                          shift and go to state 20
    logic_value                    shift and go to state 21
    negation                       shift and go to state 22
    sliceC                         shift and go to state 26
    factor                         shift and go to state 34

state 100

    (47) cicloFor -> FOR logic_operation LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (121) impresion -> . PRINT LPAREN expression RPAREN
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (45) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (46) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (47) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (48) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (84) comparison -> . value op value
    (93) logic_operation -> . logic_value logic_op logic_value
    (94) logic_operation -> . negation
    (51) decVar -> . decVarOne
    (52) decVar -> . VAR ID EQUAL INTEGER
    (53) decVar -> . VAR ID EQUAL ID
    (54) decVar -> . VAR ID EQUAL FLOAT
    (55) decVar -> . VAR ID EQUAL expression
    (56) decVar -> . VAR ID EQUAL logic_operation
    (57) decVar -> . VAR ID EQUAL comparison
    (58) decVar -> . sliceC
    (59) decVar -> . VAR ID EQUAL STRING
    (60) decVar -> . ID DEQUAL STRING
    (61) decVar -> . ID DEQUAL FLOAT
    (62) decVar -> . ID DEQUAL expression
    (63) decVar -> . ID DEQUAL logic_operation
    (64) decVar -> . ID DEQUAL comparison
    (73) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (74) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (75) funciones -> . LEN LPAREN ID RPAREN
    (76) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (77) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (80) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (81) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (102) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (107) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (108) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (112) array_var -> . ID LCORCHE index RCORCHE
    (116) array_assignment -> . array_var EQUAL something
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (85) value -> . ID
    (86) value -> . expression
    (95) logic_value -> . negation
    (96) logic_value -> . comparison
    (97) logic_value -> . ID
    (98) negation -> . NOT comparison
    (99) negation -> . NOT ID
    (78) decVarOne -> . ID DEQUAL ID
    (79) decVarOne -> . ID DEQUAL INTEGER
    (65) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (66) sliceC -> . ID DEQUAL funM
    (67) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 15
    FOR             shift and go to state 18
    VAR             shift and go to state 23
    ID              shift and go to state 24
    APPEND          shift and go to state 27
    LEN             shift and go to state 28
    COPY            shift and go to state 29
    DELETE          shift and go to state 30
    IF              shift and go to state 31
    TYPE            shift and go to state 32
    SWITCH          shift and go to state 33
    NOT             shift and go to state 35
    INTEGER         shift and go to state 25
    LPAREN          shift and go to state 16

    logic_operation                shift and go to state 6
    codigo                         shift and go to state 135
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    term                           shift and go to state 17
    decVarOne                      shift and go to state 19
    value                          shift and go to state 20
    logic_value                    shift and go to state 21
    negation                       shift and go to state 22
    sliceC                         shift and go to state 26
    factor                         shift and go to state 34

state 101

    (48) cicloFor -> FOR decVarOne COLON . comparison COLON incre LLLAVE codigo RLLAVE
    (84) comparison -> . value op value
    (85) value -> . ID
    (86) value -> . expression
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 104
    INTEGER         shift and go to state 25
    LPAREN          shift and go to state 16

    comparison                     shift and go to state 136
    value                          shift and go to state 20
    expression                     shift and go to state 56
    term                           shift and go to state 17
    factor                         shift and go to state 34

state 102

    (78) decVarOne -> ID DEQUAL . ID
    (79) decVarOne -> ID DEQUAL . INTEGER

    ID              shift and go to state 137
    INTEGER         shift and go to state 138


state 103

    (84) comparison -> value op value .

    $end            reduce using rule 84 (comparison -> value op value .)
    AND             reduce using rule 84 (comparison -> value op value .)
    OR              reduce using rule 84 (comparison -> value op value .)
    LLLAVE          reduce using rule 84 (comparison -> value op value .)
    COLON           reduce using rule 84 (comparison -> value op value .)
    RLLAVE          reduce using rule 84 (comparison -> value op value .)
    DEFAULT         reduce using rule 84 (comparison -> value op value .)
    CASE            reduce using rule 84 (comparison -> value op value .)
    COMA            reduce using rule 84 (comparison -> value op value .)
    RPAREN          reduce using rule 84 (comparison -> value op value .)


state 104

    (85) value -> ID .
    (129) factor -> ID .

  ! reduce/reduce conflict for $end resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for LLLAVE resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 85 (value -> ID .)
    $end            reduce using rule 85 (value -> ID .)
    AND             reduce using rule 85 (value -> ID .)
    OR              reduce using rule 85 (value -> ID .)
    LLLAVE          reduce using rule 85 (value -> ID .)
    COLON           reduce using rule 85 (value -> ID .)
    RLLAVE          reduce using rule 85 (value -> ID .)
    DEFAULT         reduce using rule 85 (value -> ID .)
    CASE            reduce using rule 85 (value -> ID .)
    COMA            reduce using rule 85 (value -> ID .)
    RPAREN          reduce using rule 85 (value -> ID .)
    GREATER         reduce using rule 85 (value -> ID .)
    SMALLER         reduce using rule 85 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 85 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 85 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 85 (value -> ID .)
    NOT_EQUAL       reduce using rule 85 (value -> ID .)
    TIMES           reduce using rule 129 (factor -> ID .)
    DIVIDE          reduce using rule 129 (factor -> ID .)
    PLUS            reduce using rule 129 (factor -> ID .)
    MINUS           reduce using rule 129 (factor -> ID .)

  ! $end            [ reduce using rule 129 (factor -> ID .) ]
  ! AND             [ reduce using rule 129 (factor -> ID .) ]
  ! OR              [ reduce using rule 129 (factor -> ID .) ]
  ! LLLAVE          [ reduce using rule 129 (factor -> ID .) ]
  ! COLON           [ reduce using rule 129 (factor -> ID .) ]
  ! RLLAVE          [ reduce using rule 129 (factor -> ID .) ]
  ! DEFAULT         [ reduce using rule 129 (factor -> ID .) ]
  ! CASE            [ reduce using rule 129 (factor -> ID .) ]
  ! COMA            [ reduce using rule 129 (factor -> ID .) ]
  ! RPAREN          [ reduce using rule 129 (factor -> ID .) ]
  ! GREATER         [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 129 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 129 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 129 (factor -> ID .) ]


state 105

    (93) logic_operation -> logic_value logic_op logic_value .

    $end            reduce using rule 93 (logic_operation -> logic_value logic_op logic_value .)
    LLLAVE          reduce using rule 93 (logic_operation -> logic_value logic_op logic_value .)
    COLON           reduce using rule 93 (logic_operation -> logic_value logic_op logic_value .)
    RLLAVE          reduce using rule 93 (logic_operation -> logic_value logic_op logic_value .)
    DEFAULT         reduce using rule 93 (logic_operation -> logic_value logic_op logic_value .)
    CASE            reduce using rule 93 (logic_operation -> logic_value logic_op logic_value .)
    COMA            reduce using rule 93 (logic_operation -> logic_value logic_op logic_value .)


state 106

    (95) logic_value -> negation .

    $end            reduce using rule 95 (logic_value -> negation .)
    LLLAVE          reduce using rule 95 (logic_value -> negation .)
    COLON           reduce using rule 95 (logic_value -> negation .)
    RLLAVE          reduce using rule 95 (logic_value -> negation .)
    DEFAULT         reduce using rule 95 (logic_value -> negation .)
    CASE            reduce using rule 95 (logic_value -> negation .)
    COMA            reduce using rule 95 (logic_value -> negation .)


state 107

    (96) logic_value -> comparison .

    $end            reduce using rule 96 (logic_value -> comparison .)
    LLLAVE          reduce using rule 96 (logic_value -> comparison .)
    COLON           reduce using rule 96 (logic_value -> comparison .)
    RLLAVE          reduce using rule 96 (logic_value -> comparison .)
    DEFAULT         reduce using rule 96 (logic_value -> comparison .)
    CASE            reduce using rule 96 (logic_value -> comparison .)
    COMA            reduce using rule 96 (logic_value -> comparison .)


state 108

    (97) logic_value -> ID .
    (85) value -> ID .
    (129) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 85 (value -> ID .)
    $end            reduce using rule 97 (logic_value -> ID .)
    LLLAVE          reduce using rule 97 (logic_value -> ID .)
    COLON           reduce using rule 97 (logic_value -> ID .)
    RLLAVE          reduce using rule 97 (logic_value -> ID .)
    DEFAULT         reduce using rule 97 (logic_value -> ID .)
    CASE            reduce using rule 97 (logic_value -> ID .)
    COMA            reduce using rule 97 (logic_value -> ID .)
    GREATER         reduce using rule 85 (value -> ID .)
    SMALLER         reduce using rule 85 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 85 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 85 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 85 (value -> ID .)
    NOT_EQUAL       reduce using rule 85 (value -> ID .)
    TIMES           reduce using rule 129 (factor -> ID .)
    DIVIDE          reduce using rule 129 (factor -> ID .)
    PLUS            reduce using rule 129 (factor -> ID .)
    MINUS           reduce using rule 129 (factor -> ID .)

  ! GREATER         [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 129 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 129 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 129 (factor -> ID .) ]


state 109

    (52) decVar -> VAR ID EQUAL . INTEGER
    (53) decVar -> VAR ID EQUAL . ID
    (54) decVar -> VAR ID EQUAL . FLOAT
    (55) decVar -> VAR ID EQUAL . expression
    (56) decVar -> VAR ID EQUAL . logic_operation
    (57) decVar -> VAR ID EQUAL . comparison
    (59) decVar -> VAR ID EQUAL . STRING
    (108) array_declaration -> VAR ID EQUAL . LCORCHE capacity RCORCHE data_types arr_content
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (93) logic_operation -> . logic_value logic_op logic_value
    (94) logic_operation -> . negation
    (84) comparison -> . value op value
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (95) logic_value -> . negation
    (96) logic_value -> . comparison
    (97) logic_value -> . ID
    (98) negation -> . NOT comparison
    (99) negation -> . NOT ID
    (85) value -> . ID
    (86) value -> . expression
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 140
    ID              shift and go to state 139
    FLOAT           shift and go to state 141
    STRING          shift and go to state 145
    LCORCHE         shift and go to state 146
    NOT             shift and go to state 35
    LPAREN          shift and go to state 16

    expression                     shift and go to state 142
    logic_operation                shift and go to state 143
    comparison                     shift and go to state 144
    term                           shift and go to state 17
    logic_value                    shift and go to state 21
    negation                       shift and go to state 22
    value                          shift and go to state 20
    factor                         shift and go to state 34

state 110

    (107) array_declaration -> VAR ID LCORCHE . capacity RCORCHE data_types
    (65) sliceC -> VAR ID LCORCHE . RCORCHE data_types
    (109) capacity -> . INTEGER
    (110) capacity -> . ID
    (111) capacity -> . expression
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    RCORCHE         shift and go to state 149
    INTEGER         shift and go to state 150
    ID              shift and go to state 147
    LPAREN          shift and go to state 16

    capacity                       shift and go to state 148
    expression                     shift and go to state 151
    term                           shift and go to state 17
    factor                         shift and go to state 34

state 111

    (78) decVarOne -> ID DEQUAL ID .
    (97) logic_value -> ID .
    (85) value -> ID .
    (129) factor -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 78 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for $end resolved using rule 78 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 78 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 78 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for CASE resolved using rule 78 (decVarOne -> ID DEQUAL ID .)
    COLON           reduce using rule 78 (decVarOne -> ID DEQUAL ID .)
    $end            reduce using rule 78 (decVarOne -> ID DEQUAL ID .)
    RLLAVE          reduce using rule 78 (decVarOne -> ID DEQUAL ID .)
    DEFAULT         reduce using rule 78 (decVarOne -> ID DEQUAL ID .)
    CASE            reduce using rule 78 (decVarOne -> ID DEQUAL ID .)
    AND             reduce using rule 97 (logic_value -> ID .)
    OR              reduce using rule 97 (logic_value -> ID .)
    GREATER         reduce using rule 85 (value -> ID .)
    SMALLER         reduce using rule 85 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 85 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 85 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 85 (value -> ID .)
    NOT_EQUAL       reduce using rule 85 (value -> ID .)
    TIMES           reduce using rule 129 (factor -> ID .)
    DIVIDE          reduce using rule 129 (factor -> ID .)
    PLUS            reduce using rule 129 (factor -> ID .)
    MINUS           reduce using rule 129 (factor -> ID .)

  ! COLON           [ reduce using rule 129 (factor -> ID .) ]
  ! $end            [ reduce using rule 129 (factor -> ID .) ]
  ! RLLAVE          [ reduce using rule 129 (factor -> ID .) ]
  ! GREATER         [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 129 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 129 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 129 (factor -> ID .) ]
  ! DEFAULT         [ reduce using rule 129 (factor -> ID .) ]
  ! CASE            [ reduce using rule 129 (factor -> ID .) ]


state 112

    (60) decVar -> ID DEQUAL STRING .

    COLON           reduce using rule 60 (decVar -> ID DEQUAL STRING .)
    $end            reduce using rule 60 (decVar -> ID DEQUAL STRING .)
    RLLAVE          reduce using rule 60 (decVar -> ID DEQUAL STRING .)
    DEFAULT         reduce using rule 60 (decVar -> ID DEQUAL STRING .)
    CASE            reduce using rule 60 (decVar -> ID DEQUAL STRING .)


state 113

    (61) decVar -> ID DEQUAL FLOAT .

    COLON           reduce using rule 61 (decVar -> ID DEQUAL FLOAT .)
    $end            reduce using rule 61 (decVar -> ID DEQUAL FLOAT .)
    RLLAVE          reduce using rule 61 (decVar -> ID DEQUAL FLOAT .)
    DEFAULT         reduce using rule 61 (decVar -> ID DEQUAL FLOAT .)
    CASE            reduce using rule 61 (decVar -> ID DEQUAL FLOAT .)


state 114

    (62) decVar -> ID DEQUAL expression .
    (122) expression -> expression . PLUS term
    (123) expression -> expression . MINUS term
    (86) value -> expression .

    COLON           reduce using rule 62 (decVar -> ID DEQUAL expression .)
    $end            reduce using rule 62 (decVar -> ID DEQUAL expression .)
    RLLAVE          reduce using rule 62 (decVar -> ID DEQUAL expression .)
    DEFAULT         reduce using rule 62 (decVar -> ID DEQUAL expression .)
    CASE            reduce using rule 62 (decVar -> ID DEQUAL expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    GREATER         reduce using rule 86 (value -> expression .)
    SMALLER         reduce using rule 86 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 86 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 86 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 86 (value -> expression .)
    NOT_EQUAL       reduce using rule 86 (value -> expression .)


state 115

    (63) decVar -> ID DEQUAL logic_operation .

    COLON           reduce using rule 63 (decVar -> ID DEQUAL logic_operation .)
    $end            reduce using rule 63 (decVar -> ID DEQUAL logic_operation .)
    RLLAVE          reduce using rule 63 (decVar -> ID DEQUAL logic_operation .)
    DEFAULT         reduce using rule 63 (decVar -> ID DEQUAL logic_operation .)
    CASE            reduce using rule 63 (decVar -> ID DEQUAL logic_operation .)


state 116

    (64) decVar -> ID DEQUAL comparison .
    (96) logic_value -> comparison .

    COLON           reduce using rule 64 (decVar -> ID DEQUAL comparison .)
    $end            reduce using rule 64 (decVar -> ID DEQUAL comparison .)
    RLLAVE          reduce using rule 64 (decVar -> ID DEQUAL comparison .)
    DEFAULT         reduce using rule 64 (decVar -> ID DEQUAL comparison .)
    CASE            reduce using rule 64 (decVar -> ID DEQUAL comparison .)
    AND             reduce using rule 96 (logic_value -> comparison .)
    OR              reduce using rule 96 (logic_value -> comparison .)


state 117

    (79) decVarOne -> ID DEQUAL INTEGER .
    (128) factor -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 79 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 79 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 79 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 79 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 79 (decVarOne -> ID DEQUAL INTEGER .)
    COLON           reduce using rule 79 (decVarOne -> ID DEQUAL INTEGER .)
    $end            reduce using rule 79 (decVarOne -> ID DEQUAL INTEGER .)
    RLLAVE          reduce using rule 79 (decVarOne -> ID DEQUAL INTEGER .)
    DEFAULT         reduce using rule 79 (decVarOne -> ID DEQUAL INTEGER .)
    CASE            reduce using rule 79 (decVarOne -> ID DEQUAL INTEGER .)
    TIMES           reduce using rule 128 (factor -> INTEGER .)
    DIVIDE          reduce using rule 128 (factor -> INTEGER .)
    PLUS            reduce using rule 128 (factor -> INTEGER .)
    MINUS           reduce using rule 128 (factor -> INTEGER .)
    GREATER         reduce using rule 128 (factor -> INTEGER .)
    SMALLER         reduce using rule 128 (factor -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 128 (factor -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 128 (factor -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 128 (factor -> INTEGER .)
    NOT_EQUAL       reduce using rule 128 (factor -> INTEGER .)

  ! COLON           [ reduce using rule 128 (factor -> INTEGER .) ]
  ! $end            [ reduce using rule 128 (factor -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 128 (factor -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 128 (factor -> INTEGER .) ]
  ! CASE            [ reduce using rule 128 (factor -> INTEGER .) ]


state 118

    (66) sliceC -> ID DEQUAL funM .

    COLON           reduce using rule 66 (sliceC -> ID DEQUAL funM .)
    $end            reduce using rule 66 (sliceC -> ID DEQUAL funM .)
    RLLAVE          reduce using rule 66 (sliceC -> ID DEQUAL funM .)
    DEFAULT         reduce using rule 66 (sliceC -> ID DEQUAL funM .)
    CASE            reduce using rule 66 (sliceC -> ID DEQUAL funM .)


state 119

    (67) sliceC -> ID DEQUAL LCORCHE . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 152


state 120

    (68) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (69) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LPAREN          shift and go to state 153


state 121

    (113) index -> ID .
    (129) factor -> ID .

  ! reduce/reduce conflict for RCORCHE resolved using rule 113 (index -> ID .)
    RCORCHE         reduce using rule 113 (index -> ID .)
    TIMES           reduce using rule 129 (factor -> ID .)
    DIVIDE          reduce using rule 129 (factor -> ID .)
    PLUS            reduce using rule 129 (factor -> ID .)
    MINUS           reduce using rule 129 (factor -> ID .)

  ! RCORCHE         [ reduce using rule 129 (factor -> ID .) ]


state 122

    (112) array_var -> ID LCORCHE index . RCORCHE

    RCORCHE         shift and go to state 154


state 123

    (114) index -> INTEGER .
    (128) factor -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 114 (index -> INTEGER .)
    RCORCHE         reduce using rule 114 (index -> INTEGER .)
    TIMES           reduce using rule 128 (factor -> INTEGER .)
    DIVIDE          reduce using rule 128 (factor -> INTEGER .)
    PLUS            reduce using rule 128 (factor -> INTEGER .)
    MINUS           reduce using rule 128 (factor -> INTEGER .)

  ! RCORCHE         [ reduce using rule 128 (factor -> INTEGER .) ]


state 124

    (115) index -> expression .
    (122) expression -> expression . PLUS term
    (123) expression -> expression . MINUS term

    RCORCHE         reduce using rule 115 (index -> expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39


state 125

    (73) funciones -> APPEND LPAREN ID . COMA values RPAREN
    (74) funciones -> APPEND LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 155


state 126

    (75) funciones -> LEN LPAREN ID . RPAREN

    RPAREN          shift and go to state 156


state 127

    (76) funciones -> COPY LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 157


state 128

    (77) funciones -> DELETE LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 158


state 129

    (80) SenIF -> IF LPAREN comparison . RPAREN LLLAVE codigo RLLAVE

    RPAREN          shift and go to state 159


state 130

    (81) SenStruct -> TYPE ID STRUCT . LLLAVE declaration RLLAVE

    LLLAVE          shift and go to state 160


state 131

    (102) switch_statement -> SWITCH ID LLLAVE . cases RLLAVE
    (103) cases -> . CASE values POINTS codigo
    (104) cases -> . CASE values POINTS codigo more

    CASE            shift and go to state 162

    cases                          shift and go to state 161

state 132

    (121) impresion -> PRINT LPAREN expression RPAREN .

    COLON           reduce using rule 121 (impresion -> PRINT LPAREN expression RPAREN .)
    $end            reduce using rule 121 (impresion -> PRINT LPAREN expression RPAREN .)
    RLLAVE          reduce using rule 121 (impresion -> PRINT LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 121 (impresion -> PRINT LPAREN expression RPAREN .)
    CASE            reduce using rule 121 (impresion -> PRINT LPAREN expression RPAREN .)


state 133

    (45) cicloFor -> FOR LLLAVE codigo RLLAVE .

    $end            reduce using rule 45 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 45 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 45 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 45 (cicloFor -> FOR LLLAVE codigo RLLAVE .)


state 134

    (46) cicloFor -> FOR comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 163


state 135

    (47) cicloFor -> FOR logic_operation LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 164


state 136

    (48) cicloFor -> FOR decVarOne COLON comparison . COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 165


state 137

    (78) decVarOne -> ID DEQUAL ID .

    COLON           reduce using rule 78 (decVarOne -> ID DEQUAL ID .)


state 138

    (79) decVarOne -> ID DEQUAL INTEGER .

    COLON           reduce using rule 79 (decVarOne -> ID DEQUAL INTEGER .)


state 139

    (53) decVar -> VAR ID EQUAL ID .
    (97) logic_value -> ID .
    (85) value -> ID .
    (129) factor -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 53 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for $end resolved using rule 53 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 53 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 53 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for CASE resolved using rule 53 (decVar -> VAR ID EQUAL ID .)
    COLON           reduce using rule 53 (decVar -> VAR ID EQUAL ID .)
    $end            reduce using rule 53 (decVar -> VAR ID EQUAL ID .)
    RLLAVE          reduce using rule 53 (decVar -> VAR ID EQUAL ID .)
    DEFAULT         reduce using rule 53 (decVar -> VAR ID EQUAL ID .)
    CASE            reduce using rule 53 (decVar -> VAR ID EQUAL ID .)
    AND             reduce using rule 97 (logic_value -> ID .)
    OR              reduce using rule 97 (logic_value -> ID .)
    GREATER         reduce using rule 85 (value -> ID .)
    SMALLER         reduce using rule 85 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 85 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 85 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 85 (value -> ID .)
    NOT_EQUAL       reduce using rule 85 (value -> ID .)
    TIMES           reduce using rule 129 (factor -> ID .)
    DIVIDE          reduce using rule 129 (factor -> ID .)
    PLUS            reduce using rule 129 (factor -> ID .)
    MINUS           reduce using rule 129 (factor -> ID .)

  ! COLON           [ reduce using rule 129 (factor -> ID .) ]
  ! $end            [ reduce using rule 129 (factor -> ID .) ]
  ! RLLAVE          [ reduce using rule 129 (factor -> ID .) ]
  ! GREATER         [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 129 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 129 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 129 (factor -> ID .) ]
  ! DEFAULT         [ reduce using rule 129 (factor -> ID .) ]
  ! CASE            [ reduce using rule 129 (factor -> ID .) ]


state 140

    (52) decVar -> VAR ID EQUAL INTEGER .
    (128) factor -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 52 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 52 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 52 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 52 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 52 (decVar -> VAR ID EQUAL INTEGER .)
    COLON           reduce using rule 52 (decVar -> VAR ID EQUAL INTEGER .)
    $end            reduce using rule 52 (decVar -> VAR ID EQUAL INTEGER .)
    RLLAVE          reduce using rule 52 (decVar -> VAR ID EQUAL INTEGER .)
    DEFAULT         reduce using rule 52 (decVar -> VAR ID EQUAL INTEGER .)
    CASE            reduce using rule 52 (decVar -> VAR ID EQUAL INTEGER .)
    TIMES           reduce using rule 128 (factor -> INTEGER .)
    DIVIDE          reduce using rule 128 (factor -> INTEGER .)
    PLUS            reduce using rule 128 (factor -> INTEGER .)
    MINUS           reduce using rule 128 (factor -> INTEGER .)
    GREATER         reduce using rule 128 (factor -> INTEGER .)
    SMALLER         reduce using rule 128 (factor -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 128 (factor -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 128 (factor -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 128 (factor -> INTEGER .)
    NOT_EQUAL       reduce using rule 128 (factor -> INTEGER .)

  ! COLON           [ reduce using rule 128 (factor -> INTEGER .) ]
  ! $end            [ reduce using rule 128 (factor -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 128 (factor -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 128 (factor -> INTEGER .) ]
  ! CASE            [ reduce using rule 128 (factor -> INTEGER .) ]


state 141

    (54) decVar -> VAR ID EQUAL FLOAT .

    COLON           reduce using rule 54 (decVar -> VAR ID EQUAL FLOAT .)
    $end            reduce using rule 54 (decVar -> VAR ID EQUAL FLOAT .)
    RLLAVE          reduce using rule 54 (decVar -> VAR ID EQUAL FLOAT .)
    DEFAULT         reduce using rule 54 (decVar -> VAR ID EQUAL FLOAT .)
    CASE            reduce using rule 54 (decVar -> VAR ID EQUAL FLOAT .)


state 142

    (55) decVar -> VAR ID EQUAL expression .
    (122) expression -> expression . PLUS term
    (123) expression -> expression . MINUS term
    (86) value -> expression .

    COLON           reduce using rule 55 (decVar -> VAR ID EQUAL expression .)
    $end            reduce using rule 55 (decVar -> VAR ID EQUAL expression .)
    RLLAVE          reduce using rule 55 (decVar -> VAR ID EQUAL expression .)
    DEFAULT         reduce using rule 55 (decVar -> VAR ID EQUAL expression .)
    CASE            reduce using rule 55 (decVar -> VAR ID EQUAL expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39
    GREATER         reduce using rule 86 (value -> expression .)
    SMALLER         reduce using rule 86 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 86 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 86 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 86 (value -> expression .)
    NOT_EQUAL       reduce using rule 86 (value -> expression .)


state 143

    (56) decVar -> VAR ID EQUAL logic_operation .

    COLON           reduce using rule 56 (decVar -> VAR ID EQUAL logic_operation .)
    $end            reduce using rule 56 (decVar -> VAR ID EQUAL logic_operation .)
    RLLAVE          reduce using rule 56 (decVar -> VAR ID EQUAL logic_operation .)
    DEFAULT         reduce using rule 56 (decVar -> VAR ID EQUAL logic_operation .)
    CASE            reduce using rule 56 (decVar -> VAR ID EQUAL logic_operation .)


state 144

    (57) decVar -> VAR ID EQUAL comparison .
    (96) logic_value -> comparison .

    COLON           reduce using rule 57 (decVar -> VAR ID EQUAL comparison .)
    $end            reduce using rule 57 (decVar -> VAR ID EQUAL comparison .)
    RLLAVE          reduce using rule 57 (decVar -> VAR ID EQUAL comparison .)
    DEFAULT         reduce using rule 57 (decVar -> VAR ID EQUAL comparison .)
    CASE            reduce using rule 57 (decVar -> VAR ID EQUAL comparison .)
    AND             reduce using rule 96 (logic_value -> comparison .)
    OR              reduce using rule 96 (logic_value -> comparison .)


state 145

    (59) decVar -> VAR ID EQUAL STRING .

    COLON           reduce using rule 59 (decVar -> VAR ID EQUAL STRING .)
    $end            reduce using rule 59 (decVar -> VAR ID EQUAL STRING .)
    RLLAVE          reduce using rule 59 (decVar -> VAR ID EQUAL STRING .)
    DEFAULT         reduce using rule 59 (decVar -> VAR ID EQUAL STRING .)
    CASE            reduce using rule 59 (decVar -> VAR ID EQUAL STRING .)


state 146

    (108) array_declaration -> VAR ID EQUAL LCORCHE . capacity RCORCHE data_types arr_content
    (109) capacity -> . INTEGER
    (110) capacity -> . ID
    (111) capacity -> . expression
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 150
    ID              shift and go to state 147
    LPAREN          shift and go to state 16

    capacity                       shift and go to state 166
    expression                     shift and go to state 151
    term                           shift and go to state 17
    factor                         shift and go to state 34

state 147

    (110) capacity -> ID .
    (129) factor -> ID .

  ! reduce/reduce conflict for RCORCHE resolved using rule 110 (capacity -> ID .)
    RCORCHE         reduce using rule 110 (capacity -> ID .)
    TIMES           reduce using rule 129 (factor -> ID .)
    DIVIDE          reduce using rule 129 (factor -> ID .)
    PLUS            reduce using rule 129 (factor -> ID .)
    MINUS           reduce using rule 129 (factor -> ID .)

  ! RCORCHE         [ reduce using rule 129 (factor -> ID .) ]


state 148

    (107) array_declaration -> VAR ID LCORCHE capacity . RCORCHE data_types

    RCORCHE         shift and go to state 167


state 149

    (65) sliceC -> VAR ID LCORCHE RCORCHE . data_types
    (26) data_types -> . INT32
    (27) data_types -> . INT64
    (28) data_types -> . FLOAT32
    (29) data_types -> . FLOAT64
    (30) data_types -> . BYTE
    (31) data_types -> . WINT
    (32) data_types -> . WFLOAT
    (33) data_types -> . WSTRING
    (34) data_types -> . BOOL

    INT32           shift and go to state 169
    INT64           shift and go to state 170
    FLOAT32         shift and go to state 171
    FLOAT64         shift and go to state 172
    BYTE            shift and go to state 173
    WINT            shift and go to state 174
    WFLOAT          shift and go to state 175
    WSTRING         shift and go to state 176
    BOOL            shift and go to state 177

    data_types                     shift and go to state 168

state 150

    (109) capacity -> INTEGER .
    (128) factor -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 109 (capacity -> INTEGER .)
    RCORCHE         reduce using rule 109 (capacity -> INTEGER .)
    TIMES           reduce using rule 128 (factor -> INTEGER .)
    DIVIDE          reduce using rule 128 (factor -> INTEGER .)
    PLUS            reduce using rule 128 (factor -> INTEGER .)
    MINUS           reduce using rule 128 (factor -> INTEGER .)

  ! RCORCHE         [ reduce using rule 128 (factor -> INTEGER .) ]


state 151

    (111) capacity -> expression .
    (122) expression -> expression . PLUS term
    (123) expression -> expression . MINUS term

    RCORCHE         reduce using rule 111 (capacity -> expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39


state 152

    (67) sliceC -> ID DEQUAL LCORCHE RCORCHE . data_types arr_content
    (26) data_types -> . INT32
    (27) data_types -> . INT64
    (28) data_types -> . FLOAT32
    (29) data_types -> . FLOAT64
    (30) data_types -> . BYTE
    (31) data_types -> . WINT
    (32) data_types -> . WFLOAT
    (33) data_types -> . WSTRING
    (34) data_types -> . BOOL

    INT32           shift and go to state 169
    INT64           shift and go to state 170
    FLOAT32         shift and go to state 171
    FLOAT64         shift and go to state 172
    BYTE            shift and go to state 173
    WINT            shift and go to state 174
    WFLOAT          shift and go to state 175
    WSTRING         shift and go to state 176
    BOOL            shift and go to state 177

    data_types                     shift and go to state 178

state 153

    (68) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap RPAREN
    (69) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LCORCHE         shift and go to state 179


state 154

    (112) array_var -> ID LCORCHE index RCORCHE .

    COLON           reduce using rule 112 (array_var -> ID LCORCHE index RCORCHE .)
    EQUAL           reduce using rule 112 (array_var -> ID LCORCHE index RCORCHE .)
    $end            reduce using rule 112 (array_var -> ID LCORCHE index RCORCHE .)
    RLLAVE          reduce using rule 112 (array_var -> ID LCORCHE index RCORCHE .)
    DEFAULT         reduce using rule 112 (array_var -> ID LCORCHE index RCORCHE .)
    CASE            reduce using rule 112 (array_var -> ID LCORCHE index RCORCHE .)


state 155

    (73) funciones -> APPEND LPAREN ID COMA . values RPAREN
    (74) funciones -> APPEND LPAREN ID COMA . ID RPAREN
    (21) values -> . STRING
    (22) values -> . INTEGER
    (23) values -> . FLOAT
    (24) values -> . TRUE
    (25) values -> . FALSE

    ID              shift and go to state 180
    STRING          shift and go to state 86
    INTEGER         shift and go to state 182
    FLOAT           shift and go to state 88
    TRUE            shift and go to state 89
    FALSE           shift and go to state 90

    values                         shift and go to state 181

state 156

    (75) funciones -> LEN LPAREN ID RPAREN .

    COLON           reduce using rule 75 (funciones -> LEN LPAREN ID RPAREN .)
    $end            reduce using rule 75 (funciones -> LEN LPAREN ID RPAREN .)
    RLLAVE          reduce using rule 75 (funciones -> LEN LPAREN ID RPAREN .)
    DEFAULT         reduce using rule 75 (funciones -> LEN LPAREN ID RPAREN .)
    CASE            reduce using rule 75 (funciones -> LEN LPAREN ID RPAREN .)


state 157

    (76) funciones -> COPY LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 183


state 158

    (77) funciones -> DELETE LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 184


state 159

    (80) SenIF -> IF LPAREN comparison RPAREN . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 185


state 160

    (81) SenStruct -> TYPE ID STRUCT LLLAVE . declaration RLLAVE
    (82) declaration -> . variable data_types
    (83) variable -> . ID

    ID              shift and go to state 186

    declaration                    shift and go to state 187
    variable                       shift and go to state 188

state 161

    (102) switch_statement -> SWITCH ID LLLAVE cases . RLLAVE

    RLLAVE          shift and go to state 189


state 162

    (103) cases -> CASE . values POINTS codigo
    (104) cases -> CASE . values POINTS codigo more
    (21) values -> . STRING
    (22) values -> . INTEGER
    (23) values -> . FLOAT
    (24) values -> . TRUE
    (25) values -> . FALSE

    STRING          shift and go to state 86
    INTEGER         shift and go to state 182
    FLOAT           shift and go to state 88
    TRUE            shift and go to state 89
    FALSE           shift and go to state 90

    values                         shift and go to state 190

state 163

    (46) cicloFor -> FOR comparison LLLAVE codigo RLLAVE .

    $end            reduce using rule 46 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 46 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 46 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 46 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)


state 164

    (47) cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .

    $end            reduce using rule 47 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 47 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 47 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 47 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)


state 165

    (48) cicloFor -> FOR decVarOne COLON comparison COLON . incre LLLAVE codigo RLLAVE
    (49) incre -> . ID INCREASE
    (50) incre -> . ID DECREASE

    ID              shift and go to state 192

    incre                          shift and go to state 191

state 166

    (108) array_declaration -> VAR ID EQUAL LCORCHE capacity . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 193


state 167

    (107) array_declaration -> VAR ID LCORCHE capacity RCORCHE . data_types
    (26) data_types -> . INT32
    (27) data_types -> . INT64
    (28) data_types -> . FLOAT32
    (29) data_types -> . FLOAT64
    (30) data_types -> . BYTE
    (31) data_types -> . WINT
    (32) data_types -> . WFLOAT
    (33) data_types -> . WSTRING
    (34) data_types -> . BOOL

    INT32           shift and go to state 169
    INT64           shift and go to state 170
    FLOAT32         shift and go to state 171
    FLOAT64         shift and go to state 172
    BYTE            shift and go to state 173
    WINT            shift and go to state 174
    WFLOAT          shift and go to state 175
    WSTRING         shift and go to state 176
    BOOL            shift and go to state 177

    data_types                     shift and go to state 194

state 168

    (65) sliceC -> VAR ID LCORCHE RCORCHE data_types .

    COLON           reduce using rule 65 (sliceC -> VAR ID LCORCHE RCORCHE data_types .)
    $end            reduce using rule 65 (sliceC -> VAR ID LCORCHE RCORCHE data_types .)
    RLLAVE          reduce using rule 65 (sliceC -> VAR ID LCORCHE RCORCHE data_types .)
    DEFAULT         reduce using rule 65 (sliceC -> VAR ID LCORCHE RCORCHE data_types .)
    CASE            reduce using rule 65 (sliceC -> VAR ID LCORCHE RCORCHE data_types .)


state 169

    (26) data_types -> INT32 .

    COLON           reduce using rule 26 (data_types -> INT32 .)
    $end            reduce using rule 26 (data_types -> INT32 .)
    RLLAVE          reduce using rule 26 (data_types -> INT32 .)
    DEFAULT         reduce using rule 26 (data_types -> INT32 .)
    CASE            reduce using rule 26 (data_types -> INT32 .)
    LLLAVE          reduce using rule 26 (data_types -> INT32 .)
    COMA            reduce using rule 26 (data_types -> INT32 .)


state 170

    (27) data_types -> INT64 .

    COLON           reduce using rule 27 (data_types -> INT64 .)
    $end            reduce using rule 27 (data_types -> INT64 .)
    RLLAVE          reduce using rule 27 (data_types -> INT64 .)
    DEFAULT         reduce using rule 27 (data_types -> INT64 .)
    CASE            reduce using rule 27 (data_types -> INT64 .)
    LLLAVE          reduce using rule 27 (data_types -> INT64 .)
    COMA            reduce using rule 27 (data_types -> INT64 .)


state 171

    (28) data_types -> FLOAT32 .

    COLON           reduce using rule 28 (data_types -> FLOAT32 .)
    $end            reduce using rule 28 (data_types -> FLOAT32 .)
    RLLAVE          reduce using rule 28 (data_types -> FLOAT32 .)
    DEFAULT         reduce using rule 28 (data_types -> FLOAT32 .)
    CASE            reduce using rule 28 (data_types -> FLOAT32 .)
    LLLAVE          reduce using rule 28 (data_types -> FLOAT32 .)
    COMA            reduce using rule 28 (data_types -> FLOAT32 .)


state 172

    (29) data_types -> FLOAT64 .

    COLON           reduce using rule 29 (data_types -> FLOAT64 .)
    $end            reduce using rule 29 (data_types -> FLOAT64 .)
    RLLAVE          reduce using rule 29 (data_types -> FLOAT64 .)
    DEFAULT         reduce using rule 29 (data_types -> FLOAT64 .)
    CASE            reduce using rule 29 (data_types -> FLOAT64 .)
    LLLAVE          reduce using rule 29 (data_types -> FLOAT64 .)
    COMA            reduce using rule 29 (data_types -> FLOAT64 .)


state 173

    (30) data_types -> BYTE .

    COLON           reduce using rule 30 (data_types -> BYTE .)
    $end            reduce using rule 30 (data_types -> BYTE .)
    RLLAVE          reduce using rule 30 (data_types -> BYTE .)
    DEFAULT         reduce using rule 30 (data_types -> BYTE .)
    CASE            reduce using rule 30 (data_types -> BYTE .)
    LLLAVE          reduce using rule 30 (data_types -> BYTE .)
    COMA            reduce using rule 30 (data_types -> BYTE .)


state 174

    (31) data_types -> WINT .

    COLON           reduce using rule 31 (data_types -> WINT .)
    $end            reduce using rule 31 (data_types -> WINT .)
    RLLAVE          reduce using rule 31 (data_types -> WINT .)
    DEFAULT         reduce using rule 31 (data_types -> WINT .)
    CASE            reduce using rule 31 (data_types -> WINT .)
    LLLAVE          reduce using rule 31 (data_types -> WINT .)
    COMA            reduce using rule 31 (data_types -> WINT .)


state 175

    (32) data_types -> WFLOAT .

    COLON           reduce using rule 32 (data_types -> WFLOAT .)
    $end            reduce using rule 32 (data_types -> WFLOAT .)
    RLLAVE          reduce using rule 32 (data_types -> WFLOAT .)
    DEFAULT         reduce using rule 32 (data_types -> WFLOAT .)
    CASE            reduce using rule 32 (data_types -> WFLOAT .)
    LLLAVE          reduce using rule 32 (data_types -> WFLOAT .)
    COMA            reduce using rule 32 (data_types -> WFLOAT .)


state 176

    (33) data_types -> WSTRING .

    COLON           reduce using rule 33 (data_types -> WSTRING .)
    $end            reduce using rule 33 (data_types -> WSTRING .)
    RLLAVE          reduce using rule 33 (data_types -> WSTRING .)
    DEFAULT         reduce using rule 33 (data_types -> WSTRING .)
    CASE            reduce using rule 33 (data_types -> WSTRING .)
    LLLAVE          reduce using rule 33 (data_types -> WSTRING .)
    COMA            reduce using rule 33 (data_types -> WSTRING .)


state 177

    (34) data_types -> BOOL .

    COLON           reduce using rule 34 (data_types -> BOOL .)
    $end            reduce using rule 34 (data_types -> BOOL .)
    RLLAVE          reduce using rule 34 (data_types -> BOOL .)
    DEFAULT         reduce using rule 34 (data_types -> BOOL .)
    CASE            reduce using rule 34 (data_types -> BOOL .)
    LLLAVE          reduce using rule 34 (data_types -> BOOL .)
    COMA            reduce using rule 34 (data_types -> BOOL .)


state 178

    (67) sliceC -> ID DEQUAL LCORCHE RCORCHE data_types . arr_content
    (39) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (40) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 196

    arr_content                    shift and go to state 195

state 179

    (68) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap RPAREN
    (69) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap COMA cap RPAREN

    RCORCHE         shift and go to state 197


state 180

    (74) funciones -> APPEND LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 198


state 181

    (73) funciones -> APPEND LPAREN ID COMA values . RPAREN

    RPAREN          shift and go to state 199


state 182

    (22) values -> INTEGER .

    RPAREN          reduce using rule 22 (values -> INTEGER .)
    POINTS          reduce using rule 22 (values -> INTEGER .)


state 183

    (76) funciones -> COPY LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 200


state 184

    (77) funciones -> DELETE LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 201


state 185

    (80) SenIF -> IF LPAREN comparison RPAREN LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (121) impresion -> . PRINT LPAREN expression RPAREN
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (45) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (46) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (47) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (48) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (84) comparison -> . value op value
    (93) logic_operation -> . logic_value logic_op logic_value
    (94) logic_operation -> . negation
    (51) decVar -> . decVarOne
    (52) decVar -> . VAR ID EQUAL INTEGER
    (53) decVar -> . VAR ID EQUAL ID
    (54) decVar -> . VAR ID EQUAL FLOAT
    (55) decVar -> . VAR ID EQUAL expression
    (56) decVar -> . VAR ID EQUAL logic_operation
    (57) decVar -> . VAR ID EQUAL comparison
    (58) decVar -> . sliceC
    (59) decVar -> . VAR ID EQUAL STRING
    (60) decVar -> . ID DEQUAL STRING
    (61) decVar -> . ID DEQUAL FLOAT
    (62) decVar -> . ID DEQUAL expression
    (63) decVar -> . ID DEQUAL logic_operation
    (64) decVar -> . ID DEQUAL comparison
    (73) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (74) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (75) funciones -> . LEN LPAREN ID RPAREN
    (76) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (77) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (80) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (81) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (102) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (107) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (108) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (112) array_var -> . ID LCORCHE index RCORCHE
    (116) array_assignment -> . array_var EQUAL something
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (85) value -> . ID
    (86) value -> . expression
    (95) logic_value -> . negation
    (96) logic_value -> . comparison
    (97) logic_value -> . ID
    (98) negation -> . NOT comparison
    (99) negation -> . NOT ID
    (78) decVarOne -> . ID DEQUAL ID
    (79) decVarOne -> . ID DEQUAL INTEGER
    (65) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (66) sliceC -> . ID DEQUAL funM
    (67) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 15
    FOR             shift and go to state 18
    VAR             shift and go to state 23
    ID              shift and go to state 24
    APPEND          shift and go to state 27
    LEN             shift and go to state 28
    COPY            shift and go to state 29
    DELETE          shift and go to state 30
    IF              shift and go to state 31
    TYPE            shift and go to state 32
    SWITCH          shift and go to state 33
    NOT             shift and go to state 35
    INTEGER         shift and go to state 25
    LPAREN          shift and go to state 16

    comparison                     shift and go to state 5
    codigo                         shift and go to state 202
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    term                           shift and go to state 17
    decVarOne                      shift and go to state 19
    value                          shift and go to state 20
    logic_value                    shift and go to state 21
    negation                       shift and go to state 22
    sliceC                         shift and go to state 26
    factor                         shift and go to state 34

state 186

    (83) variable -> ID .

    INT32           reduce using rule 83 (variable -> ID .)
    INT64           reduce using rule 83 (variable -> ID .)
    FLOAT32         reduce using rule 83 (variable -> ID .)
    FLOAT64         reduce using rule 83 (variable -> ID .)
    BYTE            reduce using rule 83 (variable -> ID .)
    WINT            reduce using rule 83 (variable -> ID .)
    WFLOAT          reduce using rule 83 (variable -> ID .)
    WSTRING         reduce using rule 83 (variable -> ID .)
    BOOL            reduce using rule 83 (variable -> ID .)


state 187

    (81) SenStruct -> TYPE ID STRUCT LLLAVE declaration . RLLAVE

    RLLAVE          shift and go to state 203


state 188

    (82) declaration -> variable . data_types
    (26) data_types -> . INT32
    (27) data_types -> . INT64
    (28) data_types -> . FLOAT32
    (29) data_types -> . FLOAT64
    (30) data_types -> . BYTE
    (31) data_types -> . WINT
    (32) data_types -> . WFLOAT
    (33) data_types -> . WSTRING
    (34) data_types -> . BOOL

    INT32           shift and go to state 169
    INT64           shift and go to state 170
    FLOAT32         shift and go to state 171
    FLOAT64         shift and go to state 172
    BYTE            shift and go to state 173
    WINT            shift and go to state 174
    WFLOAT          shift and go to state 175
    WSTRING         shift and go to state 176
    BOOL            shift and go to state 177

    data_types                     shift and go to state 204

state 189

    (102) switch_statement -> SWITCH ID LLLAVE cases RLLAVE .

    $end            reduce using rule 102 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RLLAVE          reduce using rule 102 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    DEFAULT         reduce using rule 102 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    CASE            reduce using rule 102 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)


state 190

    (103) cases -> CASE values . POINTS codigo
    (104) cases -> CASE values . POINTS codigo more

    POINTS          shift and go to state 205


state 191

    (48) cicloFor -> FOR decVarOne COLON comparison COLON incre . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 206


state 192

    (49) incre -> ID . INCREASE
    (50) incre -> ID . DECREASE

    INCREASE        shift and go to state 207
    DECREASE        shift and go to state 208


state 193

    (108) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE . data_types arr_content
    (26) data_types -> . INT32
    (27) data_types -> . INT64
    (28) data_types -> . FLOAT32
    (29) data_types -> . FLOAT64
    (30) data_types -> . BYTE
    (31) data_types -> . WINT
    (32) data_types -> . WFLOAT
    (33) data_types -> . WSTRING
    (34) data_types -> . BOOL

    INT32           shift and go to state 169
    INT64           shift and go to state 170
    FLOAT32         shift and go to state 171
    FLOAT64         shift and go to state 172
    BYTE            shift and go to state 173
    WINT            shift and go to state 174
    WFLOAT          shift and go to state 175
    WSTRING         shift and go to state 176
    BOOL            shift and go to state 177

    data_types                     shift and go to state 209

state 194

    (107) array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .

    COLON           reduce using rule 107 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    $end            reduce using rule 107 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RLLAVE          reduce using rule 107 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    DEFAULT         reduce using rule 107 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    CASE            reduce using rule 107 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)


state 195

    (67) sliceC -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .

    COLON           reduce using rule 67 (sliceC -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    $end            reduce using rule 67 (sliceC -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 67 (sliceC -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 67 (sliceC -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    CASE            reduce using rule 67 (sliceC -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)


state 196

    (39) arr_content -> LLLAVE . items COMA more_items RLLAVE
    (40) arr_content -> LLLAVE . items RLLAVE
    (43) items -> . values
    (44) items -> . operations
    (21) values -> . STRING
    (22) values -> . INTEGER
    (23) values -> . FLOAT
    (24) values -> . TRUE
    (25) values -> . FALSE
    (35) operations -> . expression
    (36) operations -> . comparison
    (37) operations -> . logic_operation
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (84) comparison -> . value op value
    (93) logic_operation -> . logic_value logic_op logic_value
    (94) logic_operation -> . negation
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (85) value -> . ID
    (86) value -> . expression
    (95) logic_value -> . negation
    (96) logic_value -> . comparison
    (97) logic_value -> . ID
    (98) negation -> . NOT comparison
    (99) negation -> . NOT ID
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    STRING          shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    TRUE            shift and go to state 89
    FALSE           shift and go to state 90
    ID              shift and go to state 213
    NOT             shift and go to state 35
    LPAREN          shift and go to state 16

    items                          shift and go to state 210
    values                         shift and go to state 211
    operations                     shift and go to state 212
    expression                     shift and go to state 91
    comparison                     shift and go to state 92
    logic_operation                shift and go to state 93
    term                           shift and go to state 17
    value                          shift and go to state 20
    logic_value                    shift and go to state 21
    negation                       shift and go to state 22
    factor                         shift and go to state 34

state 197

    (68) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap RPAREN
    (69) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap COMA cap RPAREN
    (26) data_types -> . INT32
    (27) data_types -> . INT64
    (28) data_types -> . FLOAT32
    (29) data_types -> . FLOAT64
    (30) data_types -> . BYTE
    (31) data_types -> . WINT
    (32) data_types -> . WFLOAT
    (33) data_types -> . WSTRING
    (34) data_types -> . BOOL

    INT32           shift and go to state 169
    INT64           shift and go to state 170
    FLOAT32         shift and go to state 171
    FLOAT64         shift and go to state 172
    BYTE            shift and go to state 173
    WINT            shift and go to state 174
    WFLOAT          shift and go to state 175
    WSTRING         shift and go to state 176
    BOOL            shift and go to state 177

    data_types                     shift and go to state 214

state 198

    (74) funciones -> APPEND LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 74 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 74 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 74 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 74 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 74 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)


state 199

    (73) funciones -> APPEND LPAREN ID COMA values RPAREN .

    COLON           reduce using rule 73 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    $end            reduce using rule 73 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RLLAVE          reduce using rule 73 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DEFAULT         reduce using rule 73 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    CASE            reduce using rule 73 (funciones -> APPEND LPAREN ID COMA values RPAREN .)


state 200

    (76) funciones -> COPY LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 76 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 76 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 76 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 76 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 76 (funciones -> COPY LPAREN ID COMA ID RPAREN .)


state 201

    (77) funciones -> DELETE LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 77 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 77 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 77 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 77 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 77 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)


state 202

    (80) SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 215


state 203

    (81) SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .

    $end            reduce using rule 81 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RLLAVE          reduce using rule 81 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    DEFAULT         reduce using rule 81 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    CASE            reduce using rule 81 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)


state 204

    (82) declaration -> variable data_types .

    RLLAVE          reduce using rule 82 (declaration -> variable data_types .)


state 205

    (103) cases -> CASE values POINTS . codigo
    (104) cases -> CASE values POINTS . codigo more
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (121) impresion -> . PRINT LPAREN expression RPAREN
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (45) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (46) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (47) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (48) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (84) comparison -> . value op value
    (93) logic_operation -> . logic_value logic_op logic_value
    (94) logic_operation -> . negation
    (51) decVar -> . decVarOne
    (52) decVar -> . VAR ID EQUAL INTEGER
    (53) decVar -> . VAR ID EQUAL ID
    (54) decVar -> . VAR ID EQUAL FLOAT
    (55) decVar -> . VAR ID EQUAL expression
    (56) decVar -> . VAR ID EQUAL logic_operation
    (57) decVar -> . VAR ID EQUAL comparison
    (58) decVar -> . sliceC
    (59) decVar -> . VAR ID EQUAL STRING
    (60) decVar -> . ID DEQUAL STRING
    (61) decVar -> . ID DEQUAL FLOAT
    (62) decVar -> . ID DEQUAL expression
    (63) decVar -> . ID DEQUAL logic_operation
    (64) decVar -> . ID DEQUAL comparison
    (73) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (74) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (75) funciones -> . LEN LPAREN ID RPAREN
    (76) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (77) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (80) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (81) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (102) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (107) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (108) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (112) array_var -> . ID LCORCHE index RCORCHE
    (116) array_assignment -> . array_var EQUAL something
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (85) value -> . ID
    (86) value -> . expression
    (95) logic_value -> . negation
    (96) logic_value -> . comparison
    (97) logic_value -> . ID
    (98) negation -> . NOT comparison
    (99) negation -> . NOT ID
    (78) decVarOne -> . ID DEQUAL ID
    (79) decVarOne -> . ID DEQUAL INTEGER
    (65) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (66) sliceC -> . ID DEQUAL funM
    (67) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 15
    FOR             shift and go to state 18
    VAR             shift and go to state 23
    ID              shift and go to state 24
    APPEND          shift and go to state 27
    LEN             shift and go to state 28
    COPY            shift and go to state 29
    DELETE          shift and go to state 30
    IF              shift and go to state 31
    TYPE            shift and go to state 32
    SWITCH          shift and go to state 33
    NOT             shift and go to state 35
    INTEGER         shift and go to state 25
    LPAREN          shift and go to state 16

    codigo                         shift and go to state 216
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    term                           shift and go to state 17
    decVarOne                      shift and go to state 19
    value                          shift and go to state 20
    logic_value                    shift and go to state 21
    negation                       shift and go to state 22
    sliceC                         shift and go to state 26
    factor                         shift and go to state 34

state 206

    (48) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (121) impresion -> . PRINT LPAREN expression RPAREN
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (45) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (46) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (47) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (48) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (84) comparison -> . value op value
    (93) logic_operation -> . logic_value logic_op logic_value
    (94) logic_operation -> . negation
    (51) decVar -> . decVarOne
    (52) decVar -> . VAR ID EQUAL INTEGER
    (53) decVar -> . VAR ID EQUAL ID
    (54) decVar -> . VAR ID EQUAL FLOAT
    (55) decVar -> . VAR ID EQUAL expression
    (56) decVar -> . VAR ID EQUAL logic_operation
    (57) decVar -> . VAR ID EQUAL comparison
    (58) decVar -> . sliceC
    (59) decVar -> . VAR ID EQUAL STRING
    (60) decVar -> . ID DEQUAL STRING
    (61) decVar -> . ID DEQUAL FLOAT
    (62) decVar -> . ID DEQUAL expression
    (63) decVar -> . ID DEQUAL logic_operation
    (64) decVar -> . ID DEQUAL comparison
    (73) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (74) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (75) funciones -> . LEN LPAREN ID RPAREN
    (76) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (77) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (80) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (81) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (102) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (107) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (108) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (112) array_var -> . ID LCORCHE index RCORCHE
    (116) array_assignment -> . array_var EQUAL something
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (85) value -> . ID
    (86) value -> . expression
    (95) logic_value -> . negation
    (96) logic_value -> . comparison
    (97) logic_value -> . ID
    (98) negation -> . NOT comparison
    (99) negation -> . NOT ID
    (78) decVarOne -> . ID DEQUAL ID
    (79) decVarOne -> . ID DEQUAL INTEGER
    (65) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (66) sliceC -> . ID DEQUAL funM
    (67) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 15
    FOR             shift and go to state 18
    VAR             shift and go to state 23
    ID              shift and go to state 24
    APPEND          shift and go to state 27
    LEN             shift and go to state 28
    COPY            shift and go to state 29
    DELETE          shift and go to state 30
    IF              shift and go to state 31
    TYPE            shift and go to state 32
    SWITCH          shift and go to state 33
    NOT             shift and go to state 35
    INTEGER         shift and go to state 25
    LPAREN          shift and go to state 16

    decVarOne                      shift and go to state 19
    comparison                     shift and go to state 5
    codigo                         shift and go to state 217
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    term                           shift and go to state 17
    value                          shift and go to state 20
    logic_value                    shift and go to state 21
    negation                       shift and go to state 22
    sliceC                         shift and go to state 26
    factor                         shift and go to state 34

state 207

    (49) incre -> ID INCREASE .

    LLLAVE          reduce using rule 49 (incre -> ID INCREASE .)


state 208

    (50) incre -> ID DECREASE .

    LLLAVE          reduce using rule 50 (incre -> ID DECREASE .)


state 209

    (108) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types . arr_content
    (39) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (40) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 196

    arr_content                    shift and go to state 218

state 210

    (39) arr_content -> LLLAVE items . COMA more_items RLLAVE
    (40) arr_content -> LLLAVE items . RLLAVE

    COMA            shift and go to state 219
    RLLAVE          shift and go to state 220


state 211

    (43) items -> values .

    COMA            reduce using rule 43 (items -> values .)
    RLLAVE          reduce using rule 43 (items -> values .)


state 212

    (44) items -> operations .

    COMA            reduce using rule 44 (items -> operations .)
    RLLAVE          reduce using rule 44 (items -> operations .)


state 213

    (85) value -> ID .
    (97) logic_value -> ID .
    (129) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 85 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 85 (value -> ID .)
    GREATER         reduce using rule 85 (value -> ID .)
    SMALLER         reduce using rule 85 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 85 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 85 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 85 (value -> ID .)
    NOT_EQUAL       reduce using rule 85 (value -> ID .)
    AND             reduce using rule 97 (logic_value -> ID .)
    OR              reduce using rule 97 (logic_value -> ID .)
    TIMES           reduce using rule 129 (factor -> ID .)
    DIVIDE          reduce using rule 129 (factor -> ID .)
    PLUS            reduce using rule 129 (factor -> ID .)
    MINUS           reduce using rule 129 (factor -> ID .)
    COMA            reduce using rule 129 (factor -> ID .)
    RLLAVE          reduce using rule 129 (factor -> ID .)

  ! GREATER         [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 129 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 129 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 129 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 129 (factor -> ID .) ]


state 214

    (68) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap RPAREN
    (69) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap COMA cap RPAREN

    COMA            shift and go to state 221


state 215

    (80) SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .

    $end            reduce using rule 80 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 80 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 80 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 80 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)


state 216

    (103) cases -> CASE values POINTS codigo .
    (104) cases -> CASE values POINTS codigo . more
    (105) more -> . cases
    (106) more -> . DEFAULT POINTS codigo
    (103) cases -> . CASE values POINTS codigo
    (104) cases -> . CASE values POINTS codigo more

    RLLAVE          reduce using rule 103 (cases -> CASE values POINTS codigo .)
    DEFAULT         shift and go to state 224
    CASE            shift and go to state 162

    more                           shift and go to state 222
    cases                          shift and go to state 223

state 217

    (48) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 225


state 218

    (108) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .

    COLON           reduce using rule 108 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    $end            reduce using rule 108 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 108 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 108 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    CASE            reduce using rule 108 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)


state 219

    (39) arr_content -> LLLAVE items COMA . more_items RLLAVE
    (41) more_items -> . items COMA more_items
    (42) more_items -> . items
    (43) items -> . values
    (44) items -> . operations
    (21) values -> . STRING
    (22) values -> . INTEGER
    (23) values -> . FLOAT
    (24) values -> . TRUE
    (25) values -> . FALSE
    (35) operations -> . expression
    (36) operations -> . comparison
    (37) operations -> . logic_operation
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (84) comparison -> . value op value
    (93) logic_operation -> . logic_value logic_op logic_value
    (94) logic_operation -> . negation
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (85) value -> . ID
    (86) value -> . expression
    (95) logic_value -> . negation
    (96) logic_value -> . comparison
    (97) logic_value -> . ID
    (98) negation -> . NOT comparison
    (99) negation -> . NOT ID
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    STRING          shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    TRUE            shift and go to state 89
    FALSE           shift and go to state 90
    ID              shift and go to state 213
    NOT             shift and go to state 35
    LPAREN          shift and go to state 16

    items                          shift and go to state 226
    more_items                     shift and go to state 227
    values                         shift and go to state 211
    operations                     shift and go to state 212
    expression                     shift and go to state 91
    comparison                     shift and go to state 92
    logic_operation                shift and go to state 93
    term                           shift and go to state 17
    value                          shift and go to state 20
    logic_value                    shift and go to state 21
    negation                       shift and go to state 22
    factor                         shift and go to state 34

state 220

    (40) arr_content -> LLLAVE items RLLAVE .

    COLON           reduce using rule 40 (arr_content -> LLLAVE items RLLAVE .)
    $end            reduce using rule 40 (arr_content -> LLLAVE items RLLAVE .)
    RLLAVE          reduce using rule 40 (arr_content -> LLLAVE items RLLAVE .)
    DEFAULT         reduce using rule 40 (arr_content -> LLLAVE items RLLAVE .)
    CASE            reduce using rule 40 (arr_content -> LLLAVE items RLLAVE .)


state 221

    (68) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap RPAREN
    (69) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap COMA cap RPAREN
    (70) cap -> . INTEGER
    (71) cap -> . ID
    (72) cap -> . expression
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 229
    ID              shift and go to state 230
    LPAREN          shift and go to state 16

    cap                            shift and go to state 228
    expression                     shift and go to state 231
    term                           shift and go to state 17
    factor                         shift and go to state 34

state 222

    (104) cases -> CASE values POINTS codigo more .

    RLLAVE          reduce using rule 104 (cases -> CASE values POINTS codigo more .)


state 223

    (105) more -> cases .

    RLLAVE          reduce using rule 105 (more -> cases .)


state 224

    (106) more -> DEFAULT . POINTS codigo

    POINTS          shift and go to state 232


state 225

    (48) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .

    $end            reduce using rule 48 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 48 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 48 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 48 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)


state 226

    (41) more_items -> items . COMA more_items
    (42) more_items -> items .

    COMA            shift and go to state 233
    RLLAVE          reduce using rule 42 (more_items -> items .)


state 227

    (39) arr_content -> LLLAVE items COMA more_items . RLLAVE

    RLLAVE          shift and go to state 234


state 228

    (68) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . RPAREN
    (69) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . COMA cap RPAREN

    RPAREN          shift and go to state 236
    COMA            shift and go to state 235


state 229

    (70) cap -> INTEGER .
    (128) factor -> INTEGER .

  ! reduce/reduce conflict for RPAREN resolved using rule 70 (cap -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 70 (cap -> INTEGER .)
    RPAREN          reduce using rule 70 (cap -> INTEGER .)
    COMA            reduce using rule 70 (cap -> INTEGER .)
    TIMES           reduce using rule 128 (factor -> INTEGER .)
    DIVIDE          reduce using rule 128 (factor -> INTEGER .)
    PLUS            reduce using rule 128 (factor -> INTEGER .)
    MINUS           reduce using rule 128 (factor -> INTEGER .)

  ! RPAREN          [ reduce using rule 128 (factor -> INTEGER .) ]
  ! COMA            [ reduce using rule 128 (factor -> INTEGER .) ]


state 230

    (71) cap -> ID .
    (129) factor -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 71 (cap -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 71 (cap -> ID .)
    RPAREN          reduce using rule 71 (cap -> ID .)
    COMA            reduce using rule 71 (cap -> ID .)
    TIMES           reduce using rule 129 (factor -> ID .)
    DIVIDE          reduce using rule 129 (factor -> ID .)
    PLUS            reduce using rule 129 (factor -> ID .)
    MINUS           reduce using rule 129 (factor -> ID .)

  ! RPAREN          [ reduce using rule 129 (factor -> ID .) ]
  ! COMA            [ reduce using rule 129 (factor -> ID .) ]


state 231

    (72) cap -> expression .
    (122) expression -> expression . PLUS term
    (123) expression -> expression . MINUS term

    RPAREN          reduce using rule 72 (cap -> expression .)
    COMA            reduce using rule 72 (cap -> expression .)
    PLUS            shift and go to state 38
    MINUS           shift and go to state 39


state 232

    (106) more -> DEFAULT POINTS . codigo
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (121) impresion -> . PRINT LPAREN expression RPAREN
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (45) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (46) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (47) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (48) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (84) comparison -> . value op value
    (93) logic_operation -> . logic_value logic_op logic_value
    (94) logic_operation -> . negation
    (51) decVar -> . decVarOne
    (52) decVar -> . VAR ID EQUAL INTEGER
    (53) decVar -> . VAR ID EQUAL ID
    (54) decVar -> . VAR ID EQUAL FLOAT
    (55) decVar -> . VAR ID EQUAL expression
    (56) decVar -> . VAR ID EQUAL logic_operation
    (57) decVar -> . VAR ID EQUAL comparison
    (58) decVar -> . sliceC
    (59) decVar -> . VAR ID EQUAL STRING
    (60) decVar -> . ID DEQUAL STRING
    (61) decVar -> . ID DEQUAL FLOAT
    (62) decVar -> . ID DEQUAL expression
    (63) decVar -> . ID DEQUAL logic_operation
    (64) decVar -> . ID DEQUAL comparison
    (73) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (74) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (75) funciones -> . LEN LPAREN ID RPAREN
    (76) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (77) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (80) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (81) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (102) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (107) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (108) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (112) array_var -> . ID LCORCHE index RCORCHE
    (116) array_assignment -> . array_var EQUAL something
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (85) value -> . ID
    (86) value -> . expression
    (95) logic_value -> . negation
    (96) logic_value -> . comparison
    (97) logic_value -> . ID
    (98) negation -> . NOT comparison
    (99) negation -> . NOT ID
    (78) decVarOne -> . ID DEQUAL ID
    (79) decVarOne -> . ID DEQUAL INTEGER
    (65) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (66) sliceC -> . ID DEQUAL funM
    (67) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 15
    FOR             shift and go to state 18
    VAR             shift and go to state 23
    ID              shift and go to state 24
    APPEND          shift and go to state 27
    LEN             shift and go to state 28
    COPY            shift and go to state 29
    DELETE          shift and go to state 30
    IF              shift and go to state 31
    TYPE            shift and go to state 32
    SWITCH          shift and go to state 33
    NOT             shift and go to state 35
    INTEGER         shift and go to state 25
    LPAREN          shift and go to state 16

    codigo                         shift and go to state 237
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    term                           shift and go to state 17
    decVarOne                      shift and go to state 19
    value                          shift and go to state 20
    logic_value                    shift and go to state 21
    negation                       shift and go to state 22
    sliceC                         shift and go to state 26
    factor                         shift and go to state 34

state 233

    (41) more_items -> items COMA . more_items
    (41) more_items -> . items COMA more_items
    (42) more_items -> . items
    (43) items -> . values
    (44) items -> . operations
    (21) values -> . STRING
    (22) values -> . INTEGER
    (23) values -> . FLOAT
    (24) values -> . TRUE
    (25) values -> . FALSE
    (35) operations -> . expression
    (36) operations -> . comparison
    (37) operations -> . logic_operation
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (84) comparison -> . value op value
    (93) logic_operation -> . logic_value logic_op logic_value
    (94) logic_operation -> . negation
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (85) value -> . ID
    (86) value -> . expression
    (95) logic_value -> . negation
    (96) logic_value -> . comparison
    (97) logic_value -> . ID
    (98) negation -> . NOT comparison
    (99) negation -> . NOT ID
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    STRING          shift and go to state 86
    INTEGER         shift and go to state 87
    FLOAT           shift and go to state 88
    TRUE            shift and go to state 89
    FALSE           shift and go to state 90
    ID              shift and go to state 213
    NOT             shift and go to state 35
    LPAREN          shift and go to state 16

    items                          shift and go to state 226
    more_items                     shift and go to state 238
    values                         shift and go to state 211
    operations                     shift and go to state 212
    expression                     shift and go to state 91
    comparison                     shift and go to state 92
    logic_operation                shift and go to state 93
    term                           shift and go to state 17
    value                          shift and go to state 20
    logic_value                    shift and go to state 21
    negation                       shift and go to state 22
    factor                         shift and go to state 34

state 234

    (39) arr_content -> LLLAVE items COMA more_items RLLAVE .

    COLON           reduce using rule 39 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    $end            reduce using rule 39 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RLLAVE          reduce using rule 39 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    DEFAULT         reduce using rule 39 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    CASE            reduce using rule 39 (arr_content -> LLLAVE items COMA more_items RLLAVE .)


state 235

    (69) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA . cap RPAREN
    (70) cap -> . INTEGER
    (71) cap -> . ID
    (72) cap -> . expression
    (122) expression -> . expression PLUS term
    (123) expression -> . expression MINUS term
    (124) expression -> . term
    (125) term -> . term TIMES factor
    (126) term -> . term DIVIDE factor
    (127) term -> . factor
    (128) factor -> . INTEGER
    (129) factor -> . ID
    (130) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 229
    ID              shift and go to state 230
    LPAREN          shift and go to state 16

    cap                            shift and go to state 239
    expression                     shift and go to state 231
    term                           shift and go to state 17
    factor                         shift and go to state 34

state 236

    (68) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .

    COLON           reduce using rule 68 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    $end            reduce using rule 68 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RLLAVE          reduce using rule 68 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    DEFAULT         reduce using rule 68 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    CASE            reduce using rule 68 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)


state 237

    (106) more -> DEFAULT POINTS codigo .

    RLLAVE          reduce using rule 106 (more -> DEFAULT POINTS codigo .)


state 238

    (41) more_items -> items COMA more_items .

    RLLAVE          reduce using rule 41 (more_items -> items COMA more_items .)


state 239

    (69) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap . RPAREN

    RPAREN          shift and go to state 240


state 240

    (69) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .

    COLON           reduce using rule 69 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    $end            reduce using rule 69 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RLLAVE          reduce using rule 69 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    DEFAULT         reduce using rule 69 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    CASE            reduce using rule 69 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 24 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 24
WARNING: reduce/reduce conflict in state 55 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 55
WARNING: reduce/reduce conflict in state 78 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 78
WARNING: reduce/reduce conflict in state 83 resolved using rule (something -> ID)
WARNING: rejected rule (factor -> ID) in state 83
WARNING: reduce/reduce conflict in state 83 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 83
WARNING: reduce/reduce conflict in state 87 resolved using rule (values -> INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 87
WARNING: reduce/reduce conflict in state 104 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 104
WARNING: reduce/reduce conflict in state 108 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 108
WARNING: reduce/reduce conflict in state 111 resolved using rule (decVarOne -> ID DEQUAL ID)
WARNING: rejected rule (factor -> ID) in state 111
WARNING: reduce/reduce conflict in state 111 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 111
WARNING: reduce/reduce conflict in state 117 resolved using rule (decVarOne -> ID DEQUAL INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 117
WARNING: reduce/reduce conflict in state 121 resolved using rule (index -> ID)
WARNING: rejected rule (factor -> ID) in state 121
WARNING: reduce/reduce conflict in state 123 resolved using rule (index -> INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 123
WARNING: reduce/reduce conflict in state 139 resolved using rule (decVar -> VAR ID EQUAL ID)
WARNING: rejected rule (factor -> ID) in state 139
WARNING: reduce/reduce conflict in state 139 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 139
WARNING: reduce/reduce conflict in state 140 resolved using rule (decVar -> VAR ID EQUAL INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 140
WARNING: reduce/reduce conflict in state 147 resolved using rule (capacity -> ID)
WARNING: rejected rule (factor -> ID) in state 147
WARNING: reduce/reduce conflict in state 150 resolved using rule (capacity -> INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 150
WARNING: reduce/reduce conflict in state 213 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 213
WARNING: reduce/reduce conflict in state 229 resolved using rule (cap -> INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 229
WARNING: reduce/reduce conflict in state 230 resolved using rule (cap -> ID)
WARNING: rejected rule (factor -> ID) in state 230
