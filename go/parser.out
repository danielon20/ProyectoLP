Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    CAP
    COMMENT
    CONST
    ELSE
    INTERFACE
    JOIN
    MAIN
    MAP
    MOD
    MULTI_COMMENT
    PACKAGE
    POINTER
    SCAN

Grammar

Rule 0     S' -> codigo
Rule 1     codigo -> impresion COLON
Rule 2     codigo -> impresion
Rule 3     codigo -> expression COLON
Rule 4     codigo -> expression
Rule 5     codigo -> cicloFor
Rule 6     codigo -> comparison
Rule 7     codigo -> logic_operation
Rule 8     codigo -> decVar COLON
Rule 9     codigo -> decVar
Rule 10    codigo -> funciones
Rule 11    codigo -> funciones COLON
Rule 12    codigo -> SenIF
Rule 13    codigo -> SenStruct
Rule 14    codigo -> switch_statement
Rule 15    codigo -> array_declaration COLON
Rule 16    codigo -> array_declaration
Rule 17    codigo -> array_var COLON
Rule 18    codigo -> array_var
Rule 19    codigo -> array_assignment COLON
Rule 20    codigo -> array_assignment
Rule 21    codigo -> slice_declaration COLON
Rule 22    codigo -> slice_declaration
Rule 23    codigo -> slice_var COLON
Rule 24    codigo -> slice_var
Rule 25    codigo -> slice_assignment COLON
Rule 26    codigo -> slice_assignment
Rule 27    codigo -> map_declaration COLON
Rule 28    codigo -> map_declaration
Rule 29    codigo -> map_assignment COLON
Rule 30    codigo -> map_assignment
Rule 31    codigo -> func_declaration
Rule 32    values -> STRING
Rule 33    values -> INTEGER
Rule 34    values -> FLOAT
Rule 35    values -> TRUE
Rule 36    values -> FALSE
Rule 37    data_types -> INT32
Rule 38    data_types -> INT64
Rule 39    data_types -> FLOAT32
Rule 40    data_types -> FLOAT64
Rule 41    data_types -> BYTE
Rule 42    data_types -> WINT
Rule 43    data_types -> WFLOAT
Rule 44    data_types -> WSTRING
Rule 45    data_types -> BOOL
Rule 46    operations -> expression
Rule 47    operations -> comparison
Rule 48    operations -> logic_operation
Rule 49    data_structure -> array_var
Rule 50    data_structure -> map_var
Rule 51    arr_content -> LLLAVE items COMA more_items RLLAVE
Rule 52    arr_content -> LLLAVE items RLLAVE
Rule 53    more_items -> items COMA more_items
Rule 54    more_items -> items
Rule 55    items -> values
Rule 56    items -> operations
Rule 57    something -> ID
Rule 58    something -> data_structure
Rule 59    something -> values
Rule 60    something -> operations
Rule 61    cicloFor -> FOR LLLAVE codigo RLLAVE
Rule 62    cicloFor -> FOR comparison LLLAVE codigo RLLAVE
Rule 63    cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE
Rule 64    cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
Rule 65    incre -> ID INCREASE
Rule 66    incre -> ID DECREASE
Rule 67    decVar -> decVarOne
Rule 68    decVar -> VAR ID EQUAL INTEGER
Rule 69    decVar -> VAR ID EQUAL ID
Rule 70    decVar -> VAR ID EQUAL FLOAT
Rule 71    decVar -> VAR ID EQUAL expression
Rule 72    decVar -> VAR ID EQUAL logic_operation
Rule 73    decVar -> VAR ID EQUAL comparison
Rule 74    decVar -> VAR ID EQUAL STRING
Rule 75    decVar -> ID DEQUAL STRING
Rule 76    decVar -> ID DEQUAL FLOAT
Rule 77    decVar -> ID DEQUAL expression
Rule 78    decVar -> ID DEQUAL logic_operation
Rule 79    decVar -> ID DEQUAL comparison
Rule 80    slice_declaration -> VAR ID LCORCHE RCORCHE data_types
Rule 81    slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
Rule 82    slice_declaration -> VAR ID EQUAL funM
Rule 83    slice_declaration -> ID DEQUAL funM
Rule 84    slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content
Rule 85    funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
Rule 86    funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
Rule 87    cap -> INTEGER
Rule 88    cap -> ID
Rule 89    cap -> expression
Rule 90    slice_var -> ID LCORCHE index_s RCORCHE
Rule 91    index_s -> ID
Rule 92    index_s -> INTEGER
Rule 93    index_s -> expression
Rule 94    slice_assignment -> slice_var EQUAL something_s
Rule 95    something_s -> ID
Rule 96    something_s -> array_var
Rule 97    something_s -> values
Rule 98    something_s -> operations
Rule 99    funciones -> APPEND LPAREN ID COMA values RPAREN
Rule 100   funciones -> APPEND LPAREN ID COMA ID RPAREN
Rule 101   funciones -> LEN LPAREN ID RPAREN
Rule 102   funciones -> COPY LPAREN ID COMA ID RPAREN
Rule 103   funciones -> DELETE LPAREN ID COMA ID RPAREN
Rule 104   decVarOne -> ID DEQUAL ID
Rule 105   decVarOne -> ID DEQUAL INTEGER
Rule 106   SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
Rule 107   SenIF -> IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
Rule 108   SenIF -> IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
Rule 109   SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE
Rule 110   declaration -> variable data_types
Rule 111   declaration -> declaration variable data_types
Rule 112   variable -> ID
Rule 113   comparison -> value op value
Rule 114   value -> ID
Rule 115   value -> expression
Rule 116   op -> GREATER
Rule 117   op -> SMALLER
Rule 118   op -> GREATER_OR_EQUAL
Rule 119   op -> SMALLER_OR_EQUAL
Rule 120   op -> EQUAL_COMPARE
Rule 121   op -> NOT_EQUAL
Rule 122   logic_operation -> logic_value logic_recu
Rule 123   logic_operation -> negation
Rule 124   logic_recu -> logic_op logic_value
Rule 125   logic_recu -> logic_op logic_value logic_recu
Rule 126   logic_value -> negation
Rule 127   logic_value -> comparison
Rule 128   logic_value -> ID
Rule 129   negation -> NOT comparison
Rule 130   negation -> NOT ID
Rule 131   logic_op -> AND
Rule 132   logic_op -> OR
Rule 133   switch_statement -> SWITCH ID LLLAVE cases RLLAVE
Rule 134   cases -> CASE values POINTS codigo
Rule 135   cases -> CASE values POINTS codigo more
Rule 136   more -> cases
Rule 137   more -> DEFAULT POINTS codigo
Rule 138   array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types
Rule 139   array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
Rule 140   capacity -> INTEGER
Rule 141   capacity -> ID
Rule 142   capacity -> expression
Rule 143   array_var -> ID LCORCHE index RCORCHE
Rule 144   index -> ID
Rule 145   index -> INTEGER
Rule 146   index -> expression
Rule 147   array_assignment -> array_var EQUAL something
Rule 148   map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types
Rule 149   map_var -> ID LCORCHE key RCORCHE
Rule 150   key -> ID
Rule 151   key -> values
Rule 152   key -> operations
Rule 153   map_assignment -> array_var EQUAL something
Rule 154   func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
Rule 155   func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
Rule 156   return_value -> retorno COLON
Rule 157   return_value -> retorno
Rule 158   retorno -> ID
Rule 159   retorno -> values
Rule 160   retorno -> operations
Rule 161   retorno -> data_structure
Rule 162   params -> ID data_types
Rule 163   params -> more_params
Rule 164   more_params -> ID data_types COMA params
Rule 165   impresion -> PRINT LPAREN expression RPAREN
Rule 166   expression -> something_ex
Rule 167   expression -> something_ex adicionaEx
Rule 168   adicionaEx -> op something_ex
Rule 169   adicionaEx -> op something_ex adicionaEx
Rule 170   something_ex -> ID
Rule 171   something_ex -> INTEGER
Rule 172   something_ex -> FLOAT
Rule 173   something_ex -> data_structure
Rule 174   something_ex -> funciones
Rule 175   op -> PLUS
Rule 176   op -> TIMES
Rule 177   op -> DIVIDE
Rule 178   op -> MINUS

Terminals, with rules where they appear

AND                  : 131
APPEND               : 99 100
ARRAY                : 
BOOL                 : 45
BYTE                 : 41
CAP                  : 
CASE                 : 134 135
COLON                : 1 3 8 11 15 17 19 21 23 25 27 29 64 64 156
COMA                 : 51 53 85 86 86 99 100 102 103 164
COMMENT              : 
CONST                : 
COPY                 : 102
DECREASE             : 66
DEFAULT              : 137
DELETE               : 103
DEQUAL               : 75 76 77 78 79 83 84 104 105
DIVIDE               : 177
ELSE                 : 
EQUAL                : 68 69 70 71 72 73 74 81 82 94 139 147 153
EQUAL_COMPARE        : 120
FALSE                : 36 108
FLOAT                : 34 70 76 172
FLOAT32              : 39
FLOAT64              : 40
FOR                  : 61 62 63 64
FUNC                 : 154 155
GREATER              : 116
GREATER_OR_EQUAL     : 118
ID                   : 57 65 66 68 69 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 88 90 91 95 99 100 100 101 102 102 103 103 104 104 105 109 112 114 128 130 133 138 139 141 143 144 148 149 150 154 155 158 162 164 170
IF                   : 106 107 108
INCREASE             : 65
INT32                : 37
INT64                : 38
INTEGER              : 33 68 87 92 105 140 145 171
INTERFACE            : 
JOIN                 : 
LCORCHE              : 80 81 84 85 86 90 138 139 143 148 149
LEN                  : 101
LLLAVE               : 51 52 61 62 63 64 106 107 108 109 133 154 155
LPAREN               : 85 86 99 100 101 102 103 106 107 108 154 155 165
MAIN                 : 
MAKE                 : 85 86
MAP                  : 
MINUS                : 178
MOD                  : 
MULTI_COMMENT        : 
NOT                  : 129 130
NOT_EQUAL            : 121
OR                   : 132
PACKAGE              : 
PLUS                 : 175
POINTER              : 
POINTS               : 134 135 137
PRINT                : 165
RCORCHE              : 80 81 84 85 86 90 138 139 143 148 149
RETURN               : 154 155
RLLAVE               : 51 52 61 62 63 64 106 107 108 109 133 154 155
RPAREN               : 85 86 99 100 101 102 103 106 107 108 154 155 165
SCAN                 : 
SMALLER              : 117
SMALLER_OR_EQUAL     : 119
STRING               : 32 74 75
STRUCT               : 109
SWITCH               : 133
TIMES                : 176
TRUE                 : 35 107
TYPE                 : 109
VAR                  : 68 69 70 71 72 73 74 80 81 82 138 139 148
WFLOAT               : 43
WINT                 : 42
WSTRING              : 44
error                : 

Nonterminals, with rules where they appear

SenIF                : 12
SenStruct            : 13
adicionaEx           : 167 169
arr_content          : 81 84 139
array_assignment     : 19 20
array_declaration    : 15 16
array_var            : 17 18 49 96 147 153
cap                  : 85 86 86
capacity             : 138 139
cases                : 133 136
cicloFor             : 5
codigo               : 61 62 63 64 106 107 108 134 135 137 154 0
comparison           : 6 47 62 64 73 79 106 127 129
data_structure       : 58 161 173
data_types           : 80 81 84 85 86 110 111 138 139 148 148 154 155 162 164
decVar               : 8 9
decVarOne            : 64 67
declaration          : 109 111
expression           : 3 4 46 71 77 89 93 115 142 146 165
funM                 : 82 83
func_declaration     : 31
funciones            : 10 11 174
impresion            : 1 2
incre                : 64
index                : 143
index_s              : 90
items                : 51 52 53 54
key                  : 149
logic_op             : 124 125
logic_operation      : 7 48 63 72 78
logic_recu           : 122 125
logic_value          : 122 124 125
map_assignment       : 29 30
map_declaration      : 27 28
map_var              : 50
more                 : 135
more_items           : 51 53
more_params          : 163
negation             : 123 126
op                   : 113 168 169
operations           : 56 60 98 152 160
params               : 154 155 164
retorno              : 154 156 157
return_value         : 155
slice_assignment     : 25 26
slice_declaration    : 21 22
slice_var            : 23 24 94
something            : 147 153
something_ex         : 166 167 168 169
something_s          : 94
switch_statement     : 14
value                : 113 113
values               : 55 59 97 99 134 135 151 159
variable             : 110 111

Parsing method: LALR

state 0

    (0) S' -> . codigo
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . slice_declaration COLON
    (22) codigo -> . slice_declaration
    (23) codigo -> . slice_var COLON
    (24) codigo -> . slice_var
    (25) codigo -> . slice_assignment COLON
    (26) codigo -> . slice_assignment
    (27) codigo -> . map_declaration COLON
    (28) codigo -> . map_declaration
    (29) codigo -> . map_assignment COLON
    (30) codigo -> . map_assignment
    (31) codigo -> . func_declaration
    (165) impresion -> . PRINT LPAREN expression RPAREN
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (61) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (62) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (63) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (64) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (67) decVar -> . decVarOne
    (68) decVar -> . VAR ID EQUAL INTEGER
    (69) decVar -> . VAR ID EQUAL ID
    (70) decVar -> . VAR ID EQUAL FLOAT
    (71) decVar -> . VAR ID EQUAL expression
    (72) decVar -> . VAR ID EQUAL logic_operation
    (73) decVar -> . VAR ID EQUAL comparison
    (74) decVar -> . VAR ID EQUAL STRING
    (75) decVar -> . ID DEQUAL STRING
    (76) decVar -> . ID DEQUAL FLOAT
    (77) decVar -> . ID DEQUAL expression
    (78) decVar -> . ID DEQUAL logic_operation
    (79) decVar -> . ID DEQUAL comparison
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (106) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (107) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (108) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (109) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (138) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (139) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (143) array_var -> . ID LCORCHE index RCORCHE
    (147) array_assignment -> . array_var EQUAL something
    (80) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (81) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (82) slice_declaration -> . VAR ID EQUAL funM
    (83) slice_declaration -> . ID DEQUAL funM
    (84) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (90) slice_var -> . ID LCORCHE index_s RCORCHE
    (94) slice_assignment -> . slice_var EQUAL something_s
    (148) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (153) map_assignment -> . array_var EQUAL something
    (154) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (104) decVarOne -> . ID DEQUAL ID
    (105) decVarOne -> . ID DEQUAL INTEGER
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (149) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 21
    FOR             shift and go to state 23
    VAR             shift and go to state 28
    ID              shift and go to state 29
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35
    IF              shift and go to state 36
    TYPE            shift and go to state 37
    SWITCH          shift and go to state 38
    FUNC            shift and go to state 39
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    NOT             shift and go to state 41

    codigo                         shift and go to state 1
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    slice_declaration              shift and go to state 15
    slice_var                      shift and go to state 16
    slice_assignment               shift and go to state 17
    map_declaration                shift and go to state 18
    map_assignment                 shift and go to state 19
    func_declaration               shift and go to state 20
    something_ex                   shift and go to state 22
    decVarOne                      shift and go to state 24
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    data_structure                 shift and go to state 40
    map_var                        shift and go to state 42

state 1

    (0) S' -> codigo .



state 2

    (1) codigo -> impresion . COLON
    (2) codigo -> impresion .

    COLON           shift and go to state 43
    $end            reduce using rule 2 (codigo -> impresion .)
    RLLAVE          reduce using rule 2 (codigo -> impresion .)
    DEFAULT         reduce using rule 2 (codigo -> impresion .)
    CASE            reduce using rule 2 (codigo -> impresion .)
    RETURN          reduce using rule 2 (codigo -> impresion .)


state 3

    (3) codigo -> expression . COLON
    (4) codigo -> expression .
    (115) value -> expression .

    COLON           shift and go to state 44
    $end            reduce using rule 4 (codigo -> expression .)
    RLLAVE          reduce using rule 4 (codigo -> expression .)
    DEFAULT         reduce using rule 4 (codigo -> expression .)
    CASE            reduce using rule 4 (codigo -> expression .)
    RETURN          reduce using rule 4 (codigo -> expression .)
    GREATER         reduce using rule 115 (value -> expression .)
    SMALLER         reduce using rule 115 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 115 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 115 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 115 (value -> expression .)
    NOT_EQUAL       reduce using rule 115 (value -> expression .)
    PLUS            reduce using rule 115 (value -> expression .)
    TIMES           reduce using rule 115 (value -> expression .)
    DIVIDE          reduce using rule 115 (value -> expression .)
    MINUS           reduce using rule 115 (value -> expression .)


state 4

    (5) codigo -> cicloFor .

    $end            reduce using rule 5 (codigo -> cicloFor .)
    RLLAVE          reduce using rule 5 (codigo -> cicloFor .)
    DEFAULT         reduce using rule 5 (codigo -> cicloFor .)
    CASE            reduce using rule 5 (codigo -> cicloFor .)
    RETURN          reduce using rule 5 (codigo -> cicloFor .)


state 5

    (6) codigo -> comparison .
    (127) logic_value -> comparison .

    $end            reduce using rule 6 (codigo -> comparison .)
    RLLAVE          reduce using rule 6 (codigo -> comparison .)
    DEFAULT         reduce using rule 6 (codigo -> comparison .)
    CASE            reduce using rule 6 (codigo -> comparison .)
    RETURN          reduce using rule 6 (codigo -> comparison .)
    AND             reduce using rule 127 (logic_value -> comparison .)
    OR              reduce using rule 127 (logic_value -> comparison .)


state 6

    (7) codigo -> logic_operation .

    $end            reduce using rule 7 (codigo -> logic_operation .)
    RLLAVE          reduce using rule 7 (codigo -> logic_operation .)
    DEFAULT         reduce using rule 7 (codigo -> logic_operation .)
    CASE            reduce using rule 7 (codigo -> logic_operation .)
    RETURN          reduce using rule 7 (codigo -> logic_operation .)


state 7

    (8) codigo -> decVar . COLON
    (9) codigo -> decVar .

    COLON           shift and go to state 45
    $end            reduce using rule 9 (codigo -> decVar .)
    RLLAVE          reduce using rule 9 (codigo -> decVar .)
    DEFAULT         reduce using rule 9 (codigo -> decVar .)
    CASE            reduce using rule 9 (codigo -> decVar .)
    RETURN          reduce using rule 9 (codigo -> decVar .)


state 8

    (10) codigo -> funciones .
    (11) codigo -> funciones . COLON
    (174) something_ex -> funciones .

  ! shift/reduce conflict for COLON resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 10 (codigo -> funciones .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 10 (codigo -> funciones .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 10 (codigo -> funciones .)
  ! reduce/reduce conflict for CASE resolved using rule 10 (codigo -> funciones .)
  ! reduce/reduce conflict for RETURN resolved using rule 10 (codigo -> funciones .)
    $end            reduce using rule 10 (codigo -> funciones .)
    RLLAVE          reduce using rule 10 (codigo -> funciones .)
    DEFAULT         reduce using rule 10 (codigo -> funciones .)
    CASE            reduce using rule 10 (codigo -> funciones .)
    RETURN          reduce using rule 10 (codigo -> funciones .)
    COLON           shift and go to state 46
    GREATER         reduce using rule 174 (something_ex -> funciones .)
    SMALLER         reduce using rule 174 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 174 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 174 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 174 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 174 (something_ex -> funciones .)
    PLUS            reduce using rule 174 (something_ex -> funciones .)
    TIMES           reduce using rule 174 (something_ex -> funciones .)
    DIVIDE          reduce using rule 174 (something_ex -> funciones .)
    MINUS           reduce using rule 174 (something_ex -> funciones .)

  ! COLON           [ reduce using rule 174 (something_ex -> funciones .) ]
  ! $end            [ reduce using rule 174 (something_ex -> funciones .) ]
  ! RLLAVE          [ reduce using rule 174 (something_ex -> funciones .) ]
  ! DEFAULT         [ reduce using rule 174 (something_ex -> funciones .) ]
  ! CASE            [ reduce using rule 174 (something_ex -> funciones .) ]
  ! RETURN          [ reduce using rule 174 (something_ex -> funciones .) ]


state 9

    (12) codigo -> SenIF .

    $end            reduce using rule 12 (codigo -> SenIF .)
    RLLAVE          reduce using rule 12 (codigo -> SenIF .)
    DEFAULT         reduce using rule 12 (codigo -> SenIF .)
    CASE            reduce using rule 12 (codigo -> SenIF .)
    RETURN          reduce using rule 12 (codigo -> SenIF .)


state 10

    (13) codigo -> SenStruct .

    $end            reduce using rule 13 (codigo -> SenStruct .)
    RLLAVE          reduce using rule 13 (codigo -> SenStruct .)
    DEFAULT         reduce using rule 13 (codigo -> SenStruct .)
    CASE            reduce using rule 13 (codigo -> SenStruct .)
    RETURN          reduce using rule 13 (codigo -> SenStruct .)


state 11

    (14) codigo -> switch_statement .

    $end            reduce using rule 14 (codigo -> switch_statement .)
    RLLAVE          reduce using rule 14 (codigo -> switch_statement .)
    DEFAULT         reduce using rule 14 (codigo -> switch_statement .)
    CASE            reduce using rule 14 (codigo -> switch_statement .)
    RETURN          reduce using rule 14 (codigo -> switch_statement .)


state 12

    (15) codigo -> array_declaration . COLON
    (16) codigo -> array_declaration .

    COLON           shift and go to state 47
    $end            reduce using rule 16 (codigo -> array_declaration .)
    RLLAVE          reduce using rule 16 (codigo -> array_declaration .)
    DEFAULT         reduce using rule 16 (codigo -> array_declaration .)
    CASE            reduce using rule 16 (codigo -> array_declaration .)
    RETURN          reduce using rule 16 (codigo -> array_declaration .)


state 13

    (17) codigo -> array_var . COLON
    (18) codigo -> array_var .
    (147) array_assignment -> array_var . EQUAL something
    (153) map_assignment -> array_var . EQUAL something
    (49) data_structure -> array_var .

  ! shift/reduce conflict for COLON resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 18 (codigo -> array_var .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 18 (codigo -> array_var .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 18 (codigo -> array_var .)
  ! reduce/reduce conflict for CASE resolved using rule 18 (codigo -> array_var .)
  ! reduce/reduce conflict for RETURN resolved using rule 18 (codigo -> array_var .)
    COLON           shift and go to state 48
    $end            reduce using rule 18 (codigo -> array_var .)
    RLLAVE          reduce using rule 18 (codigo -> array_var .)
    DEFAULT         reduce using rule 18 (codigo -> array_var .)
    CASE            reduce using rule 18 (codigo -> array_var .)
    RETURN          reduce using rule 18 (codigo -> array_var .)
    EQUAL           shift and go to state 49
    GREATER         reduce using rule 49 (data_structure -> array_var .)
    SMALLER         reduce using rule 49 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 49 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 49 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 49 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 49 (data_structure -> array_var .)
    PLUS            reduce using rule 49 (data_structure -> array_var .)
    TIMES           reduce using rule 49 (data_structure -> array_var .)
    DIVIDE          reduce using rule 49 (data_structure -> array_var .)
    MINUS           reduce using rule 49 (data_structure -> array_var .)

  ! COLON           [ reduce using rule 49 (data_structure -> array_var .) ]
  ! $end            [ reduce using rule 49 (data_structure -> array_var .) ]
  ! RLLAVE          [ reduce using rule 49 (data_structure -> array_var .) ]
  ! DEFAULT         [ reduce using rule 49 (data_structure -> array_var .) ]
  ! CASE            [ reduce using rule 49 (data_structure -> array_var .) ]
  ! RETURN          [ reduce using rule 49 (data_structure -> array_var .) ]


state 14

    (19) codigo -> array_assignment . COLON
    (20) codigo -> array_assignment .

    COLON           shift and go to state 50
    $end            reduce using rule 20 (codigo -> array_assignment .)
    RLLAVE          reduce using rule 20 (codigo -> array_assignment .)
    DEFAULT         reduce using rule 20 (codigo -> array_assignment .)
    CASE            reduce using rule 20 (codigo -> array_assignment .)
    RETURN          reduce using rule 20 (codigo -> array_assignment .)


state 15

    (21) codigo -> slice_declaration . COLON
    (22) codigo -> slice_declaration .

    COLON           shift and go to state 51
    $end            reduce using rule 22 (codigo -> slice_declaration .)
    RLLAVE          reduce using rule 22 (codigo -> slice_declaration .)
    DEFAULT         reduce using rule 22 (codigo -> slice_declaration .)
    CASE            reduce using rule 22 (codigo -> slice_declaration .)
    RETURN          reduce using rule 22 (codigo -> slice_declaration .)


state 16

    (23) codigo -> slice_var . COLON
    (24) codigo -> slice_var .
    (94) slice_assignment -> slice_var . EQUAL something_s

    COLON           shift and go to state 52
    $end            reduce using rule 24 (codigo -> slice_var .)
    RLLAVE          reduce using rule 24 (codigo -> slice_var .)
    DEFAULT         reduce using rule 24 (codigo -> slice_var .)
    CASE            reduce using rule 24 (codigo -> slice_var .)
    RETURN          reduce using rule 24 (codigo -> slice_var .)
    EQUAL           shift and go to state 53


state 17

    (25) codigo -> slice_assignment . COLON
    (26) codigo -> slice_assignment .

    COLON           shift and go to state 54
    $end            reduce using rule 26 (codigo -> slice_assignment .)
    RLLAVE          reduce using rule 26 (codigo -> slice_assignment .)
    DEFAULT         reduce using rule 26 (codigo -> slice_assignment .)
    CASE            reduce using rule 26 (codigo -> slice_assignment .)
    RETURN          reduce using rule 26 (codigo -> slice_assignment .)


state 18

    (27) codigo -> map_declaration . COLON
    (28) codigo -> map_declaration .

    COLON           shift and go to state 55
    $end            reduce using rule 28 (codigo -> map_declaration .)
    RLLAVE          reduce using rule 28 (codigo -> map_declaration .)
    DEFAULT         reduce using rule 28 (codigo -> map_declaration .)
    CASE            reduce using rule 28 (codigo -> map_declaration .)
    RETURN          reduce using rule 28 (codigo -> map_declaration .)


state 19

    (29) codigo -> map_assignment . COLON
    (30) codigo -> map_assignment .

    COLON           shift and go to state 56
    $end            reduce using rule 30 (codigo -> map_assignment .)
    RLLAVE          reduce using rule 30 (codigo -> map_assignment .)
    DEFAULT         reduce using rule 30 (codigo -> map_assignment .)
    CASE            reduce using rule 30 (codigo -> map_assignment .)
    RETURN          reduce using rule 30 (codigo -> map_assignment .)


state 20

    (31) codigo -> func_declaration .

    $end            reduce using rule 31 (codigo -> func_declaration .)
    RLLAVE          reduce using rule 31 (codigo -> func_declaration .)
    DEFAULT         reduce using rule 31 (codigo -> func_declaration .)
    CASE            reduce using rule 31 (codigo -> func_declaration .)
    RETURN          reduce using rule 31 (codigo -> func_declaration .)


state 21

    (165) impresion -> PRINT . LPAREN expression RPAREN

    LPAREN          shift and go to state 57


state 22

    (166) expression -> something_ex .
    (167) expression -> something_ex . adicionaEx
    (168) adicionaEx -> . op something_ex
    (169) adicionaEx -> . op something_ex adicionaEx
    (116) op -> . GREATER
    (117) op -> . SMALLER
    (118) op -> . GREATER_OR_EQUAL
    (119) op -> . SMALLER_OR_EQUAL
    (120) op -> . EQUAL_COMPARE
    (121) op -> . NOT_EQUAL
    (175) op -> . PLUS
    (176) op -> . TIMES
    (177) op -> . DIVIDE
    (178) op -> . MINUS

  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL_COMPARE resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    COLON           reduce using rule 166 (expression -> something_ex .)
    $end            reduce using rule 166 (expression -> something_ex .)
    RLLAVE          reduce using rule 166 (expression -> something_ex .)
    DEFAULT         reduce using rule 166 (expression -> something_ex .)
    CASE            reduce using rule 166 (expression -> something_ex .)
    RETURN          reduce using rule 166 (expression -> something_ex .)
    RPAREN          reduce using rule 166 (expression -> something_ex .)
    AND             reduce using rule 166 (expression -> something_ex .)
    OR              reduce using rule 166 (expression -> something_ex .)
    LLLAVE          reduce using rule 166 (expression -> something_ex .)
    RCORCHE         reduce using rule 166 (expression -> something_ex .)
    COMA            reduce using rule 166 (expression -> something_ex .)
    GREATER         shift and go to state 60
    SMALLER         shift and go to state 61
    GREATER_OR_EQUAL shift and go to state 62
    SMALLER_OR_EQUAL shift and go to state 63
    EQUAL_COMPARE   shift and go to state 64
    NOT_EQUAL       shift and go to state 65
    PLUS            shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MINUS           shift and go to state 69

  ! GREATER         [ reduce using rule 166 (expression -> something_ex .) ]
  ! SMALLER         [ reduce using rule 166 (expression -> something_ex .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 166 (expression -> something_ex .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 166 (expression -> something_ex .) ]
  ! EQUAL_COMPARE   [ reduce using rule 166 (expression -> something_ex .) ]
  ! NOT_EQUAL       [ reduce using rule 166 (expression -> something_ex .) ]
  ! PLUS            [ reduce using rule 166 (expression -> something_ex .) ]
  ! TIMES           [ reduce using rule 166 (expression -> something_ex .) ]
  ! DIVIDE          [ reduce using rule 166 (expression -> something_ex .) ]
  ! MINUS           [ reduce using rule 166 (expression -> something_ex .) ]

    adicionaEx                     shift and go to state 58
    op                             shift and go to state 59

state 23

    (61) cicloFor -> FOR . LLLAVE codigo RLLAVE
    (62) cicloFor -> FOR . comparison LLLAVE codigo RLLAVE
    (63) cicloFor -> FOR . logic_operation LLLAVE codigo RLLAVE
    (64) cicloFor -> FOR . decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (104) decVarOne -> . ID DEQUAL ID
    (105) decVarOne -> . ID DEQUAL INTEGER
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    LLLAVE          shift and go to state 70
    ID              shift and go to state 74
    NOT             shift and go to state 41
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    comparison                     shift and go to state 71
    logic_operation                shift and go to state 72
    decVarOne                      shift and go to state 73
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    expression                     shift and go to state 75
    something_ex                   shift and go to state 22
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 24

    (67) decVar -> decVarOne .

    COLON           reduce using rule 67 (decVar -> decVarOne .)
    $end            reduce using rule 67 (decVar -> decVarOne .)
    RLLAVE          reduce using rule 67 (decVar -> decVarOne .)
    DEFAULT         reduce using rule 67 (decVar -> decVarOne .)
    CASE            reduce using rule 67 (decVar -> decVarOne .)
    RETURN          reduce using rule 67 (decVar -> decVarOne .)


state 25

    (113) comparison -> value . op value
    (116) op -> . GREATER
    (117) op -> . SMALLER
    (118) op -> . GREATER_OR_EQUAL
    (119) op -> . SMALLER_OR_EQUAL
    (120) op -> . EQUAL_COMPARE
    (121) op -> . NOT_EQUAL
    (175) op -> . PLUS
    (176) op -> . TIMES
    (177) op -> . DIVIDE
    (178) op -> . MINUS

    GREATER         shift and go to state 60
    SMALLER         shift and go to state 61
    GREATER_OR_EQUAL shift and go to state 62
    SMALLER_OR_EQUAL shift and go to state 63
    EQUAL_COMPARE   shift and go to state 64
    NOT_EQUAL       shift and go to state 65
    PLUS            shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MINUS           shift and go to state 69

    op                             shift and go to state 78

state 26

    (122) logic_operation -> logic_value . logic_recu
    (124) logic_recu -> . logic_op logic_value
    (125) logic_recu -> . logic_op logic_value logic_recu
    (131) logic_op -> . AND
    (132) logic_op -> . OR

    AND             shift and go to state 81
    OR              shift and go to state 82

    logic_recu                     shift and go to state 79
    logic_op                       shift and go to state 80

state 27

    (123) logic_operation -> negation .
    (126) logic_value -> negation .

    $end            reduce using rule 123 (logic_operation -> negation .)
    LLLAVE          reduce using rule 123 (logic_operation -> negation .)
    COLON           reduce using rule 123 (logic_operation -> negation .)
    RLLAVE          reduce using rule 123 (logic_operation -> negation .)
    DEFAULT         reduce using rule 123 (logic_operation -> negation .)
    CASE            reduce using rule 123 (logic_operation -> negation .)
    RETURN          reduce using rule 123 (logic_operation -> negation .)
    RCORCHE         reduce using rule 123 (logic_operation -> negation .)
    COMA            reduce using rule 123 (logic_operation -> negation .)
    AND             reduce using rule 126 (logic_value -> negation .)
    OR              reduce using rule 126 (logic_value -> negation .)


state 28

    (68) decVar -> VAR . ID EQUAL INTEGER
    (69) decVar -> VAR . ID EQUAL ID
    (70) decVar -> VAR . ID EQUAL FLOAT
    (71) decVar -> VAR . ID EQUAL expression
    (72) decVar -> VAR . ID EQUAL logic_operation
    (73) decVar -> VAR . ID EQUAL comparison
    (74) decVar -> VAR . ID EQUAL STRING
    (138) array_declaration -> VAR . ID LCORCHE capacity RCORCHE data_types
    (139) array_declaration -> VAR . ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (80) slice_declaration -> VAR . ID LCORCHE RCORCHE data_types
    (81) slice_declaration -> VAR . ID EQUAL LCORCHE RCORCHE data_types arr_content
    (82) slice_declaration -> VAR . ID EQUAL funM
    (148) map_declaration -> VAR . ID LCORCHE data_types RCORCHE data_types

    ID              shift and go to state 83


state 29

    (75) decVar -> ID . DEQUAL STRING
    (76) decVar -> ID . DEQUAL FLOAT
    (77) decVar -> ID . DEQUAL expression
    (78) decVar -> ID . DEQUAL logic_operation
    (79) decVar -> ID . DEQUAL comparison
    (143) array_var -> ID . LCORCHE index RCORCHE
    (83) slice_declaration -> ID . DEQUAL funM
    (84) slice_declaration -> ID . DEQUAL LCORCHE RCORCHE data_types arr_content
    (90) slice_var -> ID . LCORCHE index_s RCORCHE
    (170) something_ex -> ID .
    (114) value -> ID .
    (128) logic_value -> ID .
    (104) decVarOne -> ID . DEQUAL ID
    (105) decVarOne -> ID . DEQUAL INTEGER
    (149) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 114 (value -> ID .)
    DEQUAL          shift and go to state 84
    LCORCHE         shift and go to state 85
    COLON           reduce using rule 170 (something_ex -> ID .)
    $end            reduce using rule 170 (something_ex -> ID .)
    RLLAVE          reduce using rule 170 (something_ex -> ID .)
    DEFAULT         reduce using rule 170 (something_ex -> ID .)
    CASE            reduce using rule 170 (something_ex -> ID .)
    RETURN          reduce using rule 170 (something_ex -> ID .)
    GREATER         reduce using rule 114 (value -> ID .)
    SMALLER         reduce using rule 114 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 114 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 114 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 114 (value -> ID .)
    NOT_EQUAL       reduce using rule 114 (value -> ID .)
    PLUS            reduce using rule 114 (value -> ID .)
    TIMES           reduce using rule 114 (value -> ID .)
    DIVIDE          reduce using rule 114 (value -> ID .)
    MINUS           reduce using rule 114 (value -> ID .)
    AND             reduce using rule 128 (logic_value -> ID .)
    OR              reduce using rule 128 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 170 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 170 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 170 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 170 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 170 (something_ex -> ID .) ]


state 30

    (171) something_ex -> INTEGER .

    GREATER         reduce using rule 171 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 171 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 171 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 171 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 171 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 171 (something_ex -> INTEGER .)
    PLUS            reduce using rule 171 (something_ex -> INTEGER .)
    TIMES           reduce using rule 171 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 171 (something_ex -> INTEGER .)
    MINUS           reduce using rule 171 (something_ex -> INTEGER .)
    COLON           reduce using rule 171 (something_ex -> INTEGER .)
    $end            reduce using rule 171 (something_ex -> INTEGER .)
    RPAREN          reduce using rule 171 (something_ex -> INTEGER .)
    RLLAVE          reduce using rule 171 (something_ex -> INTEGER .)
    DEFAULT         reduce using rule 171 (something_ex -> INTEGER .)
    CASE            reduce using rule 171 (something_ex -> INTEGER .)
    RETURN          reduce using rule 171 (something_ex -> INTEGER .)
    AND             reduce using rule 171 (something_ex -> INTEGER .)
    OR              reduce using rule 171 (something_ex -> INTEGER .)
    LLLAVE          reduce using rule 171 (something_ex -> INTEGER .)
    RCORCHE         reduce using rule 171 (something_ex -> INTEGER .)
    COMA            reduce using rule 171 (something_ex -> INTEGER .)


state 31

    (172) something_ex -> FLOAT .

    GREATER         reduce using rule 172 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 172 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 172 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 172 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 172 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 172 (something_ex -> FLOAT .)
    PLUS            reduce using rule 172 (something_ex -> FLOAT .)
    TIMES           reduce using rule 172 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 172 (something_ex -> FLOAT .)
    MINUS           reduce using rule 172 (something_ex -> FLOAT .)
    COLON           reduce using rule 172 (something_ex -> FLOAT .)
    $end            reduce using rule 172 (something_ex -> FLOAT .)
    RPAREN          reduce using rule 172 (something_ex -> FLOAT .)
    RLLAVE          reduce using rule 172 (something_ex -> FLOAT .)
    DEFAULT         reduce using rule 172 (something_ex -> FLOAT .)
    CASE            reduce using rule 172 (something_ex -> FLOAT .)
    RETURN          reduce using rule 172 (something_ex -> FLOAT .)
    AND             reduce using rule 172 (something_ex -> FLOAT .)
    OR              reduce using rule 172 (something_ex -> FLOAT .)
    LLLAVE          reduce using rule 172 (something_ex -> FLOAT .)
    RCORCHE         reduce using rule 172 (something_ex -> FLOAT .)
    COMA            reduce using rule 172 (something_ex -> FLOAT .)


state 32

    (99) funciones -> APPEND . LPAREN ID COMA values RPAREN
    (100) funciones -> APPEND . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 86


state 33

    (101) funciones -> LEN . LPAREN ID RPAREN

    LPAREN          shift and go to state 87


state 34

    (102) funciones -> COPY . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 88


state 35

    (103) funciones -> DELETE . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 89


state 36

    (106) SenIF -> IF . LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (107) SenIF -> IF . LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (108) SenIF -> IF . LPAREN FALSE RPAREN LLLAVE codigo RLLAVE

    LPAREN          shift and go to state 90


state 37

    (109) SenStruct -> TYPE . ID STRUCT LLLAVE declaration RLLAVE

    ID              shift and go to state 91


state 38

    (133) switch_statement -> SWITCH . ID LLLAVE cases RLLAVE

    ID              shift and go to state 92


state 39

    (154) func_declaration -> FUNC . ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> FUNC . ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE

    ID              shift and go to state 93


state 40

    (173) something_ex -> data_structure .

    GREATER         reduce using rule 173 (something_ex -> data_structure .)
    SMALLER         reduce using rule 173 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 173 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 173 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 173 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 173 (something_ex -> data_structure .)
    PLUS            reduce using rule 173 (something_ex -> data_structure .)
    TIMES           reduce using rule 173 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 173 (something_ex -> data_structure .)
    MINUS           reduce using rule 173 (something_ex -> data_structure .)
    COLON           reduce using rule 173 (something_ex -> data_structure .)
    $end            reduce using rule 173 (something_ex -> data_structure .)
    RLLAVE          reduce using rule 173 (something_ex -> data_structure .)
    DEFAULT         reduce using rule 173 (something_ex -> data_structure .)
    CASE            reduce using rule 173 (something_ex -> data_structure .)
    RETURN          reduce using rule 173 (something_ex -> data_structure .)
    RPAREN          reduce using rule 173 (something_ex -> data_structure .)
    AND             reduce using rule 173 (something_ex -> data_structure .)
    OR              reduce using rule 173 (something_ex -> data_structure .)
    LLLAVE          reduce using rule 173 (something_ex -> data_structure .)
    RCORCHE         reduce using rule 173 (something_ex -> data_structure .)
    COMA            reduce using rule 173 (something_ex -> data_structure .)


state 41

    (129) negation -> NOT . comparison
    (130) negation -> NOT . ID
    (113) comparison -> . value op value
    (114) value -> . ID
    (115) value -> . expression
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 95
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    comparison                     shift and go to state 94
    value                          shift and go to state 25
    expression                     shift and go to state 75
    something_ex                   shift and go to state 22
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 42

    (50) data_structure -> map_var .

    GREATER         reduce using rule 50 (data_structure -> map_var .)
    SMALLER         reduce using rule 50 (data_structure -> map_var .)
    GREATER_OR_EQUAL reduce using rule 50 (data_structure -> map_var .)
    SMALLER_OR_EQUAL reduce using rule 50 (data_structure -> map_var .)
    EQUAL_COMPARE   reduce using rule 50 (data_structure -> map_var .)
    NOT_EQUAL       reduce using rule 50 (data_structure -> map_var .)
    PLUS            reduce using rule 50 (data_structure -> map_var .)
    TIMES           reduce using rule 50 (data_structure -> map_var .)
    DIVIDE          reduce using rule 50 (data_structure -> map_var .)
    MINUS           reduce using rule 50 (data_structure -> map_var .)
    COLON           reduce using rule 50 (data_structure -> map_var .)
    $end            reduce using rule 50 (data_structure -> map_var .)
    RLLAVE          reduce using rule 50 (data_structure -> map_var .)
    DEFAULT         reduce using rule 50 (data_structure -> map_var .)
    CASE            reduce using rule 50 (data_structure -> map_var .)
    RETURN          reduce using rule 50 (data_structure -> map_var .)
    RPAREN          reduce using rule 50 (data_structure -> map_var .)
    AND             reduce using rule 50 (data_structure -> map_var .)
    OR              reduce using rule 50 (data_structure -> map_var .)
    LLLAVE          reduce using rule 50 (data_structure -> map_var .)
    RCORCHE         reduce using rule 50 (data_structure -> map_var .)
    COMA            reduce using rule 50 (data_structure -> map_var .)


state 43

    (1) codigo -> impresion COLON .

    $end            reduce using rule 1 (codigo -> impresion COLON .)
    RLLAVE          reduce using rule 1 (codigo -> impresion COLON .)
    DEFAULT         reduce using rule 1 (codigo -> impresion COLON .)
    CASE            reduce using rule 1 (codigo -> impresion COLON .)
    RETURN          reduce using rule 1 (codigo -> impresion COLON .)


state 44

    (3) codigo -> expression COLON .

    $end            reduce using rule 3 (codigo -> expression COLON .)
    RLLAVE          reduce using rule 3 (codigo -> expression COLON .)
    DEFAULT         reduce using rule 3 (codigo -> expression COLON .)
    CASE            reduce using rule 3 (codigo -> expression COLON .)
    RETURN          reduce using rule 3 (codigo -> expression COLON .)


state 45

    (8) codigo -> decVar COLON .

    $end            reduce using rule 8 (codigo -> decVar COLON .)
    RLLAVE          reduce using rule 8 (codigo -> decVar COLON .)
    DEFAULT         reduce using rule 8 (codigo -> decVar COLON .)
    CASE            reduce using rule 8 (codigo -> decVar COLON .)
    RETURN          reduce using rule 8 (codigo -> decVar COLON .)


state 46

    (11) codigo -> funciones COLON .

    $end            reduce using rule 11 (codigo -> funciones COLON .)
    RLLAVE          reduce using rule 11 (codigo -> funciones COLON .)
    DEFAULT         reduce using rule 11 (codigo -> funciones COLON .)
    CASE            reduce using rule 11 (codigo -> funciones COLON .)
    RETURN          reduce using rule 11 (codigo -> funciones COLON .)


state 47

    (15) codigo -> array_declaration COLON .

    $end            reduce using rule 15 (codigo -> array_declaration COLON .)
    RLLAVE          reduce using rule 15 (codigo -> array_declaration COLON .)
    DEFAULT         reduce using rule 15 (codigo -> array_declaration COLON .)
    CASE            reduce using rule 15 (codigo -> array_declaration COLON .)
    RETURN          reduce using rule 15 (codigo -> array_declaration COLON .)


state 48

    (17) codigo -> array_var COLON .

    $end            reduce using rule 17 (codigo -> array_var COLON .)
    RLLAVE          reduce using rule 17 (codigo -> array_var COLON .)
    DEFAULT         reduce using rule 17 (codigo -> array_var COLON .)
    CASE            reduce using rule 17 (codigo -> array_var COLON .)
    RETURN          reduce using rule 17 (codigo -> array_var COLON .)


state 49

    (147) array_assignment -> array_var EQUAL . something
    (153) map_assignment -> array_var EQUAL . something
    (57) something -> . ID
    (58) something -> . data_structure
    (59) something -> . values
    (60) something -> . operations
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (32) values -> . STRING
    (33) values -> . INTEGER
    (34) values -> . FLOAT
    (35) values -> . TRUE
    (36) values -> . FALSE
    (46) operations -> . expression
    (47) operations -> . comparison
    (48) operations -> . logic_operation
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN

    ID              shift and go to state 97
    STRING          shift and go to state 101
    INTEGER         shift and go to state 102
    FLOAT           shift and go to state 103
    TRUE            shift and go to state 104
    FALSE           shift and go to state 105
    NOT             shift and go to state 41
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    array_var                      shift and go to state 77
    something                      shift and go to state 96
    data_structure                 shift and go to state 98
    values                         shift and go to state 99
    operations                     shift and go to state 100
    map_var                        shift and go to state 42
    expression                     shift and go to state 106
    comparison                     shift and go to state 107
    logic_operation                shift and go to state 108
    something_ex                   shift and go to state 22
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    funciones                      shift and go to state 76

state 50

    (19) codigo -> array_assignment COLON .

    $end            reduce using rule 19 (codigo -> array_assignment COLON .)
    RLLAVE          reduce using rule 19 (codigo -> array_assignment COLON .)
    DEFAULT         reduce using rule 19 (codigo -> array_assignment COLON .)
    CASE            reduce using rule 19 (codigo -> array_assignment COLON .)
    RETURN          reduce using rule 19 (codigo -> array_assignment COLON .)


state 51

    (21) codigo -> slice_declaration COLON .

    $end            reduce using rule 21 (codigo -> slice_declaration COLON .)
    RLLAVE          reduce using rule 21 (codigo -> slice_declaration COLON .)
    DEFAULT         reduce using rule 21 (codigo -> slice_declaration COLON .)
    CASE            reduce using rule 21 (codigo -> slice_declaration COLON .)
    RETURN          reduce using rule 21 (codigo -> slice_declaration COLON .)


state 52

    (23) codigo -> slice_var COLON .

    $end            reduce using rule 23 (codigo -> slice_var COLON .)
    RLLAVE          reduce using rule 23 (codigo -> slice_var COLON .)
    DEFAULT         reduce using rule 23 (codigo -> slice_var COLON .)
    CASE            reduce using rule 23 (codigo -> slice_var COLON .)
    RETURN          reduce using rule 23 (codigo -> slice_var COLON .)


state 53

    (94) slice_assignment -> slice_var EQUAL . something_s
    (95) something_s -> . ID
    (96) something_s -> . array_var
    (97) something_s -> . values
    (98) something_s -> . operations
    (143) array_var -> . ID LCORCHE index RCORCHE
    (32) values -> . STRING
    (33) values -> . INTEGER
    (34) values -> . FLOAT
    (35) values -> . TRUE
    (36) values -> . FALSE
    (46) operations -> . expression
    (47) operations -> . comparison
    (48) operations -> . logic_operation
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (149) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 110
    STRING          shift and go to state 101
    INTEGER         shift and go to state 102
    FLOAT           shift and go to state 103
    TRUE            shift and go to state 104
    FALSE           shift and go to state 105
    NOT             shift and go to state 41
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    something_s                    shift and go to state 109
    array_var                      shift and go to state 111
    values                         shift and go to state 112
    operations                     shift and go to state 113
    expression                     shift and go to state 106
    comparison                     shift and go to state 107
    logic_operation                shift and go to state 108
    something_ex                   shift and go to state 22
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    map_var                        shift and go to state 42

state 54

    (25) codigo -> slice_assignment COLON .

    $end            reduce using rule 25 (codigo -> slice_assignment COLON .)
    RLLAVE          reduce using rule 25 (codigo -> slice_assignment COLON .)
    DEFAULT         reduce using rule 25 (codigo -> slice_assignment COLON .)
    CASE            reduce using rule 25 (codigo -> slice_assignment COLON .)
    RETURN          reduce using rule 25 (codigo -> slice_assignment COLON .)


state 55

    (27) codigo -> map_declaration COLON .

    $end            reduce using rule 27 (codigo -> map_declaration COLON .)
    RLLAVE          reduce using rule 27 (codigo -> map_declaration COLON .)
    DEFAULT         reduce using rule 27 (codigo -> map_declaration COLON .)
    CASE            reduce using rule 27 (codigo -> map_declaration COLON .)
    RETURN          reduce using rule 27 (codigo -> map_declaration COLON .)


state 56

    (29) codigo -> map_assignment COLON .

    $end            reduce using rule 29 (codigo -> map_assignment COLON .)
    RLLAVE          reduce using rule 29 (codigo -> map_assignment COLON .)
    DEFAULT         reduce using rule 29 (codigo -> map_assignment COLON .)
    CASE            reduce using rule 29 (codigo -> map_assignment COLON .)
    RETURN          reduce using rule 29 (codigo -> map_assignment COLON .)


state 57

    (165) impresion -> PRINT LPAREN . expression RPAREN
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 115
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    expression                     shift and go to state 114
    something_ex                   shift and go to state 22
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 58

    (167) expression -> something_ex adicionaEx .

    COLON           reduce using rule 167 (expression -> something_ex adicionaEx .)
    $end            reduce using rule 167 (expression -> something_ex adicionaEx .)
    GREATER         reduce using rule 167 (expression -> something_ex adicionaEx .)
    SMALLER         reduce using rule 167 (expression -> something_ex adicionaEx .)
    GREATER_OR_EQUAL reduce using rule 167 (expression -> something_ex adicionaEx .)
    SMALLER_OR_EQUAL reduce using rule 167 (expression -> something_ex adicionaEx .)
    EQUAL_COMPARE   reduce using rule 167 (expression -> something_ex adicionaEx .)
    NOT_EQUAL       reduce using rule 167 (expression -> something_ex adicionaEx .)
    PLUS            reduce using rule 167 (expression -> something_ex adicionaEx .)
    TIMES           reduce using rule 167 (expression -> something_ex adicionaEx .)
    DIVIDE          reduce using rule 167 (expression -> something_ex adicionaEx .)
    MINUS           reduce using rule 167 (expression -> something_ex adicionaEx .)
    RLLAVE          reduce using rule 167 (expression -> something_ex adicionaEx .)
    DEFAULT         reduce using rule 167 (expression -> something_ex adicionaEx .)
    CASE            reduce using rule 167 (expression -> something_ex adicionaEx .)
    RETURN          reduce using rule 167 (expression -> something_ex adicionaEx .)
    RPAREN          reduce using rule 167 (expression -> something_ex adicionaEx .)
    AND             reduce using rule 167 (expression -> something_ex adicionaEx .)
    OR              reduce using rule 167 (expression -> something_ex adicionaEx .)
    LLLAVE          reduce using rule 167 (expression -> something_ex adicionaEx .)
    RCORCHE         reduce using rule 167 (expression -> something_ex adicionaEx .)
    COMA            reduce using rule 167 (expression -> something_ex adicionaEx .)


state 59

    (168) adicionaEx -> op . something_ex
    (169) adicionaEx -> op . something_ex adicionaEx
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 115
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    something_ex                   shift and go to state 116
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 60

    (116) op -> GREATER .

    ID              reduce using rule 116 (op -> GREATER .)
    INTEGER         reduce using rule 116 (op -> GREATER .)
    FLOAT           reduce using rule 116 (op -> GREATER .)
    APPEND          reduce using rule 116 (op -> GREATER .)
    LEN             reduce using rule 116 (op -> GREATER .)
    COPY            reduce using rule 116 (op -> GREATER .)
    DELETE          reduce using rule 116 (op -> GREATER .)


state 61

    (117) op -> SMALLER .

    ID              reduce using rule 117 (op -> SMALLER .)
    INTEGER         reduce using rule 117 (op -> SMALLER .)
    FLOAT           reduce using rule 117 (op -> SMALLER .)
    APPEND          reduce using rule 117 (op -> SMALLER .)
    LEN             reduce using rule 117 (op -> SMALLER .)
    COPY            reduce using rule 117 (op -> SMALLER .)
    DELETE          reduce using rule 117 (op -> SMALLER .)


state 62

    (118) op -> GREATER_OR_EQUAL .

    ID              reduce using rule 118 (op -> GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 118 (op -> GREATER_OR_EQUAL .)
    FLOAT           reduce using rule 118 (op -> GREATER_OR_EQUAL .)
    APPEND          reduce using rule 118 (op -> GREATER_OR_EQUAL .)
    LEN             reduce using rule 118 (op -> GREATER_OR_EQUAL .)
    COPY            reduce using rule 118 (op -> GREATER_OR_EQUAL .)
    DELETE          reduce using rule 118 (op -> GREATER_OR_EQUAL .)


state 63

    (119) op -> SMALLER_OR_EQUAL .

    ID              reduce using rule 119 (op -> SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 119 (op -> SMALLER_OR_EQUAL .)
    FLOAT           reduce using rule 119 (op -> SMALLER_OR_EQUAL .)
    APPEND          reduce using rule 119 (op -> SMALLER_OR_EQUAL .)
    LEN             reduce using rule 119 (op -> SMALLER_OR_EQUAL .)
    COPY            reduce using rule 119 (op -> SMALLER_OR_EQUAL .)
    DELETE          reduce using rule 119 (op -> SMALLER_OR_EQUAL .)


state 64

    (120) op -> EQUAL_COMPARE .

    ID              reduce using rule 120 (op -> EQUAL_COMPARE .)
    INTEGER         reduce using rule 120 (op -> EQUAL_COMPARE .)
    FLOAT           reduce using rule 120 (op -> EQUAL_COMPARE .)
    APPEND          reduce using rule 120 (op -> EQUAL_COMPARE .)
    LEN             reduce using rule 120 (op -> EQUAL_COMPARE .)
    COPY            reduce using rule 120 (op -> EQUAL_COMPARE .)
    DELETE          reduce using rule 120 (op -> EQUAL_COMPARE .)


state 65

    (121) op -> NOT_EQUAL .

    ID              reduce using rule 121 (op -> NOT_EQUAL .)
    INTEGER         reduce using rule 121 (op -> NOT_EQUAL .)
    FLOAT           reduce using rule 121 (op -> NOT_EQUAL .)
    APPEND          reduce using rule 121 (op -> NOT_EQUAL .)
    LEN             reduce using rule 121 (op -> NOT_EQUAL .)
    COPY            reduce using rule 121 (op -> NOT_EQUAL .)
    DELETE          reduce using rule 121 (op -> NOT_EQUAL .)


state 66

    (175) op -> PLUS .

    ID              reduce using rule 175 (op -> PLUS .)
    INTEGER         reduce using rule 175 (op -> PLUS .)
    FLOAT           reduce using rule 175 (op -> PLUS .)
    APPEND          reduce using rule 175 (op -> PLUS .)
    LEN             reduce using rule 175 (op -> PLUS .)
    COPY            reduce using rule 175 (op -> PLUS .)
    DELETE          reduce using rule 175 (op -> PLUS .)


state 67

    (176) op -> TIMES .

    ID              reduce using rule 176 (op -> TIMES .)
    INTEGER         reduce using rule 176 (op -> TIMES .)
    FLOAT           reduce using rule 176 (op -> TIMES .)
    APPEND          reduce using rule 176 (op -> TIMES .)
    LEN             reduce using rule 176 (op -> TIMES .)
    COPY            reduce using rule 176 (op -> TIMES .)
    DELETE          reduce using rule 176 (op -> TIMES .)


state 68

    (177) op -> DIVIDE .

    ID              reduce using rule 177 (op -> DIVIDE .)
    INTEGER         reduce using rule 177 (op -> DIVIDE .)
    FLOAT           reduce using rule 177 (op -> DIVIDE .)
    APPEND          reduce using rule 177 (op -> DIVIDE .)
    LEN             reduce using rule 177 (op -> DIVIDE .)
    COPY            reduce using rule 177 (op -> DIVIDE .)
    DELETE          reduce using rule 177 (op -> DIVIDE .)


state 69

    (178) op -> MINUS .

    ID              reduce using rule 178 (op -> MINUS .)
    INTEGER         reduce using rule 178 (op -> MINUS .)
    FLOAT           reduce using rule 178 (op -> MINUS .)
    APPEND          reduce using rule 178 (op -> MINUS .)
    LEN             reduce using rule 178 (op -> MINUS .)
    COPY            reduce using rule 178 (op -> MINUS .)
    DELETE          reduce using rule 178 (op -> MINUS .)


state 70

    (61) cicloFor -> FOR LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . slice_declaration COLON
    (22) codigo -> . slice_declaration
    (23) codigo -> . slice_var COLON
    (24) codigo -> . slice_var
    (25) codigo -> . slice_assignment COLON
    (26) codigo -> . slice_assignment
    (27) codigo -> . map_declaration COLON
    (28) codigo -> . map_declaration
    (29) codigo -> . map_assignment COLON
    (30) codigo -> . map_assignment
    (31) codigo -> . func_declaration
    (165) impresion -> . PRINT LPAREN expression RPAREN
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (61) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (62) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (63) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (64) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (67) decVar -> . decVarOne
    (68) decVar -> . VAR ID EQUAL INTEGER
    (69) decVar -> . VAR ID EQUAL ID
    (70) decVar -> . VAR ID EQUAL FLOAT
    (71) decVar -> . VAR ID EQUAL expression
    (72) decVar -> . VAR ID EQUAL logic_operation
    (73) decVar -> . VAR ID EQUAL comparison
    (74) decVar -> . VAR ID EQUAL STRING
    (75) decVar -> . ID DEQUAL STRING
    (76) decVar -> . ID DEQUAL FLOAT
    (77) decVar -> . ID DEQUAL expression
    (78) decVar -> . ID DEQUAL logic_operation
    (79) decVar -> . ID DEQUAL comparison
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (106) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (107) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (108) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (109) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (138) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (139) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (143) array_var -> . ID LCORCHE index RCORCHE
    (147) array_assignment -> . array_var EQUAL something
    (80) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (81) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (82) slice_declaration -> . VAR ID EQUAL funM
    (83) slice_declaration -> . ID DEQUAL funM
    (84) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (90) slice_var -> . ID LCORCHE index_s RCORCHE
    (94) slice_assignment -> . slice_var EQUAL something_s
    (148) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (153) map_assignment -> . array_var EQUAL something
    (154) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (104) decVarOne -> . ID DEQUAL ID
    (105) decVarOne -> . ID DEQUAL INTEGER
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (149) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 21
    FOR             shift and go to state 23
    VAR             shift and go to state 28
    ID              shift and go to state 29
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35
    IF              shift and go to state 36
    TYPE            shift and go to state 37
    SWITCH          shift and go to state 38
    FUNC            shift and go to state 39
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    NOT             shift and go to state 41

    codigo                         shift and go to state 117
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    slice_declaration              shift and go to state 15
    slice_var                      shift and go to state 16
    slice_assignment               shift and go to state 17
    map_declaration                shift and go to state 18
    map_assignment                 shift and go to state 19
    func_declaration               shift and go to state 20
    something_ex                   shift and go to state 22
    decVarOne                      shift and go to state 24
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    data_structure                 shift and go to state 40
    map_var                        shift and go to state 42

state 71

    (62) cicloFor -> FOR comparison . LLLAVE codigo RLLAVE
    (127) logic_value -> comparison .

    LLLAVE          shift and go to state 118
    AND             reduce using rule 127 (logic_value -> comparison .)
    OR              reduce using rule 127 (logic_value -> comparison .)


state 72

    (63) cicloFor -> FOR logic_operation . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 119


state 73

    (64) cicloFor -> FOR decVarOne . COLON comparison COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 120


state 74

    (104) decVarOne -> ID . DEQUAL ID
    (105) decVarOne -> ID . DEQUAL INTEGER
    (114) value -> ID .
    (128) logic_value -> ID .
    (170) something_ex -> ID .
    (143) array_var -> ID . LCORCHE index RCORCHE
    (149) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 114 (value -> ID .)
    DEQUAL          shift and go to state 121
    GREATER         reduce using rule 114 (value -> ID .)
    SMALLER         reduce using rule 114 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 114 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 114 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 114 (value -> ID .)
    NOT_EQUAL       reduce using rule 114 (value -> ID .)
    PLUS            reduce using rule 114 (value -> ID .)
    TIMES           reduce using rule 114 (value -> ID .)
    DIVIDE          reduce using rule 114 (value -> ID .)
    MINUS           reduce using rule 114 (value -> ID .)
    AND             reduce using rule 128 (logic_value -> ID .)
    OR              reduce using rule 128 (logic_value -> ID .)
    LCORCHE         shift and go to state 122

  ! GREATER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 170 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 170 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 170 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 170 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 170 (something_ex -> ID .) ]


state 75

    (115) value -> expression .

    GREATER         reduce using rule 115 (value -> expression .)
    SMALLER         reduce using rule 115 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 115 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 115 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 115 (value -> expression .)
    NOT_EQUAL       reduce using rule 115 (value -> expression .)
    PLUS            reduce using rule 115 (value -> expression .)
    TIMES           reduce using rule 115 (value -> expression .)
    DIVIDE          reduce using rule 115 (value -> expression .)
    MINUS           reduce using rule 115 (value -> expression .)
    $end            reduce using rule 115 (value -> expression .)
    AND             reduce using rule 115 (value -> expression .)
    OR              reduce using rule 115 (value -> expression .)
    LLLAVE          reduce using rule 115 (value -> expression .)
    COLON           reduce using rule 115 (value -> expression .)
    RLLAVE          reduce using rule 115 (value -> expression .)
    DEFAULT         reduce using rule 115 (value -> expression .)
    CASE            reduce using rule 115 (value -> expression .)
    RETURN          reduce using rule 115 (value -> expression .)
    RCORCHE         reduce using rule 115 (value -> expression .)
    COMA            reduce using rule 115 (value -> expression .)
    RPAREN          reduce using rule 115 (value -> expression .)


state 76

    (174) something_ex -> funciones .

    GREATER         reduce using rule 174 (something_ex -> funciones .)
    SMALLER         reduce using rule 174 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 174 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 174 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 174 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 174 (something_ex -> funciones .)
    PLUS            reduce using rule 174 (something_ex -> funciones .)
    TIMES           reduce using rule 174 (something_ex -> funciones .)
    DIVIDE          reduce using rule 174 (something_ex -> funciones .)
    MINUS           reduce using rule 174 (something_ex -> funciones .)
    COLON           reduce using rule 174 (something_ex -> funciones .)
    $end            reduce using rule 174 (something_ex -> funciones .)
    RLLAVE          reduce using rule 174 (something_ex -> funciones .)
    DEFAULT         reduce using rule 174 (something_ex -> funciones .)
    CASE            reduce using rule 174 (something_ex -> funciones .)
    RETURN          reduce using rule 174 (something_ex -> funciones .)
    RPAREN          reduce using rule 174 (something_ex -> funciones .)
    AND             reduce using rule 174 (something_ex -> funciones .)
    OR              reduce using rule 174 (something_ex -> funciones .)
    LLLAVE          reduce using rule 174 (something_ex -> funciones .)
    RCORCHE         reduce using rule 174 (something_ex -> funciones .)
    COMA            reduce using rule 174 (something_ex -> funciones .)


state 77

    (49) data_structure -> array_var .

    GREATER         reduce using rule 49 (data_structure -> array_var .)
    SMALLER         reduce using rule 49 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 49 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 49 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 49 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 49 (data_structure -> array_var .)
    PLUS            reduce using rule 49 (data_structure -> array_var .)
    TIMES           reduce using rule 49 (data_structure -> array_var .)
    DIVIDE          reduce using rule 49 (data_structure -> array_var .)
    MINUS           reduce using rule 49 (data_structure -> array_var .)
    COLON           reduce using rule 49 (data_structure -> array_var .)
    $end            reduce using rule 49 (data_structure -> array_var .)
    RLLAVE          reduce using rule 49 (data_structure -> array_var .)
    DEFAULT         reduce using rule 49 (data_structure -> array_var .)
    CASE            reduce using rule 49 (data_structure -> array_var .)
    RETURN          reduce using rule 49 (data_structure -> array_var .)
    RPAREN          reduce using rule 49 (data_structure -> array_var .)
    AND             reduce using rule 49 (data_structure -> array_var .)
    OR              reduce using rule 49 (data_structure -> array_var .)
    LLLAVE          reduce using rule 49 (data_structure -> array_var .)
    RCORCHE         reduce using rule 49 (data_structure -> array_var .)
    COMA            reduce using rule 49 (data_structure -> array_var .)


state 78

    (113) comparison -> value op . value
    (114) value -> . ID
    (115) value -> . expression
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 124
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    value                          shift and go to state 123
    expression                     shift and go to state 75
    something_ex                   shift and go to state 22
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 79

    (122) logic_operation -> logic_value logic_recu .

    $end            reduce using rule 122 (logic_operation -> logic_value logic_recu .)
    LLLAVE          reduce using rule 122 (logic_operation -> logic_value logic_recu .)
    COLON           reduce using rule 122 (logic_operation -> logic_value logic_recu .)
    RLLAVE          reduce using rule 122 (logic_operation -> logic_value logic_recu .)
    DEFAULT         reduce using rule 122 (logic_operation -> logic_value logic_recu .)
    CASE            reduce using rule 122 (logic_operation -> logic_value logic_recu .)
    RETURN          reduce using rule 122 (logic_operation -> logic_value logic_recu .)
    RCORCHE         reduce using rule 122 (logic_operation -> logic_value logic_recu .)
    COMA            reduce using rule 122 (logic_operation -> logic_value logic_recu .)


state 80

    (124) logic_recu -> logic_op . logic_value
    (125) logic_recu -> logic_op . logic_value logic_recu
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (113) comparison -> . value op value
    (114) value -> . ID
    (115) value -> . expression
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 128
    NOT             shift and go to state 41
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    logic_value                    shift and go to state 125
    negation                       shift and go to state 126
    comparison                     shift and go to state 127
    value                          shift and go to state 25
    expression                     shift and go to state 75
    something_ex                   shift and go to state 22
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 81

    (131) logic_op -> AND .

    ID              reduce using rule 131 (logic_op -> AND .)
    NOT             reduce using rule 131 (logic_op -> AND .)
    INTEGER         reduce using rule 131 (logic_op -> AND .)
    FLOAT           reduce using rule 131 (logic_op -> AND .)
    APPEND          reduce using rule 131 (logic_op -> AND .)
    LEN             reduce using rule 131 (logic_op -> AND .)
    COPY            reduce using rule 131 (logic_op -> AND .)
    DELETE          reduce using rule 131 (logic_op -> AND .)


state 82

    (132) logic_op -> OR .

    ID              reduce using rule 132 (logic_op -> OR .)
    NOT             reduce using rule 132 (logic_op -> OR .)
    INTEGER         reduce using rule 132 (logic_op -> OR .)
    FLOAT           reduce using rule 132 (logic_op -> OR .)
    APPEND          reduce using rule 132 (logic_op -> OR .)
    LEN             reduce using rule 132 (logic_op -> OR .)
    COPY            reduce using rule 132 (logic_op -> OR .)
    DELETE          reduce using rule 132 (logic_op -> OR .)


state 83

    (68) decVar -> VAR ID . EQUAL INTEGER
    (69) decVar -> VAR ID . EQUAL ID
    (70) decVar -> VAR ID . EQUAL FLOAT
    (71) decVar -> VAR ID . EQUAL expression
    (72) decVar -> VAR ID . EQUAL logic_operation
    (73) decVar -> VAR ID . EQUAL comparison
    (74) decVar -> VAR ID . EQUAL STRING
    (138) array_declaration -> VAR ID . LCORCHE capacity RCORCHE data_types
    (139) array_declaration -> VAR ID . EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (80) slice_declaration -> VAR ID . LCORCHE RCORCHE data_types
    (81) slice_declaration -> VAR ID . EQUAL LCORCHE RCORCHE data_types arr_content
    (82) slice_declaration -> VAR ID . EQUAL funM
    (148) map_declaration -> VAR ID . LCORCHE data_types RCORCHE data_types

    EQUAL           shift and go to state 129
    LCORCHE         shift and go to state 130


state 84

    (75) decVar -> ID DEQUAL . STRING
    (76) decVar -> ID DEQUAL . FLOAT
    (77) decVar -> ID DEQUAL . expression
    (78) decVar -> ID DEQUAL . logic_operation
    (79) decVar -> ID DEQUAL . comparison
    (83) slice_declaration -> ID DEQUAL . funM
    (84) slice_declaration -> ID DEQUAL . LCORCHE RCORCHE data_types arr_content
    (104) decVarOne -> ID DEQUAL . ID
    (105) decVarOne -> ID DEQUAL . INTEGER
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (113) comparison -> . value op value
    (85) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (86) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (114) value -> . ID
    (115) value -> . expression
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    STRING          shift and go to state 132
    FLOAT           shift and go to state 133
    LCORCHE         shift and go to state 138
    ID              shift and go to state 131
    INTEGER         shift and go to state 139
    MAKE            shift and go to state 140
    NOT             shift and go to state 41
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    expression                     shift and go to state 134
    logic_operation                shift and go to state 135
    comparison                     shift and go to state 136
    funM                           shift and go to state 137
    something_ex                   shift and go to state 22
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    value                          shift and go to state 25
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 85

    (143) array_var -> ID LCORCHE . index RCORCHE
    (90) slice_var -> ID LCORCHE . index_s RCORCHE
    (149) map_var -> ID LCORCHE . key RCORCHE
    (144) index -> . ID
    (145) index -> . INTEGER
    (146) index -> . expression
    (91) index_s -> . ID
    (92) index_s -> . INTEGER
    (93) index_s -> . expression
    (150) key -> . ID
    (151) key -> . values
    (152) key -> . operations
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (32) values -> . STRING
    (33) values -> . INTEGER
    (34) values -> . FLOAT
    (35) values -> . TRUE
    (36) values -> . FALSE
    (46) operations -> . expression
    (47) operations -> . comparison
    (48) operations -> . logic_operation
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 141
    INTEGER         shift and go to state 145
    STRING          shift and go to state 101
    FLOAT           shift and go to state 103
    TRUE            shift and go to state 104
    FALSE           shift and go to state 105
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35
    NOT             shift and go to state 41

    index                          shift and go to state 142
    index_s                        shift and go to state 143
    key                            shift and go to state 144
    expression                     shift and go to state 146
    values                         shift and go to state 147
    operations                     shift and go to state 148
    something_ex                   shift and go to state 22
    comparison                     shift and go to state 107
    logic_operation                shift and go to state 108
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 86

    (99) funciones -> APPEND LPAREN . ID COMA values RPAREN
    (100) funciones -> APPEND LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 149


state 87

    (101) funciones -> LEN LPAREN . ID RPAREN

    ID              shift and go to state 150


state 88

    (102) funciones -> COPY LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 151


state 89

    (103) funciones -> DELETE LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 152


state 90

    (106) SenIF -> IF LPAREN . comparison RPAREN LLLAVE codigo RLLAVE
    (107) SenIF -> IF LPAREN . TRUE RPAREN LLLAVE codigo RLLAVE
    (108) SenIF -> IF LPAREN . FALSE RPAREN LLLAVE codigo RLLAVE
    (113) comparison -> . value op value
    (114) value -> . ID
    (115) value -> . expression
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    TRUE            shift and go to state 154
    FALSE           shift and go to state 155
    ID              shift and go to state 124
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    comparison                     shift and go to state 153
    value                          shift and go to state 25
    expression                     shift and go to state 75
    something_ex                   shift and go to state 22
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 91

    (109) SenStruct -> TYPE ID . STRUCT LLLAVE declaration RLLAVE

    STRUCT          shift and go to state 156


state 92

    (133) switch_statement -> SWITCH ID . LLLAVE cases RLLAVE

    LLLAVE          shift and go to state 157


state 93

    (154) func_declaration -> FUNC ID . LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> FUNC ID . LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE

    LPAREN          shift and go to state 158


state 94

    (129) negation -> NOT comparison .

    $end            reduce using rule 129 (negation -> NOT comparison .)
    AND             reduce using rule 129 (negation -> NOT comparison .)
    OR              reduce using rule 129 (negation -> NOT comparison .)
    LLLAVE          reduce using rule 129 (negation -> NOT comparison .)
    COLON           reduce using rule 129 (negation -> NOT comparison .)
    RLLAVE          reduce using rule 129 (negation -> NOT comparison .)
    DEFAULT         reduce using rule 129 (negation -> NOT comparison .)
    CASE            reduce using rule 129 (negation -> NOT comparison .)
    RETURN          reduce using rule 129 (negation -> NOT comparison .)
    RCORCHE         reduce using rule 129 (negation -> NOT comparison .)
    COMA            reduce using rule 129 (negation -> NOT comparison .)


state 95

    (130) negation -> NOT ID .
    (114) value -> ID .
    (170) something_ex -> ID .
    (143) array_var -> ID . LCORCHE index RCORCHE
    (149) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 114 (value -> ID .)
    $end            reduce using rule 130 (negation -> NOT ID .)
    AND             reduce using rule 130 (negation -> NOT ID .)
    OR              reduce using rule 130 (negation -> NOT ID .)
    LLLAVE          reduce using rule 130 (negation -> NOT ID .)
    COLON           reduce using rule 130 (negation -> NOT ID .)
    RLLAVE          reduce using rule 130 (negation -> NOT ID .)
    DEFAULT         reduce using rule 130 (negation -> NOT ID .)
    CASE            reduce using rule 130 (negation -> NOT ID .)
    RETURN          reduce using rule 130 (negation -> NOT ID .)
    RCORCHE         reduce using rule 130 (negation -> NOT ID .)
    COMA            reduce using rule 130 (negation -> NOT ID .)
    GREATER         reduce using rule 114 (value -> ID .)
    SMALLER         reduce using rule 114 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 114 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 114 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 114 (value -> ID .)
    NOT_EQUAL       reduce using rule 114 (value -> ID .)
    PLUS            reduce using rule 114 (value -> ID .)
    TIMES           reduce using rule 114 (value -> ID .)
    DIVIDE          reduce using rule 114 (value -> ID .)
    MINUS           reduce using rule 114 (value -> ID .)
    LCORCHE         shift and go to state 122

  ! GREATER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 170 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 170 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 170 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 170 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 170 (something_ex -> ID .) ]


state 96

    (147) array_assignment -> array_var EQUAL something .
    (153) map_assignment -> array_var EQUAL something .

  ! reduce/reduce conflict for COLON resolved using rule 147 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for $end resolved using rule 147 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 147 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 147 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for CASE resolved using rule 147 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for RETURN resolved using rule 147 (array_assignment -> array_var EQUAL something .)
    COLON           reduce using rule 147 (array_assignment -> array_var EQUAL something .)
    $end            reduce using rule 147 (array_assignment -> array_var EQUAL something .)
    RLLAVE          reduce using rule 147 (array_assignment -> array_var EQUAL something .)
    DEFAULT         reduce using rule 147 (array_assignment -> array_var EQUAL something .)
    CASE            reduce using rule 147 (array_assignment -> array_var EQUAL something .)
    RETURN          reduce using rule 147 (array_assignment -> array_var EQUAL something .)

  ! COLON           [ reduce using rule 153 (map_assignment -> array_var EQUAL something .) ]
  ! $end            [ reduce using rule 153 (map_assignment -> array_var EQUAL something .) ]
  ! RLLAVE          [ reduce using rule 153 (map_assignment -> array_var EQUAL something .) ]
  ! DEFAULT         [ reduce using rule 153 (map_assignment -> array_var EQUAL something .) ]
  ! CASE            [ reduce using rule 153 (map_assignment -> array_var EQUAL something .) ]
  ! RETURN          [ reduce using rule 153 (map_assignment -> array_var EQUAL something .) ]


state 97

    (57) something -> ID .
    (143) array_var -> ID . LCORCHE index RCORCHE
    (149) map_var -> ID . LCORCHE key RCORCHE
    (170) something_ex -> ID .
    (114) value -> ID .
    (128) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 57 (something -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 57 (something -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 57 (something -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 57 (something -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 57 (something -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 57 (something -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 114 (value -> ID .)
    COLON           reduce using rule 57 (something -> ID .)
    $end            reduce using rule 57 (something -> ID .)
    RLLAVE          reduce using rule 57 (something -> ID .)
    DEFAULT         reduce using rule 57 (something -> ID .)
    CASE            reduce using rule 57 (something -> ID .)
    RETURN          reduce using rule 57 (something -> ID .)
    LCORCHE         shift and go to state 122
    GREATER         reduce using rule 114 (value -> ID .)
    SMALLER         reduce using rule 114 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 114 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 114 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 114 (value -> ID .)
    NOT_EQUAL       reduce using rule 114 (value -> ID .)
    PLUS            reduce using rule 114 (value -> ID .)
    TIMES           reduce using rule 114 (value -> ID .)
    DIVIDE          reduce using rule 114 (value -> ID .)
    MINUS           reduce using rule 114 (value -> ID .)
    AND             reduce using rule 128 (logic_value -> ID .)
    OR              reduce using rule 128 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 170 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 170 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 170 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 170 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 170 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 170 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 170 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 170 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 170 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 170 (something_ex -> ID .) ]


state 98

    (58) something -> data_structure .
    (173) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 58 (something -> data_structure .)
  ! reduce/reduce conflict for $end resolved using rule 58 (something -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 58 (something -> data_structure .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 58 (something -> data_structure .)
  ! reduce/reduce conflict for CASE resolved using rule 58 (something -> data_structure .)
  ! reduce/reduce conflict for RETURN resolved using rule 58 (something -> data_structure .)
    COLON           reduce using rule 58 (something -> data_structure .)
    $end            reduce using rule 58 (something -> data_structure .)
    RLLAVE          reduce using rule 58 (something -> data_structure .)
    DEFAULT         reduce using rule 58 (something -> data_structure .)
    CASE            reduce using rule 58 (something -> data_structure .)
    RETURN          reduce using rule 58 (something -> data_structure .)
    GREATER         reduce using rule 173 (something_ex -> data_structure .)
    SMALLER         reduce using rule 173 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 173 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 173 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 173 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 173 (something_ex -> data_structure .)
    PLUS            reduce using rule 173 (something_ex -> data_structure .)
    TIMES           reduce using rule 173 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 173 (something_ex -> data_structure .)
    MINUS           reduce using rule 173 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 173 (something_ex -> data_structure .) ]
  ! $end            [ reduce using rule 173 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 173 (something_ex -> data_structure .) ]
  ! DEFAULT         [ reduce using rule 173 (something_ex -> data_structure .) ]
  ! CASE            [ reduce using rule 173 (something_ex -> data_structure .) ]
  ! RETURN          [ reduce using rule 173 (something_ex -> data_structure .) ]


state 99

    (59) something -> values .

    COLON           reduce using rule 59 (something -> values .)
    $end            reduce using rule 59 (something -> values .)
    RLLAVE          reduce using rule 59 (something -> values .)
    DEFAULT         reduce using rule 59 (something -> values .)
    CASE            reduce using rule 59 (something -> values .)
    RETURN          reduce using rule 59 (something -> values .)


state 100

    (60) something -> operations .

    COLON           reduce using rule 60 (something -> operations .)
    $end            reduce using rule 60 (something -> operations .)
    RLLAVE          reduce using rule 60 (something -> operations .)
    DEFAULT         reduce using rule 60 (something -> operations .)
    CASE            reduce using rule 60 (something -> operations .)
    RETURN          reduce using rule 60 (something -> operations .)


state 101

    (32) values -> STRING .

    COLON           reduce using rule 32 (values -> STRING .)
    $end            reduce using rule 32 (values -> STRING .)
    RLLAVE          reduce using rule 32 (values -> STRING .)
    DEFAULT         reduce using rule 32 (values -> STRING .)
    CASE            reduce using rule 32 (values -> STRING .)
    RETURN          reduce using rule 32 (values -> STRING .)
    RCORCHE         reduce using rule 32 (values -> STRING .)
    RPAREN          reduce using rule 32 (values -> STRING .)
    POINTS          reduce using rule 32 (values -> STRING .)
    COMA            reduce using rule 32 (values -> STRING .)


state 102

    (33) values -> INTEGER .
    (171) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 33 (values -> INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 33 (values -> INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 33 (values -> INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 33 (values -> INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 33 (values -> INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 33 (values -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 33 (values -> INTEGER .)
    COLON           reduce using rule 33 (values -> INTEGER .)
    $end            reduce using rule 33 (values -> INTEGER .)
    RLLAVE          reduce using rule 33 (values -> INTEGER .)
    DEFAULT         reduce using rule 33 (values -> INTEGER .)
    CASE            reduce using rule 33 (values -> INTEGER .)
    RETURN          reduce using rule 33 (values -> INTEGER .)
    COMA            reduce using rule 33 (values -> INTEGER .)
    GREATER         reduce using rule 171 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 171 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 171 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 171 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 171 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 171 (something_ex -> INTEGER .)
    PLUS            reduce using rule 171 (something_ex -> INTEGER .)
    TIMES           reduce using rule 171 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 171 (something_ex -> INTEGER .)
    MINUS           reduce using rule 171 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! COMA            [ reduce using rule 171 (something_ex -> INTEGER .) ]


state 103

    (34) values -> FLOAT .
    (172) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 34 (values -> FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 34 (values -> FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 34 (values -> FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 34 (values -> FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 34 (values -> FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 34 (values -> FLOAT .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 34 (values -> FLOAT .)
  ! reduce/reduce conflict for COMA resolved using rule 34 (values -> FLOAT .)
    COLON           reduce using rule 34 (values -> FLOAT .)
    $end            reduce using rule 34 (values -> FLOAT .)
    RLLAVE          reduce using rule 34 (values -> FLOAT .)
    DEFAULT         reduce using rule 34 (values -> FLOAT .)
    CASE            reduce using rule 34 (values -> FLOAT .)
    RETURN          reduce using rule 34 (values -> FLOAT .)
    RCORCHE         reduce using rule 34 (values -> FLOAT .)
    COMA            reduce using rule 34 (values -> FLOAT .)
    GREATER         reduce using rule 172 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 172 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 172 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 172 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 172 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 172 (something_ex -> FLOAT .)
    PLUS            reduce using rule 172 (something_ex -> FLOAT .)
    TIMES           reduce using rule 172 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 172 (something_ex -> FLOAT .)
    MINUS           reduce using rule 172 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! RCORCHE         [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! COMA            [ reduce using rule 172 (something_ex -> FLOAT .) ]


state 104

    (35) values -> TRUE .

    COLON           reduce using rule 35 (values -> TRUE .)
    $end            reduce using rule 35 (values -> TRUE .)
    RLLAVE          reduce using rule 35 (values -> TRUE .)
    DEFAULT         reduce using rule 35 (values -> TRUE .)
    CASE            reduce using rule 35 (values -> TRUE .)
    RETURN          reduce using rule 35 (values -> TRUE .)
    RCORCHE         reduce using rule 35 (values -> TRUE .)
    RPAREN          reduce using rule 35 (values -> TRUE .)
    POINTS          reduce using rule 35 (values -> TRUE .)
    COMA            reduce using rule 35 (values -> TRUE .)


state 105

    (36) values -> FALSE .

    COLON           reduce using rule 36 (values -> FALSE .)
    $end            reduce using rule 36 (values -> FALSE .)
    RLLAVE          reduce using rule 36 (values -> FALSE .)
    DEFAULT         reduce using rule 36 (values -> FALSE .)
    CASE            reduce using rule 36 (values -> FALSE .)
    RETURN          reduce using rule 36 (values -> FALSE .)
    RCORCHE         reduce using rule 36 (values -> FALSE .)
    RPAREN          reduce using rule 36 (values -> FALSE .)
    POINTS          reduce using rule 36 (values -> FALSE .)
    COMA            reduce using rule 36 (values -> FALSE .)


state 106

    (46) operations -> expression .
    (115) value -> expression .

    COLON           reduce using rule 46 (operations -> expression .)
    $end            reduce using rule 46 (operations -> expression .)
    RLLAVE          reduce using rule 46 (operations -> expression .)
    DEFAULT         reduce using rule 46 (operations -> expression .)
    CASE            reduce using rule 46 (operations -> expression .)
    RETURN          reduce using rule 46 (operations -> expression .)
    COMA            reduce using rule 46 (operations -> expression .)
    GREATER         reduce using rule 115 (value -> expression .)
    SMALLER         reduce using rule 115 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 115 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 115 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 115 (value -> expression .)
    NOT_EQUAL       reduce using rule 115 (value -> expression .)
    PLUS            reduce using rule 115 (value -> expression .)
    TIMES           reduce using rule 115 (value -> expression .)
    DIVIDE          reduce using rule 115 (value -> expression .)
    MINUS           reduce using rule 115 (value -> expression .)


state 107

    (47) operations -> comparison .
    (127) logic_value -> comparison .

    COLON           reduce using rule 47 (operations -> comparison .)
    $end            reduce using rule 47 (operations -> comparison .)
    RLLAVE          reduce using rule 47 (operations -> comparison .)
    DEFAULT         reduce using rule 47 (operations -> comparison .)
    CASE            reduce using rule 47 (operations -> comparison .)
    RETURN          reduce using rule 47 (operations -> comparison .)
    RCORCHE         reduce using rule 47 (operations -> comparison .)
    COMA            reduce using rule 47 (operations -> comparison .)
    AND             reduce using rule 127 (logic_value -> comparison .)
    OR              reduce using rule 127 (logic_value -> comparison .)


state 108

    (48) operations -> logic_operation .

    COLON           reduce using rule 48 (operations -> logic_operation .)
    $end            reduce using rule 48 (operations -> logic_operation .)
    RLLAVE          reduce using rule 48 (operations -> logic_operation .)
    DEFAULT         reduce using rule 48 (operations -> logic_operation .)
    CASE            reduce using rule 48 (operations -> logic_operation .)
    RETURN          reduce using rule 48 (operations -> logic_operation .)
    RCORCHE         reduce using rule 48 (operations -> logic_operation .)
    COMA            reduce using rule 48 (operations -> logic_operation .)


state 109

    (94) slice_assignment -> slice_var EQUAL something_s .

    COLON           reduce using rule 94 (slice_assignment -> slice_var EQUAL something_s .)
    $end            reduce using rule 94 (slice_assignment -> slice_var EQUAL something_s .)
    RLLAVE          reduce using rule 94 (slice_assignment -> slice_var EQUAL something_s .)
    DEFAULT         reduce using rule 94 (slice_assignment -> slice_var EQUAL something_s .)
    CASE            reduce using rule 94 (slice_assignment -> slice_var EQUAL something_s .)
    RETURN          reduce using rule 94 (slice_assignment -> slice_var EQUAL something_s .)


state 110

    (95) something_s -> ID .
    (143) array_var -> ID . LCORCHE index RCORCHE
    (170) something_ex -> ID .
    (114) value -> ID .
    (128) logic_value -> ID .
    (149) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for COLON resolved using rule 95 (something_s -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 95 (something_s -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 95 (something_s -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 95 (something_s -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 95 (something_s -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 95 (something_s -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 114 (value -> ID .)
    COLON           reduce using rule 95 (something_s -> ID .)
    $end            reduce using rule 95 (something_s -> ID .)
    RLLAVE          reduce using rule 95 (something_s -> ID .)
    DEFAULT         reduce using rule 95 (something_s -> ID .)
    CASE            reduce using rule 95 (something_s -> ID .)
    RETURN          reduce using rule 95 (something_s -> ID .)
    LCORCHE         shift and go to state 122
    GREATER         reduce using rule 114 (value -> ID .)
    SMALLER         reduce using rule 114 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 114 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 114 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 114 (value -> ID .)
    NOT_EQUAL       reduce using rule 114 (value -> ID .)
    PLUS            reduce using rule 114 (value -> ID .)
    TIMES           reduce using rule 114 (value -> ID .)
    DIVIDE          reduce using rule 114 (value -> ID .)
    MINUS           reduce using rule 114 (value -> ID .)
    AND             reduce using rule 128 (logic_value -> ID .)
    OR              reduce using rule 128 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 170 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 170 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 170 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 170 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 170 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 170 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 170 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 170 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 170 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 170 (something_ex -> ID .) ]


state 111

    (96) something_s -> array_var .
    (49) data_structure -> array_var .

  ! reduce/reduce conflict for COLON resolved using rule 49 (data_structure -> array_var .)
  ! reduce/reduce conflict for $end resolved using rule 49 (data_structure -> array_var .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 49 (data_structure -> array_var .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 49 (data_structure -> array_var .)
  ! reduce/reduce conflict for CASE resolved using rule 49 (data_structure -> array_var .)
  ! reduce/reduce conflict for RETURN resolved using rule 49 (data_structure -> array_var .)
    GREATER         reduce using rule 49 (data_structure -> array_var .)
    SMALLER         reduce using rule 49 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 49 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 49 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 49 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 49 (data_structure -> array_var .)
    PLUS            reduce using rule 49 (data_structure -> array_var .)
    TIMES           reduce using rule 49 (data_structure -> array_var .)
    DIVIDE          reduce using rule 49 (data_structure -> array_var .)
    MINUS           reduce using rule 49 (data_structure -> array_var .)
    COLON           reduce using rule 49 (data_structure -> array_var .)
    $end            reduce using rule 49 (data_structure -> array_var .)
    RLLAVE          reduce using rule 49 (data_structure -> array_var .)
    DEFAULT         reduce using rule 49 (data_structure -> array_var .)
    CASE            reduce using rule 49 (data_structure -> array_var .)
    RETURN          reduce using rule 49 (data_structure -> array_var .)

  ! COLON           [ reduce using rule 96 (something_s -> array_var .) ]
  ! $end            [ reduce using rule 96 (something_s -> array_var .) ]
  ! RLLAVE          [ reduce using rule 96 (something_s -> array_var .) ]
  ! DEFAULT         [ reduce using rule 96 (something_s -> array_var .) ]
  ! CASE            [ reduce using rule 96 (something_s -> array_var .) ]
  ! RETURN          [ reduce using rule 96 (something_s -> array_var .) ]


state 112

    (97) something_s -> values .

    COLON           reduce using rule 97 (something_s -> values .)
    $end            reduce using rule 97 (something_s -> values .)
    RLLAVE          reduce using rule 97 (something_s -> values .)
    DEFAULT         reduce using rule 97 (something_s -> values .)
    CASE            reduce using rule 97 (something_s -> values .)
    RETURN          reduce using rule 97 (something_s -> values .)


state 113

    (98) something_s -> operations .

    COLON           reduce using rule 98 (something_s -> operations .)
    $end            reduce using rule 98 (something_s -> operations .)
    RLLAVE          reduce using rule 98 (something_s -> operations .)
    DEFAULT         reduce using rule 98 (something_s -> operations .)
    CASE            reduce using rule 98 (something_s -> operations .)
    RETURN          reduce using rule 98 (something_s -> operations .)


state 114

    (165) impresion -> PRINT LPAREN expression . RPAREN

    RPAREN          shift and go to state 159


state 115

    (170) something_ex -> ID .
    (143) array_var -> ID . LCORCHE index RCORCHE
    (149) map_var -> ID . LCORCHE key RCORCHE

    GREATER         reduce using rule 170 (something_ex -> ID .)
    SMALLER         reduce using rule 170 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 170 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 170 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 170 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 170 (something_ex -> ID .)
    PLUS            reduce using rule 170 (something_ex -> ID .)
    TIMES           reduce using rule 170 (something_ex -> ID .)
    DIVIDE          reduce using rule 170 (something_ex -> ID .)
    MINUS           reduce using rule 170 (something_ex -> ID .)
    RPAREN          reduce using rule 170 (something_ex -> ID .)
    COLON           reduce using rule 170 (something_ex -> ID .)
    $end            reduce using rule 170 (something_ex -> ID .)
    RLLAVE          reduce using rule 170 (something_ex -> ID .)
    DEFAULT         reduce using rule 170 (something_ex -> ID .)
    CASE            reduce using rule 170 (something_ex -> ID .)
    RETURN          reduce using rule 170 (something_ex -> ID .)
    AND             reduce using rule 170 (something_ex -> ID .)
    OR              reduce using rule 170 (something_ex -> ID .)
    LLLAVE          reduce using rule 170 (something_ex -> ID .)
    RCORCHE         reduce using rule 170 (something_ex -> ID .)
    COMA            reduce using rule 170 (something_ex -> ID .)
    LCORCHE         shift and go to state 122


state 116

    (168) adicionaEx -> op something_ex .
    (169) adicionaEx -> op something_ex . adicionaEx
    (168) adicionaEx -> . op something_ex
    (169) adicionaEx -> . op something_ex adicionaEx
    (116) op -> . GREATER
    (117) op -> . SMALLER
    (118) op -> . GREATER_OR_EQUAL
    (119) op -> . SMALLER_OR_EQUAL
    (120) op -> . EQUAL_COMPARE
    (121) op -> . NOT_EQUAL
    (175) op -> . PLUS
    (176) op -> . TIMES
    (177) op -> . DIVIDE
    (178) op -> . MINUS

  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL_COMPARE resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    COLON           reduce using rule 168 (adicionaEx -> op something_ex .)
    $end            reduce using rule 168 (adicionaEx -> op something_ex .)
    RLLAVE          reduce using rule 168 (adicionaEx -> op something_ex .)
    DEFAULT         reduce using rule 168 (adicionaEx -> op something_ex .)
    CASE            reduce using rule 168 (adicionaEx -> op something_ex .)
    RETURN          reduce using rule 168 (adicionaEx -> op something_ex .)
    RPAREN          reduce using rule 168 (adicionaEx -> op something_ex .)
    AND             reduce using rule 168 (adicionaEx -> op something_ex .)
    OR              reduce using rule 168 (adicionaEx -> op something_ex .)
    LLLAVE          reduce using rule 168 (adicionaEx -> op something_ex .)
    RCORCHE         reduce using rule 168 (adicionaEx -> op something_ex .)
    COMA            reduce using rule 168 (adicionaEx -> op something_ex .)
    GREATER         shift and go to state 60
    SMALLER         shift and go to state 61
    GREATER_OR_EQUAL shift and go to state 62
    SMALLER_OR_EQUAL shift and go to state 63
    EQUAL_COMPARE   shift and go to state 64
    NOT_EQUAL       shift and go to state 65
    PLUS            shift and go to state 66
    TIMES           shift and go to state 67
    DIVIDE          shift and go to state 68
    MINUS           shift and go to state 69

  ! GREATER         [ reduce using rule 168 (adicionaEx -> op something_ex .) ]
  ! SMALLER         [ reduce using rule 168 (adicionaEx -> op something_ex .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 168 (adicionaEx -> op something_ex .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 168 (adicionaEx -> op something_ex .) ]
  ! EQUAL_COMPARE   [ reduce using rule 168 (adicionaEx -> op something_ex .) ]
  ! NOT_EQUAL       [ reduce using rule 168 (adicionaEx -> op something_ex .) ]
  ! PLUS            [ reduce using rule 168 (adicionaEx -> op something_ex .) ]
  ! TIMES           [ reduce using rule 168 (adicionaEx -> op something_ex .) ]
  ! DIVIDE          [ reduce using rule 168 (adicionaEx -> op something_ex .) ]
  ! MINUS           [ reduce using rule 168 (adicionaEx -> op something_ex .) ]

    op                             shift and go to state 59
    adicionaEx                     shift and go to state 160

state 117

    (61) cicloFor -> FOR LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 161


state 118

    (62) cicloFor -> FOR comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . slice_declaration COLON
    (22) codigo -> . slice_declaration
    (23) codigo -> . slice_var COLON
    (24) codigo -> . slice_var
    (25) codigo -> . slice_assignment COLON
    (26) codigo -> . slice_assignment
    (27) codigo -> . map_declaration COLON
    (28) codigo -> . map_declaration
    (29) codigo -> . map_assignment COLON
    (30) codigo -> . map_assignment
    (31) codigo -> . func_declaration
    (165) impresion -> . PRINT LPAREN expression RPAREN
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (61) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (62) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (63) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (64) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (67) decVar -> . decVarOne
    (68) decVar -> . VAR ID EQUAL INTEGER
    (69) decVar -> . VAR ID EQUAL ID
    (70) decVar -> . VAR ID EQUAL FLOAT
    (71) decVar -> . VAR ID EQUAL expression
    (72) decVar -> . VAR ID EQUAL logic_operation
    (73) decVar -> . VAR ID EQUAL comparison
    (74) decVar -> . VAR ID EQUAL STRING
    (75) decVar -> . ID DEQUAL STRING
    (76) decVar -> . ID DEQUAL FLOAT
    (77) decVar -> . ID DEQUAL expression
    (78) decVar -> . ID DEQUAL logic_operation
    (79) decVar -> . ID DEQUAL comparison
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (106) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (107) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (108) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (109) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (138) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (139) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (143) array_var -> . ID LCORCHE index RCORCHE
    (147) array_assignment -> . array_var EQUAL something
    (80) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (81) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (82) slice_declaration -> . VAR ID EQUAL funM
    (83) slice_declaration -> . ID DEQUAL funM
    (84) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (90) slice_var -> . ID LCORCHE index_s RCORCHE
    (94) slice_assignment -> . slice_var EQUAL something_s
    (148) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (153) map_assignment -> . array_var EQUAL something
    (154) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (104) decVarOne -> . ID DEQUAL ID
    (105) decVarOne -> . ID DEQUAL INTEGER
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (149) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 21
    FOR             shift and go to state 23
    VAR             shift and go to state 28
    ID              shift and go to state 29
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35
    IF              shift and go to state 36
    TYPE            shift and go to state 37
    SWITCH          shift and go to state 38
    FUNC            shift and go to state 39
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    NOT             shift and go to state 41

    comparison                     shift and go to state 5
    codigo                         shift and go to state 162
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    slice_declaration              shift and go to state 15
    slice_var                      shift and go to state 16
    slice_assignment               shift and go to state 17
    map_declaration                shift and go to state 18
    map_assignment                 shift and go to state 19
    func_declaration               shift and go to state 20
    something_ex                   shift and go to state 22
    decVarOne                      shift and go to state 24
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    data_structure                 shift and go to state 40
    map_var                        shift and go to state 42

state 119

    (63) cicloFor -> FOR logic_operation LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . slice_declaration COLON
    (22) codigo -> . slice_declaration
    (23) codigo -> . slice_var COLON
    (24) codigo -> . slice_var
    (25) codigo -> . slice_assignment COLON
    (26) codigo -> . slice_assignment
    (27) codigo -> . map_declaration COLON
    (28) codigo -> . map_declaration
    (29) codigo -> . map_assignment COLON
    (30) codigo -> . map_assignment
    (31) codigo -> . func_declaration
    (165) impresion -> . PRINT LPAREN expression RPAREN
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (61) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (62) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (63) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (64) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (67) decVar -> . decVarOne
    (68) decVar -> . VAR ID EQUAL INTEGER
    (69) decVar -> . VAR ID EQUAL ID
    (70) decVar -> . VAR ID EQUAL FLOAT
    (71) decVar -> . VAR ID EQUAL expression
    (72) decVar -> . VAR ID EQUAL logic_operation
    (73) decVar -> . VAR ID EQUAL comparison
    (74) decVar -> . VAR ID EQUAL STRING
    (75) decVar -> . ID DEQUAL STRING
    (76) decVar -> . ID DEQUAL FLOAT
    (77) decVar -> . ID DEQUAL expression
    (78) decVar -> . ID DEQUAL logic_operation
    (79) decVar -> . ID DEQUAL comparison
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (106) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (107) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (108) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (109) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (138) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (139) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (143) array_var -> . ID LCORCHE index RCORCHE
    (147) array_assignment -> . array_var EQUAL something
    (80) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (81) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (82) slice_declaration -> . VAR ID EQUAL funM
    (83) slice_declaration -> . ID DEQUAL funM
    (84) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (90) slice_var -> . ID LCORCHE index_s RCORCHE
    (94) slice_assignment -> . slice_var EQUAL something_s
    (148) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (153) map_assignment -> . array_var EQUAL something
    (154) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (104) decVarOne -> . ID DEQUAL ID
    (105) decVarOne -> . ID DEQUAL INTEGER
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (149) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 21
    FOR             shift and go to state 23
    VAR             shift and go to state 28
    ID              shift and go to state 29
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35
    IF              shift and go to state 36
    TYPE            shift and go to state 37
    SWITCH          shift and go to state 38
    FUNC            shift and go to state 39
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    NOT             shift and go to state 41

    logic_operation                shift and go to state 6
    codigo                         shift and go to state 163
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    slice_declaration              shift and go to state 15
    slice_var                      shift and go to state 16
    slice_assignment               shift and go to state 17
    map_declaration                shift and go to state 18
    map_assignment                 shift and go to state 19
    func_declaration               shift and go to state 20
    something_ex                   shift and go to state 22
    decVarOne                      shift and go to state 24
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    data_structure                 shift and go to state 40
    map_var                        shift and go to state 42

state 120

    (64) cicloFor -> FOR decVarOne COLON . comparison COLON incre LLLAVE codigo RLLAVE
    (113) comparison -> . value op value
    (114) value -> . ID
    (115) value -> . expression
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 124
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    comparison                     shift and go to state 164
    value                          shift and go to state 25
    expression                     shift and go to state 75
    something_ex                   shift and go to state 22
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 121

    (104) decVarOne -> ID DEQUAL . ID
    (105) decVarOne -> ID DEQUAL . INTEGER

    ID              shift and go to state 165
    INTEGER         shift and go to state 166


state 122

    (143) array_var -> ID LCORCHE . index RCORCHE
    (149) map_var -> ID LCORCHE . key RCORCHE
    (144) index -> . ID
    (145) index -> . INTEGER
    (146) index -> . expression
    (150) key -> . ID
    (151) key -> . values
    (152) key -> . operations
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (32) values -> . STRING
    (33) values -> . INTEGER
    (34) values -> . FLOAT
    (35) values -> . TRUE
    (36) values -> . FALSE
    (46) operations -> . expression
    (47) operations -> . comparison
    (48) operations -> . logic_operation
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 167
    INTEGER         shift and go to state 168
    STRING          shift and go to state 101
    FLOAT           shift and go to state 103
    TRUE            shift and go to state 104
    FALSE           shift and go to state 105
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35
    NOT             shift and go to state 41

    index                          shift and go to state 142
    key                            shift and go to state 144
    expression                     shift and go to state 169
    values                         shift and go to state 147
    operations                     shift and go to state 148
    something_ex                   shift and go to state 22
    comparison                     shift and go to state 107
    logic_operation                shift and go to state 108
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 123

    (113) comparison -> value op value .

    $end            reduce using rule 113 (comparison -> value op value .)
    AND             reduce using rule 113 (comparison -> value op value .)
    OR              reduce using rule 113 (comparison -> value op value .)
    LLLAVE          reduce using rule 113 (comparison -> value op value .)
    COLON           reduce using rule 113 (comparison -> value op value .)
    RLLAVE          reduce using rule 113 (comparison -> value op value .)
    DEFAULT         reduce using rule 113 (comparison -> value op value .)
    CASE            reduce using rule 113 (comparison -> value op value .)
    RETURN          reduce using rule 113 (comparison -> value op value .)
    RCORCHE         reduce using rule 113 (comparison -> value op value .)
    COMA            reduce using rule 113 (comparison -> value op value .)
    RPAREN          reduce using rule 113 (comparison -> value op value .)


state 124

    (114) value -> ID .
    (170) something_ex -> ID .
    (143) array_var -> ID . LCORCHE index RCORCHE
    (149) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for LLLAVE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 114 (value -> ID .)
    $end            reduce using rule 114 (value -> ID .)
    AND             reduce using rule 114 (value -> ID .)
    OR              reduce using rule 114 (value -> ID .)
    LLLAVE          reduce using rule 114 (value -> ID .)
    COLON           reduce using rule 114 (value -> ID .)
    RLLAVE          reduce using rule 114 (value -> ID .)
    DEFAULT         reduce using rule 114 (value -> ID .)
    CASE            reduce using rule 114 (value -> ID .)
    RETURN          reduce using rule 114 (value -> ID .)
    RCORCHE         reduce using rule 114 (value -> ID .)
    COMA            reduce using rule 114 (value -> ID .)
    RPAREN          reduce using rule 114 (value -> ID .)
    GREATER         reduce using rule 114 (value -> ID .)
    SMALLER         reduce using rule 114 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 114 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 114 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 114 (value -> ID .)
    NOT_EQUAL       reduce using rule 114 (value -> ID .)
    PLUS            reduce using rule 114 (value -> ID .)
    TIMES           reduce using rule 114 (value -> ID .)
    DIVIDE          reduce using rule 114 (value -> ID .)
    MINUS           reduce using rule 114 (value -> ID .)
    LCORCHE         shift and go to state 122

  ! GREATER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 170 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 170 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 170 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 170 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 170 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 170 (something_ex -> ID .) ]
  ! AND             [ reduce using rule 170 (something_ex -> ID .) ]
  ! OR              [ reduce using rule 170 (something_ex -> ID .) ]
  ! LLLAVE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 170 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 170 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 170 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 170 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 170 (something_ex -> ID .) ]
  ! COMA            [ reduce using rule 170 (something_ex -> ID .) ]
  ! RPAREN          [ reduce using rule 170 (something_ex -> ID .) ]


state 125

    (124) logic_recu -> logic_op logic_value .
    (125) logic_recu -> logic_op logic_value . logic_recu
    (124) logic_recu -> . logic_op logic_value
    (125) logic_recu -> . logic_op logic_value logic_recu
    (131) logic_op -> . AND
    (132) logic_op -> . OR

    $end            reduce using rule 124 (logic_recu -> logic_op logic_value .)
    LLLAVE          reduce using rule 124 (logic_recu -> logic_op logic_value .)
    COLON           reduce using rule 124 (logic_recu -> logic_op logic_value .)
    RLLAVE          reduce using rule 124 (logic_recu -> logic_op logic_value .)
    DEFAULT         reduce using rule 124 (logic_recu -> logic_op logic_value .)
    CASE            reduce using rule 124 (logic_recu -> logic_op logic_value .)
    RETURN          reduce using rule 124 (logic_recu -> logic_op logic_value .)
    RCORCHE         reduce using rule 124 (logic_recu -> logic_op logic_value .)
    COMA            reduce using rule 124 (logic_recu -> logic_op logic_value .)
    AND             shift and go to state 81
    OR              shift and go to state 82

    logic_op                       shift and go to state 80
    logic_recu                     shift and go to state 170

state 126

    (126) logic_value -> negation .

    AND             reduce using rule 126 (logic_value -> negation .)
    OR              reduce using rule 126 (logic_value -> negation .)
    $end            reduce using rule 126 (logic_value -> negation .)
    LLLAVE          reduce using rule 126 (logic_value -> negation .)
    COLON           reduce using rule 126 (logic_value -> negation .)
    RLLAVE          reduce using rule 126 (logic_value -> negation .)
    DEFAULT         reduce using rule 126 (logic_value -> negation .)
    CASE            reduce using rule 126 (logic_value -> negation .)
    RETURN          reduce using rule 126 (logic_value -> negation .)
    RCORCHE         reduce using rule 126 (logic_value -> negation .)
    COMA            reduce using rule 126 (logic_value -> negation .)


state 127

    (127) logic_value -> comparison .

    AND             reduce using rule 127 (logic_value -> comparison .)
    OR              reduce using rule 127 (logic_value -> comparison .)
    $end            reduce using rule 127 (logic_value -> comparison .)
    LLLAVE          reduce using rule 127 (logic_value -> comparison .)
    COLON           reduce using rule 127 (logic_value -> comparison .)
    RLLAVE          reduce using rule 127 (logic_value -> comparison .)
    DEFAULT         reduce using rule 127 (logic_value -> comparison .)
    CASE            reduce using rule 127 (logic_value -> comparison .)
    RETURN          reduce using rule 127 (logic_value -> comparison .)
    RCORCHE         reduce using rule 127 (logic_value -> comparison .)
    COMA            reduce using rule 127 (logic_value -> comparison .)


state 128

    (128) logic_value -> ID .
    (114) value -> ID .
    (170) something_ex -> ID .
    (143) array_var -> ID . LCORCHE index RCORCHE
    (149) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 114 (value -> ID .)
    AND             reduce using rule 128 (logic_value -> ID .)
    OR              reduce using rule 128 (logic_value -> ID .)
    $end            reduce using rule 128 (logic_value -> ID .)
    LLLAVE          reduce using rule 128 (logic_value -> ID .)
    COLON           reduce using rule 128 (logic_value -> ID .)
    RLLAVE          reduce using rule 128 (logic_value -> ID .)
    DEFAULT         reduce using rule 128 (logic_value -> ID .)
    CASE            reduce using rule 128 (logic_value -> ID .)
    RETURN          reduce using rule 128 (logic_value -> ID .)
    RCORCHE         reduce using rule 128 (logic_value -> ID .)
    COMA            reduce using rule 128 (logic_value -> ID .)
    GREATER         reduce using rule 114 (value -> ID .)
    SMALLER         reduce using rule 114 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 114 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 114 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 114 (value -> ID .)
    NOT_EQUAL       reduce using rule 114 (value -> ID .)
    PLUS            reduce using rule 114 (value -> ID .)
    TIMES           reduce using rule 114 (value -> ID .)
    DIVIDE          reduce using rule 114 (value -> ID .)
    MINUS           reduce using rule 114 (value -> ID .)
    LCORCHE         shift and go to state 122

  ! GREATER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 170 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 170 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 170 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 170 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 170 (something_ex -> ID .) ]


state 129

    (68) decVar -> VAR ID EQUAL . INTEGER
    (69) decVar -> VAR ID EQUAL . ID
    (70) decVar -> VAR ID EQUAL . FLOAT
    (71) decVar -> VAR ID EQUAL . expression
    (72) decVar -> VAR ID EQUAL . logic_operation
    (73) decVar -> VAR ID EQUAL . comparison
    (74) decVar -> VAR ID EQUAL . STRING
    (139) array_declaration -> VAR ID EQUAL . LCORCHE capacity RCORCHE data_types arr_content
    (81) slice_declaration -> VAR ID EQUAL . LCORCHE RCORCHE data_types arr_content
    (82) slice_declaration -> VAR ID EQUAL . funM
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (113) comparison -> . value op value
    (85) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (86) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (114) value -> . ID
    (115) value -> . expression
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    INTEGER         shift and go to state 172
    ID              shift and go to state 171
    FLOAT           shift and go to state 173
    STRING          shift and go to state 177
    LCORCHE         shift and go to state 178
    MAKE            shift and go to state 140
    NOT             shift and go to state 41
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    expression                     shift and go to state 174
    logic_operation                shift and go to state 175
    comparison                     shift and go to state 176
    funM                           shift and go to state 179
    something_ex                   shift and go to state 22
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    value                          shift and go to state 25
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 130

    (138) array_declaration -> VAR ID LCORCHE . capacity RCORCHE data_types
    (80) slice_declaration -> VAR ID LCORCHE . RCORCHE data_types
    (148) map_declaration -> VAR ID LCORCHE . data_types RCORCHE data_types
    (140) capacity -> . INTEGER
    (141) capacity -> . ID
    (142) capacity -> . expression
    (37) data_types -> . INT32
    (38) data_types -> . INT64
    (39) data_types -> . FLOAT32
    (40) data_types -> . FLOAT64
    (41) data_types -> . BYTE
    (42) data_types -> . WINT
    (43) data_types -> . WFLOAT
    (44) data_types -> . WSTRING
    (45) data_types -> . BOOL
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    RCORCHE         shift and go to state 182
    INTEGER         shift and go to state 184
    ID              shift and go to state 180
    INT32           shift and go to state 186
    INT64           shift and go to state 187
    FLOAT32         shift and go to state 188
    FLOAT64         shift and go to state 189
    BYTE            shift and go to state 190
    WINT            shift and go to state 191
    WFLOAT          shift and go to state 192
    WSTRING         shift and go to state 193
    BOOL            shift and go to state 194
    FLOAT           shift and go to state 31
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    capacity                       shift and go to state 181
    data_types                     shift and go to state 183
    expression                     shift and go to state 185
    something_ex                   shift and go to state 22
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 131

    (104) decVarOne -> ID DEQUAL ID .
    (170) something_ex -> ID .
    (128) logic_value -> ID .
    (114) value -> ID .
    (143) array_var -> ID . LCORCHE index RCORCHE
    (149) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for COLON resolved using rule 104 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for $end resolved using rule 104 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 104 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 104 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for CASE resolved using rule 104 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 104 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 114 (value -> ID .)
    COLON           reduce using rule 104 (decVarOne -> ID DEQUAL ID .)
    $end            reduce using rule 104 (decVarOne -> ID DEQUAL ID .)
    RLLAVE          reduce using rule 104 (decVarOne -> ID DEQUAL ID .)
    DEFAULT         reduce using rule 104 (decVarOne -> ID DEQUAL ID .)
    CASE            reduce using rule 104 (decVarOne -> ID DEQUAL ID .)
    RETURN          reduce using rule 104 (decVarOne -> ID DEQUAL ID .)
    AND             reduce using rule 128 (logic_value -> ID .)
    OR              reduce using rule 128 (logic_value -> ID .)
    GREATER         reduce using rule 114 (value -> ID .)
    SMALLER         reduce using rule 114 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 114 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 114 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 114 (value -> ID .)
    NOT_EQUAL       reduce using rule 114 (value -> ID .)
    PLUS            reduce using rule 114 (value -> ID .)
    TIMES           reduce using rule 114 (value -> ID .)
    DIVIDE          reduce using rule 114 (value -> ID .)
    MINUS           reduce using rule 114 (value -> ID .)
    LCORCHE         shift and go to state 122

  ! GREATER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 170 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 170 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 170 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 170 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 170 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 170 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 170 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 170 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 170 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 170 (something_ex -> ID .) ]


state 132

    (75) decVar -> ID DEQUAL STRING .

    COLON           reduce using rule 75 (decVar -> ID DEQUAL STRING .)
    $end            reduce using rule 75 (decVar -> ID DEQUAL STRING .)
    RLLAVE          reduce using rule 75 (decVar -> ID DEQUAL STRING .)
    DEFAULT         reduce using rule 75 (decVar -> ID DEQUAL STRING .)
    CASE            reduce using rule 75 (decVar -> ID DEQUAL STRING .)
    RETURN          reduce using rule 75 (decVar -> ID DEQUAL STRING .)


state 133

    (76) decVar -> ID DEQUAL FLOAT .
    (172) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 76 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 76 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 76 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 76 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 76 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 76 (decVar -> ID DEQUAL FLOAT .)
    COLON           reduce using rule 76 (decVar -> ID DEQUAL FLOAT .)
    $end            reduce using rule 76 (decVar -> ID DEQUAL FLOAT .)
    RLLAVE          reduce using rule 76 (decVar -> ID DEQUAL FLOAT .)
    DEFAULT         reduce using rule 76 (decVar -> ID DEQUAL FLOAT .)
    CASE            reduce using rule 76 (decVar -> ID DEQUAL FLOAT .)
    RETURN          reduce using rule 76 (decVar -> ID DEQUAL FLOAT .)
    GREATER         reduce using rule 172 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 172 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 172 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 172 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 172 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 172 (something_ex -> FLOAT .)
    PLUS            reduce using rule 172 (something_ex -> FLOAT .)
    TIMES           reduce using rule 172 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 172 (something_ex -> FLOAT .)
    MINUS           reduce using rule 172 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 172 (something_ex -> FLOAT .) ]


state 134

    (77) decVar -> ID DEQUAL expression .
    (115) value -> expression .

    COLON           reduce using rule 77 (decVar -> ID DEQUAL expression .)
    $end            reduce using rule 77 (decVar -> ID DEQUAL expression .)
    RLLAVE          reduce using rule 77 (decVar -> ID DEQUAL expression .)
    DEFAULT         reduce using rule 77 (decVar -> ID DEQUAL expression .)
    CASE            reduce using rule 77 (decVar -> ID DEQUAL expression .)
    RETURN          reduce using rule 77 (decVar -> ID DEQUAL expression .)
    GREATER         reduce using rule 115 (value -> expression .)
    SMALLER         reduce using rule 115 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 115 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 115 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 115 (value -> expression .)
    NOT_EQUAL       reduce using rule 115 (value -> expression .)
    PLUS            reduce using rule 115 (value -> expression .)
    TIMES           reduce using rule 115 (value -> expression .)
    DIVIDE          reduce using rule 115 (value -> expression .)
    MINUS           reduce using rule 115 (value -> expression .)


state 135

    (78) decVar -> ID DEQUAL logic_operation .

    COLON           reduce using rule 78 (decVar -> ID DEQUAL logic_operation .)
    $end            reduce using rule 78 (decVar -> ID DEQUAL logic_operation .)
    RLLAVE          reduce using rule 78 (decVar -> ID DEQUAL logic_operation .)
    DEFAULT         reduce using rule 78 (decVar -> ID DEQUAL logic_operation .)
    CASE            reduce using rule 78 (decVar -> ID DEQUAL logic_operation .)
    RETURN          reduce using rule 78 (decVar -> ID DEQUAL logic_operation .)


state 136

    (79) decVar -> ID DEQUAL comparison .
    (127) logic_value -> comparison .

    COLON           reduce using rule 79 (decVar -> ID DEQUAL comparison .)
    $end            reduce using rule 79 (decVar -> ID DEQUAL comparison .)
    RLLAVE          reduce using rule 79 (decVar -> ID DEQUAL comparison .)
    DEFAULT         reduce using rule 79 (decVar -> ID DEQUAL comparison .)
    CASE            reduce using rule 79 (decVar -> ID DEQUAL comparison .)
    RETURN          reduce using rule 79 (decVar -> ID DEQUAL comparison .)
    AND             reduce using rule 127 (logic_value -> comparison .)
    OR              reduce using rule 127 (logic_value -> comparison .)


state 137

    (83) slice_declaration -> ID DEQUAL funM .

    COLON           reduce using rule 83 (slice_declaration -> ID DEQUAL funM .)
    $end            reduce using rule 83 (slice_declaration -> ID DEQUAL funM .)
    RLLAVE          reduce using rule 83 (slice_declaration -> ID DEQUAL funM .)
    DEFAULT         reduce using rule 83 (slice_declaration -> ID DEQUAL funM .)
    CASE            reduce using rule 83 (slice_declaration -> ID DEQUAL funM .)
    RETURN          reduce using rule 83 (slice_declaration -> ID DEQUAL funM .)


state 138

    (84) slice_declaration -> ID DEQUAL LCORCHE . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 195


state 139

    (105) decVarOne -> ID DEQUAL INTEGER .
    (171) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 105 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 105 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 105 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 105 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 105 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 105 (decVarOne -> ID DEQUAL INTEGER .)
    COLON           reduce using rule 105 (decVarOne -> ID DEQUAL INTEGER .)
    $end            reduce using rule 105 (decVarOne -> ID DEQUAL INTEGER .)
    RLLAVE          reduce using rule 105 (decVarOne -> ID DEQUAL INTEGER .)
    DEFAULT         reduce using rule 105 (decVarOne -> ID DEQUAL INTEGER .)
    CASE            reduce using rule 105 (decVarOne -> ID DEQUAL INTEGER .)
    RETURN          reduce using rule 105 (decVarOne -> ID DEQUAL INTEGER .)
    GREATER         reduce using rule 171 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 171 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 171 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 171 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 171 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 171 (something_ex -> INTEGER .)
    PLUS            reduce using rule 171 (something_ex -> INTEGER .)
    TIMES           reduce using rule 171 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 171 (something_ex -> INTEGER .)
    MINUS           reduce using rule 171 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 171 (something_ex -> INTEGER .) ]


state 140

    (85) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (86) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LPAREN          shift and go to state 196


state 141

    (144) index -> ID .
    (91) index_s -> ID .
    (150) key -> ID .
    (170) something_ex -> ID .
    (114) value -> ID .
    (128) logic_value -> ID .
    (143) array_var -> ID . LCORCHE index RCORCHE
    (149) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for RCORCHE resolved using rule 91 (index_s -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 91 (index_s -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 91 (index_s -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 114 (value -> ID .)
    RCORCHE         reduce using rule 91 (index_s -> ID .)
    GREATER         reduce using rule 114 (value -> ID .)
    SMALLER         reduce using rule 114 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 114 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 114 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 114 (value -> ID .)
    NOT_EQUAL       reduce using rule 114 (value -> ID .)
    PLUS            reduce using rule 114 (value -> ID .)
    TIMES           reduce using rule 114 (value -> ID .)
    DIVIDE          reduce using rule 114 (value -> ID .)
    MINUS           reduce using rule 114 (value -> ID .)
    AND             reduce using rule 128 (logic_value -> ID .)
    OR              reduce using rule 128 (logic_value -> ID .)
    LCORCHE         shift and go to state 122

  ! RCORCHE         [ reduce using rule 144 (index -> ID .) ]
  ! RCORCHE         [ reduce using rule 150 (key -> ID .) ]
  ! GREATER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 170 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 170 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 170 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 170 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 170 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 170 (something_ex -> ID .) ]


state 142

    (143) array_var -> ID LCORCHE index . RCORCHE

    RCORCHE         shift and go to state 197


state 143

    (90) slice_var -> ID LCORCHE index_s . RCORCHE

    RCORCHE         shift and go to state 198


state 144

    (149) map_var -> ID LCORCHE key . RCORCHE

    RCORCHE         shift and go to state 199


state 145

    (145) index -> INTEGER .
    (92) index_s -> INTEGER .
    (33) values -> INTEGER .
    (171) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 92 (index_s -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 33 (values -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 33 (values -> INTEGER .)
    RCORCHE         reduce using rule 33 (values -> INTEGER .)
    GREATER         reduce using rule 171 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 171 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 171 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 171 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 171 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 171 (something_ex -> INTEGER .)
    PLUS            reduce using rule 171 (something_ex -> INTEGER .)
    TIMES           reduce using rule 171 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 171 (something_ex -> INTEGER .)
    MINUS           reduce using rule 171 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 145 (index -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 92 (index_s -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 171 (something_ex -> INTEGER .) ]


state 146

    (146) index -> expression .
    (93) index_s -> expression .
    (46) operations -> expression .
    (115) value -> expression .

  ! reduce/reduce conflict for RCORCHE resolved using rule 93 (index_s -> expression .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 46 (operations -> expression .)
    RCORCHE         reduce using rule 46 (operations -> expression .)
    GREATER         reduce using rule 115 (value -> expression .)
    SMALLER         reduce using rule 115 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 115 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 115 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 115 (value -> expression .)
    NOT_EQUAL       reduce using rule 115 (value -> expression .)
    PLUS            reduce using rule 115 (value -> expression .)
    TIMES           reduce using rule 115 (value -> expression .)
    DIVIDE          reduce using rule 115 (value -> expression .)
    MINUS           reduce using rule 115 (value -> expression .)

  ! RCORCHE         [ reduce using rule 146 (index -> expression .) ]
  ! RCORCHE         [ reduce using rule 93 (index_s -> expression .) ]


state 147

    (151) key -> values .

    RCORCHE         reduce using rule 151 (key -> values .)


state 148

    (152) key -> operations .

    RCORCHE         reduce using rule 152 (key -> operations .)


state 149

    (99) funciones -> APPEND LPAREN ID . COMA values RPAREN
    (100) funciones -> APPEND LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 200


state 150

    (101) funciones -> LEN LPAREN ID . RPAREN

    RPAREN          shift and go to state 201


state 151

    (102) funciones -> COPY LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 202


state 152

    (103) funciones -> DELETE LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 203


state 153

    (106) SenIF -> IF LPAREN comparison . RPAREN LLLAVE codigo RLLAVE

    RPAREN          shift and go to state 204


state 154

    (107) SenIF -> IF LPAREN TRUE . RPAREN LLLAVE codigo RLLAVE

    RPAREN          shift and go to state 205


state 155

    (108) SenIF -> IF LPAREN FALSE . RPAREN LLLAVE codigo RLLAVE

    RPAREN          shift and go to state 206


state 156

    (109) SenStruct -> TYPE ID STRUCT . LLLAVE declaration RLLAVE

    LLLAVE          shift and go to state 207


state 157

    (133) switch_statement -> SWITCH ID LLLAVE . cases RLLAVE
    (134) cases -> . CASE values POINTS codigo
    (135) cases -> . CASE values POINTS codigo more

    CASE            shift and go to state 209

    cases                          shift and go to state 208

state 158

    (154) func_declaration -> FUNC ID LPAREN . params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> FUNC ID LPAREN . params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (162) params -> . ID data_types
    (163) params -> . more_params
    (164) more_params -> . ID data_types COMA params

    ID              shift and go to state 210

    params                         shift and go to state 211
    more_params                    shift and go to state 212

state 159

    (165) impresion -> PRINT LPAREN expression RPAREN .

    COLON           reduce using rule 165 (impresion -> PRINT LPAREN expression RPAREN .)
    $end            reduce using rule 165 (impresion -> PRINT LPAREN expression RPAREN .)
    RLLAVE          reduce using rule 165 (impresion -> PRINT LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 165 (impresion -> PRINT LPAREN expression RPAREN .)
    CASE            reduce using rule 165 (impresion -> PRINT LPAREN expression RPAREN .)
    RETURN          reduce using rule 165 (impresion -> PRINT LPAREN expression RPAREN .)


state 160

    (169) adicionaEx -> op something_ex adicionaEx .

    COLON           reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    $end            reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    GREATER         reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    SMALLER         reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    GREATER_OR_EQUAL reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    SMALLER_OR_EQUAL reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    EQUAL_COMPARE   reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    NOT_EQUAL       reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    PLUS            reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    TIMES           reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    DIVIDE          reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    MINUS           reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    RLLAVE          reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    DEFAULT         reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    CASE            reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    RETURN          reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    RPAREN          reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    AND             reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    OR              reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    LLLAVE          reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    RCORCHE         reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)
    COMA            reduce using rule 169 (adicionaEx -> op something_ex adicionaEx .)


state 161

    (61) cicloFor -> FOR LLLAVE codigo RLLAVE .

    $end            reduce using rule 61 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 61 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 61 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 61 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 61 (cicloFor -> FOR LLLAVE codigo RLLAVE .)


state 162

    (62) cicloFor -> FOR comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 213


state 163

    (63) cicloFor -> FOR logic_operation LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 214


state 164

    (64) cicloFor -> FOR decVarOne COLON comparison . COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 215


state 165

    (104) decVarOne -> ID DEQUAL ID .

    COLON           reduce using rule 104 (decVarOne -> ID DEQUAL ID .)


state 166

    (105) decVarOne -> ID DEQUAL INTEGER .

    COLON           reduce using rule 105 (decVarOne -> ID DEQUAL INTEGER .)


state 167

    (144) index -> ID .
    (150) key -> ID .
    (170) something_ex -> ID .
    (114) value -> ID .
    (128) logic_value -> ID .
    (143) array_var -> ID . LCORCHE index RCORCHE
    (149) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for RCORCHE resolved using rule 144 (index -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 144 (index -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 114 (value -> ID .)
    RCORCHE         reduce using rule 144 (index -> ID .)
    GREATER         reduce using rule 114 (value -> ID .)
    SMALLER         reduce using rule 114 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 114 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 114 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 114 (value -> ID .)
    NOT_EQUAL       reduce using rule 114 (value -> ID .)
    PLUS            reduce using rule 114 (value -> ID .)
    TIMES           reduce using rule 114 (value -> ID .)
    DIVIDE          reduce using rule 114 (value -> ID .)
    MINUS           reduce using rule 114 (value -> ID .)
    AND             reduce using rule 128 (logic_value -> ID .)
    OR              reduce using rule 128 (logic_value -> ID .)
    LCORCHE         shift and go to state 122

  ! RCORCHE         [ reduce using rule 150 (key -> ID .) ]
  ! GREATER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 170 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 170 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 170 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 170 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 170 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 170 (something_ex -> ID .) ]


state 168

    (145) index -> INTEGER .
    (33) values -> INTEGER .
    (171) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 33 (values -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 33 (values -> INTEGER .)
    RCORCHE         reduce using rule 33 (values -> INTEGER .)
    GREATER         reduce using rule 171 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 171 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 171 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 171 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 171 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 171 (something_ex -> INTEGER .)
    PLUS            reduce using rule 171 (something_ex -> INTEGER .)
    TIMES           reduce using rule 171 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 171 (something_ex -> INTEGER .)
    MINUS           reduce using rule 171 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 145 (index -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 171 (something_ex -> INTEGER .) ]


state 169

    (146) index -> expression .
    (46) operations -> expression .
    (115) value -> expression .

  ! reduce/reduce conflict for RCORCHE resolved using rule 46 (operations -> expression .)
    RCORCHE         reduce using rule 46 (operations -> expression .)
    GREATER         reduce using rule 115 (value -> expression .)
    SMALLER         reduce using rule 115 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 115 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 115 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 115 (value -> expression .)
    NOT_EQUAL       reduce using rule 115 (value -> expression .)
    PLUS            reduce using rule 115 (value -> expression .)
    TIMES           reduce using rule 115 (value -> expression .)
    DIVIDE          reduce using rule 115 (value -> expression .)
    MINUS           reduce using rule 115 (value -> expression .)

  ! RCORCHE         [ reduce using rule 146 (index -> expression .) ]


state 170

    (125) logic_recu -> logic_op logic_value logic_recu .

    $end            reduce using rule 125 (logic_recu -> logic_op logic_value logic_recu .)
    LLLAVE          reduce using rule 125 (logic_recu -> logic_op logic_value logic_recu .)
    COLON           reduce using rule 125 (logic_recu -> logic_op logic_value logic_recu .)
    RLLAVE          reduce using rule 125 (logic_recu -> logic_op logic_value logic_recu .)
    DEFAULT         reduce using rule 125 (logic_recu -> logic_op logic_value logic_recu .)
    CASE            reduce using rule 125 (logic_recu -> logic_op logic_value logic_recu .)
    RETURN          reduce using rule 125 (logic_recu -> logic_op logic_value logic_recu .)
    RCORCHE         reduce using rule 125 (logic_recu -> logic_op logic_value logic_recu .)
    COMA            reduce using rule 125 (logic_recu -> logic_op logic_value logic_recu .)


state 171

    (69) decVar -> VAR ID EQUAL ID .
    (170) something_ex -> ID .
    (128) logic_value -> ID .
    (114) value -> ID .
    (143) array_var -> ID . LCORCHE index RCORCHE
    (149) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for COLON resolved using rule 69 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for $end resolved using rule 69 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 69 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 69 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for CASE resolved using rule 69 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 69 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 114 (value -> ID .)
    COLON           reduce using rule 69 (decVar -> VAR ID EQUAL ID .)
    $end            reduce using rule 69 (decVar -> VAR ID EQUAL ID .)
    RLLAVE          reduce using rule 69 (decVar -> VAR ID EQUAL ID .)
    DEFAULT         reduce using rule 69 (decVar -> VAR ID EQUAL ID .)
    CASE            reduce using rule 69 (decVar -> VAR ID EQUAL ID .)
    RETURN          reduce using rule 69 (decVar -> VAR ID EQUAL ID .)
    AND             reduce using rule 128 (logic_value -> ID .)
    OR              reduce using rule 128 (logic_value -> ID .)
    GREATER         reduce using rule 114 (value -> ID .)
    SMALLER         reduce using rule 114 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 114 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 114 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 114 (value -> ID .)
    NOT_EQUAL       reduce using rule 114 (value -> ID .)
    PLUS            reduce using rule 114 (value -> ID .)
    TIMES           reduce using rule 114 (value -> ID .)
    DIVIDE          reduce using rule 114 (value -> ID .)
    MINUS           reduce using rule 114 (value -> ID .)
    LCORCHE         shift and go to state 122

  ! GREATER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 170 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 170 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 170 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 170 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 170 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 170 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 170 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 170 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 170 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 170 (something_ex -> ID .) ]


state 172

    (68) decVar -> VAR ID EQUAL INTEGER .
    (171) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 68 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 68 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 68 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 68 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 68 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 68 (decVar -> VAR ID EQUAL INTEGER .)
    COLON           reduce using rule 68 (decVar -> VAR ID EQUAL INTEGER .)
    $end            reduce using rule 68 (decVar -> VAR ID EQUAL INTEGER .)
    RLLAVE          reduce using rule 68 (decVar -> VAR ID EQUAL INTEGER .)
    DEFAULT         reduce using rule 68 (decVar -> VAR ID EQUAL INTEGER .)
    CASE            reduce using rule 68 (decVar -> VAR ID EQUAL INTEGER .)
    RETURN          reduce using rule 68 (decVar -> VAR ID EQUAL INTEGER .)
    GREATER         reduce using rule 171 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 171 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 171 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 171 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 171 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 171 (something_ex -> INTEGER .)
    PLUS            reduce using rule 171 (something_ex -> INTEGER .)
    TIMES           reduce using rule 171 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 171 (something_ex -> INTEGER .)
    MINUS           reduce using rule 171 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 171 (something_ex -> INTEGER .) ]


state 173

    (70) decVar -> VAR ID EQUAL FLOAT .
    (172) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 70 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 70 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 70 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 70 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 70 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 70 (decVar -> VAR ID EQUAL FLOAT .)
    COLON           reduce using rule 70 (decVar -> VAR ID EQUAL FLOAT .)
    $end            reduce using rule 70 (decVar -> VAR ID EQUAL FLOAT .)
    RLLAVE          reduce using rule 70 (decVar -> VAR ID EQUAL FLOAT .)
    DEFAULT         reduce using rule 70 (decVar -> VAR ID EQUAL FLOAT .)
    CASE            reduce using rule 70 (decVar -> VAR ID EQUAL FLOAT .)
    RETURN          reduce using rule 70 (decVar -> VAR ID EQUAL FLOAT .)
    GREATER         reduce using rule 172 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 172 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 172 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 172 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 172 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 172 (something_ex -> FLOAT .)
    PLUS            reduce using rule 172 (something_ex -> FLOAT .)
    TIMES           reduce using rule 172 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 172 (something_ex -> FLOAT .)
    MINUS           reduce using rule 172 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 172 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 172 (something_ex -> FLOAT .) ]


state 174

    (71) decVar -> VAR ID EQUAL expression .
    (115) value -> expression .

    COLON           reduce using rule 71 (decVar -> VAR ID EQUAL expression .)
    $end            reduce using rule 71 (decVar -> VAR ID EQUAL expression .)
    RLLAVE          reduce using rule 71 (decVar -> VAR ID EQUAL expression .)
    DEFAULT         reduce using rule 71 (decVar -> VAR ID EQUAL expression .)
    CASE            reduce using rule 71 (decVar -> VAR ID EQUAL expression .)
    RETURN          reduce using rule 71 (decVar -> VAR ID EQUAL expression .)
    GREATER         reduce using rule 115 (value -> expression .)
    SMALLER         reduce using rule 115 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 115 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 115 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 115 (value -> expression .)
    NOT_EQUAL       reduce using rule 115 (value -> expression .)
    PLUS            reduce using rule 115 (value -> expression .)
    TIMES           reduce using rule 115 (value -> expression .)
    DIVIDE          reduce using rule 115 (value -> expression .)
    MINUS           reduce using rule 115 (value -> expression .)


state 175

    (72) decVar -> VAR ID EQUAL logic_operation .

    COLON           reduce using rule 72 (decVar -> VAR ID EQUAL logic_operation .)
    $end            reduce using rule 72 (decVar -> VAR ID EQUAL logic_operation .)
    RLLAVE          reduce using rule 72 (decVar -> VAR ID EQUAL logic_operation .)
    DEFAULT         reduce using rule 72 (decVar -> VAR ID EQUAL logic_operation .)
    CASE            reduce using rule 72 (decVar -> VAR ID EQUAL logic_operation .)
    RETURN          reduce using rule 72 (decVar -> VAR ID EQUAL logic_operation .)


state 176

    (73) decVar -> VAR ID EQUAL comparison .
    (127) logic_value -> comparison .

    COLON           reduce using rule 73 (decVar -> VAR ID EQUAL comparison .)
    $end            reduce using rule 73 (decVar -> VAR ID EQUAL comparison .)
    RLLAVE          reduce using rule 73 (decVar -> VAR ID EQUAL comparison .)
    DEFAULT         reduce using rule 73 (decVar -> VAR ID EQUAL comparison .)
    CASE            reduce using rule 73 (decVar -> VAR ID EQUAL comparison .)
    RETURN          reduce using rule 73 (decVar -> VAR ID EQUAL comparison .)
    AND             reduce using rule 127 (logic_value -> comparison .)
    OR              reduce using rule 127 (logic_value -> comparison .)


state 177

    (74) decVar -> VAR ID EQUAL STRING .

    COLON           reduce using rule 74 (decVar -> VAR ID EQUAL STRING .)
    $end            reduce using rule 74 (decVar -> VAR ID EQUAL STRING .)
    RLLAVE          reduce using rule 74 (decVar -> VAR ID EQUAL STRING .)
    DEFAULT         reduce using rule 74 (decVar -> VAR ID EQUAL STRING .)
    CASE            reduce using rule 74 (decVar -> VAR ID EQUAL STRING .)
    RETURN          reduce using rule 74 (decVar -> VAR ID EQUAL STRING .)


state 178

    (139) array_declaration -> VAR ID EQUAL LCORCHE . capacity RCORCHE data_types arr_content
    (81) slice_declaration -> VAR ID EQUAL LCORCHE . RCORCHE data_types arr_content
    (140) capacity -> . INTEGER
    (141) capacity -> . ID
    (142) capacity -> . expression
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    RCORCHE         shift and go to state 217
    INTEGER         shift and go to state 184
    ID              shift and go to state 180
    FLOAT           shift and go to state 31
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    capacity                       shift and go to state 216
    expression                     shift and go to state 185
    something_ex                   shift and go to state 22
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 179

    (82) slice_declaration -> VAR ID EQUAL funM .

    COLON           reduce using rule 82 (slice_declaration -> VAR ID EQUAL funM .)
    $end            reduce using rule 82 (slice_declaration -> VAR ID EQUAL funM .)
    RLLAVE          reduce using rule 82 (slice_declaration -> VAR ID EQUAL funM .)
    DEFAULT         reduce using rule 82 (slice_declaration -> VAR ID EQUAL funM .)
    CASE            reduce using rule 82 (slice_declaration -> VAR ID EQUAL funM .)
    RETURN          reduce using rule 82 (slice_declaration -> VAR ID EQUAL funM .)


state 180

    (141) capacity -> ID .
    (170) something_ex -> ID .
    (143) array_var -> ID . LCORCHE index RCORCHE
    (149) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for RCORCHE resolved using rule 141 (capacity -> ID .)
    RCORCHE         reduce using rule 141 (capacity -> ID .)
    GREATER         reduce using rule 170 (something_ex -> ID .)
    SMALLER         reduce using rule 170 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 170 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 170 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 170 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 170 (something_ex -> ID .)
    PLUS            reduce using rule 170 (something_ex -> ID .)
    TIMES           reduce using rule 170 (something_ex -> ID .)
    DIVIDE          reduce using rule 170 (something_ex -> ID .)
    MINUS           reduce using rule 170 (something_ex -> ID .)
    LCORCHE         shift and go to state 122

  ! RCORCHE         [ reduce using rule 170 (something_ex -> ID .) ]


state 181

    (138) array_declaration -> VAR ID LCORCHE capacity . RCORCHE data_types

    RCORCHE         shift and go to state 218


state 182

    (80) slice_declaration -> VAR ID LCORCHE RCORCHE . data_types
    (37) data_types -> . INT32
    (38) data_types -> . INT64
    (39) data_types -> . FLOAT32
    (40) data_types -> . FLOAT64
    (41) data_types -> . BYTE
    (42) data_types -> . WINT
    (43) data_types -> . WFLOAT
    (44) data_types -> . WSTRING
    (45) data_types -> . BOOL

    INT32           shift and go to state 186
    INT64           shift and go to state 187
    FLOAT32         shift and go to state 188
    FLOAT64         shift and go to state 189
    BYTE            shift and go to state 190
    WINT            shift and go to state 191
    WFLOAT          shift and go to state 192
    WSTRING         shift and go to state 193
    BOOL            shift and go to state 194

    data_types                     shift and go to state 219

state 183

    (148) map_declaration -> VAR ID LCORCHE data_types . RCORCHE data_types

    RCORCHE         shift and go to state 220


state 184

    (140) capacity -> INTEGER .
    (171) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 140 (capacity -> INTEGER .)
    RCORCHE         reduce using rule 140 (capacity -> INTEGER .)
    GREATER         reduce using rule 171 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 171 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 171 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 171 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 171 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 171 (something_ex -> INTEGER .)
    PLUS            reduce using rule 171 (something_ex -> INTEGER .)
    TIMES           reduce using rule 171 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 171 (something_ex -> INTEGER .)
    MINUS           reduce using rule 171 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 171 (something_ex -> INTEGER .) ]


state 185

    (142) capacity -> expression .

    RCORCHE         reduce using rule 142 (capacity -> expression .)


state 186

    (37) data_types -> INT32 .

    RCORCHE         reduce using rule 37 (data_types -> INT32 .)
    COLON           reduce using rule 37 (data_types -> INT32 .)
    $end            reduce using rule 37 (data_types -> INT32 .)
    RLLAVE          reduce using rule 37 (data_types -> INT32 .)
    DEFAULT         reduce using rule 37 (data_types -> INT32 .)
    CASE            reduce using rule 37 (data_types -> INT32 .)
    RETURN          reduce using rule 37 (data_types -> INT32 .)
    LLLAVE          reduce using rule 37 (data_types -> INT32 .)
    COMA            reduce using rule 37 (data_types -> INT32 .)
    RPAREN          reduce using rule 37 (data_types -> INT32 .)
    ID              reduce using rule 37 (data_types -> INT32 .)


state 187

    (38) data_types -> INT64 .

    RCORCHE         reduce using rule 38 (data_types -> INT64 .)
    COLON           reduce using rule 38 (data_types -> INT64 .)
    $end            reduce using rule 38 (data_types -> INT64 .)
    RLLAVE          reduce using rule 38 (data_types -> INT64 .)
    DEFAULT         reduce using rule 38 (data_types -> INT64 .)
    CASE            reduce using rule 38 (data_types -> INT64 .)
    RETURN          reduce using rule 38 (data_types -> INT64 .)
    LLLAVE          reduce using rule 38 (data_types -> INT64 .)
    COMA            reduce using rule 38 (data_types -> INT64 .)
    RPAREN          reduce using rule 38 (data_types -> INT64 .)
    ID              reduce using rule 38 (data_types -> INT64 .)


state 188

    (39) data_types -> FLOAT32 .

    RCORCHE         reduce using rule 39 (data_types -> FLOAT32 .)
    COLON           reduce using rule 39 (data_types -> FLOAT32 .)
    $end            reduce using rule 39 (data_types -> FLOAT32 .)
    RLLAVE          reduce using rule 39 (data_types -> FLOAT32 .)
    DEFAULT         reduce using rule 39 (data_types -> FLOAT32 .)
    CASE            reduce using rule 39 (data_types -> FLOAT32 .)
    RETURN          reduce using rule 39 (data_types -> FLOAT32 .)
    LLLAVE          reduce using rule 39 (data_types -> FLOAT32 .)
    COMA            reduce using rule 39 (data_types -> FLOAT32 .)
    RPAREN          reduce using rule 39 (data_types -> FLOAT32 .)
    ID              reduce using rule 39 (data_types -> FLOAT32 .)


state 189

    (40) data_types -> FLOAT64 .

    RCORCHE         reduce using rule 40 (data_types -> FLOAT64 .)
    COLON           reduce using rule 40 (data_types -> FLOAT64 .)
    $end            reduce using rule 40 (data_types -> FLOAT64 .)
    RLLAVE          reduce using rule 40 (data_types -> FLOAT64 .)
    DEFAULT         reduce using rule 40 (data_types -> FLOAT64 .)
    CASE            reduce using rule 40 (data_types -> FLOAT64 .)
    RETURN          reduce using rule 40 (data_types -> FLOAT64 .)
    LLLAVE          reduce using rule 40 (data_types -> FLOAT64 .)
    COMA            reduce using rule 40 (data_types -> FLOAT64 .)
    RPAREN          reduce using rule 40 (data_types -> FLOAT64 .)
    ID              reduce using rule 40 (data_types -> FLOAT64 .)


state 190

    (41) data_types -> BYTE .

    RCORCHE         reduce using rule 41 (data_types -> BYTE .)
    COLON           reduce using rule 41 (data_types -> BYTE .)
    $end            reduce using rule 41 (data_types -> BYTE .)
    RLLAVE          reduce using rule 41 (data_types -> BYTE .)
    DEFAULT         reduce using rule 41 (data_types -> BYTE .)
    CASE            reduce using rule 41 (data_types -> BYTE .)
    RETURN          reduce using rule 41 (data_types -> BYTE .)
    LLLAVE          reduce using rule 41 (data_types -> BYTE .)
    COMA            reduce using rule 41 (data_types -> BYTE .)
    RPAREN          reduce using rule 41 (data_types -> BYTE .)
    ID              reduce using rule 41 (data_types -> BYTE .)


state 191

    (42) data_types -> WINT .

    RCORCHE         reduce using rule 42 (data_types -> WINT .)
    COLON           reduce using rule 42 (data_types -> WINT .)
    $end            reduce using rule 42 (data_types -> WINT .)
    RLLAVE          reduce using rule 42 (data_types -> WINT .)
    DEFAULT         reduce using rule 42 (data_types -> WINT .)
    CASE            reduce using rule 42 (data_types -> WINT .)
    RETURN          reduce using rule 42 (data_types -> WINT .)
    LLLAVE          reduce using rule 42 (data_types -> WINT .)
    COMA            reduce using rule 42 (data_types -> WINT .)
    RPAREN          reduce using rule 42 (data_types -> WINT .)
    ID              reduce using rule 42 (data_types -> WINT .)


state 192

    (43) data_types -> WFLOAT .

    RCORCHE         reduce using rule 43 (data_types -> WFLOAT .)
    COLON           reduce using rule 43 (data_types -> WFLOAT .)
    $end            reduce using rule 43 (data_types -> WFLOAT .)
    RLLAVE          reduce using rule 43 (data_types -> WFLOAT .)
    DEFAULT         reduce using rule 43 (data_types -> WFLOAT .)
    CASE            reduce using rule 43 (data_types -> WFLOAT .)
    RETURN          reduce using rule 43 (data_types -> WFLOAT .)
    LLLAVE          reduce using rule 43 (data_types -> WFLOAT .)
    COMA            reduce using rule 43 (data_types -> WFLOAT .)
    RPAREN          reduce using rule 43 (data_types -> WFLOAT .)
    ID              reduce using rule 43 (data_types -> WFLOAT .)


state 193

    (44) data_types -> WSTRING .

    RCORCHE         reduce using rule 44 (data_types -> WSTRING .)
    COLON           reduce using rule 44 (data_types -> WSTRING .)
    $end            reduce using rule 44 (data_types -> WSTRING .)
    RLLAVE          reduce using rule 44 (data_types -> WSTRING .)
    DEFAULT         reduce using rule 44 (data_types -> WSTRING .)
    CASE            reduce using rule 44 (data_types -> WSTRING .)
    RETURN          reduce using rule 44 (data_types -> WSTRING .)
    LLLAVE          reduce using rule 44 (data_types -> WSTRING .)
    COMA            reduce using rule 44 (data_types -> WSTRING .)
    RPAREN          reduce using rule 44 (data_types -> WSTRING .)
    ID              reduce using rule 44 (data_types -> WSTRING .)


state 194

    (45) data_types -> BOOL .

    RCORCHE         reduce using rule 45 (data_types -> BOOL .)
    COLON           reduce using rule 45 (data_types -> BOOL .)
    $end            reduce using rule 45 (data_types -> BOOL .)
    RLLAVE          reduce using rule 45 (data_types -> BOOL .)
    DEFAULT         reduce using rule 45 (data_types -> BOOL .)
    CASE            reduce using rule 45 (data_types -> BOOL .)
    RETURN          reduce using rule 45 (data_types -> BOOL .)
    LLLAVE          reduce using rule 45 (data_types -> BOOL .)
    COMA            reduce using rule 45 (data_types -> BOOL .)
    RPAREN          reduce using rule 45 (data_types -> BOOL .)
    ID              reduce using rule 45 (data_types -> BOOL .)


state 195

    (84) slice_declaration -> ID DEQUAL LCORCHE RCORCHE . data_types arr_content
    (37) data_types -> . INT32
    (38) data_types -> . INT64
    (39) data_types -> . FLOAT32
    (40) data_types -> . FLOAT64
    (41) data_types -> . BYTE
    (42) data_types -> . WINT
    (43) data_types -> . WFLOAT
    (44) data_types -> . WSTRING
    (45) data_types -> . BOOL

    INT32           shift and go to state 186
    INT64           shift and go to state 187
    FLOAT32         shift and go to state 188
    FLOAT64         shift and go to state 189
    BYTE            shift and go to state 190
    WINT            shift and go to state 191
    WFLOAT          shift and go to state 192
    WSTRING         shift and go to state 193
    BOOL            shift and go to state 194

    data_types                     shift and go to state 221

state 196

    (85) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap RPAREN
    (86) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LCORCHE         shift and go to state 222


state 197

    (143) array_var -> ID LCORCHE index RCORCHE .

    COLON           reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    EQUAL           reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    $end            reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    GREATER         reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    SMALLER         reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    GREATER_OR_EQUAL reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    SMALLER_OR_EQUAL reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    EQUAL_COMPARE   reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    NOT_EQUAL       reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    PLUS            reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    TIMES           reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    DIVIDE          reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    MINUS           reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    RLLAVE          reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    DEFAULT         reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    CASE            reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    RETURN          reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    RPAREN          reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    AND             reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    OR              reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    LLLAVE          reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    RCORCHE         reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)
    COMA            reduce using rule 143 (array_var -> ID LCORCHE index RCORCHE .)


state 198

    (90) slice_var -> ID LCORCHE index_s RCORCHE .

    COLON           reduce using rule 90 (slice_var -> ID LCORCHE index_s RCORCHE .)
    EQUAL           reduce using rule 90 (slice_var -> ID LCORCHE index_s RCORCHE .)
    $end            reduce using rule 90 (slice_var -> ID LCORCHE index_s RCORCHE .)
    RLLAVE          reduce using rule 90 (slice_var -> ID LCORCHE index_s RCORCHE .)
    DEFAULT         reduce using rule 90 (slice_var -> ID LCORCHE index_s RCORCHE .)
    CASE            reduce using rule 90 (slice_var -> ID LCORCHE index_s RCORCHE .)
    RETURN          reduce using rule 90 (slice_var -> ID LCORCHE index_s RCORCHE .)


state 199

    (149) map_var -> ID LCORCHE key RCORCHE .

    GREATER         reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    SMALLER         reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    GREATER_OR_EQUAL reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    SMALLER_OR_EQUAL reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    EQUAL_COMPARE   reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    NOT_EQUAL       reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    PLUS            reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    TIMES           reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    DIVIDE          reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    MINUS           reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    COLON           reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    $end            reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    RLLAVE          reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    DEFAULT         reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    CASE            reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    RETURN          reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    RPAREN          reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    AND             reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    OR              reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    LLLAVE          reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    RCORCHE         reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)
    COMA            reduce using rule 149 (map_var -> ID LCORCHE key RCORCHE .)


state 200

    (99) funciones -> APPEND LPAREN ID COMA . values RPAREN
    (100) funciones -> APPEND LPAREN ID COMA . ID RPAREN
    (32) values -> . STRING
    (33) values -> . INTEGER
    (34) values -> . FLOAT
    (35) values -> . TRUE
    (36) values -> . FALSE

    ID              shift and go to state 223
    STRING          shift and go to state 101
    INTEGER         shift and go to state 225
    FLOAT           shift and go to state 226
    TRUE            shift and go to state 104
    FALSE           shift and go to state 105

    values                         shift and go to state 224

state 201

    (101) funciones -> LEN LPAREN ID RPAREN .

    COLON           reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    $end            reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    GREATER         reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    SMALLER         reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    NOT_EQUAL       reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    PLUS            reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    TIMES           reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    DIVIDE          reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    MINUS           reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    RLLAVE          reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    DEFAULT         reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    CASE            reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    RETURN          reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    RPAREN          reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    AND             reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    OR              reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    LLLAVE          reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    RCORCHE         reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)
    COMA            reduce using rule 101 (funciones -> LEN LPAREN ID RPAREN .)


state 202

    (102) funciones -> COPY LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 227


state 203

    (103) funciones -> DELETE LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 228


state 204

    (106) SenIF -> IF LPAREN comparison RPAREN . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 229


state 205

    (107) SenIF -> IF LPAREN TRUE RPAREN . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 230


state 206

    (108) SenIF -> IF LPAREN FALSE RPAREN . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 231


state 207

    (109) SenStruct -> TYPE ID STRUCT LLLAVE . declaration RLLAVE
    (110) declaration -> . variable data_types
    (111) declaration -> . declaration variable data_types
    (112) variable -> . ID

    ID              shift and go to state 232

    declaration                    shift and go to state 233
    variable                       shift and go to state 234

state 208

    (133) switch_statement -> SWITCH ID LLLAVE cases . RLLAVE

    RLLAVE          shift and go to state 235


state 209

    (134) cases -> CASE . values POINTS codigo
    (135) cases -> CASE . values POINTS codigo more
    (32) values -> . STRING
    (33) values -> . INTEGER
    (34) values -> . FLOAT
    (35) values -> . TRUE
    (36) values -> . FALSE

    STRING          shift and go to state 101
    INTEGER         shift and go to state 225
    FLOAT           shift and go to state 226
    TRUE            shift and go to state 104
    FALSE           shift and go to state 105

    values                         shift and go to state 236

state 210

    (162) params -> ID . data_types
    (164) more_params -> ID . data_types COMA params
    (37) data_types -> . INT32
    (38) data_types -> . INT64
    (39) data_types -> . FLOAT32
    (40) data_types -> . FLOAT64
    (41) data_types -> . BYTE
    (42) data_types -> . WINT
    (43) data_types -> . WFLOAT
    (44) data_types -> . WSTRING
    (45) data_types -> . BOOL

    INT32           shift and go to state 186
    INT64           shift and go to state 187
    FLOAT32         shift and go to state 188
    FLOAT64         shift and go to state 189
    BYTE            shift and go to state 190
    WINT            shift and go to state 191
    WFLOAT          shift and go to state 192
    WSTRING         shift and go to state 193
    BOOL            shift and go to state 194

    data_types                     shift and go to state 237

state 211

    (154) func_declaration -> FUNC ID LPAREN params . RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> FUNC ID LPAREN params . RPAREN data_types LLLAVE RETURN return_value RLLAVE

    RPAREN          shift and go to state 238


state 212

    (163) params -> more_params .

    RPAREN          reduce using rule 163 (params -> more_params .)


state 213

    (62) cicloFor -> FOR comparison LLLAVE codigo RLLAVE .

    $end            reduce using rule 62 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 62 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 62 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 62 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 62 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)


state 214

    (63) cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .

    $end            reduce using rule 63 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 63 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 63 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 63 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 63 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)


state 215

    (64) cicloFor -> FOR decVarOne COLON comparison COLON . incre LLLAVE codigo RLLAVE
    (65) incre -> . ID INCREASE
    (66) incre -> . ID DECREASE

    ID              shift and go to state 240

    incre                          shift and go to state 239

state 216

    (139) array_declaration -> VAR ID EQUAL LCORCHE capacity . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 241


state 217

    (81) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE . data_types arr_content
    (37) data_types -> . INT32
    (38) data_types -> . INT64
    (39) data_types -> . FLOAT32
    (40) data_types -> . FLOAT64
    (41) data_types -> . BYTE
    (42) data_types -> . WINT
    (43) data_types -> . WFLOAT
    (44) data_types -> . WSTRING
    (45) data_types -> . BOOL

    INT32           shift and go to state 186
    INT64           shift and go to state 187
    FLOAT32         shift and go to state 188
    FLOAT64         shift and go to state 189
    BYTE            shift and go to state 190
    WINT            shift and go to state 191
    WFLOAT          shift and go to state 192
    WSTRING         shift and go to state 193
    BOOL            shift and go to state 194

    data_types                     shift and go to state 242

state 218

    (138) array_declaration -> VAR ID LCORCHE capacity RCORCHE . data_types
    (37) data_types -> . INT32
    (38) data_types -> . INT64
    (39) data_types -> . FLOAT32
    (40) data_types -> . FLOAT64
    (41) data_types -> . BYTE
    (42) data_types -> . WINT
    (43) data_types -> . WFLOAT
    (44) data_types -> . WSTRING
    (45) data_types -> . BOOL

    INT32           shift and go to state 186
    INT64           shift and go to state 187
    FLOAT32         shift and go to state 188
    FLOAT64         shift and go to state 189
    BYTE            shift and go to state 190
    WINT            shift and go to state 191
    WFLOAT          shift and go to state 192
    WSTRING         shift and go to state 193
    BOOL            shift and go to state 194

    data_types                     shift and go to state 243

state 219

    (80) slice_declaration -> VAR ID LCORCHE RCORCHE data_types .

    COLON           reduce using rule 80 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    $end            reduce using rule 80 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    RLLAVE          reduce using rule 80 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    DEFAULT         reduce using rule 80 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    CASE            reduce using rule 80 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    RETURN          reduce using rule 80 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)


state 220

    (148) map_declaration -> VAR ID LCORCHE data_types RCORCHE . data_types
    (37) data_types -> . INT32
    (38) data_types -> . INT64
    (39) data_types -> . FLOAT32
    (40) data_types -> . FLOAT64
    (41) data_types -> . BYTE
    (42) data_types -> . WINT
    (43) data_types -> . WFLOAT
    (44) data_types -> . WSTRING
    (45) data_types -> . BOOL

    INT32           shift and go to state 186
    INT64           shift and go to state 187
    FLOAT32         shift and go to state 188
    FLOAT64         shift and go to state 189
    BYTE            shift and go to state 190
    WINT            shift and go to state 191
    WFLOAT          shift and go to state 192
    WSTRING         shift and go to state 193
    BOOL            shift and go to state 194

    data_types                     shift and go to state 244

state 221

    (84) slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types . arr_content
    (51) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (52) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 246

    arr_content                    shift and go to state 245

state 222

    (85) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap RPAREN
    (86) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap COMA cap RPAREN

    RCORCHE         shift and go to state 247


state 223

    (100) funciones -> APPEND LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 248


state 224

    (99) funciones -> APPEND LPAREN ID COMA values . RPAREN

    RPAREN          shift and go to state 249


state 225

    (33) values -> INTEGER .

    RPAREN          reduce using rule 33 (values -> INTEGER .)
    POINTS          reduce using rule 33 (values -> INTEGER .)


state 226

    (34) values -> FLOAT .

    RPAREN          reduce using rule 34 (values -> FLOAT .)
    POINTS          reduce using rule 34 (values -> FLOAT .)


state 227

    (102) funciones -> COPY LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 250


state 228

    (103) funciones -> DELETE LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 251


state 229

    (106) SenIF -> IF LPAREN comparison RPAREN LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . slice_declaration COLON
    (22) codigo -> . slice_declaration
    (23) codigo -> . slice_var COLON
    (24) codigo -> . slice_var
    (25) codigo -> . slice_assignment COLON
    (26) codigo -> . slice_assignment
    (27) codigo -> . map_declaration COLON
    (28) codigo -> . map_declaration
    (29) codigo -> . map_assignment COLON
    (30) codigo -> . map_assignment
    (31) codigo -> . func_declaration
    (165) impresion -> . PRINT LPAREN expression RPAREN
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (61) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (62) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (63) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (64) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (67) decVar -> . decVarOne
    (68) decVar -> . VAR ID EQUAL INTEGER
    (69) decVar -> . VAR ID EQUAL ID
    (70) decVar -> . VAR ID EQUAL FLOAT
    (71) decVar -> . VAR ID EQUAL expression
    (72) decVar -> . VAR ID EQUAL logic_operation
    (73) decVar -> . VAR ID EQUAL comparison
    (74) decVar -> . VAR ID EQUAL STRING
    (75) decVar -> . ID DEQUAL STRING
    (76) decVar -> . ID DEQUAL FLOAT
    (77) decVar -> . ID DEQUAL expression
    (78) decVar -> . ID DEQUAL logic_operation
    (79) decVar -> . ID DEQUAL comparison
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (106) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (107) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (108) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (109) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (138) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (139) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (143) array_var -> . ID LCORCHE index RCORCHE
    (147) array_assignment -> . array_var EQUAL something
    (80) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (81) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (82) slice_declaration -> . VAR ID EQUAL funM
    (83) slice_declaration -> . ID DEQUAL funM
    (84) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (90) slice_var -> . ID LCORCHE index_s RCORCHE
    (94) slice_assignment -> . slice_var EQUAL something_s
    (148) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (153) map_assignment -> . array_var EQUAL something
    (154) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (104) decVarOne -> . ID DEQUAL ID
    (105) decVarOne -> . ID DEQUAL INTEGER
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (149) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 21
    FOR             shift and go to state 23
    VAR             shift and go to state 28
    ID              shift and go to state 29
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35
    IF              shift and go to state 36
    TYPE            shift and go to state 37
    SWITCH          shift and go to state 38
    FUNC            shift and go to state 39
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    NOT             shift and go to state 41

    comparison                     shift and go to state 5
    codigo                         shift and go to state 252
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    slice_declaration              shift and go to state 15
    slice_var                      shift and go to state 16
    slice_assignment               shift and go to state 17
    map_declaration                shift and go to state 18
    map_assignment                 shift and go to state 19
    func_declaration               shift and go to state 20
    something_ex                   shift and go to state 22
    decVarOne                      shift and go to state 24
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    data_structure                 shift and go to state 40
    map_var                        shift and go to state 42

state 230

    (107) SenIF -> IF LPAREN TRUE RPAREN LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . slice_declaration COLON
    (22) codigo -> . slice_declaration
    (23) codigo -> . slice_var COLON
    (24) codigo -> . slice_var
    (25) codigo -> . slice_assignment COLON
    (26) codigo -> . slice_assignment
    (27) codigo -> . map_declaration COLON
    (28) codigo -> . map_declaration
    (29) codigo -> . map_assignment COLON
    (30) codigo -> . map_assignment
    (31) codigo -> . func_declaration
    (165) impresion -> . PRINT LPAREN expression RPAREN
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (61) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (62) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (63) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (64) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (67) decVar -> . decVarOne
    (68) decVar -> . VAR ID EQUAL INTEGER
    (69) decVar -> . VAR ID EQUAL ID
    (70) decVar -> . VAR ID EQUAL FLOAT
    (71) decVar -> . VAR ID EQUAL expression
    (72) decVar -> . VAR ID EQUAL logic_operation
    (73) decVar -> . VAR ID EQUAL comparison
    (74) decVar -> . VAR ID EQUAL STRING
    (75) decVar -> . ID DEQUAL STRING
    (76) decVar -> . ID DEQUAL FLOAT
    (77) decVar -> . ID DEQUAL expression
    (78) decVar -> . ID DEQUAL logic_operation
    (79) decVar -> . ID DEQUAL comparison
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (106) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (107) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (108) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (109) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (138) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (139) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (143) array_var -> . ID LCORCHE index RCORCHE
    (147) array_assignment -> . array_var EQUAL something
    (80) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (81) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (82) slice_declaration -> . VAR ID EQUAL funM
    (83) slice_declaration -> . ID DEQUAL funM
    (84) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (90) slice_var -> . ID LCORCHE index_s RCORCHE
    (94) slice_assignment -> . slice_var EQUAL something_s
    (148) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (153) map_assignment -> . array_var EQUAL something
    (154) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (104) decVarOne -> . ID DEQUAL ID
    (105) decVarOne -> . ID DEQUAL INTEGER
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (149) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 21
    FOR             shift and go to state 23
    VAR             shift and go to state 28
    ID              shift and go to state 29
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35
    IF              shift and go to state 36
    TYPE            shift and go to state 37
    SWITCH          shift and go to state 38
    FUNC            shift and go to state 39
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    NOT             shift and go to state 41

    codigo                         shift and go to state 253
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    slice_declaration              shift and go to state 15
    slice_var                      shift and go to state 16
    slice_assignment               shift and go to state 17
    map_declaration                shift and go to state 18
    map_assignment                 shift and go to state 19
    func_declaration               shift and go to state 20
    something_ex                   shift and go to state 22
    decVarOne                      shift and go to state 24
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    data_structure                 shift and go to state 40
    map_var                        shift and go to state 42

state 231

    (108) SenIF -> IF LPAREN FALSE RPAREN LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . slice_declaration COLON
    (22) codigo -> . slice_declaration
    (23) codigo -> . slice_var COLON
    (24) codigo -> . slice_var
    (25) codigo -> . slice_assignment COLON
    (26) codigo -> . slice_assignment
    (27) codigo -> . map_declaration COLON
    (28) codigo -> . map_declaration
    (29) codigo -> . map_assignment COLON
    (30) codigo -> . map_assignment
    (31) codigo -> . func_declaration
    (165) impresion -> . PRINT LPAREN expression RPAREN
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (61) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (62) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (63) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (64) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (67) decVar -> . decVarOne
    (68) decVar -> . VAR ID EQUAL INTEGER
    (69) decVar -> . VAR ID EQUAL ID
    (70) decVar -> . VAR ID EQUAL FLOAT
    (71) decVar -> . VAR ID EQUAL expression
    (72) decVar -> . VAR ID EQUAL logic_operation
    (73) decVar -> . VAR ID EQUAL comparison
    (74) decVar -> . VAR ID EQUAL STRING
    (75) decVar -> . ID DEQUAL STRING
    (76) decVar -> . ID DEQUAL FLOAT
    (77) decVar -> . ID DEQUAL expression
    (78) decVar -> . ID DEQUAL logic_operation
    (79) decVar -> . ID DEQUAL comparison
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (106) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (107) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (108) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (109) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (138) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (139) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (143) array_var -> . ID LCORCHE index RCORCHE
    (147) array_assignment -> . array_var EQUAL something
    (80) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (81) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (82) slice_declaration -> . VAR ID EQUAL funM
    (83) slice_declaration -> . ID DEQUAL funM
    (84) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (90) slice_var -> . ID LCORCHE index_s RCORCHE
    (94) slice_assignment -> . slice_var EQUAL something_s
    (148) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (153) map_assignment -> . array_var EQUAL something
    (154) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (104) decVarOne -> . ID DEQUAL ID
    (105) decVarOne -> . ID DEQUAL INTEGER
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (149) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 21
    FOR             shift and go to state 23
    VAR             shift and go to state 28
    ID              shift and go to state 29
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35
    IF              shift and go to state 36
    TYPE            shift and go to state 37
    SWITCH          shift and go to state 38
    FUNC            shift and go to state 39
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    NOT             shift and go to state 41

    codigo                         shift and go to state 254
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    slice_declaration              shift and go to state 15
    slice_var                      shift and go to state 16
    slice_assignment               shift and go to state 17
    map_declaration                shift and go to state 18
    map_assignment                 shift and go to state 19
    func_declaration               shift and go to state 20
    something_ex                   shift and go to state 22
    decVarOne                      shift and go to state 24
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    data_structure                 shift and go to state 40
    map_var                        shift and go to state 42

state 232

    (112) variable -> ID .

    INT32           reduce using rule 112 (variable -> ID .)
    INT64           reduce using rule 112 (variable -> ID .)
    FLOAT32         reduce using rule 112 (variable -> ID .)
    FLOAT64         reduce using rule 112 (variable -> ID .)
    BYTE            reduce using rule 112 (variable -> ID .)
    WINT            reduce using rule 112 (variable -> ID .)
    WFLOAT          reduce using rule 112 (variable -> ID .)
    WSTRING         reduce using rule 112 (variable -> ID .)
    BOOL            reduce using rule 112 (variable -> ID .)


state 233

    (109) SenStruct -> TYPE ID STRUCT LLLAVE declaration . RLLAVE
    (111) declaration -> declaration . variable data_types
    (112) variable -> . ID

    RLLAVE          shift and go to state 255
    ID              shift and go to state 232

    variable                       shift and go to state 256

state 234

    (110) declaration -> variable . data_types
    (37) data_types -> . INT32
    (38) data_types -> . INT64
    (39) data_types -> . FLOAT32
    (40) data_types -> . FLOAT64
    (41) data_types -> . BYTE
    (42) data_types -> . WINT
    (43) data_types -> . WFLOAT
    (44) data_types -> . WSTRING
    (45) data_types -> . BOOL

    INT32           shift and go to state 186
    INT64           shift and go to state 187
    FLOAT32         shift and go to state 188
    FLOAT64         shift and go to state 189
    BYTE            shift and go to state 190
    WINT            shift and go to state 191
    WFLOAT          shift and go to state 192
    WSTRING         shift and go to state 193
    BOOL            shift and go to state 194

    data_types                     shift and go to state 257

state 235

    (133) switch_statement -> SWITCH ID LLLAVE cases RLLAVE .

    $end            reduce using rule 133 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RLLAVE          reduce using rule 133 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    DEFAULT         reduce using rule 133 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    CASE            reduce using rule 133 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RETURN          reduce using rule 133 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)


state 236

    (134) cases -> CASE values . POINTS codigo
    (135) cases -> CASE values . POINTS codigo more

    POINTS          shift and go to state 258


state 237

    (162) params -> ID data_types .
    (164) more_params -> ID data_types . COMA params

    RPAREN          reduce using rule 162 (params -> ID data_types .)
    COMA            shift and go to state 259


state 238

    (154) func_declaration -> FUNC ID LPAREN params RPAREN . data_types LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> FUNC ID LPAREN params RPAREN . data_types LLLAVE RETURN return_value RLLAVE
    (37) data_types -> . INT32
    (38) data_types -> . INT64
    (39) data_types -> . FLOAT32
    (40) data_types -> . FLOAT64
    (41) data_types -> . BYTE
    (42) data_types -> . WINT
    (43) data_types -> . WFLOAT
    (44) data_types -> . WSTRING
    (45) data_types -> . BOOL

    INT32           shift and go to state 186
    INT64           shift and go to state 187
    FLOAT32         shift and go to state 188
    FLOAT64         shift and go to state 189
    BYTE            shift and go to state 190
    WINT            shift and go to state 191
    WFLOAT          shift and go to state 192
    WSTRING         shift and go to state 193
    BOOL            shift and go to state 194

    data_types                     shift and go to state 260

state 239

    (64) cicloFor -> FOR decVarOne COLON comparison COLON incre . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 261


state 240

    (65) incre -> ID . INCREASE
    (66) incre -> ID . DECREASE

    INCREASE        shift and go to state 262
    DECREASE        shift and go to state 263


state 241

    (139) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE . data_types arr_content
    (37) data_types -> . INT32
    (38) data_types -> . INT64
    (39) data_types -> . FLOAT32
    (40) data_types -> . FLOAT64
    (41) data_types -> . BYTE
    (42) data_types -> . WINT
    (43) data_types -> . WFLOAT
    (44) data_types -> . WSTRING
    (45) data_types -> . BOOL

    INT32           shift and go to state 186
    INT64           shift and go to state 187
    FLOAT32         shift and go to state 188
    FLOAT64         shift and go to state 189
    BYTE            shift and go to state 190
    WINT            shift and go to state 191
    WFLOAT          shift and go to state 192
    WSTRING         shift and go to state 193
    BOOL            shift and go to state 194

    data_types                     shift and go to state 264

state 242

    (81) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types . arr_content
    (51) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (52) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 246

    arr_content                    shift and go to state 265

state 243

    (138) array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .

    COLON           reduce using rule 138 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    $end            reduce using rule 138 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RLLAVE          reduce using rule 138 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    DEFAULT         reduce using rule 138 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    CASE            reduce using rule 138 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RETURN          reduce using rule 138 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)


state 244

    (148) map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .

    COLON           reduce using rule 148 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    $end            reduce using rule 148 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    RLLAVE          reduce using rule 148 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    DEFAULT         reduce using rule 148 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    CASE            reduce using rule 148 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    RETURN          reduce using rule 148 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)


state 245

    (84) slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .

    COLON           reduce using rule 84 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    $end            reduce using rule 84 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 84 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 84 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    CASE            reduce using rule 84 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RETURN          reduce using rule 84 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)


state 246

    (51) arr_content -> LLLAVE . items COMA more_items RLLAVE
    (52) arr_content -> LLLAVE . items RLLAVE
    (55) items -> . values
    (56) items -> . operations
    (32) values -> . STRING
    (33) values -> . INTEGER
    (34) values -> . FLOAT
    (35) values -> . TRUE
    (36) values -> . FALSE
    (46) operations -> . expression
    (47) operations -> . comparison
    (48) operations -> . logic_operation
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    STRING          shift and go to state 101
    INTEGER         shift and go to state 102
    FLOAT           shift and go to state 103
    TRUE            shift and go to state 104
    FALSE           shift and go to state 105
    ID              shift and go to state 269
    NOT             shift and go to state 41
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    items                          shift and go to state 266
    values                         shift and go to state 267
    operations                     shift and go to state 268
    expression                     shift and go to state 106
    comparison                     shift and go to state 107
    logic_operation                shift and go to state 108
    something_ex                   shift and go to state 22
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 247

    (85) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap RPAREN
    (86) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap COMA cap RPAREN
    (37) data_types -> . INT32
    (38) data_types -> . INT64
    (39) data_types -> . FLOAT32
    (40) data_types -> . FLOAT64
    (41) data_types -> . BYTE
    (42) data_types -> . WINT
    (43) data_types -> . WFLOAT
    (44) data_types -> . WSTRING
    (45) data_types -> . BOOL

    INT32           shift and go to state 186
    INT64           shift and go to state 187
    FLOAT32         shift and go to state 188
    FLOAT64         shift and go to state 189
    BYTE            shift and go to state 190
    WINT            shift and go to state 191
    WFLOAT          shift and go to state 192
    WSTRING         shift and go to state 193
    BOOL            shift and go to state 194

    data_types                     shift and go to state 270

state 248

    (100) funciones -> APPEND LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 100 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)


state 249

    (99) funciones -> APPEND LPAREN ID COMA values RPAREN .

    COLON           reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    $end            reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    GREATER         reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SMALLER         reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    GREATER_OR_EQUAL reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    EQUAL_COMPARE   reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    NOT_EQUAL       reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    PLUS            reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    TIMES           reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DIVIDE          reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    MINUS           reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RLLAVE          reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DEFAULT         reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    CASE            reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RETURN          reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RPAREN          reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    AND             reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    OR              reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    LLLAVE          reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RCORCHE         reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    COMA            reduce using rule 99 (funciones -> APPEND LPAREN ID COMA values RPAREN .)


state 250

    (102) funciones -> COPY LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 102 (funciones -> COPY LPAREN ID COMA ID RPAREN .)


state 251

    (103) funciones -> DELETE LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 103 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)


state 252

    (106) SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 271


state 253

    (107) SenIF -> IF LPAREN TRUE RPAREN LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 272


state 254

    (108) SenIF -> IF LPAREN FALSE RPAREN LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 273


state 255

    (109) SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .

    $end            reduce using rule 109 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RLLAVE          reduce using rule 109 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    DEFAULT         reduce using rule 109 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    CASE            reduce using rule 109 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RETURN          reduce using rule 109 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)


state 256

    (111) declaration -> declaration variable . data_types
    (37) data_types -> . INT32
    (38) data_types -> . INT64
    (39) data_types -> . FLOAT32
    (40) data_types -> . FLOAT64
    (41) data_types -> . BYTE
    (42) data_types -> . WINT
    (43) data_types -> . WFLOAT
    (44) data_types -> . WSTRING
    (45) data_types -> . BOOL

    INT32           shift and go to state 186
    INT64           shift and go to state 187
    FLOAT32         shift and go to state 188
    FLOAT64         shift and go to state 189
    BYTE            shift and go to state 190
    WINT            shift and go to state 191
    WFLOAT          shift and go to state 192
    WSTRING         shift and go to state 193
    BOOL            shift and go to state 194

    data_types                     shift and go to state 274

state 257

    (110) declaration -> variable data_types .

    RLLAVE          reduce using rule 110 (declaration -> variable data_types .)
    ID              reduce using rule 110 (declaration -> variable data_types .)


state 258

    (134) cases -> CASE values POINTS . codigo
    (135) cases -> CASE values POINTS . codigo more
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . slice_declaration COLON
    (22) codigo -> . slice_declaration
    (23) codigo -> . slice_var COLON
    (24) codigo -> . slice_var
    (25) codigo -> . slice_assignment COLON
    (26) codigo -> . slice_assignment
    (27) codigo -> . map_declaration COLON
    (28) codigo -> . map_declaration
    (29) codigo -> . map_assignment COLON
    (30) codigo -> . map_assignment
    (31) codigo -> . func_declaration
    (165) impresion -> . PRINT LPAREN expression RPAREN
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (61) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (62) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (63) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (64) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (67) decVar -> . decVarOne
    (68) decVar -> . VAR ID EQUAL INTEGER
    (69) decVar -> . VAR ID EQUAL ID
    (70) decVar -> . VAR ID EQUAL FLOAT
    (71) decVar -> . VAR ID EQUAL expression
    (72) decVar -> . VAR ID EQUAL logic_operation
    (73) decVar -> . VAR ID EQUAL comparison
    (74) decVar -> . VAR ID EQUAL STRING
    (75) decVar -> . ID DEQUAL STRING
    (76) decVar -> . ID DEQUAL FLOAT
    (77) decVar -> . ID DEQUAL expression
    (78) decVar -> . ID DEQUAL logic_operation
    (79) decVar -> . ID DEQUAL comparison
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (106) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (107) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (108) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (109) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (138) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (139) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (143) array_var -> . ID LCORCHE index RCORCHE
    (147) array_assignment -> . array_var EQUAL something
    (80) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (81) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (82) slice_declaration -> . VAR ID EQUAL funM
    (83) slice_declaration -> . ID DEQUAL funM
    (84) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (90) slice_var -> . ID LCORCHE index_s RCORCHE
    (94) slice_assignment -> . slice_var EQUAL something_s
    (148) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (153) map_assignment -> . array_var EQUAL something
    (154) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (104) decVarOne -> . ID DEQUAL ID
    (105) decVarOne -> . ID DEQUAL INTEGER
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (149) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 21
    FOR             shift and go to state 23
    VAR             shift and go to state 28
    ID              shift and go to state 29
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35
    IF              shift and go to state 36
    TYPE            shift and go to state 37
    SWITCH          shift and go to state 38
    FUNC            shift and go to state 39
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    NOT             shift and go to state 41

    codigo                         shift and go to state 275
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    slice_declaration              shift and go to state 15
    slice_var                      shift and go to state 16
    slice_assignment               shift and go to state 17
    map_declaration                shift and go to state 18
    map_assignment                 shift and go to state 19
    func_declaration               shift and go to state 20
    something_ex                   shift and go to state 22
    decVarOne                      shift and go to state 24
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    data_structure                 shift and go to state 40
    map_var                        shift and go to state 42

state 259

    (164) more_params -> ID data_types COMA . params
    (162) params -> . ID data_types
    (163) params -> . more_params
    (164) more_params -> . ID data_types COMA params

    ID              shift and go to state 210

    params                         shift and go to state 276
    more_params                    shift and go to state 212

state 260

    (154) func_declaration -> FUNC ID LPAREN params RPAREN data_types . LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> FUNC ID LPAREN params RPAREN data_types . LLLAVE RETURN return_value RLLAVE

    LLLAVE          shift and go to state 277


state 261

    (64) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . slice_declaration COLON
    (22) codigo -> . slice_declaration
    (23) codigo -> . slice_var COLON
    (24) codigo -> . slice_var
    (25) codigo -> . slice_assignment COLON
    (26) codigo -> . slice_assignment
    (27) codigo -> . map_declaration COLON
    (28) codigo -> . map_declaration
    (29) codigo -> . map_assignment COLON
    (30) codigo -> . map_assignment
    (31) codigo -> . func_declaration
    (165) impresion -> . PRINT LPAREN expression RPAREN
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (61) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (62) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (63) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (64) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (67) decVar -> . decVarOne
    (68) decVar -> . VAR ID EQUAL INTEGER
    (69) decVar -> . VAR ID EQUAL ID
    (70) decVar -> . VAR ID EQUAL FLOAT
    (71) decVar -> . VAR ID EQUAL expression
    (72) decVar -> . VAR ID EQUAL logic_operation
    (73) decVar -> . VAR ID EQUAL comparison
    (74) decVar -> . VAR ID EQUAL STRING
    (75) decVar -> . ID DEQUAL STRING
    (76) decVar -> . ID DEQUAL FLOAT
    (77) decVar -> . ID DEQUAL expression
    (78) decVar -> . ID DEQUAL logic_operation
    (79) decVar -> . ID DEQUAL comparison
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (106) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (107) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (108) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (109) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (138) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (139) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (143) array_var -> . ID LCORCHE index RCORCHE
    (147) array_assignment -> . array_var EQUAL something
    (80) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (81) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (82) slice_declaration -> . VAR ID EQUAL funM
    (83) slice_declaration -> . ID DEQUAL funM
    (84) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (90) slice_var -> . ID LCORCHE index_s RCORCHE
    (94) slice_assignment -> . slice_var EQUAL something_s
    (148) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (153) map_assignment -> . array_var EQUAL something
    (154) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (104) decVarOne -> . ID DEQUAL ID
    (105) decVarOne -> . ID DEQUAL INTEGER
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (149) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 21
    FOR             shift and go to state 23
    VAR             shift and go to state 28
    ID              shift and go to state 29
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35
    IF              shift and go to state 36
    TYPE            shift and go to state 37
    SWITCH          shift and go to state 38
    FUNC            shift and go to state 39
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    NOT             shift and go to state 41

    decVarOne                      shift and go to state 24
    comparison                     shift and go to state 5
    codigo                         shift and go to state 278
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    slice_declaration              shift and go to state 15
    slice_var                      shift and go to state 16
    slice_assignment               shift and go to state 17
    map_declaration                shift and go to state 18
    map_assignment                 shift and go to state 19
    func_declaration               shift and go to state 20
    something_ex                   shift and go to state 22
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    data_structure                 shift and go to state 40
    map_var                        shift and go to state 42

state 262

    (65) incre -> ID INCREASE .

    LLLAVE          reduce using rule 65 (incre -> ID INCREASE .)


state 263

    (66) incre -> ID DECREASE .

    LLLAVE          reduce using rule 66 (incre -> ID DECREASE .)


state 264

    (139) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types . arr_content
    (51) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (52) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 246

    arr_content                    shift and go to state 279

state 265

    (81) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .

    COLON           reduce using rule 81 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    $end            reduce using rule 81 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 81 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 81 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    CASE            reduce using rule 81 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    RETURN          reduce using rule 81 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)


state 266

    (51) arr_content -> LLLAVE items . COMA more_items RLLAVE
    (52) arr_content -> LLLAVE items . RLLAVE

    COMA            shift and go to state 280
    RLLAVE          shift and go to state 281


state 267

    (55) items -> values .

    COMA            reduce using rule 55 (items -> values .)
    RLLAVE          reduce using rule 55 (items -> values .)


state 268

    (56) items -> operations .

    COMA            reduce using rule 56 (items -> operations .)
    RLLAVE          reduce using rule 56 (items -> operations .)


state 269

    (170) something_ex -> ID .
    (114) value -> ID .
    (128) logic_value -> ID .
    (143) array_var -> ID . LCORCHE index RCORCHE
    (149) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 114 (value -> ID .)
    COMA            reduce using rule 170 (something_ex -> ID .)
    RLLAVE          reduce using rule 170 (something_ex -> ID .)
    GREATER         reduce using rule 114 (value -> ID .)
    SMALLER         reduce using rule 114 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 114 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 114 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 114 (value -> ID .)
    NOT_EQUAL       reduce using rule 114 (value -> ID .)
    PLUS            reduce using rule 114 (value -> ID .)
    TIMES           reduce using rule 114 (value -> ID .)
    DIVIDE          reduce using rule 114 (value -> ID .)
    MINUS           reduce using rule 114 (value -> ID .)
    AND             reduce using rule 128 (logic_value -> ID .)
    OR              reduce using rule 128 (logic_value -> ID .)
    LCORCHE         shift and go to state 122

  ! GREATER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 170 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 170 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 170 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 170 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 170 (something_ex -> ID .) ]


state 270

    (85) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap RPAREN
    (86) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap COMA cap RPAREN

    COMA            shift and go to state 282


state 271

    (106) SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .

    $end            reduce using rule 106 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 106 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 106 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 106 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 106 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)


state 272

    (107) SenIF -> IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE .

    $end            reduce using rule 107 (SenIF -> IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 107 (SenIF -> IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 107 (SenIF -> IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 107 (SenIF -> IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 107 (SenIF -> IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE .)


state 273

    (108) SenIF -> IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE .

    $end            reduce using rule 108 (SenIF -> IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 108 (SenIF -> IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 108 (SenIF -> IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 108 (SenIF -> IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 108 (SenIF -> IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE .)


state 274

    (111) declaration -> declaration variable data_types .

    RLLAVE          reduce using rule 111 (declaration -> declaration variable data_types .)
    ID              reduce using rule 111 (declaration -> declaration variable data_types .)


state 275

    (134) cases -> CASE values POINTS codigo .
    (135) cases -> CASE values POINTS codigo . more
    (136) more -> . cases
    (137) more -> . DEFAULT POINTS codigo
    (134) cases -> . CASE values POINTS codigo
    (135) cases -> . CASE values POINTS codigo more

    RLLAVE          reduce using rule 134 (cases -> CASE values POINTS codigo .)
    DEFAULT         shift and go to state 285
    CASE            shift and go to state 209

    more                           shift and go to state 283
    cases                          shift and go to state 284

state 276

    (164) more_params -> ID data_types COMA params .

    RPAREN          reduce using rule 164 (more_params -> ID data_types COMA params .)


state 277

    (154) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE . codigo RETURN retorno RLLAVE
    (155) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE . RETURN return_value RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . slice_declaration COLON
    (22) codigo -> . slice_declaration
    (23) codigo -> . slice_var COLON
    (24) codigo -> . slice_var
    (25) codigo -> . slice_assignment COLON
    (26) codigo -> . slice_assignment
    (27) codigo -> . map_declaration COLON
    (28) codigo -> . map_declaration
    (29) codigo -> . map_assignment COLON
    (30) codigo -> . map_assignment
    (31) codigo -> . func_declaration
    (165) impresion -> . PRINT LPAREN expression RPAREN
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (61) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (62) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (63) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (64) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (67) decVar -> . decVarOne
    (68) decVar -> . VAR ID EQUAL INTEGER
    (69) decVar -> . VAR ID EQUAL ID
    (70) decVar -> . VAR ID EQUAL FLOAT
    (71) decVar -> . VAR ID EQUAL expression
    (72) decVar -> . VAR ID EQUAL logic_operation
    (73) decVar -> . VAR ID EQUAL comparison
    (74) decVar -> . VAR ID EQUAL STRING
    (75) decVar -> . ID DEQUAL STRING
    (76) decVar -> . ID DEQUAL FLOAT
    (77) decVar -> . ID DEQUAL expression
    (78) decVar -> . ID DEQUAL logic_operation
    (79) decVar -> . ID DEQUAL comparison
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (106) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (107) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (108) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (109) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (138) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (139) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (143) array_var -> . ID LCORCHE index RCORCHE
    (147) array_assignment -> . array_var EQUAL something
    (80) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (81) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (82) slice_declaration -> . VAR ID EQUAL funM
    (83) slice_declaration -> . ID DEQUAL funM
    (84) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (90) slice_var -> . ID LCORCHE index_s RCORCHE
    (94) slice_assignment -> . slice_var EQUAL something_s
    (148) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (153) map_assignment -> . array_var EQUAL something
    (154) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (104) decVarOne -> . ID DEQUAL ID
    (105) decVarOne -> . ID DEQUAL INTEGER
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (149) map_var -> . ID LCORCHE key RCORCHE

    RETURN          shift and go to state 287
    PRINT           shift and go to state 21
    FOR             shift and go to state 23
    VAR             shift and go to state 28
    ID              shift and go to state 29
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35
    IF              shift and go to state 36
    TYPE            shift and go to state 37
    SWITCH          shift and go to state 38
    FUNC            shift and go to state 39
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    NOT             shift and go to state 41

    codigo                         shift and go to state 286
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    slice_declaration              shift and go to state 15
    slice_var                      shift and go to state 16
    slice_assignment               shift and go to state 17
    map_declaration                shift and go to state 18
    map_assignment                 shift and go to state 19
    func_declaration               shift and go to state 20
    something_ex                   shift and go to state 22
    decVarOne                      shift and go to state 24
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    data_structure                 shift and go to state 40
    map_var                        shift and go to state 42

state 278

    (64) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 288


state 279

    (139) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .

    COLON           reduce using rule 139 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    $end            reduce using rule 139 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 139 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 139 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    CASE            reduce using rule 139 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RETURN          reduce using rule 139 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)


state 280

    (51) arr_content -> LLLAVE items COMA . more_items RLLAVE
    (53) more_items -> . items COMA more_items
    (54) more_items -> . items
    (55) items -> . values
    (56) items -> . operations
    (32) values -> . STRING
    (33) values -> . INTEGER
    (34) values -> . FLOAT
    (35) values -> . TRUE
    (36) values -> . FALSE
    (46) operations -> . expression
    (47) operations -> . comparison
    (48) operations -> . logic_operation
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    STRING          shift and go to state 101
    INTEGER         shift and go to state 102
    FLOAT           shift and go to state 103
    TRUE            shift and go to state 104
    FALSE           shift and go to state 105
    ID              shift and go to state 269
    NOT             shift and go to state 41
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    items                          shift and go to state 289
    more_items                     shift and go to state 290
    values                         shift and go to state 267
    operations                     shift and go to state 268
    expression                     shift and go to state 106
    comparison                     shift and go to state 107
    logic_operation                shift and go to state 108
    something_ex                   shift and go to state 22
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 281

    (52) arr_content -> LLLAVE items RLLAVE .

    COLON           reduce using rule 52 (arr_content -> LLLAVE items RLLAVE .)
    $end            reduce using rule 52 (arr_content -> LLLAVE items RLLAVE .)
    RLLAVE          reduce using rule 52 (arr_content -> LLLAVE items RLLAVE .)
    DEFAULT         reduce using rule 52 (arr_content -> LLLAVE items RLLAVE .)
    CASE            reduce using rule 52 (arr_content -> LLLAVE items RLLAVE .)
    RETURN          reduce using rule 52 (arr_content -> LLLAVE items RLLAVE .)


state 282

    (85) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap RPAREN
    (86) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap COMA cap RPAREN
    (87) cap -> . INTEGER
    (88) cap -> . ID
    (89) cap -> . expression
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    INTEGER         shift and go to state 292
    ID              shift and go to state 293
    FLOAT           shift and go to state 31
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    cap                            shift and go to state 291
    expression                     shift and go to state 294
    something_ex                   shift and go to state 22
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 283

    (135) cases -> CASE values POINTS codigo more .

    RLLAVE          reduce using rule 135 (cases -> CASE values POINTS codigo more .)


state 284

    (136) more -> cases .

    RLLAVE          reduce using rule 136 (more -> cases .)


state 285

    (137) more -> DEFAULT . POINTS codigo

    POINTS          shift and go to state 295


state 286

    (154) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo . RETURN retorno RLLAVE

    RETURN          shift and go to state 296


state 287

    (155) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN . return_value RLLAVE
    (156) return_value -> . retorno COLON
    (157) return_value -> . retorno
    (158) retorno -> . ID
    (159) retorno -> . values
    (160) retorno -> . operations
    (161) retorno -> . data_structure
    (32) values -> . STRING
    (33) values -> . INTEGER
    (34) values -> . FLOAT
    (35) values -> . TRUE
    (36) values -> . FALSE
    (46) operations -> . expression
    (47) operations -> . comparison
    (48) operations -> . logic_operation
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN

    ID              shift and go to state 297
    STRING          shift and go to state 101
    INTEGER         shift and go to state 102
    FLOAT           shift and go to state 103
    TRUE            shift and go to state 104
    FALSE           shift and go to state 105
    NOT             shift and go to state 41
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    return_value                   shift and go to state 298
    retorno                        shift and go to state 299
    values                         shift and go to state 300
    operations                     shift and go to state 301
    data_structure                 shift and go to state 302
    expression                     shift and go to state 106
    comparison                     shift and go to state 107
    logic_operation                shift and go to state 108
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42
    something_ex                   shift and go to state 22
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    funciones                      shift and go to state 76

state 288

    (64) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .

    $end            reduce using rule 64 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 64 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 64 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 64 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 64 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)


state 289

    (53) more_items -> items . COMA more_items
    (54) more_items -> items .

    COMA            shift and go to state 303
    RLLAVE          reduce using rule 54 (more_items -> items .)


state 290

    (51) arr_content -> LLLAVE items COMA more_items . RLLAVE

    RLLAVE          shift and go to state 304


state 291

    (85) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . RPAREN
    (86) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . COMA cap RPAREN

    RPAREN          shift and go to state 306
    COMA            shift and go to state 305


state 292

    (87) cap -> INTEGER .
    (171) something_ex -> INTEGER .

  ! reduce/reduce conflict for RPAREN resolved using rule 87 (cap -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 87 (cap -> INTEGER .)
    RPAREN          reduce using rule 87 (cap -> INTEGER .)
    COMA            reduce using rule 87 (cap -> INTEGER .)
    GREATER         reduce using rule 171 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 171 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 171 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 171 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 171 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 171 (something_ex -> INTEGER .)
    PLUS            reduce using rule 171 (something_ex -> INTEGER .)
    TIMES           reduce using rule 171 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 171 (something_ex -> INTEGER .)
    MINUS           reduce using rule 171 (something_ex -> INTEGER .)

  ! RPAREN          [ reduce using rule 171 (something_ex -> INTEGER .) ]
  ! COMA            [ reduce using rule 171 (something_ex -> INTEGER .) ]


state 293

    (88) cap -> ID .
    (170) something_ex -> ID .
    (143) array_var -> ID . LCORCHE index RCORCHE
    (149) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for RPAREN resolved using rule 88 (cap -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 88 (cap -> ID .)
    RPAREN          reduce using rule 88 (cap -> ID .)
    COMA            reduce using rule 88 (cap -> ID .)
    GREATER         reduce using rule 170 (something_ex -> ID .)
    SMALLER         reduce using rule 170 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 170 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 170 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 170 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 170 (something_ex -> ID .)
    PLUS            reduce using rule 170 (something_ex -> ID .)
    TIMES           reduce using rule 170 (something_ex -> ID .)
    DIVIDE          reduce using rule 170 (something_ex -> ID .)
    MINUS           reduce using rule 170 (something_ex -> ID .)
    LCORCHE         shift and go to state 122

  ! RPAREN          [ reduce using rule 170 (something_ex -> ID .) ]
  ! COMA            [ reduce using rule 170 (something_ex -> ID .) ]


state 294

    (89) cap -> expression .

    RPAREN          reduce using rule 89 (cap -> expression .)
    COMA            reduce using rule 89 (cap -> expression .)


state 295

    (137) more -> DEFAULT POINTS . codigo
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . slice_declaration COLON
    (22) codigo -> . slice_declaration
    (23) codigo -> . slice_var COLON
    (24) codigo -> . slice_var
    (25) codigo -> . slice_assignment COLON
    (26) codigo -> . slice_assignment
    (27) codigo -> . map_declaration COLON
    (28) codigo -> . map_declaration
    (29) codigo -> . map_assignment COLON
    (30) codigo -> . map_assignment
    (31) codigo -> . func_declaration
    (165) impresion -> . PRINT LPAREN expression RPAREN
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (61) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (62) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (63) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (64) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (67) decVar -> . decVarOne
    (68) decVar -> . VAR ID EQUAL INTEGER
    (69) decVar -> . VAR ID EQUAL ID
    (70) decVar -> . VAR ID EQUAL FLOAT
    (71) decVar -> . VAR ID EQUAL expression
    (72) decVar -> . VAR ID EQUAL logic_operation
    (73) decVar -> . VAR ID EQUAL comparison
    (74) decVar -> . VAR ID EQUAL STRING
    (75) decVar -> . ID DEQUAL STRING
    (76) decVar -> . ID DEQUAL FLOAT
    (77) decVar -> . ID DEQUAL expression
    (78) decVar -> . ID DEQUAL logic_operation
    (79) decVar -> . ID DEQUAL comparison
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (106) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (107) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (108) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (109) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (138) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (139) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (143) array_var -> . ID LCORCHE index RCORCHE
    (147) array_assignment -> . array_var EQUAL something
    (80) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (81) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (82) slice_declaration -> . VAR ID EQUAL funM
    (83) slice_declaration -> . ID DEQUAL funM
    (84) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (90) slice_var -> . ID LCORCHE index_s RCORCHE
    (94) slice_assignment -> . slice_var EQUAL something_s
    (148) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (153) map_assignment -> . array_var EQUAL something
    (154) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (155) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (104) decVarOne -> . ID DEQUAL ID
    (105) decVarOne -> . ID DEQUAL INTEGER
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (149) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 21
    FOR             shift and go to state 23
    VAR             shift and go to state 28
    ID              shift and go to state 29
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35
    IF              shift and go to state 36
    TYPE            shift and go to state 37
    SWITCH          shift and go to state 38
    FUNC            shift and go to state 39
    INTEGER         shift and go to state 30
    FLOAT           shift and go to state 31
    NOT             shift and go to state 41

    codigo                         shift and go to state 307
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    slice_declaration              shift and go to state 15
    slice_var                      shift and go to state 16
    slice_assignment               shift and go to state 17
    map_declaration                shift and go to state 18
    map_assignment                 shift and go to state 19
    func_declaration               shift and go to state 20
    something_ex                   shift and go to state 22
    decVarOne                      shift and go to state 24
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    data_structure                 shift and go to state 40
    map_var                        shift and go to state 42

state 296

    (154) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN . retorno RLLAVE
    (158) retorno -> . ID
    (159) retorno -> . values
    (160) retorno -> . operations
    (161) retorno -> . data_structure
    (32) values -> . STRING
    (33) values -> . INTEGER
    (34) values -> . FLOAT
    (35) values -> . TRUE
    (36) values -> . FALSE
    (46) operations -> . expression
    (47) operations -> . comparison
    (48) operations -> . logic_operation
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN

    ID              shift and go to state 297
    STRING          shift and go to state 101
    INTEGER         shift and go to state 102
    FLOAT           shift and go to state 103
    TRUE            shift and go to state 104
    FALSE           shift and go to state 105
    NOT             shift and go to state 41
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    retorno                        shift and go to state 308
    values                         shift and go to state 300
    operations                     shift and go to state 301
    data_structure                 shift and go to state 302
    expression                     shift and go to state 106
    comparison                     shift and go to state 107
    logic_operation                shift and go to state 108
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42
    something_ex                   shift and go to state 22
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    funciones                      shift and go to state 76

state 297

    (158) retorno -> ID .
    (143) array_var -> ID . LCORCHE index RCORCHE
    (149) map_var -> ID . LCORCHE key RCORCHE
    (170) something_ex -> ID .
    (114) value -> ID .
    (128) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 158 (retorno -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 158 (retorno -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 114 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 114 (value -> ID .)
    COLON           reduce using rule 158 (retorno -> ID .)
    RLLAVE          reduce using rule 158 (retorno -> ID .)
    LCORCHE         shift and go to state 122
    GREATER         reduce using rule 114 (value -> ID .)
    SMALLER         reduce using rule 114 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 114 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 114 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 114 (value -> ID .)
    NOT_EQUAL       reduce using rule 114 (value -> ID .)
    PLUS            reduce using rule 114 (value -> ID .)
    TIMES           reduce using rule 114 (value -> ID .)
    DIVIDE          reduce using rule 114 (value -> ID .)
    MINUS           reduce using rule 114 (value -> ID .)
    AND             reduce using rule 128 (logic_value -> ID .)
    OR              reduce using rule 128 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 170 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 170 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 170 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 170 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 170 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 170 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 170 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 170 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 170 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 170 (something_ex -> ID .) ]


state 298

    (155) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value . RLLAVE

    RLLAVE          shift and go to state 309


state 299

    (156) return_value -> retorno . COLON
    (157) return_value -> retorno .

    COLON           shift and go to state 310
    RLLAVE          reduce using rule 157 (return_value -> retorno .)


state 300

    (159) retorno -> values .

    COLON           reduce using rule 159 (retorno -> values .)
    RLLAVE          reduce using rule 159 (retorno -> values .)


state 301

    (160) retorno -> operations .

    COLON           reduce using rule 160 (retorno -> operations .)
    RLLAVE          reduce using rule 160 (retorno -> operations .)


state 302

    (161) retorno -> data_structure .
    (173) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 161 (retorno -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 161 (retorno -> data_structure .)
    COLON           reduce using rule 161 (retorno -> data_structure .)
    RLLAVE          reduce using rule 161 (retorno -> data_structure .)
    GREATER         reduce using rule 173 (something_ex -> data_structure .)
    SMALLER         reduce using rule 173 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 173 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 173 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 173 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 173 (something_ex -> data_structure .)
    PLUS            reduce using rule 173 (something_ex -> data_structure .)
    TIMES           reduce using rule 173 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 173 (something_ex -> data_structure .)
    MINUS           reduce using rule 173 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 173 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 173 (something_ex -> data_structure .) ]


state 303

    (53) more_items -> items COMA . more_items
    (53) more_items -> . items COMA more_items
    (54) more_items -> . items
    (55) items -> . values
    (56) items -> . operations
    (32) values -> . STRING
    (33) values -> . INTEGER
    (34) values -> . FLOAT
    (35) values -> . TRUE
    (36) values -> . FALSE
    (46) operations -> . expression
    (47) operations -> . comparison
    (48) operations -> . logic_operation
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (113) comparison -> . value op value
    (122) logic_operation -> . logic_value logic_recu
    (123) logic_operation -> . negation
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (114) value -> . ID
    (115) value -> . expression
    (126) logic_value -> . negation
    (127) logic_value -> . comparison
    (128) logic_value -> . ID
    (129) negation -> . NOT comparison
    (130) negation -> . NOT ID
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    STRING          shift and go to state 101
    INTEGER         shift and go to state 102
    FLOAT           shift and go to state 103
    TRUE            shift and go to state 104
    FALSE           shift and go to state 105
    ID              shift and go to state 269
    NOT             shift and go to state 41
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    items                          shift and go to state 289
    more_items                     shift and go to state 311
    values                         shift and go to state 267
    operations                     shift and go to state 268
    expression                     shift and go to state 106
    comparison                     shift and go to state 107
    logic_operation                shift and go to state 108
    something_ex                   shift and go to state 22
    value                          shift and go to state 25
    logic_value                    shift and go to state 26
    negation                       shift and go to state 27
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 304

    (51) arr_content -> LLLAVE items COMA more_items RLLAVE .

    COLON           reduce using rule 51 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    $end            reduce using rule 51 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RLLAVE          reduce using rule 51 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    DEFAULT         reduce using rule 51 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    CASE            reduce using rule 51 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RETURN          reduce using rule 51 (arr_content -> LLLAVE items COMA more_items RLLAVE .)


state 305

    (86) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA . cap RPAREN
    (87) cap -> . INTEGER
    (88) cap -> . ID
    (89) cap -> . expression
    (166) expression -> . something_ex
    (167) expression -> . something_ex adicionaEx
    (170) something_ex -> . ID
    (171) something_ex -> . INTEGER
    (172) something_ex -> . FLOAT
    (173) something_ex -> . data_structure
    (174) something_ex -> . funciones
    (49) data_structure -> . array_var
    (50) data_structure -> . map_var
    (99) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (100) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (101) funciones -> . LEN LPAREN ID RPAREN
    (102) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (103) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (143) array_var -> . ID LCORCHE index RCORCHE
    (149) map_var -> . ID LCORCHE key RCORCHE

    INTEGER         shift and go to state 292
    ID              shift and go to state 293
    FLOAT           shift and go to state 31
    APPEND          shift and go to state 32
    LEN             shift and go to state 33
    COPY            shift and go to state 34
    DELETE          shift and go to state 35

    cap                            shift and go to state 312
    expression                     shift and go to state 294
    something_ex                   shift and go to state 22
    data_structure                 shift and go to state 40
    funciones                      shift and go to state 76
    array_var                      shift and go to state 77
    map_var                        shift and go to state 42

state 306

    (85) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .

    COLON           reduce using rule 85 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    $end            reduce using rule 85 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RLLAVE          reduce using rule 85 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    DEFAULT         reduce using rule 85 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    CASE            reduce using rule 85 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RETURN          reduce using rule 85 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)


state 307

    (137) more -> DEFAULT POINTS codigo .

    RLLAVE          reduce using rule 137 (more -> DEFAULT POINTS codigo .)


state 308

    (154) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno . RLLAVE

    RLLAVE          shift and go to state 313


state 309

    (155) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .

    $end            reduce using rule 155 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    RLLAVE          reduce using rule 155 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    DEFAULT         reduce using rule 155 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    CASE            reduce using rule 155 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    RETURN          reduce using rule 155 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)


state 310

    (156) return_value -> retorno COLON .

    RLLAVE          reduce using rule 156 (return_value -> retorno COLON .)


state 311

    (53) more_items -> items COMA more_items .

    RLLAVE          reduce using rule 53 (more_items -> items COMA more_items .)


state 312

    (86) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap . RPAREN

    RPAREN          shift and go to state 314


state 313

    (154) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .

    $end            reduce using rule 154 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    RLLAVE          reduce using rule 154 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    DEFAULT         reduce using rule 154 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    CASE            reduce using rule 154 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    RETURN          reduce using rule 154 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)


state 314

    (86) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .

    COLON           reduce using rule 86 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    $end            reduce using rule 86 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RLLAVE          reduce using rule 86 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    DEFAULT         reduce using rule 86 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    CASE            reduce using rule 86 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RETURN          reduce using rule 86 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COLON in state 8 resolved as shift
WARNING: shift/reduce conflict for COLON in state 13 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 22 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 22 resolved as shift
WARNING: shift/reduce conflict for GREATER_OR_EQUAL in state 22 resolved as shift
WARNING: shift/reduce conflict for SMALLER_OR_EQUAL in state 22 resolved as shift
WARNING: shift/reduce conflict for EQUAL_COMPARE in state 22 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 22 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 22 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 22 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 22 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 22 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 116 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 116 resolved as shift
WARNING: shift/reduce conflict for GREATER_OR_EQUAL in state 116 resolved as shift
WARNING: shift/reduce conflict for SMALLER_OR_EQUAL in state 116 resolved as shift
WARNING: shift/reduce conflict for EQUAL_COMPARE in state 116 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 116 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 116 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 116 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 116 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 116 resolved as shift
WARNING: reduce/reduce conflict in state 8 resolved using rule (codigo -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 8
WARNING: reduce/reduce conflict in state 13 resolved using rule (codigo -> array_var)
WARNING: rejected rule (data_structure -> array_var) in state 13
WARNING: reduce/reduce conflict in state 29 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 29
WARNING: reduce/reduce conflict in state 74 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 74
WARNING: reduce/reduce conflict in state 95 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 95
WARNING: reduce/reduce conflict in state 96 resolved using rule (array_assignment -> array_var EQUAL something)
WARNING: rejected rule (map_assignment -> array_var EQUAL something) in state 96
WARNING: reduce/reduce conflict in state 97 resolved using rule (something -> ID)
WARNING: rejected rule (something_ex -> ID) in state 97
WARNING: reduce/reduce conflict in state 97 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 97
WARNING: reduce/reduce conflict in state 98 resolved using rule (something -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 98
WARNING: reduce/reduce conflict in state 102 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 102
WARNING: reduce/reduce conflict in state 103 resolved using rule (values -> FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 103
WARNING: reduce/reduce conflict in state 110 resolved using rule (something_s -> ID)
WARNING: rejected rule (something_ex -> ID) in state 110
WARNING: reduce/reduce conflict in state 110 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 110
WARNING: reduce/reduce conflict in state 111 resolved using rule (data_structure -> array_var)
WARNING: rejected rule (something_s -> array_var) in state 111
WARNING: reduce/reduce conflict in state 124 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 124
WARNING: reduce/reduce conflict in state 128 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 128
WARNING: reduce/reduce conflict in state 131 resolved using rule (decVarOne -> ID DEQUAL ID)
WARNING: rejected rule (something_ex -> ID) in state 131
WARNING: reduce/reduce conflict in state 131 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 131
WARNING: reduce/reduce conflict in state 133 resolved using rule (decVar -> ID DEQUAL FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 133
WARNING: reduce/reduce conflict in state 139 resolved using rule (decVarOne -> ID DEQUAL INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 139
WARNING: reduce/reduce conflict in state 141 resolved using rule (index_s -> ID)
WARNING: rejected rule (index -> ID) in state 141
WARNING: reduce/reduce conflict in state 141 resolved using rule (index_s -> ID)
WARNING: rejected rule (key -> ID) in state 141
WARNING: reduce/reduce conflict in state 141 resolved using rule (index_s -> ID)
WARNING: rejected rule (something_ex -> ID) in state 141
WARNING: reduce/reduce conflict in state 141 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 141
WARNING: reduce/reduce conflict in state 145 resolved using rule (index_s -> INTEGER)
WARNING: rejected rule (index -> INTEGER) in state 145
WARNING: reduce/reduce conflict in state 145 resolved using rule (values -> INTEGER)
WARNING: rejected rule (index_s -> INTEGER) in state 145
WARNING: reduce/reduce conflict in state 145 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 145
WARNING: reduce/reduce conflict in state 146 resolved using rule (index_s -> expression)
WARNING: rejected rule (index -> expression) in state 146
WARNING: reduce/reduce conflict in state 146 resolved using rule (operations -> expression)
WARNING: rejected rule (index_s -> expression) in state 146
WARNING: reduce/reduce conflict in state 167 resolved using rule (index -> ID)
WARNING: rejected rule (key -> ID) in state 167
WARNING: reduce/reduce conflict in state 167 resolved using rule (index -> ID)
WARNING: rejected rule (something_ex -> ID) in state 167
WARNING: reduce/reduce conflict in state 167 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 167
WARNING: reduce/reduce conflict in state 168 resolved using rule (values -> INTEGER)
WARNING: rejected rule (index -> INTEGER) in state 168
WARNING: reduce/reduce conflict in state 168 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 168
WARNING: reduce/reduce conflict in state 169 resolved using rule (operations -> expression)
WARNING: rejected rule (index -> expression) in state 169
WARNING: reduce/reduce conflict in state 171 resolved using rule (decVar -> VAR ID EQUAL ID)
WARNING: rejected rule (something_ex -> ID) in state 171
WARNING: reduce/reduce conflict in state 171 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 171
WARNING: reduce/reduce conflict in state 172 resolved using rule (decVar -> VAR ID EQUAL INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 172
WARNING: reduce/reduce conflict in state 173 resolved using rule (decVar -> VAR ID EQUAL FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 173
WARNING: reduce/reduce conflict in state 180 resolved using rule (capacity -> ID)
WARNING: rejected rule (something_ex -> ID) in state 180
WARNING: reduce/reduce conflict in state 184 resolved using rule (capacity -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 184
WARNING: reduce/reduce conflict in state 269 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 269
WARNING: reduce/reduce conflict in state 292 resolved using rule (cap -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 292
WARNING: reduce/reduce conflict in state 293 resolved using rule (cap -> ID)
WARNING: rejected rule (something_ex -> ID) in state 293
WARNING: reduce/reduce conflict in state 297 resolved using rule (retorno -> ID)
WARNING: rejected rule (something_ex -> ID) in state 297
WARNING: reduce/reduce conflict in state 297 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 297
WARNING: reduce/reduce conflict in state 302 resolved using rule (retorno -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 302
WARNING: Rule (map_assignment -> array_var EQUAL something) is never reduced
WARNING: Rule (something_s -> array_var) is never reduced
WARNING: Rule (key -> ID) is never reduced
WARNING: Rule (index -> INTEGER) is never reduced
WARNING: Rule (index_s -> INTEGER) is never reduced
WARNING: Rule (index -> expression) is never reduced
WARNING: Rule (index_s -> expression) is never reduced
