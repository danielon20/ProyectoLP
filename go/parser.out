Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    CAP
    COMMENT
    CONST
    ELSE
    INTERFACE
    JOIN
    MAP
    MOD
    MULTI_COMMENT
    PACKAGE

Grammar

Rule 0     S' -> codigo
Rule 1     codigo -> impresion COLON
Rule 2     codigo -> impresion
Rule 3     codigo -> scan_func COLON
Rule 4     codigo -> scan_func
Rule 5     codigo -> expression COLON
Rule 6     codigo -> expression
Rule 7     codigo -> cicloFor
Rule 8     codigo -> comparison
Rule 9     codigo -> logic_operation
Rule 10    codigo -> decVar COLON
Rule 11    codigo -> decVar
Rule 12    codigo -> var_asignation
Rule 13    codigo -> var_asignation COLON
Rule 14    codigo -> funciones
Rule 15    codigo -> funciones COLON
Rule 16    codigo -> SenIF
Rule 17    codigo -> SenStruct
Rule 18    codigo -> cStruct
Rule 19    codigo -> switch_statement
Rule 20    codigo -> array_declaration COLON
Rule 21    codigo -> array_declaration
Rule 22    codigo -> array_var COLON
Rule 23    codigo -> array_var
Rule 24    codigo -> array_assignment COLON
Rule 25    codigo -> array_assignment
Rule 26    codigo -> slice_declaration COLON
Rule 27    codigo -> slice_declaration
Rule 28    codigo -> slice_var COLON
Rule 29    codigo -> slice_var
Rule 30    codigo -> slice_assignment COLON
Rule 31    codigo -> slice_assignment
Rule 32    codigo -> map_declaration COLON
Rule 33    codigo -> map_declaration
Rule 34    codigo -> map_assignment COLON
Rule 35    codigo -> map_assignment
Rule 36    codigo -> func_declaration
Rule 37    codigo -> main_func
Rule 38    values -> STRING
Rule 39    values -> INTEGER
Rule 40    values -> FLOAT
Rule 41    values -> TRUE
Rule 42    values -> FALSE
Rule 43    data_types -> INT32
Rule 44    data_types -> INT64
Rule 45    data_types -> FLOAT32
Rule 46    data_types -> FLOAT64
Rule 47    data_types -> BYTE
Rule 48    data_types -> WINT
Rule 49    data_types -> WFLOAT
Rule 50    data_types -> WSTRING
Rule 51    data_types -> BOOL
Rule 52    operations -> expression
Rule 53    operations -> comparison
Rule 54    operations -> logic_operation
Rule 55    data_structure -> array_var
Rule 56    data_structure -> map_var
Rule 57    var_asignation -> ID EQUAL any
Rule 58    any -> values
Rule 59    any -> operations
Rule 60    any -> ID
Rule 61    any -> data_structure
Rule 62    any -> funciones
Rule 63    arr_content -> LLLAVE items COMA more_items RLLAVE
Rule 64    arr_content -> LLLAVE items RLLAVE
Rule 65    more_items -> items COMA more_items
Rule 66    more_items -> items
Rule 67    items -> values
Rule 68    items -> operations
Rule 69    something -> ID
Rule 70    something -> data_structure
Rule 71    something -> values
Rule 72    something -> operations
Rule 73    main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
Rule 74    scan_func -> SCAN LPAREN POINTER RPAREN
Rule 75    cicloFor -> FOR LLLAVE codigo RLLAVE
Rule 76    cicloFor -> FOR comparison LLLAVE codigo RLLAVE
Rule 77    cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE
Rule 78    cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
Rule 79    incre -> ID INCREASE
Rule 80    incre -> ID DECREASE
Rule 81    decVar -> decVarOne
Rule 82    decVar -> VAR ID EQUAL INTEGER
Rule 83    decVar -> VAR ID EQUAL ID
Rule 84    decVar -> VAR ID EQUAL FLOAT
Rule 85    decVar -> VAR ID EQUAL expression
Rule 86    decVar -> VAR ID EQUAL logic_operation
Rule 87    decVar -> VAR ID EQUAL comparison
Rule 88    decVar -> VAR ID EQUAL STRING
Rule 89    decVar -> ID DEQUAL STRING
Rule 90    decVar -> ID DEQUAL FLOAT
Rule 91    decVar -> ID DEQUAL expression
Rule 92    decVar -> ID DEQUAL logic_operation
Rule 93    decVar -> ID DEQUAL comparison
Rule 94    slice_declaration -> VAR ID LCORCHE RCORCHE data_types
Rule 95    slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
Rule 96    slice_declaration -> VAR ID EQUAL funM
Rule 97    slice_declaration -> ID DEQUAL funM
Rule 98    slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content
Rule 99    funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
Rule 100   funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
Rule 101   cap -> INTEGER
Rule 102   cap -> ID
Rule 103   cap -> expression
Rule 104   slice_var -> ID LCORCHE index_s RCORCHE
Rule 105   index_s -> ID
Rule 106   index_s -> INTEGER
Rule 107   index_s -> expression
Rule 108   slice_assignment -> slice_var EQUAL something_s
Rule 109   something_s -> ID
Rule 110   something_s -> array_var
Rule 111   something_s -> values
Rule 112   something_s -> operations
Rule 113   funciones -> APPEND LPAREN ID COMA values RPAREN
Rule 114   funciones -> APPEND LPAREN ID COMA ID RPAREN
Rule 115   funciones -> LEN LPAREN ID RPAREN
Rule 116   funciones -> COPY LPAREN ID COMA ID RPAREN
Rule 117   funciones -> DELETE LPAREN ID COMA ID RPAREN
Rule 118   decVarOne -> ID DEQUAL ID
Rule 119   decVarOne -> ID DEQUAL INTEGER
Rule 120   SenIF -> IF comparison LLLAVE codigo RLLAVE
Rule 121   SenIF -> IF TRUE LLLAVE codigo RLLAVE
Rule 122   SenIF -> IF FALSE LLLAVE codigo RLLAVE
Rule 123   SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE
Rule 124   declaration -> variable data_types
Rule 125   declaration -> declaration variable data_types
Rule 126   variable -> ID
Rule 127   cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE
Rule 128   asignaciones -> ID POINTS valor
Rule 129   asignaciones -> ID POINTS valor COMA asignaciones
Rule 130   valor -> ID
Rule 131   valor -> INTEGER
Rule 132   valor -> TRUE
Rule 133   valor -> FALSE
Rule 134   comparison -> value op value
Rule 135   value -> ID
Rule 136   value -> expression
Rule 137   op -> GREATER
Rule 138   op -> SMALLER
Rule 139   op -> GREATER_OR_EQUAL
Rule 140   op -> SMALLER_OR_EQUAL
Rule 141   op -> EQUAL_COMPARE
Rule 142   op -> NOT_EQUAL
Rule 143   logic_operation -> logic_value logic_recu
Rule 144   logic_operation -> negation
Rule 145   logic_recu -> logic_op logic_value
Rule 146   logic_recu -> logic_op logic_value logic_recu
Rule 147   logic_value -> negation
Rule 148   logic_value -> comparison
Rule 149   logic_value -> ID
Rule 150   negation -> NOT comparison
Rule 151   negation -> NOT ID
Rule 152   logic_op -> AND
Rule 153   logic_op -> OR
Rule 154   switch_statement -> SWITCH ID LLLAVE cases RLLAVE
Rule 155   cases -> CASE values POINTS codigo
Rule 156   cases -> CASE values POINTS codigo more
Rule 157   more -> cases
Rule 158   more -> DEFAULT POINTS codigo
Rule 159   array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types
Rule 160   array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
Rule 161   capacity -> INTEGER
Rule 162   capacity -> ID
Rule 163   capacity -> expression
Rule 164   array_var -> ID LCORCHE index RCORCHE
Rule 165   index -> ID
Rule 166   index -> INTEGER
Rule 167   index -> expression
Rule 168   array_assignment -> array_var EQUAL something
Rule 169   map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types
Rule 170   map_var -> ID LCORCHE key RCORCHE
Rule 171   key -> ID
Rule 172   key -> values
Rule 173   key -> operations
Rule 174   map_assignment -> array_var EQUAL something
Rule 175   func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
Rule 176   func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
Rule 177   return_value -> retorno COLON
Rule 178   return_value -> retorno
Rule 179   retorno -> ID
Rule 180   retorno -> values
Rule 181   retorno -> operations
Rule 182   retorno -> data_structure
Rule 183   params -> ID data_types
Rule 184   params -> more_params
Rule 185   more_params -> ID data_types COMA params
Rule 186   impresion -> PRINT LPAREN content RPAREN
Rule 187   content -> values
Rule 188   content -> operations
Rule 189   content -> funciones
Rule 190   content -> data_structure
Rule 191   content -> ID
Rule 192   expression -> something_ex
Rule 193   expression -> something_ex adicionaEx
Rule 194   adicionaEx -> op something_ex
Rule 195   adicionaEx -> op something_ex adicionaEx
Rule 196   something_ex -> ID
Rule 197   something_ex -> INTEGER
Rule 198   something_ex -> FLOAT
Rule 199   something_ex -> data_structure
Rule 200   something_ex -> funciones
Rule 201   op -> PLUS
Rule 202   op -> TIMES
Rule 203   op -> DIVIDE
Rule 204   op -> MINUS

Terminals, with rules where they appear

AND                  : 152
APPEND               : 113 114
ARRAY                : 
BOOL                 : 51
BYTE                 : 47
CAP                  : 
CASE                 : 155 156
COLON                : 1 3 5 10 13 15 20 22 24 26 28 30 32 34 78 78 177
COMA                 : 63 65 99 100 100 113 114 116 117 129 185
COMMENT              : 
CONST                : 
COPY                 : 116
DECREASE             : 80
DEFAULT              : 158
DELETE               : 117
DEQUAL               : 89 90 91 92 93 97 98 118 119 127
DIVIDE               : 203
ELSE                 : 
EQUAL                : 57 82 83 84 85 86 87 88 95 96 108 160 168 174
EQUAL_COMPARE        : 141
FALSE                : 42 122 133
FLOAT                : 40 84 90 198
FLOAT32              : 45
FLOAT64              : 46
FOR                  : 75 76 77 78
FUNC                 : 73 175 176
GREATER              : 137
GREATER_OR_EQUAL     : 139
ID                   : 57 60 69 79 80 82 83 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 102 104 105 109 113 114 114 115 116 116 117 117 118 118 119 123 126 127 127 128 129 130 135 149 151 154 159 160 162 164 165 169 170 171 175 176 179 183 185 191 196
IF                   : 120 121 122
INCREASE             : 79
INT32                : 43
INT64                : 44
INTEGER              : 39 82 101 106 119 131 161 166 197
INTERFACE            : 
JOIN                 : 
LCORCHE              : 94 95 98 99 100 104 159 160 164 169 170
LEN                  : 115
LLLAVE               : 63 64 73 75 76 77 78 120 121 122 123 127 154 175 176
LPAREN               : 73 74 99 100 113 114 115 116 117 175 176 186
MAIN                 : 73
MAKE                 : 99 100
MAP                  : 
MINUS                : 204
MOD                  : 
MULTI_COMMENT        : 
NOT                  : 150 151
NOT_EQUAL            : 142
OR                   : 153
PACKAGE              : 
PLUS                 : 201
POINTER              : 74
POINTS               : 128 129 155 156 158
PRINT                : 186
RCORCHE              : 94 95 98 99 100 104 159 160 164 169 170
RETURN               : 175 176
RLLAVE               : 63 64 73 75 76 77 78 120 121 122 123 127 154 175 176
RPAREN               : 73 74 99 100 113 114 115 116 117 175 176 186
SCAN                 : 74
SMALLER              : 138
SMALLER_OR_EQUAL     : 140
STRING               : 38 88 89
STRUCT               : 123
SWITCH               : 154
TIMES                : 202
TRUE                 : 41 121 132
TYPE                 : 123
VAR                  : 82 83 84 85 86 87 88 94 95 96 159 160 169
WFLOAT               : 49
WINT                 : 48
WSTRING              : 50
error                : 

Nonterminals, with rules where they appear

SenIF                : 16
SenStruct            : 17
adicionaEx           : 193 195
any                  : 57
arr_content          : 95 98 160
array_assignment     : 24 25
array_declaration    : 20 21
array_var            : 22 23 55 110 168 174
asignaciones         : 127 129
cStruct              : 18
cap                  : 99 100 100
capacity             : 159 160
cases                : 154 157
cicloFor             : 7
codigo               : 73 75 76 77 78 120 121 122 155 156 158 175 0
comparison           : 8 53 76 78 87 93 120 148 150
content              : 186
data_structure       : 61 70 182 190 199
data_types           : 94 95 98 99 100 124 125 159 160 169 169 175 176 183 185
decVar               : 10 11
decVarOne            : 78 81
declaration          : 123 125
expression           : 5 6 52 85 91 103 107 136 163 167
funM                 : 96 97
func_declaration     : 36
funciones            : 14 15 62 189 200
impresion            : 1 2
incre                : 78
index                : 164
index_s              : 104
items                : 63 64 65 66
key                  : 170
logic_op             : 145 146
logic_operation      : 9 54 77 86 92
logic_recu           : 143 146
logic_value          : 143 145 146
main_func            : 37
map_assignment       : 34 35
map_declaration      : 32 33
map_var              : 56
more                 : 156
more_items           : 63 65
more_params          : 184
negation             : 144 147
op                   : 134 194 195
operations           : 59 68 72 112 173 181 188
params               : 175 176 185
retorno              : 175 177 178
return_value         : 176
scan_func            : 3 4
slice_assignment     : 30 31
slice_declaration    : 26 27
slice_var            : 28 29 108
something            : 168 174
something_ex         : 192 193 194 195
something_s          : 108
switch_statement     : 19
valor                : 128 129
value                : 134 134
values               : 58 67 71 111 113 155 156 172 180 187
var_asignation       : 12 13
variable             : 124 125

Parsing method: LALR

state 0

    (0) S' -> . codigo
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenStruct
    (18) codigo -> . cStruct
    (19) codigo -> . switch_statement
    (20) codigo -> . array_declaration COLON
    (21) codigo -> . array_declaration
    (22) codigo -> . array_var COLON
    (23) codigo -> . array_var
    (24) codigo -> . array_assignment COLON
    (25) codigo -> . array_assignment
    (26) codigo -> . slice_declaration COLON
    (27) codigo -> . slice_declaration
    (28) codigo -> . slice_var COLON
    (29) codigo -> . slice_var
    (30) codigo -> . slice_assignment COLON
    (31) codigo -> . slice_assignment
    (32) codigo -> . map_declaration COLON
    (33) codigo -> . map_declaration
    (34) codigo -> . map_assignment COLON
    (35) codigo -> . map_assignment
    (36) codigo -> . func_declaration
    (37) codigo -> . main_func
    (186) impresion -> . PRINT LPAREN content RPAREN
    (74) scan_func -> . SCAN LPAREN POINTER RPAREN
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (75) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (76) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (77) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (81) decVar -> . decVarOne
    (82) decVar -> . VAR ID EQUAL INTEGER
    (83) decVar -> . VAR ID EQUAL ID
    (84) decVar -> . VAR ID EQUAL FLOAT
    (85) decVar -> . VAR ID EQUAL expression
    (86) decVar -> . VAR ID EQUAL logic_operation
    (87) decVar -> . VAR ID EQUAL comparison
    (88) decVar -> . VAR ID EQUAL STRING
    (89) decVar -> . ID DEQUAL STRING
    (90) decVar -> . ID DEQUAL FLOAT
    (91) decVar -> . ID DEQUAL expression
    (92) decVar -> . ID DEQUAL logic_operation
    (93) decVar -> . ID DEQUAL comparison
    (57) var_asignation -> . ID EQUAL any
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (120) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (121) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (122) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (123) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (127) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (154) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (159) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (160) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (164) array_var -> . ID LCORCHE index RCORCHE
    (168) array_assignment -> . array_var EQUAL something
    (94) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (95) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (96) slice_declaration -> . VAR ID EQUAL funM
    (97) slice_declaration -> . ID DEQUAL funM
    (98) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (104) slice_var -> . ID LCORCHE index_s RCORCHE
    (108) slice_assignment -> . slice_var EQUAL something_s
    (169) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (174) map_assignment -> . array_var EQUAL something
    (175) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (73) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (118) decVarOne -> . ID DEQUAL ID
    (119) decVarOne -> . ID DEQUAL INTEGER
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (170) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 25
    SCAN            shift and go to state 26
    FOR             shift and go to state 28
    VAR             shift and go to state 33
    ID              shift and go to state 34
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40
    IF              shift and go to state 41
    TYPE            shift and go to state 42
    SWITCH          shift and go to state 43
    FUNC            shift and go to state 44
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    NOT             shift and go to state 46

    codigo                         shift and go to state 1
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenStruct                      shift and go to state 12
    cStruct                        shift and go to state 13
    switch_statement               shift and go to state 14
    array_declaration              shift and go to state 15
    array_var                      shift and go to state 16
    array_assignment               shift and go to state 17
    slice_declaration              shift and go to state 18
    slice_var                      shift and go to state 19
    slice_assignment               shift and go to state 20
    map_declaration                shift and go to state 21
    map_assignment                 shift and go to state 22
    func_declaration               shift and go to state 23
    main_func                      shift and go to state 24
    something_ex                   shift and go to state 27
    decVarOne                      shift and go to state 29
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    data_structure                 shift and go to state 45
    map_var                        shift and go to state 47

state 1

    (0) S' -> codigo .



state 2

    (1) codigo -> impresion . COLON
    (2) codigo -> impresion .

    COLON           shift and go to state 48
    $end            reduce using rule 2 (codigo -> impresion .)
    RLLAVE          reduce using rule 2 (codigo -> impresion .)
    DEFAULT         reduce using rule 2 (codigo -> impresion .)
    CASE            reduce using rule 2 (codigo -> impresion .)
    RETURN          reduce using rule 2 (codigo -> impresion .)


state 3

    (3) codigo -> scan_func . COLON
    (4) codigo -> scan_func .

    COLON           shift and go to state 49
    $end            reduce using rule 4 (codigo -> scan_func .)
    RLLAVE          reduce using rule 4 (codigo -> scan_func .)
    DEFAULT         reduce using rule 4 (codigo -> scan_func .)
    CASE            reduce using rule 4 (codigo -> scan_func .)
    RETURN          reduce using rule 4 (codigo -> scan_func .)


state 4

    (5) codigo -> expression . COLON
    (6) codigo -> expression .
    (136) value -> expression .

    COLON           shift and go to state 50
    $end            reduce using rule 6 (codigo -> expression .)
    RLLAVE          reduce using rule 6 (codigo -> expression .)
    DEFAULT         reduce using rule 6 (codigo -> expression .)
    CASE            reduce using rule 6 (codigo -> expression .)
    RETURN          reduce using rule 6 (codigo -> expression .)
    GREATER         reduce using rule 136 (value -> expression .)
    SMALLER         reduce using rule 136 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 136 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 136 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 136 (value -> expression .)
    NOT_EQUAL       reduce using rule 136 (value -> expression .)
    PLUS            reduce using rule 136 (value -> expression .)
    TIMES           reduce using rule 136 (value -> expression .)
    DIVIDE          reduce using rule 136 (value -> expression .)
    MINUS           reduce using rule 136 (value -> expression .)


state 5

    (7) codigo -> cicloFor .

    $end            reduce using rule 7 (codigo -> cicloFor .)
    RLLAVE          reduce using rule 7 (codigo -> cicloFor .)
    DEFAULT         reduce using rule 7 (codigo -> cicloFor .)
    CASE            reduce using rule 7 (codigo -> cicloFor .)
    RETURN          reduce using rule 7 (codigo -> cicloFor .)


state 6

    (8) codigo -> comparison .
    (148) logic_value -> comparison .

    $end            reduce using rule 8 (codigo -> comparison .)
    RLLAVE          reduce using rule 8 (codigo -> comparison .)
    DEFAULT         reduce using rule 8 (codigo -> comparison .)
    CASE            reduce using rule 8 (codigo -> comparison .)
    RETURN          reduce using rule 8 (codigo -> comparison .)
    AND             reduce using rule 148 (logic_value -> comparison .)
    OR              reduce using rule 148 (logic_value -> comparison .)


state 7

    (9) codigo -> logic_operation .

    $end            reduce using rule 9 (codigo -> logic_operation .)
    RLLAVE          reduce using rule 9 (codigo -> logic_operation .)
    DEFAULT         reduce using rule 9 (codigo -> logic_operation .)
    CASE            reduce using rule 9 (codigo -> logic_operation .)
    RETURN          reduce using rule 9 (codigo -> logic_operation .)


state 8

    (10) codigo -> decVar . COLON
    (11) codigo -> decVar .

    COLON           shift and go to state 51
    $end            reduce using rule 11 (codigo -> decVar .)
    RLLAVE          reduce using rule 11 (codigo -> decVar .)
    DEFAULT         reduce using rule 11 (codigo -> decVar .)
    CASE            reduce using rule 11 (codigo -> decVar .)
    RETURN          reduce using rule 11 (codigo -> decVar .)


state 9

    (12) codigo -> var_asignation .
    (13) codigo -> var_asignation . COLON

    $end            reduce using rule 12 (codigo -> var_asignation .)
    RLLAVE          reduce using rule 12 (codigo -> var_asignation .)
    DEFAULT         reduce using rule 12 (codigo -> var_asignation .)
    CASE            reduce using rule 12 (codigo -> var_asignation .)
    RETURN          reduce using rule 12 (codigo -> var_asignation .)
    COLON           shift and go to state 52


state 10

    (14) codigo -> funciones .
    (15) codigo -> funciones . COLON
    (200) something_ex -> funciones .

  ! shift/reduce conflict for COLON resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 14 (codigo -> funciones .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 14 (codigo -> funciones .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 14 (codigo -> funciones .)
  ! reduce/reduce conflict for CASE resolved using rule 14 (codigo -> funciones .)
  ! reduce/reduce conflict for RETURN resolved using rule 14 (codigo -> funciones .)
    $end            reduce using rule 14 (codigo -> funciones .)
    RLLAVE          reduce using rule 14 (codigo -> funciones .)
    DEFAULT         reduce using rule 14 (codigo -> funciones .)
    CASE            reduce using rule 14 (codigo -> funciones .)
    RETURN          reduce using rule 14 (codigo -> funciones .)
    COLON           shift and go to state 53
    GREATER         reduce using rule 200 (something_ex -> funciones .)
    SMALLER         reduce using rule 200 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 200 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 200 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 200 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 200 (something_ex -> funciones .)
    PLUS            reduce using rule 200 (something_ex -> funciones .)
    TIMES           reduce using rule 200 (something_ex -> funciones .)
    DIVIDE          reduce using rule 200 (something_ex -> funciones .)
    MINUS           reduce using rule 200 (something_ex -> funciones .)

  ! COLON           [ reduce using rule 200 (something_ex -> funciones .) ]
  ! $end            [ reduce using rule 200 (something_ex -> funciones .) ]
  ! RLLAVE          [ reduce using rule 200 (something_ex -> funciones .) ]
  ! DEFAULT         [ reduce using rule 200 (something_ex -> funciones .) ]
  ! CASE            [ reduce using rule 200 (something_ex -> funciones .) ]
  ! RETURN          [ reduce using rule 200 (something_ex -> funciones .) ]


state 11

    (16) codigo -> SenIF .

    $end            reduce using rule 16 (codigo -> SenIF .)
    RLLAVE          reduce using rule 16 (codigo -> SenIF .)
    DEFAULT         reduce using rule 16 (codigo -> SenIF .)
    CASE            reduce using rule 16 (codigo -> SenIF .)
    RETURN          reduce using rule 16 (codigo -> SenIF .)


state 12

    (17) codigo -> SenStruct .

    $end            reduce using rule 17 (codigo -> SenStruct .)
    RLLAVE          reduce using rule 17 (codigo -> SenStruct .)
    DEFAULT         reduce using rule 17 (codigo -> SenStruct .)
    CASE            reduce using rule 17 (codigo -> SenStruct .)
    RETURN          reduce using rule 17 (codigo -> SenStruct .)


state 13

    (18) codigo -> cStruct .

    $end            reduce using rule 18 (codigo -> cStruct .)
    RLLAVE          reduce using rule 18 (codigo -> cStruct .)
    DEFAULT         reduce using rule 18 (codigo -> cStruct .)
    CASE            reduce using rule 18 (codigo -> cStruct .)
    RETURN          reduce using rule 18 (codigo -> cStruct .)


state 14

    (19) codigo -> switch_statement .

    $end            reduce using rule 19 (codigo -> switch_statement .)
    RLLAVE          reduce using rule 19 (codigo -> switch_statement .)
    DEFAULT         reduce using rule 19 (codigo -> switch_statement .)
    CASE            reduce using rule 19 (codigo -> switch_statement .)
    RETURN          reduce using rule 19 (codigo -> switch_statement .)


state 15

    (20) codigo -> array_declaration . COLON
    (21) codigo -> array_declaration .

    COLON           shift and go to state 54
    $end            reduce using rule 21 (codigo -> array_declaration .)
    RLLAVE          reduce using rule 21 (codigo -> array_declaration .)
    DEFAULT         reduce using rule 21 (codigo -> array_declaration .)
    CASE            reduce using rule 21 (codigo -> array_declaration .)
    RETURN          reduce using rule 21 (codigo -> array_declaration .)


state 16

    (22) codigo -> array_var . COLON
    (23) codigo -> array_var .
    (168) array_assignment -> array_var . EQUAL something
    (174) map_assignment -> array_var . EQUAL something
    (55) data_structure -> array_var .

  ! shift/reduce conflict for COLON resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 23 (codigo -> array_var .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 23 (codigo -> array_var .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 23 (codigo -> array_var .)
  ! reduce/reduce conflict for CASE resolved using rule 23 (codigo -> array_var .)
  ! reduce/reduce conflict for RETURN resolved using rule 23 (codigo -> array_var .)
    COLON           shift and go to state 55
    $end            reduce using rule 23 (codigo -> array_var .)
    RLLAVE          reduce using rule 23 (codigo -> array_var .)
    DEFAULT         reduce using rule 23 (codigo -> array_var .)
    CASE            reduce using rule 23 (codigo -> array_var .)
    RETURN          reduce using rule 23 (codigo -> array_var .)
    EQUAL           shift and go to state 56
    GREATER         reduce using rule 55 (data_structure -> array_var .)
    SMALLER         reduce using rule 55 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 55 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 55 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 55 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 55 (data_structure -> array_var .)
    PLUS            reduce using rule 55 (data_structure -> array_var .)
    TIMES           reduce using rule 55 (data_structure -> array_var .)
    DIVIDE          reduce using rule 55 (data_structure -> array_var .)
    MINUS           reduce using rule 55 (data_structure -> array_var .)

  ! COLON           [ reduce using rule 55 (data_structure -> array_var .) ]
  ! $end            [ reduce using rule 55 (data_structure -> array_var .) ]
  ! RLLAVE          [ reduce using rule 55 (data_structure -> array_var .) ]
  ! DEFAULT         [ reduce using rule 55 (data_structure -> array_var .) ]
  ! CASE            [ reduce using rule 55 (data_structure -> array_var .) ]
  ! RETURN          [ reduce using rule 55 (data_structure -> array_var .) ]


state 17

    (24) codigo -> array_assignment . COLON
    (25) codigo -> array_assignment .

    COLON           shift and go to state 57
    $end            reduce using rule 25 (codigo -> array_assignment .)
    RLLAVE          reduce using rule 25 (codigo -> array_assignment .)
    DEFAULT         reduce using rule 25 (codigo -> array_assignment .)
    CASE            reduce using rule 25 (codigo -> array_assignment .)
    RETURN          reduce using rule 25 (codigo -> array_assignment .)


state 18

    (26) codigo -> slice_declaration . COLON
    (27) codigo -> slice_declaration .

    COLON           shift and go to state 58
    $end            reduce using rule 27 (codigo -> slice_declaration .)
    RLLAVE          reduce using rule 27 (codigo -> slice_declaration .)
    DEFAULT         reduce using rule 27 (codigo -> slice_declaration .)
    CASE            reduce using rule 27 (codigo -> slice_declaration .)
    RETURN          reduce using rule 27 (codigo -> slice_declaration .)


state 19

    (28) codigo -> slice_var . COLON
    (29) codigo -> slice_var .
    (108) slice_assignment -> slice_var . EQUAL something_s

    COLON           shift and go to state 59
    $end            reduce using rule 29 (codigo -> slice_var .)
    RLLAVE          reduce using rule 29 (codigo -> slice_var .)
    DEFAULT         reduce using rule 29 (codigo -> slice_var .)
    CASE            reduce using rule 29 (codigo -> slice_var .)
    RETURN          reduce using rule 29 (codigo -> slice_var .)
    EQUAL           shift and go to state 60


state 20

    (30) codigo -> slice_assignment . COLON
    (31) codigo -> slice_assignment .

    COLON           shift and go to state 61
    $end            reduce using rule 31 (codigo -> slice_assignment .)
    RLLAVE          reduce using rule 31 (codigo -> slice_assignment .)
    DEFAULT         reduce using rule 31 (codigo -> slice_assignment .)
    CASE            reduce using rule 31 (codigo -> slice_assignment .)
    RETURN          reduce using rule 31 (codigo -> slice_assignment .)


state 21

    (32) codigo -> map_declaration . COLON
    (33) codigo -> map_declaration .

    COLON           shift and go to state 62
    $end            reduce using rule 33 (codigo -> map_declaration .)
    RLLAVE          reduce using rule 33 (codigo -> map_declaration .)
    DEFAULT         reduce using rule 33 (codigo -> map_declaration .)
    CASE            reduce using rule 33 (codigo -> map_declaration .)
    RETURN          reduce using rule 33 (codigo -> map_declaration .)


state 22

    (34) codigo -> map_assignment . COLON
    (35) codigo -> map_assignment .

    COLON           shift and go to state 63
    $end            reduce using rule 35 (codigo -> map_assignment .)
    RLLAVE          reduce using rule 35 (codigo -> map_assignment .)
    DEFAULT         reduce using rule 35 (codigo -> map_assignment .)
    CASE            reduce using rule 35 (codigo -> map_assignment .)
    RETURN          reduce using rule 35 (codigo -> map_assignment .)


state 23

    (36) codigo -> func_declaration .

    $end            reduce using rule 36 (codigo -> func_declaration .)
    RLLAVE          reduce using rule 36 (codigo -> func_declaration .)
    DEFAULT         reduce using rule 36 (codigo -> func_declaration .)
    CASE            reduce using rule 36 (codigo -> func_declaration .)
    RETURN          reduce using rule 36 (codigo -> func_declaration .)


state 24

    (37) codigo -> main_func .

    $end            reduce using rule 37 (codigo -> main_func .)
    RLLAVE          reduce using rule 37 (codigo -> main_func .)
    DEFAULT         reduce using rule 37 (codigo -> main_func .)
    CASE            reduce using rule 37 (codigo -> main_func .)
    RETURN          reduce using rule 37 (codigo -> main_func .)


state 25

    (186) impresion -> PRINT . LPAREN content RPAREN

    LPAREN          shift and go to state 64


state 26

    (74) scan_func -> SCAN . LPAREN POINTER RPAREN

    LPAREN          shift and go to state 65


state 27

    (192) expression -> something_ex .
    (193) expression -> something_ex . adicionaEx
    (194) adicionaEx -> . op something_ex
    (195) adicionaEx -> . op something_ex adicionaEx
    (137) op -> . GREATER
    (138) op -> . SMALLER
    (139) op -> . GREATER_OR_EQUAL
    (140) op -> . SMALLER_OR_EQUAL
    (141) op -> . EQUAL_COMPARE
    (142) op -> . NOT_EQUAL
    (201) op -> . PLUS
    (202) op -> . TIMES
    (203) op -> . DIVIDE
    (204) op -> . MINUS

  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL_COMPARE resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    COLON           reduce using rule 192 (expression -> something_ex .)
    $end            reduce using rule 192 (expression -> something_ex .)
    RLLAVE          reduce using rule 192 (expression -> something_ex .)
    DEFAULT         reduce using rule 192 (expression -> something_ex .)
    CASE            reduce using rule 192 (expression -> something_ex .)
    RETURN          reduce using rule 192 (expression -> something_ex .)
    RPAREN          reduce using rule 192 (expression -> something_ex .)
    AND             reduce using rule 192 (expression -> something_ex .)
    OR              reduce using rule 192 (expression -> something_ex .)
    LLLAVE          reduce using rule 192 (expression -> something_ex .)
    RCORCHE         reduce using rule 192 (expression -> something_ex .)
    COMA            reduce using rule 192 (expression -> something_ex .)
    GREATER         shift and go to state 68
    SMALLER         shift and go to state 69
    GREATER_OR_EQUAL shift and go to state 70
    SMALLER_OR_EQUAL shift and go to state 71
    EQUAL_COMPARE   shift and go to state 72
    NOT_EQUAL       shift and go to state 73
    PLUS            shift and go to state 74
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    MINUS           shift and go to state 77

  ! GREATER         [ reduce using rule 192 (expression -> something_ex .) ]
  ! SMALLER         [ reduce using rule 192 (expression -> something_ex .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 192 (expression -> something_ex .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 192 (expression -> something_ex .) ]
  ! EQUAL_COMPARE   [ reduce using rule 192 (expression -> something_ex .) ]
  ! NOT_EQUAL       [ reduce using rule 192 (expression -> something_ex .) ]
  ! PLUS            [ reduce using rule 192 (expression -> something_ex .) ]
  ! TIMES           [ reduce using rule 192 (expression -> something_ex .) ]
  ! DIVIDE          [ reduce using rule 192 (expression -> something_ex .) ]
  ! MINUS           [ reduce using rule 192 (expression -> something_ex .) ]

    adicionaEx                     shift and go to state 66
    op                             shift and go to state 67

state 28

    (75) cicloFor -> FOR . LLLAVE codigo RLLAVE
    (76) cicloFor -> FOR . comparison LLLAVE codigo RLLAVE
    (77) cicloFor -> FOR . logic_operation LLLAVE codigo RLLAVE
    (78) cicloFor -> FOR . decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (118) decVarOne -> . ID DEQUAL ID
    (119) decVarOne -> . ID DEQUAL INTEGER
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    LLLAVE          shift and go to state 78
    ID              shift and go to state 82
    NOT             shift and go to state 46
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    comparison                     shift and go to state 79
    logic_operation                shift and go to state 80
    decVarOne                      shift and go to state 81
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    expression                     shift and go to state 83
    something_ex                   shift and go to state 27
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 29

    (81) decVar -> decVarOne .

    COLON           reduce using rule 81 (decVar -> decVarOne .)
    $end            reduce using rule 81 (decVar -> decVarOne .)
    RLLAVE          reduce using rule 81 (decVar -> decVarOne .)
    DEFAULT         reduce using rule 81 (decVar -> decVarOne .)
    CASE            reduce using rule 81 (decVar -> decVarOne .)
    RETURN          reduce using rule 81 (decVar -> decVarOne .)


state 30

    (134) comparison -> value . op value
    (137) op -> . GREATER
    (138) op -> . SMALLER
    (139) op -> . GREATER_OR_EQUAL
    (140) op -> . SMALLER_OR_EQUAL
    (141) op -> . EQUAL_COMPARE
    (142) op -> . NOT_EQUAL
    (201) op -> . PLUS
    (202) op -> . TIMES
    (203) op -> . DIVIDE
    (204) op -> . MINUS

    GREATER         shift and go to state 68
    SMALLER         shift and go to state 69
    GREATER_OR_EQUAL shift and go to state 70
    SMALLER_OR_EQUAL shift and go to state 71
    EQUAL_COMPARE   shift and go to state 72
    NOT_EQUAL       shift and go to state 73
    PLUS            shift and go to state 74
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    MINUS           shift and go to state 77

    op                             shift and go to state 86

state 31

    (143) logic_operation -> logic_value . logic_recu
    (145) logic_recu -> . logic_op logic_value
    (146) logic_recu -> . logic_op logic_value logic_recu
    (152) logic_op -> . AND
    (153) logic_op -> . OR

    AND             shift and go to state 89
    OR              shift and go to state 90

    logic_recu                     shift and go to state 87
    logic_op                       shift and go to state 88

state 32

    (144) logic_operation -> negation .
    (147) logic_value -> negation .

    $end            reduce using rule 144 (logic_operation -> negation .)
    LLLAVE          reduce using rule 144 (logic_operation -> negation .)
    COLON           reduce using rule 144 (logic_operation -> negation .)
    RLLAVE          reduce using rule 144 (logic_operation -> negation .)
    DEFAULT         reduce using rule 144 (logic_operation -> negation .)
    CASE            reduce using rule 144 (logic_operation -> negation .)
    RETURN          reduce using rule 144 (logic_operation -> negation .)
    RPAREN          reduce using rule 144 (logic_operation -> negation .)
    RCORCHE         reduce using rule 144 (logic_operation -> negation .)
    COMA            reduce using rule 144 (logic_operation -> negation .)
    AND             reduce using rule 147 (logic_value -> negation .)
    OR              reduce using rule 147 (logic_value -> negation .)


state 33

    (82) decVar -> VAR . ID EQUAL INTEGER
    (83) decVar -> VAR . ID EQUAL ID
    (84) decVar -> VAR . ID EQUAL FLOAT
    (85) decVar -> VAR . ID EQUAL expression
    (86) decVar -> VAR . ID EQUAL logic_operation
    (87) decVar -> VAR . ID EQUAL comparison
    (88) decVar -> VAR . ID EQUAL STRING
    (159) array_declaration -> VAR . ID LCORCHE capacity RCORCHE data_types
    (160) array_declaration -> VAR . ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (94) slice_declaration -> VAR . ID LCORCHE RCORCHE data_types
    (95) slice_declaration -> VAR . ID EQUAL LCORCHE RCORCHE data_types arr_content
    (96) slice_declaration -> VAR . ID EQUAL funM
    (169) map_declaration -> VAR . ID LCORCHE data_types RCORCHE data_types

    ID              shift and go to state 91


state 34

    (89) decVar -> ID . DEQUAL STRING
    (90) decVar -> ID . DEQUAL FLOAT
    (91) decVar -> ID . DEQUAL expression
    (92) decVar -> ID . DEQUAL logic_operation
    (93) decVar -> ID . DEQUAL comparison
    (57) var_asignation -> ID . EQUAL any
    (127) cStruct -> ID . DEQUAL ID LLLAVE asignaciones RLLAVE
    (164) array_var -> ID . LCORCHE index RCORCHE
    (97) slice_declaration -> ID . DEQUAL funM
    (98) slice_declaration -> ID . DEQUAL LCORCHE RCORCHE data_types arr_content
    (104) slice_var -> ID . LCORCHE index_s RCORCHE
    (196) something_ex -> ID .
    (135) value -> ID .
    (149) logic_value -> ID .
    (118) decVarOne -> ID . DEQUAL ID
    (119) decVarOne -> ID . DEQUAL INTEGER
    (170) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 135 (value -> ID .)
    DEQUAL          shift and go to state 92
    EQUAL           shift and go to state 93
    LCORCHE         shift and go to state 94
    COLON           reduce using rule 196 (something_ex -> ID .)
    $end            reduce using rule 196 (something_ex -> ID .)
    RLLAVE          reduce using rule 196 (something_ex -> ID .)
    DEFAULT         reduce using rule 196 (something_ex -> ID .)
    CASE            reduce using rule 196 (something_ex -> ID .)
    RETURN          reduce using rule 196 (something_ex -> ID .)
    GREATER         reduce using rule 135 (value -> ID .)
    SMALLER         reduce using rule 135 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 135 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 135 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 135 (value -> ID .)
    NOT_EQUAL       reduce using rule 135 (value -> ID .)
    PLUS            reduce using rule 135 (value -> ID .)
    TIMES           reduce using rule 135 (value -> ID .)
    DIVIDE          reduce using rule 135 (value -> ID .)
    MINUS           reduce using rule 135 (value -> ID .)
    AND             reduce using rule 149 (logic_value -> ID .)
    OR              reduce using rule 149 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 196 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 196 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 196 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 196 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 196 (something_ex -> ID .) ]


state 35

    (197) something_ex -> INTEGER .

    GREATER         reduce using rule 197 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 197 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 197 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 197 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 197 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 197 (something_ex -> INTEGER .)
    PLUS            reduce using rule 197 (something_ex -> INTEGER .)
    TIMES           reduce using rule 197 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 197 (something_ex -> INTEGER .)
    MINUS           reduce using rule 197 (something_ex -> INTEGER .)
    COLON           reduce using rule 197 (something_ex -> INTEGER .)
    $end            reduce using rule 197 (something_ex -> INTEGER .)
    RLLAVE          reduce using rule 197 (something_ex -> INTEGER .)
    DEFAULT         reduce using rule 197 (something_ex -> INTEGER .)
    CASE            reduce using rule 197 (something_ex -> INTEGER .)
    RETURN          reduce using rule 197 (something_ex -> INTEGER .)
    RPAREN          reduce using rule 197 (something_ex -> INTEGER .)
    AND             reduce using rule 197 (something_ex -> INTEGER .)
    OR              reduce using rule 197 (something_ex -> INTEGER .)
    LLLAVE          reduce using rule 197 (something_ex -> INTEGER .)
    RCORCHE         reduce using rule 197 (something_ex -> INTEGER .)
    COMA            reduce using rule 197 (something_ex -> INTEGER .)


state 36

    (198) something_ex -> FLOAT .

    GREATER         reduce using rule 198 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 198 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 198 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 198 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 198 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 198 (something_ex -> FLOAT .)
    PLUS            reduce using rule 198 (something_ex -> FLOAT .)
    TIMES           reduce using rule 198 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 198 (something_ex -> FLOAT .)
    MINUS           reduce using rule 198 (something_ex -> FLOAT .)
    COLON           reduce using rule 198 (something_ex -> FLOAT .)
    $end            reduce using rule 198 (something_ex -> FLOAT .)
    RLLAVE          reduce using rule 198 (something_ex -> FLOAT .)
    DEFAULT         reduce using rule 198 (something_ex -> FLOAT .)
    CASE            reduce using rule 198 (something_ex -> FLOAT .)
    RETURN          reduce using rule 198 (something_ex -> FLOAT .)
    RPAREN          reduce using rule 198 (something_ex -> FLOAT .)
    AND             reduce using rule 198 (something_ex -> FLOAT .)
    OR              reduce using rule 198 (something_ex -> FLOAT .)
    LLLAVE          reduce using rule 198 (something_ex -> FLOAT .)
    RCORCHE         reduce using rule 198 (something_ex -> FLOAT .)
    COMA            reduce using rule 198 (something_ex -> FLOAT .)


state 37

    (113) funciones -> APPEND . LPAREN ID COMA values RPAREN
    (114) funciones -> APPEND . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 95


state 38

    (115) funciones -> LEN . LPAREN ID RPAREN

    LPAREN          shift and go to state 96


state 39

    (116) funciones -> COPY . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 97


state 40

    (117) funciones -> DELETE . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 98


state 41

    (120) SenIF -> IF . comparison LLLAVE codigo RLLAVE
    (121) SenIF -> IF . TRUE LLLAVE codigo RLLAVE
    (122) SenIF -> IF . FALSE LLLAVE codigo RLLAVE
    (134) comparison -> . value op value
    (135) value -> . ID
    (136) value -> . expression
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    TRUE            shift and go to state 100
    FALSE           shift and go to state 101
    ID              shift and go to state 102
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    comparison                     shift and go to state 99
    value                          shift and go to state 30
    expression                     shift and go to state 83
    something_ex                   shift and go to state 27
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 42

    (123) SenStruct -> TYPE . ID STRUCT LLLAVE declaration RLLAVE

    ID              shift and go to state 103


state 43

    (154) switch_statement -> SWITCH . ID LLLAVE cases RLLAVE

    ID              shift and go to state 104


state 44

    (175) func_declaration -> FUNC . ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> FUNC . ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (73) main_func -> FUNC . MAIN LPAREN RPAREN LLLAVE codigo RLLAVE

    ID              shift and go to state 105
    MAIN            shift and go to state 106


state 45

    (199) something_ex -> data_structure .

    GREATER         reduce using rule 199 (something_ex -> data_structure .)
    SMALLER         reduce using rule 199 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 199 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 199 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 199 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 199 (something_ex -> data_structure .)
    PLUS            reduce using rule 199 (something_ex -> data_structure .)
    TIMES           reduce using rule 199 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 199 (something_ex -> data_structure .)
    MINUS           reduce using rule 199 (something_ex -> data_structure .)
    COLON           reduce using rule 199 (something_ex -> data_structure .)
    $end            reduce using rule 199 (something_ex -> data_structure .)
    RLLAVE          reduce using rule 199 (something_ex -> data_structure .)
    DEFAULT         reduce using rule 199 (something_ex -> data_structure .)
    CASE            reduce using rule 199 (something_ex -> data_structure .)
    RETURN          reduce using rule 199 (something_ex -> data_structure .)
    RPAREN          reduce using rule 199 (something_ex -> data_structure .)
    AND             reduce using rule 199 (something_ex -> data_structure .)
    OR              reduce using rule 199 (something_ex -> data_structure .)
    LLLAVE          reduce using rule 199 (something_ex -> data_structure .)
    RCORCHE         reduce using rule 199 (something_ex -> data_structure .)
    COMA            reduce using rule 199 (something_ex -> data_structure .)


state 46

    (150) negation -> NOT . comparison
    (151) negation -> NOT . ID
    (134) comparison -> . value op value
    (135) value -> . ID
    (136) value -> . expression
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 108
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    comparison                     shift and go to state 107
    value                          shift and go to state 30
    expression                     shift and go to state 83
    something_ex                   shift and go to state 27
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 47

    (56) data_structure -> map_var .

    GREATER         reduce using rule 56 (data_structure -> map_var .)
    SMALLER         reduce using rule 56 (data_structure -> map_var .)
    GREATER_OR_EQUAL reduce using rule 56 (data_structure -> map_var .)
    SMALLER_OR_EQUAL reduce using rule 56 (data_structure -> map_var .)
    EQUAL_COMPARE   reduce using rule 56 (data_structure -> map_var .)
    NOT_EQUAL       reduce using rule 56 (data_structure -> map_var .)
    PLUS            reduce using rule 56 (data_structure -> map_var .)
    TIMES           reduce using rule 56 (data_structure -> map_var .)
    DIVIDE          reduce using rule 56 (data_structure -> map_var .)
    MINUS           reduce using rule 56 (data_structure -> map_var .)
    COLON           reduce using rule 56 (data_structure -> map_var .)
    $end            reduce using rule 56 (data_structure -> map_var .)
    RLLAVE          reduce using rule 56 (data_structure -> map_var .)
    DEFAULT         reduce using rule 56 (data_structure -> map_var .)
    CASE            reduce using rule 56 (data_structure -> map_var .)
    RETURN          reduce using rule 56 (data_structure -> map_var .)
    RPAREN          reduce using rule 56 (data_structure -> map_var .)
    AND             reduce using rule 56 (data_structure -> map_var .)
    OR              reduce using rule 56 (data_structure -> map_var .)
    LLLAVE          reduce using rule 56 (data_structure -> map_var .)
    RCORCHE         reduce using rule 56 (data_structure -> map_var .)
    COMA            reduce using rule 56 (data_structure -> map_var .)


state 48

    (1) codigo -> impresion COLON .

    $end            reduce using rule 1 (codigo -> impresion COLON .)
    RLLAVE          reduce using rule 1 (codigo -> impresion COLON .)
    DEFAULT         reduce using rule 1 (codigo -> impresion COLON .)
    CASE            reduce using rule 1 (codigo -> impresion COLON .)
    RETURN          reduce using rule 1 (codigo -> impresion COLON .)


state 49

    (3) codigo -> scan_func COLON .

    $end            reduce using rule 3 (codigo -> scan_func COLON .)
    RLLAVE          reduce using rule 3 (codigo -> scan_func COLON .)
    DEFAULT         reduce using rule 3 (codigo -> scan_func COLON .)
    CASE            reduce using rule 3 (codigo -> scan_func COLON .)
    RETURN          reduce using rule 3 (codigo -> scan_func COLON .)


state 50

    (5) codigo -> expression COLON .

    $end            reduce using rule 5 (codigo -> expression COLON .)
    RLLAVE          reduce using rule 5 (codigo -> expression COLON .)
    DEFAULT         reduce using rule 5 (codigo -> expression COLON .)
    CASE            reduce using rule 5 (codigo -> expression COLON .)
    RETURN          reduce using rule 5 (codigo -> expression COLON .)


state 51

    (10) codigo -> decVar COLON .

    $end            reduce using rule 10 (codigo -> decVar COLON .)
    RLLAVE          reduce using rule 10 (codigo -> decVar COLON .)
    DEFAULT         reduce using rule 10 (codigo -> decVar COLON .)
    CASE            reduce using rule 10 (codigo -> decVar COLON .)
    RETURN          reduce using rule 10 (codigo -> decVar COLON .)


state 52

    (13) codigo -> var_asignation COLON .

    $end            reduce using rule 13 (codigo -> var_asignation COLON .)
    RLLAVE          reduce using rule 13 (codigo -> var_asignation COLON .)
    DEFAULT         reduce using rule 13 (codigo -> var_asignation COLON .)
    CASE            reduce using rule 13 (codigo -> var_asignation COLON .)
    RETURN          reduce using rule 13 (codigo -> var_asignation COLON .)


state 53

    (15) codigo -> funciones COLON .

    $end            reduce using rule 15 (codigo -> funciones COLON .)
    RLLAVE          reduce using rule 15 (codigo -> funciones COLON .)
    DEFAULT         reduce using rule 15 (codigo -> funciones COLON .)
    CASE            reduce using rule 15 (codigo -> funciones COLON .)
    RETURN          reduce using rule 15 (codigo -> funciones COLON .)


state 54

    (20) codigo -> array_declaration COLON .

    $end            reduce using rule 20 (codigo -> array_declaration COLON .)
    RLLAVE          reduce using rule 20 (codigo -> array_declaration COLON .)
    DEFAULT         reduce using rule 20 (codigo -> array_declaration COLON .)
    CASE            reduce using rule 20 (codigo -> array_declaration COLON .)
    RETURN          reduce using rule 20 (codigo -> array_declaration COLON .)


state 55

    (22) codigo -> array_var COLON .

    $end            reduce using rule 22 (codigo -> array_var COLON .)
    RLLAVE          reduce using rule 22 (codigo -> array_var COLON .)
    DEFAULT         reduce using rule 22 (codigo -> array_var COLON .)
    CASE            reduce using rule 22 (codigo -> array_var COLON .)
    RETURN          reduce using rule 22 (codigo -> array_var COLON .)


state 56

    (168) array_assignment -> array_var EQUAL . something
    (174) map_assignment -> array_var EQUAL . something
    (69) something -> . ID
    (70) something -> . data_structure
    (71) something -> . values
    (72) something -> . operations
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (38) values -> . STRING
    (39) values -> . INTEGER
    (40) values -> . FLOAT
    (41) values -> . TRUE
    (42) values -> . FALSE
    (52) operations -> . expression
    (53) operations -> . comparison
    (54) operations -> . logic_operation
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN

    ID              shift and go to state 110
    STRING          shift and go to state 114
    INTEGER         shift and go to state 115
    FLOAT           shift and go to state 116
    TRUE            shift and go to state 117
    FALSE           shift and go to state 118
    NOT             shift and go to state 46
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    array_var                      shift and go to state 85
    something                      shift and go to state 109
    data_structure                 shift and go to state 111
    values                         shift and go to state 112
    operations                     shift and go to state 113
    map_var                        shift and go to state 47
    expression                     shift and go to state 119
    comparison                     shift and go to state 120
    logic_operation                shift and go to state 121
    something_ex                   shift and go to state 27
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    funciones                      shift and go to state 84

state 57

    (24) codigo -> array_assignment COLON .

    $end            reduce using rule 24 (codigo -> array_assignment COLON .)
    RLLAVE          reduce using rule 24 (codigo -> array_assignment COLON .)
    DEFAULT         reduce using rule 24 (codigo -> array_assignment COLON .)
    CASE            reduce using rule 24 (codigo -> array_assignment COLON .)
    RETURN          reduce using rule 24 (codigo -> array_assignment COLON .)


state 58

    (26) codigo -> slice_declaration COLON .

    $end            reduce using rule 26 (codigo -> slice_declaration COLON .)
    RLLAVE          reduce using rule 26 (codigo -> slice_declaration COLON .)
    DEFAULT         reduce using rule 26 (codigo -> slice_declaration COLON .)
    CASE            reduce using rule 26 (codigo -> slice_declaration COLON .)
    RETURN          reduce using rule 26 (codigo -> slice_declaration COLON .)


state 59

    (28) codigo -> slice_var COLON .

    $end            reduce using rule 28 (codigo -> slice_var COLON .)
    RLLAVE          reduce using rule 28 (codigo -> slice_var COLON .)
    DEFAULT         reduce using rule 28 (codigo -> slice_var COLON .)
    CASE            reduce using rule 28 (codigo -> slice_var COLON .)
    RETURN          reduce using rule 28 (codigo -> slice_var COLON .)


state 60

    (108) slice_assignment -> slice_var EQUAL . something_s
    (109) something_s -> . ID
    (110) something_s -> . array_var
    (111) something_s -> . values
    (112) something_s -> . operations
    (164) array_var -> . ID LCORCHE index RCORCHE
    (38) values -> . STRING
    (39) values -> . INTEGER
    (40) values -> . FLOAT
    (41) values -> . TRUE
    (42) values -> . FALSE
    (52) operations -> . expression
    (53) operations -> . comparison
    (54) operations -> . logic_operation
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 123
    STRING          shift and go to state 114
    INTEGER         shift and go to state 115
    FLOAT           shift and go to state 116
    TRUE            shift and go to state 117
    FALSE           shift and go to state 118
    NOT             shift and go to state 46
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    something_s                    shift and go to state 122
    array_var                      shift and go to state 124
    values                         shift and go to state 125
    operations                     shift and go to state 126
    expression                     shift and go to state 119
    comparison                     shift and go to state 120
    logic_operation                shift and go to state 121
    something_ex                   shift and go to state 27
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    map_var                        shift and go to state 47

state 61

    (30) codigo -> slice_assignment COLON .

    $end            reduce using rule 30 (codigo -> slice_assignment COLON .)
    RLLAVE          reduce using rule 30 (codigo -> slice_assignment COLON .)
    DEFAULT         reduce using rule 30 (codigo -> slice_assignment COLON .)
    CASE            reduce using rule 30 (codigo -> slice_assignment COLON .)
    RETURN          reduce using rule 30 (codigo -> slice_assignment COLON .)


state 62

    (32) codigo -> map_declaration COLON .

    $end            reduce using rule 32 (codigo -> map_declaration COLON .)
    RLLAVE          reduce using rule 32 (codigo -> map_declaration COLON .)
    DEFAULT         reduce using rule 32 (codigo -> map_declaration COLON .)
    CASE            reduce using rule 32 (codigo -> map_declaration COLON .)
    RETURN          reduce using rule 32 (codigo -> map_declaration COLON .)


state 63

    (34) codigo -> map_assignment COLON .

    $end            reduce using rule 34 (codigo -> map_assignment COLON .)
    RLLAVE          reduce using rule 34 (codigo -> map_assignment COLON .)
    DEFAULT         reduce using rule 34 (codigo -> map_assignment COLON .)
    CASE            reduce using rule 34 (codigo -> map_assignment COLON .)
    RETURN          reduce using rule 34 (codigo -> map_assignment COLON .)


state 64

    (186) impresion -> PRINT LPAREN . content RPAREN
    (187) content -> . values
    (188) content -> . operations
    (189) content -> . funciones
    (190) content -> . data_structure
    (191) content -> . ID
    (38) values -> . STRING
    (39) values -> . INTEGER
    (40) values -> . FLOAT
    (41) values -> . TRUE
    (42) values -> . FALSE
    (52) operations -> . expression
    (53) operations -> . comparison
    (54) operations -> . logic_operation
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID

    ID              shift and go to state 132
    STRING          shift and go to state 114
    INTEGER         shift and go to state 115
    FLOAT           shift and go to state 116
    TRUE            shift and go to state 117
    FALSE           shift and go to state 118
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40
    NOT             shift and go to state 46

    content                        shift and go to state 127
    values                         shift and go to state 128
    operations                     shift and go to state 129
    funciones                      shift and go to state 130
    data_structure                 shift and go to state 131
    expression                     shift and go to state 119
    comparison                     shift and go to state 120
    logic_operation                shift and go to state 121
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47
    something_ex                   shift and go to state 27
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32

state 65

    (74) scan_func -> SCAN LPAREN . POINTER RPAREN

    POINTER         shift and go to state 133


state 66

    (193) expression -> something_ex adicionaEx .

    COLON           reduce using rule 193 (expression -> something_ex adicionaEx .)
    $end            reduce using rule 193 (expression -> something_ex adicionaEx .)
    GREATER         reduce using rule 193 (expression -> something_ex adicionaEx .)
    SMALLER         reduce using rule 193 (expression -> something_ex adicionaEx .)
    GREATER_OR_EQUAL reduce using rule 193 (expression -> something_ex adicionaEx .)
    SMALLER_OR_EQUAL reduce using rule 193 (expression -> something_ex adicionaEx .)
    EQUAL_COMPARE   reduce using rule 193 (expression -> something_ex adicionaEx .)
    NOT_EQUAL       reduce using rule 193 (expression -> something_ex adicionaEx .)
    PLUS            reduce using rule 193 (expression -> something_ex adicionaEx .)
    TIMES           reduce using rule 193 (expression -> something_ex adicionaEx .)
    DIVIDE          reduce using rule 193 (expression -> something_ex adicionaEx .)
    MINUS           reduce using rule 193 (expression -> something_ex adicionaEx .)
    RLLAVE          reduce using rule 193 (expression -> something_ex adicionaEx .)
    DEFAULT         reduce using rule 193 (expression -> something_ex adicionaEx .)
    CASE            reduce using rule 193 (expression -> something_ex adicionaEx .)
    RETURN          reduce using rule 193 (expression -> something_ex adicionaEx .)
    RPAREN          reduce using rule 193 (expression -> something_ex adicionaEx .)
    AND             reduce using rule 193 (expression -> something_ex adicionaEx .)
    OR              reduce using rule 193 (expression -> something_ex adicionaEx .)
    LLLAVE          reduce using rule 193 (expression -> something_ex adicionaEx .)
    RCORCHE         reduce using rule 193 (expression -> something_ex adicionaEx .)
    COMA            reduce using rule 193 (expression -> something_ex adicionaEx .)


state 67

    (194) adicionaEx -> op . something_ex
    (195) adicionaEx -> op . something_ex adicionaEx
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 135
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    something_ex                   shift and go to state 134
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 68

    (137) op -> GREATER .

    ID              reduce using rule 137 (op -> GREATER .)
    INTEGER         reduce using rule 137 (op -> GREATER .)
    FLOAT           reduce using rule 137 (op -> GREATER .)
    APPEND          reduce using rule 137 (op -> GREATER .)
    LEN             reduce using rule 137 (op -> GREATER .)
    COPY            reduce using rule 137 (op -> GREATER .)
    DELETE          reduce using rule 137 (op -> GREATER .)


state 69

    (138) op -> SMALLER .

    ID              reduce using rule 138 (op -> SMALLER .)
    INTEGER         reduce using rule 138 (op -> SMALLER .)
    FLOAT           reduce using rule 138 (op -> SMALLER .)
    APPEND          reduce using rule 138 (op -> SMALLER .)
    LEN             reduce using rule 138 (op -> SMALLER .)
    COPY            reduce using rule 138 (op -> SMALLER .)
    DELETE          reduce using rule 138 (op -> SMALLER .)


state 70

    (139) op -> GREATER_OR_EQUAL .

    ID              reduce using rule 139 (op -> GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 139 (op -> GREATER_OR_EQUAL .)
    FLOAT           reduce using rule 139 (op -> GREATER_OR_EQUAL .)
    APPEND          reduce using rule 139 (op -> GREATER_OR_EQUAL .)
    LEN             reduce using rule 139 (op -> GREATER_OR_EQUAL .)
    COPY            reduce using rule 139 (op -> GREATER_OR_EQUAL .)
    DELETE          reduce using rule 139 (op -> GREATER_OR_EQUAL .)


state 71

    (140) op -> SMALLER_OR_EQUAL .

    ID              reduce using rule 140 (op -> SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 140 (op -> SMALLER_OR_EQUAL .)
    FLOAT           reduce using rule 140 (op -> SMALLER_OR_EQUAL .)
    APPEND          reduce using rule 140 (op -> SMALLER_OR_EQUAL .)
    LEN             reduce using rule 140 (op -> SMALLER_OR_EQUAL .)
    COPY            reduce using rule 140 (op -> SMALLER_OR_EQUAL .)
    DELETE          reduce using rule 140 (op -> SMALLER_OR_EQUAL .)


state 72

    (141) op -> EQUAL_COMPARE .

    ID              reduce using rule 141 (op -> EQUAL_COMPARE .)
    INTEGER         reduce using rule 141 (op -> EQUAL_COMPARE .)
    FLOAT           reduce using rule 141 (op -> EQUAL_COMPARE .)
    APPEND          reduce using rule 141 (op -> EQUAL_COMPARE .)
    LEN             reduce using rule 141 (op -> EQUAL_COMPARE .)
    COPY            reduce using rule 141 (op -> EQUAL_COMPARE .)
    DELETE          reduce using rule 141 (op -> EQUAL_COMPARE .)


state 73

    (142) op -> NOT_EQUAL .

    ID              reduce using rule 142 (op -> NOT_EQUAL .)
    INTEGER         reduce using rule 142 (op -> NOT_EQUAL .)
    FLOAT           reduce using rule 142 (op -> NOT_EQUAL .)
    APPEND          reduce using rule 142 (op -> NOT_EQUAL .)
    LEN             reduce using rule 142 (op -> NOT_EQUAL .)
    COPY            reduce using rule 142 (op -> NOT_EQUAL .)
    DELETE          reduce using rule 142 (op -> NOT_EQUAL .)


state 74

    (201) op -> PLUS .

    ID              reduce using rule 201 (op -> PLUS .)
    INTEGER         reduce using rule 201 (op -> PLUS .)
    FLOAT           reduce using rule 201 (op -> PLUS .)
    APPEND          reduce using rule 201 (op -> PLUS .)
    LEN             reduce using rule 201 (op -> PLUS .)
    COPY            reduce using rule 201 (op -> PLUS .)
    DELETE          reduce using rule 201 (op -> PLUS .)


state 75

    (202) op -> TIMES .

    ID              reduce using rule 202 (op -> TIMES .)
    INTEGER         reduce using rule 202 (op -> TIMES .)
    FLOAT           reduce using rule 202 (op -> TIMES .)
    APPEND          reduce using rule 202 (op -> TIMES .)
    LEN             reduce using rule 202 (op -> TIMES .)
    COPY            reduce using rule 202 (op -> TIMES .)
    DELETE          reduce using rule 202 (op -> TIMES .)


state 76

    (203) op -> DIVIDE .

    ID              reduce using rule 203 (op -> DIVIDE .)
    INTEGER         reduce using rule 203 (op -> DIVIDE .)
    FLOAT           reduce using rule 203 (op -> DIVIDE .)
    APPEND          reduce using rule 203 (op -> DIVIDE .)
    LEN             reduce using rule 203 (op -> DIVIDE .)
    COPY            reduce using rule 203 (op -> DIVIDE .)
    DELETE          reduce using rule 203 (op -> DIVIDE .)


state 77

    (204) op -> MINUS .

    ID              reduce using rule 204 (op -> MINUS .)
    INTEGER         reduce using rule 204 (op -> MINUS .)
    FLOAT           reduce using rule 204 (op -> MINUS .)
    APPEND          reduce using rule 204 (op -> MINUS .)
    LEN             reduce using rule 204 (op -> MINUS .)
    COPY            reduce using rule 204 (op -> MINUS .)
    DELETE          reduce using rule 204 (op -> MINUS .)


state 78

    (75) cicloFor -> FOR LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenStruct
    (18) codigo -> . cStruct
    (19) codigo -> . switch_statement
    (20) codigo -> . array_declaration COLON
    (21) codigo -> . array_declaration
    (22) codigo -> . array_var COLON
    (23) codigo -> . array_var
    (24) codigo -> . array_assignment COLON
    (25) codigo -> . array_assignment
    (26) codigo -> . slice_declaration COLON
    (27) codigo -> . slice_declaration
    (28) codigo -> . slice_var COLON
    (29) codigo -> . slice_var
    (30) codigo -> . slice_assignment COLON
    (31) codigo -> . slice_assignment
    (32) codigo -> . map_declaration COLON
    (33) codigo -> . map_declaration
    (34) codigo -> . map_assignment COLON
    (35) codigo -> . map_assignment
    (36) codigo -> . func_declaration
    (37) codigo -> . main_func
    (186) impresion -> . PRINT LPAREN content RPAREN
    (74) scan_func -> . SCAN LPAREN POINTER RPAREN
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (75) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (76) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (77) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (81) decVar -> . decVarOne
    (82) decVar -> . VAR ID EQUAL INTEGER
    (83) decVar -> . VAR ID EQUAL ID
    (84) decVar -> . VAR ID EQUAL FLOAT
    (85) decVar -> . VAR ID EQUAL expression
    (86) decVar -> . VAR ID EQUAL logic_operation
    (87) decVar -> . VAR ID EQUAL comparison
    (88) decVar -> . VAR ID EQUAL STRING
    (89) decVar -> . ID DEQUAL STRING
    (90) decVar -> . ID DEQUAL FLOAT
    (91) decVar -> . ID DEQUAL expression
    (92) decVar -> . ID DEQUAL logic_operation
    (93) decVar -> . ID DEQUAL comparison
    (57) var_asignation -> . ID EQUAL any
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (120) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (121) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (122) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (123) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (127) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (154) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (159) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (160) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (164) array_var -> . ID LCORCHE index RCORCHE
    (168) array_assignment -> . array_var EQUAL something
    (94) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (95) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (96) slice_declaration -> . VAR ID EQUAL funM
    (97) slice_declaration -> . ID DEQUAL funM
    (98) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (104) slice_var -> . ID LCORCHE index_s RCORCHE
    (108) slice_assignment -> . slice_var EQUAL something_s
    (169) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (174) map_assignment -> . array_var EQUAL something
    (175) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (73) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (118) decVarOne -> . ID DEQUAL ID
    (119) decVarOne -> . ID DEQUAL INTEGER
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (170) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 25
    SCAN            shift and go to state 26
    FOR             shift and go to state 28
    VAR             shift and go to state 33
    ID              shift and go to state 34
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40
    IF              shift and go to state 41
    TYPE            shift and go to state 42
    SWITCH          shift and go to state 43
    FUNC            shift and go to state 44
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    NOT             shift and go to state 46

    codigo                         shift and go to state 136
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenStruct                      shift and go to state 12
    cStruct                        shift and go to state 13
    switch_statement               shift and go to state 14
    array_declaration              shift and go to state 15
    array_var                      shift and go to state 16
    array_assignment               shift and go to state 17
    slice_declaration              shift and go to state 18
    slice_var                      shift and go to state 19
    slice_assignment               shift and go to state 20
    map_declaration                shift and go to state 21
    map_assignment                 shift and go to state 22
    func_declaration               shift and go to state 23
    main_func                      shift and go to state 24
    something_ex                   shift and go to state 27
    decVarOne                      shift and go to state 29
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    data_structure                 shift and go to state 45
    map_var                        shift and go to state 47

state 79

    (76) cicloFor -> FOR comparison . LLLAVE codigo RLLAVE
    (148) logic_value -> comparison .

    LLLAVE          shift and go to state 137
    AND             reduce using rule 148 (logic_value -> comparison .)
    OR              reduce using rule 148 (logic_value -> comparison .)


state 80

    (77) cicloFor -> FOR logic_operation . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 138


state 81

    (78) cicloFor -> FOR decVarOne . COLON comparison COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 139


state 82

    (118) decVarOne -> ID . DEQUAL ID
    (119) decVarOne -> ID . DEQUAL INTEGER
    (135) value -> ID .
    (149) logic_value -> ID .
    (196) something_ex -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (170) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 135 (value -> ID .)
    DEQUAL          shift and go to state 140
    GREATER         reduce using rule 135 (value -> ID .)
    SMALLER         reduce using rule 135 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 135 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 135 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 135 (value -> ID .)
    NOT_EQUAL       reduce using rule 135 (value -> ID .)
    PLUS            reduce using rule 135 (value -> ID .)
    TIMES           reduce using rule 135 (value -> ID .)
    DIVIDE          reduce using rule 135 (value -> ID .)
    MINUS           reduce using rule 135 (value -> ID .)
    AND             reduce using rule 149 (logic_value -> ID .)
    OR              reduce using rule 149 (logic_value -> ID .)
    LCORCHE         shift and go to state 141

  ! GREATER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 196 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 196 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 196 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 196 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 196 (something_ex -> ID .) ]


state 83

    (136) value -> expression .

    GREATER         reduce using rule 136 (value -> expression .)
    SMALLER         reduce using rule 136 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 136 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 136 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 136 (value -> expression .)
    NOT_EQUAL       reduce using rule 136 (value -> expression .)
    PLUS            reduce using rule 136 (value -> expression .)
    TIMES           reduce using rule 136 (value -> expression .)
    DIVIDE          reduce using rule 136 (value -> expression .)
    MINUS           reduce using rule 136 (value -> expression .)
    $end            reduce using rule 136 (value -> expression .)
    AND             reduce using rule 136 (value -> expression .)
    OR              reduce using rule 136 (value -> expression .)
    LLLAVE          reduce using rule 136 (value -> expression .)
    COLON           reduce using rule 136 (value -> expression .)
    RLLAVE          reduce using rule 136 (value -> expression .)
    DEFAULT         reduce using rule 136 (value -> expression .)
    CASE            reduce using rule 136 (value -> expression .)
    RETURN          reduce using rule 136 (value -> expression .)
    RPAREN          reduce using rule 136 (value -> expression .)
    RCORCHE         reduce using rule 136 (value -> expression .)
    COMA            reduce using rule 136 (value -> expression .)


state 84

    (200) something_ex -> funciones .

    GREATER         reduce using rule 200 (something_ex -> funciones .)
    SMALLER         reduce using rule 200 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 200 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 200 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 200 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 200 (something_ex -> funciones .)
    PLUS            reduce using rule 200 (something_ex -> funciones .)
    TIMES           reduce using rule 200 (something_ex -> funciones .)
    DIVIDE          reduce using rule 200 (something_ex -> funciones .)
    MINUS           reduce using rule 200 (something_ex -> funciones .)
    COLON           reduce using rule 200 (something_ex -> funciones .)
    $end            reduce using rule 200 (something_ex -> funciones .)
    RLLAVE          reduce using rule 200 (something_ex -> funciones .)
    DEFAULT         reduce using rule 200 (something_ex -> funciones .)
    CASE            reduce using rule 200 (something_ex -> funciones .)
    RETURN          reduce using rule 200 (something_ex -> funciones .)
    RPAREN          reduce using rule 200 (something_ex -> funciones .)
    AND             reduce using rule 200 (something_ex -> funciones .)
    OR              reduce using rule 200 (something_ex -> funciones .)
    LLLAVE          reduce using rule 200 (something_ex -> funciones .)
    RCORCHE         reduce using rule 200 (something_ex -> funciones .)
    COMA            reduce using rule 200 (something_ex -> funciones .)


state 85

    (55) data_structure -> array_var .

    GREATER         reduce using rule 55 (data_structure -> array_var .)
    SMALLER         reduce using rule 55 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 55 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 55 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 55 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 55 (data_structure -> array_var .)
    PLUS            reduce using rule 55 (data_structure -> array_var .)
    TIMES           reduce using rule 55 (data_structure -> array_var .)
    DIVIDE          reduce using rule 55 (data_structure -> array_var .)
    MINUS           reduce using rule 55 (data_structure -> array_var .)
    COLON           reduce using rule 55 (data_structure -> array_var .)
    $end            reduce using rule 55 (data_structure -> array_var .)
    RLLAVE          reduce using rule 55 (data_structure -> array_var .)
    DEFAULT         reduce using rule 55 (data_structure -> array_var .)
    CASE            reduce using rule 55 (data_structure -> array_var .)
    RETURN          reduce using rule 55 (data_structure -> array_var .)
    RPAREN          reduce using rule 55 (data_structure -> array_var .)
    AND             reduce using rule 55 (data_structure -> array_var .)
    OR              reduce using rule 55 (data_structure -> array_var .)
    LLLAVE          reduce using rule 55 (data_structure -> array_var .)
    RCORCHE         reduce using rule 55 (data_structure -> array_var .)
    COMA            reduce using rule 55 (data_structure -> array_var .)


state 86

    (134) comparison -> value op . value
    (135) value -> . ID
    (136) value -> . expression
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 102
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    value                          shift and go to state 142
    expression                     shift and go to state 83
    something_ex                   shift and go to state 27
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 87

    (143) logic_operation -> logic_value logic_recu .

    $end            reduce using rule 143 (logic_operation -> logic_value logic_recu .)
    LLLAVE          reduce using rule 143 (logic_operation -> logic_value logic_recu .)
    COLON           reduce using rule 143 (logic_operation -> logic_value logic_recu .)
    RLLAVE          reduce using rule 143 (logic_operation -> logic_value logic_recu .)
    DEFAULT         reduce using rule 143 (logic_operation -> logic_value logic_recu .)
    CASE            reduce using rule 143 (logic_operation -> logic_value logic_recu .)
    RETURN          reduce using rule 143 (logic_operation -> logic_value logic_recu .)
    RPAREN          reduce using rule 143 (logic_operation -> logic_value logic_recu .)
    RCORCHE         reduce using rule 143 (logic_operation -> logic_value logic_recu .)
    COMA            reduce using rule 143 (logic_operation -> logic_value logic_recu .)


state 88

    (145) logic_recu -> logic_op . logic_value
    (146) logic_recu -> logic_op . logic_value logic_recu
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (134) comparison -> . value op value
    (135) value -> . ID
    (136) value -> . expression
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 146
    NOT             shift and go to state 46
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    logic_value                    shift and go to state 143
    negation                       shift and go to state 144
    comparison                     shift and go to state 145
    value                          shift and go to state 30
    expression                     shift and go to state 83
    something_ex                   shift and go to state 27
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 89

    (152) logic_op -> AND .

    ID              reduce using rule 152 (logic_op -> AND .)
    NOT             reduce using rule 152 (logic_op -> AND .)
    INTEGER         reduce using rule 152 (logic_op -> AND .)
    FLOAT           reduce using rule 152 (logic_op -> AND .)
    APPEND          reduce using rule 152 (logic_op -> AND .)
    LEN             reduce using rule 152 (logic_op -> AND .)
    COPY            reduce using rule 152 (logic_op -> AND .)
    DELETE          reduce using rule 152 (logic_op -> AND .)


state 90

    (153) logic_op -> OR .

    ID              reduce using rule 153 (logic_op -> OR .)
    NOT             reduce using rule 153 (logic_op -> OR .)
    INTEGER         reduce using rule 153 (logic_op -> OR .)
    FLOAT           reduce using rule 153 (logic_op -> OR .)
    APPEND          reduce using rule 153 (logic_op -> OR .)
    LEN             reduce using rule 153 (logic_op -> OR .)
    COPY            reduce using rule 153 (logic_op -> OR .)
    DELETE          reduce using rule 153 (logic_op -> OR .)


state 91

    (82) decVar -> VAR ID . EQUAL INTEGER
    (83) decVar -> VAR ID . EQUAL ID
    (84) decVar -> VAR ID . EQUAL FLOAT
    (85) decVar -> VAR ID . EQUAL expression
    (86) decVar -> VAR ID . EQUAL logic_operation
    (87) decVar -> VAR ID . EQUAL comparison
    (88) decVar -> VAR ID . EQUAL STRING
    (159) array_declaration -> VAR ID . LCORCHE capacity RCORCHE data_types
    (160) array_declaration -> VAR ID . EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (94) slice_declaration -> VAR ID . LCORCHE RCORCHE data_types
    (95) slice_declaration -> VAR ID . EQUAL LCORCHE RCORCHE data_types arr_content
    (96) slice_declaration -> VAR ID . EQUAL funM
    (169) map_declaration -> VAR ID . LCORCHE data_types RCORCHE data_types

    EQUAL           shift and go to state 147
    LCORCHE         shift and go to state 148


state 92

    (89) decVar -> ID DEQUAL . STRING
    (90) decVar -> ID DEQUAL . FLOAT
    (91) decVar -> ID DEQUAL . expression
    (92) decVar -> ID DEQUAL . logic_operation
    (93) decVar -> ID DEQUAL . comparison
    (127) cStruct -> ID DEQUAL . ID LLLAVE asignaciones RLLAVE
    (97) slice_declaration -> ID DEQUAL . funM
    (98) slice_declaration -> ID DEQUAL . LCORCHE RCORCHE data_types arr_content
    (118) decVarOne -> ID DEQUAL . ID
    (119) decVarOne -> ID DEQUAL . INTEGER
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (134) comparison -> . value op value
    (99) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (100) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (135) value -> . ID
    (136) value -> . expression
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    STRING          shift and go to state 150
    FLOAT           shift and go to state 151
    ID              shift and go to state 149
    LCORCHE         shift and go to state 156
    INTEGER         shift and go to state 157
    MAKE            shift and go to state 158
    NOT             shift and go to state 46
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    expression                     shift and go to state 152
    logic_operation                shift and go to state 153
    comparison                     shift and go to state 154
    funM                           shift and go to state 155
    something_ex                   shift and go to state 27
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    value                          shift and go to state 30
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 93

    (57) var_asignation -> ID EQUAL . any
    (58) any -> . values
    (59) any -> . operations
    (60) any -> . ID
    (61) any -> . data_structure
    (62) any -> . funciones
    (38) values -> . STRING
    (39) values -> . INTEGER
    (40) values -> . FLOAT
    (41) values -> . TRUE
    (42) values -> . FALSE
    (52) operations -> . expression
    (53) operations -> . comparison
    (54) operations -> . logic_operation
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID

    ID              shift and go to state 159
    STRING          shift and go to state 114
    INTEGER         shift and go to state 115
    FLOAT           shift and go to state 116
    TRUE            shift and go to state 117
    FALSE           shift and go to state 118
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40
    NOT             shift and go to state 46

    any                            shift and go to state 160
    values                         shift and go to state 161
    operations                     shift and go to state 162
    data_structure                 shift and go to state 163
    funciones                      shift and go to state 164
    expression                     shift and go to state 119
    comparison                     shift and go to state 120
    logic_operation                shift and go to state 121
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47
    something_ex                   shift and go to state 27
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32

state 94

    (164) array_var -> ID LCORCHE . index RCORCHE
    (104) slice_var -> ID LCORCHE . index_s RCORCHE
    (170) map_var -> ID LCORCHE . key RCORCHE
    (165) index -> . ID
    (166) index -> . INTEGER
    (167) index -> . expression
    (105) index_s -> . ID
    (106) index_s -> . INTEGER
    (107) index_s -> . expression
    (171) key -> . ID
    (172) key -> . values
    (173) key -> . operations
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (38) values -> . STRING
    (39) values -> . INTEGER
    (40) values -> . FLOAT
    (41) values -> . TRUE
    (42) values -> . FALSE
    (52) operations -> . expression
    (53) operations -> . comparison
    (54) operations -> . logic_operation
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 165
    INTEGER         shift and go to state 169
    STRING          shift and go to state 114
    FLOAT           shift and go to state 116
    TRUE            shift and go to state 117
    FALSE           shift and go to state 118
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40
    NOT             shift and go to state 46

    index                          shift and go to state 166
    index_s                        shift and go to state 167
    key                            shift and go to state 168
    expression                     shift and go to state 170
    values                         shift and go to state 171
    operations                     shift and go to state 172
    something_ex                   shift and go to state 27
    comparison                     shift and go to state 120
    logic_operation                shift and go to state 121
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 95

    (113) funciones -> APPEND LPAREN . ID COMA values RPAREN
    (114) funciones -> APPEND LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 173


state 96

    (115) funciones -> LEN LPAREN . ID RPAREN

    ID              shift and go to state 174


state 97

    (116) funciones -> COPY LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 175


state 98

    (117) funciones -> DELETE LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 176


state 99

    (120) SenIF -> IF comparison . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 177


state 100

    (121) SenIF -> IF TRUE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 178


state 101

    (122) SenIF -> IF FALSE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 179


state 102

    (135) value -> ID .
    (196) something_ex -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (170) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for LLLAVE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 135 (value -> ID .)
    GREATER         reduce using rule 135 (value -> ID .)
    SMALLER         reduce using rule 135 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 135 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 135 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 135 (value -> ID .)
    NOT_EQUAL       reduce using rule 135 (value -> ID .)
    PLUS            reduce using rule 135 (value -> ID .)
    TIMES           reduce using rule 135 (value -> ID .)
    DIVIDE          reduce using rule 135 (value -> ID .)
    MINUS           reduce using rule 135 (value -> ID .)
    $end            reduce using rule 135 (value -> ID .)
    AND             reduce using rule 135 (value -> ID .)
    OR              reduce using rule 135 (value -> ID .)
    LLLAVE          reduce using rule 135 (value -> ID .)
    COLON           reduce using rule 135 (value -> ID .)
    RLLAVE          reduce using rule 135 (value -> ID .)
    DEFAULT         reduce using rule 135 (value -> ID .)
    CASE            reduce using rule 135 (value -> ID .)
    RETURN          reduce using rule 135 (value -> ID .)
    RPAREN          reduce using rule 135 (value -> ID .)
    RCORCHE         reduce using rule 135 (value -> ID .)
    COMA            reduce using rule 135 (value -> ID .)
    LCORCHE         shift and go to state 141

  ! GREATER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 196 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 196 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 196 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 196 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 196 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 196 (something_ex -> ID .) ]
  ! AND             [ reduce using rule 196 (something_ex -> ID .) ]
  ! OR              [ reduce using rule 196 (something_ex -> ID .) ]
  ! LLLAVE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 196 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 196 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 196 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 196 (something_ex -> ID .) ]
  ! RPAREN          [ reduce using rule 196 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 196 (something_ex -> ID .) ]
  ! COMA            [ reduce using rule 196 (something_ex -> ID .) ]


state 103

    (123) SenStruct -> TYPE ID . STRUCT LLLAVE declaration RLLAVE

    STRUCT          shift and go to state 180


state 104

    (154) switch_statement -> SWITCH ID . LLLAVE cases RLLAVE

    LLLAVE          shift and go to state 181


state 105

    (175) func_declaration -> FUNC ID . LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> FUNC ID . LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE

    LPAREN          shift and go to state 182


state 106

    (73) main_func -> FUNC MAIN . LPAREN RPAREN LLLAVE codigo RLLAVE

    LPAREN          shift and go to state 183


state 107

    (150) negation -> NOT comparison .

    $end            reduce using rule 150 (negation -> NOT comparison .)
    AND             reduce using rule 150 (negation -> NOT comparison .)
    OR              reduce using rule 150 (negation -> NOT comparison .)
    LLLAVE          reduce using rule 150 (negation -> NOT comparison .)
    COLON           reduce using rule 150 (negation -> NOT comparison .)
    RLLAVE          reduce using rule 150 (negation -> NOT comparison .)
    DEFAULT         reduce using rule 150 (negation -> NOT comparison .)
    CASE            reduce using rule 150 (negation -> NOT comparison .)
    RETURN          reduce using rule 150 (negation -> NOT comparison .)
    RPAREN          reduce using rule 150 (negation -> NOT comparison .)
    RCORCHE         reduce using rule 150 (negation -> NOT comparison .)
    COMA            reduce using rule 150 (negation -> NOT comparison .)


state 108

    (151) negation -> NOT ID .
    (135) value -> ID .
    (196) something_ex -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (170) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 135 (value -> ID .)
    $end            reduce using rule 151 (negation -> NOT ID .)
    AND             reduce using rule 151 (negation -> NOT ID .)
    OR              reduce using rule 151 (negation -> NOT ID .)
    LLLAVE          reduce using rule 151 (negation -> NOT ID .)
    COLON           reduce using rule 151 (negation -> NOT ID .)
    RLLAVE          reduce using rule 151 (negation -> NOT ID .)
    DEFAULT         reduce using rule 151 (negation -> NOT ID .)
    CASE            reduce using rule 151 (negation -> NOT ID .)
    RETURN          reduce using rule 151 (negation -> NOT ID .)
    RPAREN          reduce using rule 151 (negation -> NOT ID .)
    RCORCHE         reduce using rule 151 (negation -> NOT ID .)
    COMA            reduce using rule 151 (negation -> NOT ID .)
    GREATER         reduce using rule 135 (value -> ID .)
    SMALLER         reduce using rule 135 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 135 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 135 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 135 (value -> ID .)
    NOT_EQUAL       reduce using rule 135 (value -> ID .)
    PLUS            reduce using rule 135 (value -> ID .)
    TIMES           reduce using rule 135 (value -> ID .)
    DIVIDE          reduce using rule 135 (value -> ID .)
    MINUS           reduce using rule 135 (value -> ID .)
    LCORCHE         shift and go to state 141

  ! GREATER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 196 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 196 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 196 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 196 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 196 (something_ex -> ID .) ]


state 109

    (168) array_assignment -> array_var EQUAL something .
    (174) map_assignment -> array_var EQUAL something .

  ! reduce/reduce conflict for COLON resolved using rule 168 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for $end resolved using rule 168 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 168 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 168 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for CASE resolved using rule 168 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for RETURN resolved using rule 168 (array_assignment -> array_var EQUAL something .)
    COLON           reduce using rule 168 (array_assignment -> array_var EQUAL something .)
    $end            reduce using rule 168 (array_assignment -> array_var EQUAL something .)
    RLLAVE          reduce using rule 168 (array_assignment -> array_var EQUAL something .)
    DEFAULT         reduce using rule 168 (array_assignment -> array_var EQUAL something .)
    CASE            reduce using rule 168 (array_assignment -> array_var EQUAL something .)
    RETURN          reduce using rule 168 (array_assignment -> array_var EQUAL something .)

  ! COLON           [ reduce using rule 174 (map_assignment -> array_var EQUAL something .) ]
  ! $end            [ reduce using rule 174 (map_assignment -> array_var EQUAL something .) ]
  ! RLLAVE          [ reduce using rule 174 (map_assignment -> array_var EQUAL something .) ]
  ! DEFAULT         [ reduce using rule 174 (map_assignment -> array_var EQUAL something .) ]
  ! CASE            [ reduce using rule 174 (map_assignment -> array_var EQUAL something .) ]
  ! RETURN          [ reduce using rule 174 (map_assignment -> array_var EQUAL something .) ]


state 110

    (69) something -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (170) map_var -> ID . LCORCHE key RCORCHE
    (196) something_ex -> ID .
    (135) value -> ID .
    (149) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 69 (something -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 69 (something -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 69 (something -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 69 (something -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 69 (something -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 69 (something -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 135 (value -> ID .)
    COLON           reduce using rule 69 (something -> ID .)
    $end            reduce using rule 69 (something -> ID .)
    RLLAVE          reduce using rule 69 (something -> ID .)
    DEFAULT         reduce using rule 69 (something -> ID .)
    CASE            reduce using rule 69 (something -> ID .)
    RETURN          reduce using rule 69 (something -> ID .)
    LCORCHE         shift and go to state 141
    GREATER         reduce using rule 135 (value -> ID .)
    SMALLER         reduce using rule 135 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 135 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 135 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 135 (value -> ID .)
    NOT_EQUAL       reduce using rule 135 (value -> ID .)
    PLUS            reduce using rule 135 (value -> ID .)
    TIMES           reduce using rule 135 (value -> ID .)
    DIVIDE          reduce using rule 135 (value -> ID .)
    MINUS           reduce using rule 135 (value -> ID .)
    AND             reduce using rule 149 (logic_value -> ID .)
    OR              reduce using rule 149 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 196 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 196 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 196 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 196 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 196 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 196 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 196 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 196 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 196 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 196 (something_ex -> ID .) ]


state 111

    (70) something -> data_structure .
    (199) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 70 (something -> data_structure .)
  ! reduce/reduce conflict for $end resolved using rule 70 (something -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 70 (something -> data_structure .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 70 (something -> data_structure .)
  ! reduce/reduce conflict for CASE resolved using rule 70 (something -> data_structure .)
  ! reduce/reduce conflict for RETURN resolved using rule 70 (something -> data_structure .)
    COLON           reduce using rule 70 (something -> data_structure .)
    $end            reduce using rule 70 (something -> data_structure .)
    RLLAVE          reduce using rule 70 (something -> data_structure .)
    DEFAULT         reduce using rule 70 (something -> data_structure .)
    CASE            reduce using rule 70 (something -> data_structure .)
    RETURN          reduce using rule 70 (something -> data_structure .)
    GREATER         reduce using rule 199 (something_ex -> data_structure .)
    SMALLER         reduce using rule 199 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 199 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 199 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 199 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 199 (something_ex -> data_structure .)
    PLUS            reduce using rule 199 (something_ex -> data_structure .)
    TIMES           reduce using rule 199 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 199 (something_ex -> data_structure .)
    MINUS           reduce using rule 199 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 199 (something_ex -> data_structure .) ]
  ! $end            [ reduce using rule 199 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 199 (something_ex -> data_structure .) ]
  ! DEFAULT         [ reduce using rule 199 (something_ex -> data_structure .) ]
  ! CASE            [ reduce using rule 199 (something_ex -> data_structure .) ]
  ! RETURN          [ reduce using rule 199 (something_ex -> data_structure .) ]


state 112

    (71) something -> values .

    COLON           reduce using rule 71 (something -> values .)
    $end            reduce using rule 71 (something -> values .)
    RLLAVE          reduce using rule 71 (something -> values .)
    DEFAULT         reduce using rule 71 (something -> values .)
    CASE            reduce using rule 71 (something -> values .)
    RETURN          reduce using rule 71 (something -> values .)


state 113

    (72) something -> operations .

    COLON           reduce using rule 72 (something -> operations .)
    $end            reduce using rule 72 (something -> operations .)
    RLLAVE          reduce using rule 72 (something -> operations .)
    DEFAULT         reduce using rule 72 (something -> operations .)
    CASE            reduce using rule 72 (something -> operations .)
    RETURN          reduce using rule 72 (something -> operations .)


state 114

    (38) values -> STRING .

    COLON           reduce using rule 38 (values -> STRING .)
    $end            reduce using rule 38 (values -> STRING .)
    RLLAVE          reduce using rule 38 (values -> STRING .)
    DEFAULT         reduce using rule 38 (values -> STRING .)
    CASE            reduce using rule 38 (values -> STRING .)
    RETURN          reduce using rule 38 (values -> STRING .)
    RPAREN          reduce using rule 38 (values -> STRING .)
    RCORCHE         reduce using rule 38 (values -> STRING .)
    POINTS          reduce using rule 38 (values -> STRING .)
    COMA            reduce using rule 38 (values -> STRING .)


state 115

    (39) values -> INTEGER .
    (197) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 39 (values -> INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 39 (values -> INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 39 (values -> INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 39 (values -> INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 39 (values -> INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 39 (values -> INTEGER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 39 (values -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 39 (values -> INTEGER .)
    COLON           reduce using rule 39 (values -> INTEGER .)
    $end            reduce using rule 39 (values -> INTEGER .)
    RLLAVE          reduce using rule 39 (values -> INTEGER .)
    DEFAULT         reduce using rule 39 (values -> INTEGER .)
    CASE            reduce using rule 39 (values -> INTEGER .)
    RETURN          reduce using rule 39 (values -> INTEGER .)
    RPAREN          reduce using rule 39 (values -> INTEGER .)
    COMA            reduce using rule 39 (values -> INTEGER .)
    GREATER         reduce using rule 197 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 197 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 197 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 197 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 197 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 197 (something_ex -> INTEGER .)
    PLUS            reduce using rule 197 (something_ex -> INTEGER .)
    TIMES           reduce using rule 197 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 197 (something_ex -> INTEGER .)
    MINUS           reduce using rule 197 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! RPAREN          [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! COMA            [ reduce using rule 197 (something_ex -> INTEGER .) ]


state 116

    (40) values -> FLOAT .
    (198) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 40 (values -> FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 40 (values -> FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 40 (values -> FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 40 (values -> FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 40 (values -> FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 40 (values -> FLOAT .)
  ! reduce/reduce conflict for RPAREN resolved using rule 40 (values -> FLOAT .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 40 (values -> FLOAT .)
  ! reduce/reduce conflict for COMA resolved using rule 40 (values -> FLOAT .)
    COLON           reduce using rule 40 (values -> FLOAT .)
    $end            reduce using rule 40 (values -> FLOAT .)
    RLLAVE          reduce using rule 40 (values -> FLOAT .)
    DEFAULT         reduce using rule 40 (values -> FLOAT .)
    CASE            reduce using rule 40 (values -> FLOAT .)
    RETURN          reduce using rule 40 (values -> FLOAT .)
    RPAREN          reduce using rule 40 (values -> FLOAT .)
    RCORCHE         reduce using rule 40 (values -> FLOAT .)
    COMA            reduce using rule 40 (values -> FLOAT .)
    GREATER         reduce using rule 198 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 198 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 198 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 198 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 198 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 198 (something_ex -> FLOAT .)
    PLUS            reduce using rule 198 (something_ex -> FLOAT .)
    TIMES           reduce using rule 198 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 198 (something_ex -> FLOAT .)
    MINUS           reduce using rule 198 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! RPAREN          [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! RCORCHE         [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! COMA            [ reduce using rule 198 (something_ex -> FLOAT .) ]


state 117

    (41) values -> TRUE .

    COLON           reduce using rule 41 (values -> TRUE .)
    $end            reduce using rule 41 (values -> TRUE .)
    RLLAVE          reduce using rule 41 (values -> TRUE .)
    DEFAULT         reduce using rule 41 (values -> TRUE .)
    CASE            reduce using rule 41 (values -> TRUE .)
    RETURN          reduce using rule 41 (values -> TRUE .)
    RPAREN          reduce using rule 41 (values -> TRUE .)
    RCORCHE         reduce using rule 41 (values -> TRUE .)
    POINTS          reduce using rule 41 (values -> TRUE .)
    COMA            reduce using rule 41 (values -> TRUE .)


state 118

    (42) values -> FALSE .

    COLON           reduce using rule 42 (values -> FALSE .)
    $end            reduce using rule 42 (values -> FALSE .)
    RLLAVE          reduce using rule 42 (values -> FALSE .)
    DEFAULT         reduce using rule 42 (values -> FALSE .)
    CASE            reduce using rule 42 (values -> FALSE .)
    RETURN          reduce using rule 42 (values -> FALSE .)
    RPAREN          reduce using rule 42 (values -> FALSE .)
    RCORCHE         reduce using rule 42 (values -> FALSE .)
    POINTS          reduce using rule 42 (values -> FALSE .)
    COMA            reduce using rule 42 (values -> FALSE .)


state 119

    (52) operations -> expression .
    (136) value -> expression .

    COLON           reduce using rule 52 (operations -> expression .)
    $end            reduce using rule 52 (operations -> expression .)
    RLLAVE          reduce using rule 52 (operations -> expression .)
    DEFAULT         reduce using rule 52 (operations -> expression .)
    CASE            reduce using rule 52 (operations -> expression .)
    RETURN          reduce using rule 52 (operations -> expression .)
    RPAREN          reduce using rule 52 (operations -> expression .)
    COMA            reduce using rule 52 (operations -> expression .)
    GREATER         reduce using rule 136 (value -> expression .)
    SMALLER         reduce using rule 136 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 136 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 136 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 136 (value -> expression .)
    NOT_EQUAL       reduce using rule 136 (value -> expression .)
    PLUS            reduce using rule 136 (value -> expression .)
    TIMES           reduce using rule 136 (value -> expression .)
    DIVIDE          reduce using rule 136 (value -> expression .)
    MINUS           reduce using rule 136 (value -> expression .)


state 120

    (53) operations -> comparison .
    (148) logic_value -> comparison .

    COLON           reduce using rule 53 (operations -> comparison .)
    $end            reduce using rule 53 (operations -> comparison .)
    RLLAVE          reduce using rule 53 (operations -> comparison .)
    DEFAULT         reduce using rule 53 (operations -> comparison .)
    CASE            reduce using rule 53 (operations -> comparison .)
    RETURN          reduce using rule 53 (operations -> comparison .)
    RPAREN          reduce using rule 53 (operations -> comparison .)
    RCORCHE         reduce using rule 53 (operations -> comparison .)
    COMA            reduce using rule 53 (operations -> comparison .)
    AND             reduce using rule 148 (logic_value -> comparison .)
    OR              reduce using rule 148 (logic_value -> comparison .)


state 121

    (54) operations -> logic_operation .

    COLON           reduce using rule 54 (operations -> logic_operation .)
    $end            reduce using rule 54 (operations -> logic_operation .)
    RLLAVE          reduce using rule 54 (operations -> logic_operation .)
    DEFAULT         reduce using rule 54 (operations -> logic_operation .)
    CASE            reduce using rule 54 (operations -> logic_operation .)
    RETURN          reduce using rule 54 (operations -> logic_operation .)
    RPAREN          reduce using rule 54 (operations -> logic_operation .)
    RCORCHE         reduce using rule 54 (operations -> logic_operation .)
    COMA            reduce using rule 54 (operations -> logic_operation .)


state 122

    (108) slice_assignment -> slice_var EQUAL something_s .

    COLON           reduce using rule 108 (slice_assignment -> slice_var EQUAL something_s .)
    $end            reduce using rule 108 (slice_assignment -> slice_var EQUAL something_s .)
    RLLAVE          reduce using rule 108 (slice_assignment -> slice_var EQUAL something_s .)
    DEFAULT         reduce using rule 108 (slice_assignment -> slice_var EQUAL something_s .)
    CASE            reduce using rule 108 (slice_assignment -> slice_var EQUAL something_s .)
    RETURN          reduce using rule 108 (slice_assignment -> slice_var EQUAL something_s .)


state 123

    (109) something_s -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (196) something_ex -> ID .
    (135) value -> ID .
    (149) logic_value -> ID .
    (170) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for COLON resolved using rule 109 (something_s -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 109 (something_s -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 109 (something_s -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 109 (something_s -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 109 (something_s -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 109 (something_s -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 135 (value -> ID .)
    COLON           reduce using rule 109 (something_s -> ID .)
    $end            reduce using rule 109 (something_s -> ID .)
    RLLAVE          reduce using rule 109 (something_s -> ID .)
    DEFAULT         reduce using rule 109 (something_s -> ID .)
    CASE            reduce using rule 109 (something_s -> ID .)
    RETURN          reduce using rule 109 (something_s -> ID .)
    LCORCHE         shift and go to state 141
    GREATER         reduce using rule 135 (value -> ID .)
    SMALLER         reduce using rule 135 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 135 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 135 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 135 (value -> ID .)
    NOT_EQUAL       reduce using rule 135 (value -> ID .)
    PLUS            reduce using rule 135 (value -> ID .)
    TIMES           reduce using rule 135 (value -> ID .)
    DIVIDE          reduce using rule 135 (value -> ID .)
    MINUS           reduce using rule 135 (value -> ID .)
    AND             reduce using rule 149 (logic_value -> ID .)
    OR              reduce using rule 149 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 196 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 196 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 196 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 196 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 196 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 196 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 196 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 196 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 196 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 196 (something_ex -> ID .) ]


state 124

    (110) something_s -> array_var .
    (55) data_structure -> array_var .

  ! reduce/reduce conflict for COLON resolved using rule 55 (data_structure -> array_var .)
  ! reduce/reduce conflict for $end resolved using rule 55 (data_structure -> array_var .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 55 (data_structure -> array_var .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 55 (data_structure -> array_var .)
  ! reduce/reduce conflict for CASE resolved using rule 55 (data_structure -> array_var .)
  ! reduce/reduce conflict for RETURN resolved using rule 55 (data_structure -> array_var .)
    GREATER         reduce using rule 55 (data_structure -> array_var .)
    SMALLER         reduce using rule 55 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 55 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 55 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 55 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 55 (data_structure -> array_var .)
    PLUS            reduce using rule 55 (data_structure -> array_var .)
    TIMES           reduce using rule 55 (data_structure -> array_var .)
    DIVIDE          reduce using rule 55 (data_structure -> array_var .)
    MINUS           reduce using rule 55 (data_structure -> array_var .)
    COLON           reduce using rule 55 (data_structure -> array_var .)
    $end            reduce using rule 55 (data_structure -> array_var .)
    RLLAVE          reduce using rule 55 (data_structure -> array_var .)
    DEFAULT         reduce using rule 55 (data_structure -> array_var .)
    CASE            reduce using rule 55 (data_structure -> array_var .)
    RETURN          reduce using rule 55 (data_structure -> array_var .)

  ! COLON           [ reduce using rule 110 (something_s -> array_var .) ]
  ! $end            [ reduce using rule 110 (something_s -> array_var .) ]
  ! RLLAVE          [ reduce using rule 110 (something_s -> array_var .) ]
  ! DEFAULT         [ reduce using rule 110 (something_s -> array_var .) ]
  ! CASE            [ reduce using rule 110 (something_s -> array_var .) ]
  ! RETURN          [ reduce using rule 110 (something_s -> array_var .) ]


state 125

    (111) something_s -> values .

    COLON           reduce using rule 111 (something_s -> values .)
    $end            reduce using rule 111 (something_s -> values .)
    RLLAVE          reduce using rule 111 (something_s -> values .)
    DEFAULT         reduce using rule 111 (something_s -> values .)
    CASE            reduce using rule 111 (something_s -> values .)
    RETURN          reduce using rule 111 (something_s -> values .)


state 126

    (112) something_s -> operations .

    COLON           reduce using rule 112 (something_s -> operations .)
    $end            reduce using rule 112 (something_s -> operations .)
    RLLAVE          reduce using rule 112 (something_s -> operations .)
    DEFAULT         reduce using rule 112 (something_s -> operations .)
    CASE            reduce using rule 112 (something_s -> operations .)
    RETURN          reduce using rule 112 (something_s -> operations .)


state 127

    (186) impresion -> PRINT LPAREN content . RPAREN

    RPAREN          shift and go to state 184


state 128

    (187) content -> values .

    RPAREN          reduce using rule 187 (content -> values .)


state 129

    (188) content -> operations .

    RPAREN          reduce using rule 188 (content -> operations .)


state 130

    (189) content -> funciones .
    (200) something_ex -> funciones .

  ! reduce/reduce conflict for RPAREN resolved using rule 189 (content -> funciones .)
    RPAREN          reduce using rule 189 (content -> funciones .)
    GREATER         reduce using rule 200 (something_ex -> funciones .)
    SMALLER         reduce using rule 200 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 200 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 200 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 200 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 200 (something_ex -> funciones .)
    PLUS            reduce using rule 200 (something_ex -> funciones .)
    TIMES           reduce using rule 200 (something_ex -> funciones .)
    DIVIDE          reduce using rule 200 (something_ex -> funciones .)
    MINUS           reduce using rule 200 (something_ex -> funciones .)

  ! RPAREN          [ reduce using rule 200 (something_ex -> funciones .) ]


state 131

    (190) content -> data_structure .
    (199) something_ex -> data_structure .

  ! reduce/reduce conflict for RPAREN resolved using rule 190 (content -> data_structure .)
    RPAREN          reduce using rule 190 (content -> data_structure .)
    GREATER         reduce using rule 199 (something_ex -> data_structure .)
    SMALLER         reduce using rule 199 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 199 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 199 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 199 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 199 (something_ex -> data_structure .)
    PLUS            reduce using rule 199 (something_ex -> data_structure .)
    TIMES           reduce using rule 199 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 199 (something_ex -> data_structure .)
    MINUS           reduce using rule 199 (something_ex -> data_structure .)

  ! RPAREN          [ reduce using rule 199 (something_ex -> data_structure .) ]


state 132

    (191) content -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (170) map_var -> ID . LCORCHE key RCORCHE
    (196) something_ex -> ID .
    (135) value -> ID .
    (149) logic_value -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 191 (content -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 135 (value -> ID .)
    RPAREN          reduce using rule 191 (content -> ID .)
    LCORCHE         shift and go to state 141
    GREATER         reduce using rule 135 (value -> ID .)
    SMALLER         reduce using rule 135 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 135 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 135 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 135 (value -> ID .)
    NOT_EQUAL       reduce using rule 135 (value -> ID .)
    PLUS            reduce using rule 135 (value -> ID .)
    TIMES           reduce using rule 135 (value -> ID .)
    DIVIDE          reduce using rule 135 (value -> ID .)
    MINUS           reduce using rule 135 (value -> ID .)
    AND             reduce using rule 149 (logic_value -> ID .)
    OR              reduce using rule 149 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 196 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 196 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 196 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 196 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 196 (something_ex -> ID .) ]
  ! RPAREN          [ reduce using rule 196 (something_ex -> ID .) ]


state 133

    (74) scan_func -> SCAN LPAREN POINTER . RPAREN

    RPAREN          shift and go to state 185


state 134

    (194) adicionaEx -> op something_ex .
    (195) adicionaEx -> op something_ex . adicionaEx
    (194) adicionaEx -> . op something_ex
    (195) adicionaEx -> . op something_ex adicionaEx
    (137) op -> . GREATER
    (138) op -> . SMALLER
    (139) op -> . GREATER_OR_EQUAL
    (140) op -> . SMALLER_OR_EQUAL
    (141) op -> . EQUAL_COMPARE
    (142) op -> . NOT_EQUAL
    (201) op -> . PLUS
    (202) op -> . TIMES
    (203) op -> . DIVIDE
    (204) op -> . MINUS

  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL_COMPARE resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    COLON           reduce using rule 194 (adicionaEx -> op something_ex .)
    $end            reduce using rule 194 (adicionaEx -> op something_ex .)
    RLLAVE          reduce using rule 194 (adicionaEx -> op something_ex .)
    DEFAULT         reduce using rule 194 (adicionaEx -> op something_ex .)
    CASE            reduce using rule 194 (adicionaEx -> op something_ex .)
    RETURN          reduce using rule 194 (adicionaEx -> op something_ex .)
    RPAREN          reduce using rule 194 (adicionaEx -> op something_ex .)
    AND             reduce using rule 194 (adicionaEx -> op something_ex .)
    OR              reduce using rule 194 (adicionaEx -> op something_ex .)
    LLLAVE          reduce using rule 194 (adicionaEx -> op something_ex .)
    RCORCHE         reduce using rule 194 (adicionaEx -> op something_ex .)
    COMA            reduce using rule 194 (adicionaEx -> op something_ex .)
    GREATER         shift and go to state 68
    SMALLER         shift and go to state 69
    GREATER_OR_EQUAL shift and go to state 70
    SMALLER_OR_EQUAL shift and go to state 71
    EQUAL_COMPARE   shift and go to state 72
    NOT_EQUAL       shift and go to state 73
    PLUS            shift and go to state 74
    TIMES           shift and go to state 75
    DIVIDE          shift and go to state 76
    MINUS           shift and go to state 77

  ! GREATER         [ reduce using rule 194 (adicionaEx -> op something_ex .) ]
  ! SMALLER         [ reduce using rule 194 (adicionaEx -> op something_ex .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 194 (adicionaEx -> op something_ex .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 194 (adicionaEx -> op something_ex .) ]
  ! EQUAL_COMPARE   [ reduce using rule 194 (adicionaEx -> op something_ex .) ]
  ! NOT_EQUAL       [ reduce using rule 194 (adicionaEx -> op something_ex .) ]
  ! PLUS            [ reduce using rule 194 (adicionaEx -> op something_ex .) ]
  ! TIMES           [ reduce using rule 194 (adicionaEx -> op something_ex .) ]
  ! DIVIDE          [ reduce using rule 194 (adicionaEx -> op something_ex .) ]
  ! MINUS           [ reduce using rule 194 (adicionaEx -> op something_ex .) ]

    op                             shift and go to state 67
    adicionaEx                     shift and go to state 186

state 135

    (196) something_ex -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (170) map_var -> ID . LCORCHE key RCORCHE

    GREATER         reduce using rule 196 (something_ex -> ID .)
    SMALLER         reduce using rule 196 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 196 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 196 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 196 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 196 (something_ex -> ID .)
    PLUS            reduce using rule 196 (something_ex -> ID .)
    TIMES           reduce using rule 196 (something_ex -> ID .)
    DIVIDE          reduce using rule 196 (something_ex -> ID .)
    MINUS           reduce using rule 196 (something_ex -> ID .)
    COLON           reduce using rule 196 (something_ex -> ID .)
    $end            reduce using rule 196 (something_ex -> ID .)
    RLLAVE          reduce using rule 196 (something_ex -> ID .)
    DEFAULT         reduce using rule 196 (something_ex -> ID .)
    CASE            reduce using rule 196 (something_ex -> ID .)
    RETURN          reduce using rule 196 (something_ex -> ID .)
    RPAREN          reduce using rule 196 (something_ex -> ID .)
    AND             reduce using rule 196 (something_ex -> ID .)
    OR              reduce using rule 196 (something_ex -> ID .)
    LLLAVE          reduce using rule 196 (something_ex -> ID .)
    RCORCHE         reduce using rule 196 (something_ex -> ID .)
    COMA            reduce using rule 196 (something_ex -> ID .)
    LCORCHE         shift and go to state 141


state 136

    (75) cicloFor -> FOR LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 187


state 137

    (76) cicloFor -> FOR comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenStruct
    (18) codigo -> . cStruct
    (19) codigo -> . switch_statement
    (20) codigo -> . array_declaration COLON
    (21) codigo -> . array_declaration
    (22) codigo -> . array_var COLON
    (23) codigo -> . array_var
    (24) codigo -> . array_assignment COLON
    (25) codigo -> . array_assignment
    (26) codigo -> . slice_declaration COLON
    (27) codigo -> . slice_declaration
    (28) codigo -> . slice_var COLON
    (29) codigo -> . slice_var
    (30) codigo -> . slice_assignment COLON
    (31) codigo -> . slice_assignment
    (32) codigo -> . map_declaration COLON
    (33) codigo -> . map_declaration
    (34) codigo -> . map_assignment COLON
    (35) codigo -> . map_assignment
    (36) codigo -> . func_declaration
    (37) codigo -> . main_func
    (186) impresion -> . PRINT LPAREN content RPAREN
    (74) scan_func -> . SCAN LPAREN POINTER RPAREN
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (75) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (76) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (77) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (81) decVar -> . decVarOne
    (82) decVar -> . VAR ID EQUAL INTEGER
    (83) decVar -> . VAR ID EQUAL ID
    (84) decVar -> . VAR ID EQUAL FLOAT
    (85) decVar -> . VAR ID EQUAL expression
    (86) decVar -> . VAR ID EQUAL logic_operation
    (87) decVar -> . VAR ID EQUAL comparison
    (88) decVar -> . VAR ID EQUAL STRING
    (89) decVar -> . ID DEQUAL STRING
    (90) decVar -> . ID DEQUAL FLOAT
    (91) decVar -> . ID DEQUAL expression
    (92) decVar -> . ID DEQUAL logic_operation
    (93) decVar -> . ID DEQUAL comparison
    (57) var_asignation -> . ID EQUAL any
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (120) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (121) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (122) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (123) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (127) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (154) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (159) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (160) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (164) array_var -> . ID LCORCHE index RCORCHE
    (168) array_assignment -> . array_var EQUAL something
    (94) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (95) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (96) slice_declaration -> . VAR ID EQUAL funM
    (97) slice_declaration -> . ID DEQUAL funM
    (98) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (104) slice_var -> . ID LCORCHE index_s RCORCHE
    (108) slice_assignment -> . slice_var EQUAL something_s
    (169) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (174) map_assignment -> . array_var EQUAL something
    (175) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (73) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (118) decVarOne -> . ID DEQUAL ID
    (119) decVarOne -> . ID DEQUAL INTEGER
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (170) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 25
    SCAN            shift and go to state 26
    FOR             shift and go to state 28
    VAR             shift and go to state 33
    ID              shift and go to state 34
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40
    IF              shift and go to state 41
    TYPE            shift and go to state 42
    SWITCH          shift and go to state 43
    FUNC            shift and go to state 44
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    NOT             shift and go to state 46

    comparison                     shift and go to state 6
    codigo                         shift and go to state 188
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenStruct                      shift and go to state 12
    cStruct                        shift and go to state 13
    switch_statement               shift and go to state 14
    array_declaration              shift and go to state 15
    array_var                      shift and go to state 16
    array_assignment               shift and go to state 17
    slice_declaration              shift and go to state 18
    slice_var                      shift and go to state 19
    slice_assignment               shift and go to state 20
    map_declaration                shift and go to state 21
    map_assignment                 shift and go to state 22
    func_declaration               shift and go to state 23
    main_func                      shift and go to state 24
    something_ex                   shift and go to state 27
    decVarOne                      shift and go to state 29
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    data_structure                 shift and go to state 45
    map_var                        shift and go to state 47

state 138

    (77) cicloFor -> FOR logic_operation LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenStruct
    (18) codigo -> . cStruct
    (19) codigo -> . switch_statement
    (20) codigo -> . array_declaration COLON
    (21) codigo -> . array_declaration
    (22) codigo -> . array_var COLON
    (23) codigo -> . array_var
    (24) codigo -> . array_assignment COLON
    (25) codigo -> . array_assignment
    (26) codigo -> . slice_declaration COLON
    (27) codigo -> . slice_declaration
    (28) codigo -> . slice_var COLON
    (29) codigo -> . slice_var
    (30) codigo -> . slice_assignment COLON
    (31) codigo -> . slice_assignment
    (32) codigo -> . map_declaration COLON
    (33) codigo -> . map_declaration
    (34) codigo -> . map_assignment COLON
    (35) codigo -> . map_assignment
    (36) codigo -> . func_declaration
    (37) codigo -> . main_func
    (186) impresion -> . PRINT LPAREN content RPAREN
    (74) scan_func -> . SCAN LPAREN POINTER RPAREN
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (75) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (76) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (77) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (81) decVar -> . decVarOne
    (82) decVar -> . VAR ID EQUAL INTEGER
    (83) decVar -> . VAR ID EQUAL ID
    (84) decVar -> . VAR ID EQUAL FLOAT
    (85) decVar -> . VAR ID EQUAL expression
    (86) decVar -> . VAR ID EQUAL logic_operation
    (87) decVar -> . VAR ID EQUAL comparison
    (88) decVar -> . VAR ID EQUAL STRING
    (89) decVar -> . ID DEQUAL STRING
    (90) decVar -> . ID DEQUAL FLOAT
    (91) decVar -> . ID DEQUAL expression
    (92) decVar -> . ID DEQUAL logic_operation
    (93) decVar -> . ID DEQUAL comparison
    (57) var_asignation -> . ID EQUAL any
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (120) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (121) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (122) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (123) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (127) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (154) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (159) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (160) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (164) array_var -> . ID LCORCHE index RCORCHE
    (168) array_assignment -> . array_var EQUAL something
    (94) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (95) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (96) slice_declaration -> . VAR ID EQUAL funM
    (97) slice_declaration -> . ID DEQUAL funM
    (98) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (104) slice_var -> . ID LCORCHE index_s RCORCHE
    (108) slice_assignment -> . slice_var EQUAL something_s
    (169) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (174) map_assignment -> . array_var EQUAL something
    (175) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (73) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (118) decVarOne -> . ID DEQUAL ID
    (119) decVarOne -> . ID DEQUAL INTEGER
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (170) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 25
    SCAN            shift and go to state 26
    FOR             shift and go to state 28
    VAR             shift and go to state 33
    ID              shift and go to state 34
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40
    IF              shift and go to state 41
    TYPE            shift and go to state 42
    SWITCH          shift and go to state 43
    FUNC            shift and go to state 44
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    NOT             shift and go to state 46

    logic_operation                shift and go to state 7
    codigo                         shift and go to state 189
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenStruct                      shift and go to state 12
    cStruct                        shift and go to state 13
    switch_statement               shift and go to state 14
    array_declaration              shift and go to state 15
    array_var                      shift and go to state 16
    array_assignment               shift and go to state 17
    slice_declaration              shift and go to state 18
    slice_var                      shift and go to state 19
    slice_assignment               shift and go to state 20
    map_declaration                shift and go to state 21
    map_assignment                 shift and go to state 22
    func_declaration               shift and go to state 23
    main_func                      shift and go to state 24
    something_ex                   shift and go to state 27
    decVarOne                      shift and go to state 29
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    data_structure                 shift and go to state 45
    map_var                        shift and go to state 47

state 139

    (78) cicloFor -> FOR decVarOne COLON . comparison COLON incre LLLAVE codigo RLLAVE
    (134) comparison -> . value op value
    (135) value -> . ID
    (136) value -> . expression
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 102
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    comparison                     shift and go to state 190
    value                          shift and go to state 30
    expression                     shift and go to state 83
    something_ex                   shift and go to state 27
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 140

    (118) decVarOne -> ID DEQUAL . ID
    (119) decVarOne -> ID DEQUAL . INTEGER

    ID              shift and go to state 191
    INTEGER         shift and go to state 192


state 141

    (164) array_var -> ID LCORCHE . index RCORCHE
    (170) map_var -> ID LCORCHE . key RCORCHE
    (165) index -> . ID
    (166) index -> . INTEGER
    (167) index -> . expression
    (171) key -> . ID
    (172) key -> . values
    (173) key -> . operations
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (38) values -> . STRING
    (39) values -> . INTEGER
    (40) values -> . FLOAT
    (41) values -> . TRUE
    (42) values -> . FALSE
    (52) operations -> . expression
    (53) operations -> . comparison
    (54) operations -> . logic_operation
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 193
    INTEGER         shift and go to state 194
    STRING          shift and go to state 114
    FLOAT           shift and go to state 116
    TRUE            shift and go to state 117
    FALSE           shift and go to state 118
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40
    NOT             shift and go to state 46

    index                          shift and go to state 166
    key                            shift and go to state 168
    expression                     shift and go to state 195
    values                         shift and go to state 171
    operations                     shift and go to state 172
    something_ex                   shift and go to state 27
    comparison                     shift and go to state 120
    logic_operation                shift and go to state 121
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 142

    (134) comparison -> value op value .

    $end            reduce using rule 134 (comparison -> value op value .)
    AND             reduce using rule 134 (comparison -> value op value .)
    OR              reduce using rule 134 (comparison -> value op value .)
    LLLAVE          reduce using rule 134 (comparison -> value op value .)
    COLON           reduce using rule 134 (comparison -> value op value .)
    RLLAVE          reduce using rule 134 (comparison -> value op value .)
    DEFAULT         reduce using rule 134 (comparison -> value op value .)
    CASE            reduce using rule 134 (comparison -> value op value .)
    RETURN          reduce using rule 134 (comparison -> value op value .)
    RPAREN          reduce using rule 134 (comparison -> value op value .)
    RCORCHE         reduce using rule 134 (comparison -> value op value .)
    COMA            reduce using rule 134 (comparison -> value op value .)


state 143

    (145) logic_recu -> logic_op logic_value .
    (146) logic_recu -> logic_op logic_value . logic_recu
    (145) logic_recu -> . logic_op logic_value
    (146) logic_recu -> . logic_op logic_value logic_recu
    (152) logic_op -> . AND
    (153) logic_op -> . OR

    $end            reduce using rule 145 (logic_recu -> logic_op logic_value .)
    LLLAVE          reduce using rule 145 (logic_recu -> logic_op logic_value .)
    COLON           reduce using rule 145 (logic_recu -> logic_op logic_value .)
    RLLAVE          reduce using rule 145 (logic_recu -> logic_op logic_value .)
    DEFAULT         reduce using rule 145 (logic_recu -> logic_op logic_value .)
    CASE            reduce using rule 145 (logic_recu -> logic_op logic_value .)
    RETURN          reduce using rule 145 (logic_recu -> logic_op logic_value .)
    RPAREN          reduce using rule 145 (logic_recu -> logic_op logic_value .)
    RCORCHE         reduce using rule 145 (logic_recu -> logic_op logic_value .)
    COMA            reduce using rule 145 (logic_recu -> logic_op logic_value .)
    AND             shift and go to state 89
    OR              shift and go to state 90

    logic_op                       shift and go to state 88
    logic_recu                     shift and go to state 196

state 144

    (147) logic_value -> negation .

    AND             reduce using rule 147 (logic_value -> negation .)
    OR              reduce using rule 147 (logic_value -> negation .)
    $end            reduce using rule 147 (logic_value -> negation .)
    LLLAVE          reduce using rule 147 (logic_value -> negation .)
    COLON           reduce using rule 147 (logic_value -> negation .)
    RLLAVE          reduce using rule 147 (logic_value -> negation .)
    DEFAULT         reduce using rule 147 (logic_value -> negation .)
    CASE            reduce using rule 147 (logic_value -> negation .)
    RETURN          reduce using rule 147 (logic_value -> negation .)
    RPAREN          reduce using rule 147 (logic_value -> negation .)
    RCORCHE         reduce using rule 147 (logic_value -> negation .)
    COMA            reduce using rule 147 (logic_value -> negation .)


state 145

    (148) logic_value -> comparison .

    AND             reduce using rule 148 (logic_value -> comparison .)
    OR              reduce using rule 148 (logic_value -> comparison .)
    $end            reduce using rule 148 (logic_value -> comparison .)
    LLLAVE          reduce using rule 148 (logic_value -> comparison .)
    COLON           reduce using rule 148 (logic_value -> comparison .)
    RLLAVE          reduce using rule 148 (logic_value -> comparison .)
    DEFAULT         reduce using rule 148 (logic_value -> comparison .)
    CASE            reduce using rule 148 (logic_value -> comparison .)
    RETURN          reduce using rule 148 (logic_value -> comparison .)
    RPAREN          reduce using rule 148 (logic_value -> comparison .)
    RCORCHE         reduce using rule 148 (logic_value -> comparison .)
    COMA            reduce using rule 148 (logic_value -> comparison .)


state 146

    (149) logic_value -> ID .
    (135) value -> ID .
    (196) something_ex -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (170) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 135 (value -> ID .)
    AND             reduce using rule 149 (logic_value -> ID .)
    OR              reduce using rule 149 (logic_value -> ID .)
    $end            reduce using rule 149 (logic_value -> ID .)
    LLLAVE          reduce using rule 149 (logic_value -> ID .)
    COLON           reduce using rule 149 (logic_value -> ID .)
    RLLAVE          reduce using rule 149 (logic_value -> ID .)
    DEFAULT         reduce using rule 149 (logic_value -> ID .)
    CASE            reduce using rule 149 (logic_value -> ID .)
    RETURN          reduce using rule 149 (logic_value -> ID .)
    RPAREN          reduce using rule 149 (logic_value -> ID .)
    RCORCHE         reduce using rule 149 (logic_value -> ID .)
    COMA            reduce using rule 149 (logic_value -> ID .)
    GREATER         reduce using rule 135 (value -> ID .)
    SMALLER         reduce using rule 135 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 135 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 135 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 135 (value -> ID .)
    NOT_EQUAL       reduce using rule 135 (value -> ID .)
    PLUS            reduce using rule 135 (value -> ID .)
    TIMES           reduce using rule 135 (value -> ID .)
    DIVIDE          reduce using rule 135 (value -> ID .)
    MINUS           reduce using rule 135 (value -> ID .)
    LCORCHE         shift and go to state 141

  ! GREATER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 196 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 196 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 196 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 196 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 196 (something_ex -> ID .) ]


state 147

    (82) decVar -> VAR ID EQUAL . INTEGER
    (83) decVar -> VAR ID EQUAL . ID
    (84) decVar -> VAR ID EQUAL . FLOAT
    (85) decVar -> VAR ID EQUAL . expression
    (86) decVar -> VAR ID EQUAL . logic_operation
    (87) decVar -> VAR ID EQUAL . comparison
    (88) decVar -> VAR ID EQUAL . STRING
    (160) array_declaration -> VAR ID EQUAL . LCORCHE capacity RCORCHE data_types arr_content
    (95) slice_declaration -> VAR ID EQUAL . LCORCHE RCORCHE data_types arr_content
    (96) slice_declaration -> VAR ID EQUAL . funM
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (134) comparison -> . value op value
    (99) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (100) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (135) value -> . ID
    (136) value -> . expression
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    INTEGER         shift and go to state 198
    ID              shift and go to state 197
    FLOAT           shift and go to state 199
    STRING          shift and go to state 203
    LCORCHE         shift and go to state 204
    MAKE            shift and go to state 158
    NOT             shift and go to state 46
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    expression                     shift and go to state 200
    logic_operation                shift and go to state 201
    comparison                     shift and go to state 202
    funM                           shift and go to state 205
    something_ex                   shift and go to state 27
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    value                          shift and go to state 30
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 148

    (159) array_declaration -> VAR ID LCORCHE . capacity RCORCHE data_types
    (94) slice_declaration -> VAR ID LCORCHE . RCORCHE data_types
    (169) map_declaration -> VAR ID LCORCHE . data_types RCORCHE data_types
    (161) capacity -> . INTEGER
    (162) capacity -> . ID
    (163) capacity -> . expression
    (43) data_types -> . INT32
    (44) data_types -> . INT64
    (45) data_types -> . FLOAT32
    (46) data_types -> . FLOAT64
    (47) data_types -> . BYTE
    (48) data_types -> . WINT
    (49) data_types -> . WFLOAT
    (50) data_types -> . WSTRING
    (51) data_types -> . BOOL
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    RCORCHE         shift and go to state 208
    INTEGER         shift and go to state 210
    ID              shift and go to state 206
    INT32           shift and go to state 212
    INT64           shift and go to state 213
    FLOAT32         shift and go to state 214
    FLOAT64         shift and go to state 215
    BYTE            shift and go to state 216
    WINT            shift and go to state 217
    WFLOAT          shift and go to state 218
    WSTRING         shift and go to state 219
    BOOL            shift and go to state 220
    FLOAT           shift and go to state 36
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    capacity                       shift and go to state 207
    data_types                     shift and go to state 209
    expression                     shift and go to state 211
    something_ex                   shift and go to state 27
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 149

    (127) cStruct -> ID DEQUAL ID . LLLAVE asignaciones RLLAVE
    (118) decVarOne -> ID DEQUAL ID .
    (196) something_ex -> ID .
    (149) logic_value -> ID .
    (135) value -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (170) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for COLON resolved using rule 118 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for $end resolved using rule 118 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 118 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 118 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for CASE resolved using rule 118 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 118 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 135 (value -> ID .)
    LLLAVE          shift and go to state 221
    COLON           reduce using rule 118 (decVarOne -> ID DEQUAL ID .)
    $end            reduce using rule 118 (decVarOne -> ID DEQUAL ID .)
    RLLAVE          reduce using rule 118 (decVarOne -> ID DEQUAL ID .)
    DEFAULT         reduce using rule 118 (decVarOne -> ID DEQUAL ID .)
    CASE            reduce using rule 118 (decVarOne -> ID DEQUAL ID .)
    RETURN          reduce using rule 118 (decVarOne -> ID DEQUAL ID .)
    AND             reduce using rule 149 (logic_value -> ID .)
    OR              reduce using rule 149 (logic_value -> ID .)
    GREATER         reduce using rule 135 (value -> ID .)
    SMALLER         reduce using rule 135 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 135 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 135 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 135 (value -> ID .)
    NOT_EQUAL       reduce using rule 135 (value -> ID .)
    PLUS            reduce using rule 135 (value -> ID .)
    TIMES           reduce using rule 135 (value -> ID .)
    DIVIDE          reduce using rule 135 (value -> ID .)
    MINUS           reduce using rule 135 (value -> ID .)
    LCORCHE         shift and go to state 141

  ! GREATER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 196 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 196 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 196 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 196 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 196 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 196 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 196 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 196 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 196 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 196 (something_ex -> ID .) ]


state 150

    (89) decVar -> ID DEQUAL STRING .

    COLON           reduce using rule 89 (decVar -> ID DEQUAL STRING .)
    $end            reduce using rule 89 (decVar -> ID DEQUAL STRING .)
    RLLAVE          reduce using rule 89 (decVar -> ID DEQUAL STRING .)
    DEFAULT         reduce using rule 89 (decVar -> ID DEQUAL STRING .)
    CASE            reduce using rule 89 (decVar -> ID DEQUAL STRING .)
    RETURN          reduce using rule 89 (decVar -> ID DEQUAL STRING .)


state 151

    (90) decVar -> ID DEQUAL FLOAT .
    (198) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 90 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 90 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 90 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 90 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 90 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 90 (decVar -> ID DEQUAL FLOAT .)
    COLON           reduce using rule 90 (decVar -> ID DEQUAL FLOAT .)
    $end            reduce using rule 90 (decVar -> ID DEQUAL FLOAT .)
    RLLAVE          reduce using rule 90 (decVar -> ID DEQUAL FLOAT .)
    DEFAULT         reduce using rule 90 (decVar -> ID DEQUAL FLOAT .)
    CASE            reduce using rule 90 (decVar -> ID DEQUAL FLOAT .)
    RETURN          reduce using rule 90 (decVar -> ID DEQUAL FLOAT .)
    GREATER         reduce using rule 198 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 198 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 198 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 198 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 198 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 198 (something_ex -> FLOAT .)
    PLUS            reduce using rule 198 (something_ex -> FLOAT .)
    TIMES           reduce using rule 198 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 198 (something_ex -> FLOAT .)
    MINUS           reduce using rule 198 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 198 (something_ex -> FLOAT .) ]


state 152

    (91) decVar -> ID DEQUAL expression .
    (136) value -> expression .

    COLON           reduce using rule 91 (decVar -> ID DEQUAL expression .)
    $end            reduce using rule 91 (decVar -> ID DEQUAL expression .)
    RLLAVE          reduce using rule 91 (decVar -> ID DEQUAL expression .)
    DEFAULT         reduce using rule 91 (decVar -> ID DEQUAL expression .)
    CASE            reduce using rule 91 (decVar -> ID DEQUAL expression .)
    RETURN          reduce using rule 91 (decVar -> ID DEQUAL expression .)
    GREATER         reduce using rule 136 (value -> expression .)
    SMALLER         reduce using rule 136 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 136 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 136 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 136 (value -> expression .)
    NOT_EQUAL       reduce using rule 136 (value -> expression .)
    PLUS            reduce using rule 136 (value -> expression .)
    TIMES           reduce using rule 136 (value -> expression .)
    DIVIDE          reduce using rule 136 (value -> expression .)
    MINUS           reduce using rule 136 (value -> expression .)


state 153

    (92) decVar -> ID DEQUAL logic_operation .

    COLON           reduce using rule 92 (decVar -> ID DEQUAL logic_operation .)
    $end            reduce using rule 92 (decVar -> ID DEQUAL logic_operation .)
    RLLAVE          reduce using rule 92 (decVar -> ID DEQUAL logic_operation .)
    DEFAULT         reduce using rule 92 (decVar -> ID DEQUAL logic_operation .)
    CASE            reduce using rule 92 (decVar -> ID DEQUAL logic_operation .)
    RETURN          reduce using rule 92 (decVar -> ID DEQUAL logic_operation .)


state 154

    (93) decVar -> ID DEQUAL comparison .
    (148) logic_value -> comparison .

    COLON           reduce using rule 93 (decVar -> ID DEQUAL comparison .)
    $end            reduce using rule 93 (decVar -> ID DEQUAL comparison .)
    RLLAVE          reduce using rule 93 (decVar -> ID DEQUAL comparison .)
    DEFAULT         reduce using rule 93 (decVar -> ID DEQUAL comparison .)
    CASE            reduce using rule 93 (decVar -> ID DEQUAL comparison .)
    RETURN          reduce using rule 93 (decVar -> ID DEQUAL comparison .)
    AND             reduce using rule 148 (logic_value -> comparison .)
    OR              reduce using rule 148 (logic_value -> comparison .)


state 155

    (97) slice_declaration -> ID DEQUAL funM .

    COLON           reduce using rule 97 (slice_declaration -> ID DEQUAL funM .)
    $end            reduce using rule 97 (slice_declaration -> ID DEQUAL funM .)
    RLLAVE          reduce using rule 97 (slice_declaration -> ID DEQUAL funM .)
    DEFAULT         reduce using rule 97 (slice_declaration -> ID DEQUAL funM .)
    CASE            reduce using rule 97 (slice_declaration -> ID DEQUAL funM .)
    RETURN          reduce using rule 97 (slice_declaration -> ID DEQUAL funM .)


state 156

    (98) slice_declaration -> ID DEQUAL LCORCHE . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 222


state 157

    (119) decVarOne -> ID DEQUAL INTEGER .
    (197) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 119 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 119 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 119 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 119 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 119 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 119 (decVarOne -> ID DEQUAL INTEGER .)
    COLON           reduce using rule 119 (decVarOne -> ID DEQUAL INTEGER .)
    $end            reduce using rule 119 (decVarOne -> ID DEQUAL INTEGER .)
    RLLAVE          reduce using rule 119 (decVarOne -> ID DEQUAL INTEGER .)
    DEFAULT         reduce using rule 119 (decVarOne -> ID DEQUAL INTEGER .)
    CASE            reduce using rule 119 (decVarOne -> ID DEQUAL INTEGER .)
    RETURN          reduce using rule 119 (decVarOne -> ID DEQUAL INTEGER .)
    GREATER         reduce using rule 197 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 197 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 197 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 197 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 197 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 197 (something_ex -> INTEGER .)
    PLUS            reduce using rule 197 (something_ex -> INTEGER .)
    TIMES           reduce using rule 197 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 197 (something_ex -> INTEGER .)
    MINUS           reduce using rule 197 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 197 (something_ex -> INTEGER .) ]


state 158

    (99) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (100) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LPAREN          shift and go to state 223


state 159

    (60) any -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (170) map_var -> ID . LCORCHE key RCORCHE
    (196) something_ex -> ID .
    (135) value -> ID .
    (149) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 60 (any -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 60 (any -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 60 (any -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 60 (any -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 60 (any -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 60 (any -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 135 (value -> ID .)
    COLON           reduce using rule 60 (any -> ID .)
    $end            reduce using rule 60 (any -> ID .)
    RLLAVE          reduce using rule 60 (any -> ID .)
    DEFAULT         reduce using rule 60 (any -> ID .)
    CASE            reduce using rule 60 (any -> ID .)
    RETURN          reduce using rule 60 (any -> ID .)
    LCORCHE         shift and go to state 141
    GREATER         reduce using rule 135 (value -> ID .)
    SMALLER         reduce using rule 135 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 135 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 135 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 135 (value -> ID .)
    NOT_EQUAL       reduce using rule 135 (value -> ID .)
    PLUS            reduce using rule 135 (value -> ID .)
    TIMES           reduce using rule 135 (value -> ID .)
    DIVIDE          reduce using rule 135 (value -> ID .)
    MINUS           reduce using rule 135 (value -> ID .)
    AND             reduce using rule 149 (logic_value -> ID .)
    OR              reduce using rule 149 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 196 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 196 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 196 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 196 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 196 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 196 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 196 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 196 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 196 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 196 (something_ex -> ID .) ]


state 160

    (57) var_asignation -> ID EQUAL any .

    COLON           reduce using rule 57 (var_asignation -> ID EQUAL any .)
    $end            reduce using rule 57 (var_asignation -> ID EQUAL any .)
    RLLAVE          reduce using rule 57 (var_asignation -> ID EQUAL any .)
    DEFAULT         reduce using rule 57 (var_asignation -> ID EQUAL any .)
    CASE            reduce using rule 57 (var_asignation -> ID EQUAL any .)
    RETURN          reduce using rule 57 (var_asignation -> ID EQUAL any .)


state 161

    (58) any -> values .

    COLON           reduce using rule 58 (any -> values .)
    $end            reduce using rule 58 (any -> values .)
    RLLAVE          reduce using rule 58 (any -> values .)
    DEFAULT         reduce using rule 58 (any -> values .)
    CASE            reduce using rule 58 (any -> values .)
    RETURN          reduce using rule 58 (any -> values .)


state 162

    (59) any -> operations .

    COLON           reduce using rule 59 (any -> operations .)
    $end            reduce using rule 59 (any -> operations .)
    RLLAVE          reduce using rule 59 (any -> operations .)
    DEFAULT         reduce using rule 59 (any -> operations .)
    CASE            reduce using rule 59 (any -> operations .)
    RETURN          reduce using rule 59 (any -> operations .)


state 163

    (61) any -> data_structure .
    (199) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 61 (any -> data_structure .)
  ! reduce/reduce conflict for $end resolved using rule 61 (any -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 61 (any -> data_structure .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 61 (any -> data_structure .)
  ! reduce/reduce conflict for CASE resolved using rule 61 (any -> data_structure .)
  ! reduce/reduce conflict for RETURN resolved using rule 61 (any -> data_structure .)
    COLON           reduce using rule 61 (any -> data_structure .)
    $end            reduce using rule 61 (any -> data_structure .)
    RLLAVE          reduce using rule 61 (any -> data_structure .)
    DEFAULT         reduce using rule 61 (any -> data_structure .)
    CASE            reduce using rule 61 (any -> data_structure .)
    RETURN          reduce using rule 61 (any -> data_structure .)
    GREATER         reduce using rule 199 (something_ex -> data_structure .)
    SMALLER         reduce using rule 199 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 199 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 199 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 199 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 199 (something_ex -> data_structure .)
    PLUS            reduce using rule 199 (something_ex -> data_structure .)
    TIMES           reduce using rule 199 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 199 (something_ex -> data_structure .)
    MINUS           reduce using rule 199 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 199 (something_ex -> data_structure .) ]
  ! $end            [ reduce using rule 199 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 199 (something_ex -> data_structure .) ]
  ! DEFAULT         [ reduce using rule 199 (something_ex -> data_structure .) ]
  ! CASE            [ reduce using rule 199 (something_ex -> data_structure .) ]
  ! RETURN          [ reduce using rule 199 (something_ex -> data_structure .) ]


state 164

    (62) any -> funciones .
    (200) something_ex -> funciones .

  ! reduce/reduce conflict for COLON resolved using rule 62 (any -> funciones .)
  ! reduce/reduce conflict for $end resolved using rule 62 (any -> funciones .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 62 (any -> funciones .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 62 (any -> funciones .)
  ! reduce/reduce conflict for CASE resolved using rule 62 (any -> funciones .)
  ! reduce/reduce conflict for RETURN resolved using rule 62 (any -> funciones .)
    COLON           reduce using rule 62 (any -> funciones .)
    $end            reduce using rule 62 (any -> funciones .)
    RLLAVE          reduce using rule 62 (any -> funciones .)
    DEFAULT         reduce using rule 62 (any -> funciones .)
    CASE            reduce using rule 62 (any -> funciones .)
    RETURN          reduce using rule 62 (any -> funciones .)
    GREATER         reduce using rule 200 (something_ex -> funciones .)
    SMALLER         reduce using rule 200 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 200 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 200 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 200 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 200 (something_ex -> funciones .)
    PLUS            reduce using rule 200 (something_ex -> funciones .)
    TIMES           reduce using rule 200 (something_ex -> funciones .)
    DIVIDE          reduce using rule 200 (something_ex -> funciones .)
    MINUS           reduce using rule 200 (something_ex -> funciones .)

  ! COLON           [ reduce using rule 200 (something_ex -> funciones .) ]
  ! $end            [ reduce using rule 200 (something_ex -> funciones .) ]
  ! RLLAVE          [ reduce using rule 200 (something_ex -> funciones .) ]
  ! DEFAULT         [ reduce using rule 200 (something_ex -> funciones .) ]
  ! CASE            [ reduce using rule 200 (something_ex -> funciones .) ]
  ! RETURN          [ reduce using rule 200 (something_ex -> funciones .) ]


state 165

    (165) index -> ID .
    (105) index_s -> ID .
    (171) key -> ID .
    (196) something_ex -> ID .
    (135) value -> ID .
    (149) logic_value -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (170) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for RCORCHE resolved using rule 105 (index_s -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 105 (index_s -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 105 (index_s -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 135 (value -> ID .)
    RCORCHE         reduce using rule 105 (index_s -> ID .)
    GREATER         reduce using rule 135 (value -> ID .)
    SMALLER         reduce using rule 135 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 135 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 135 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 135 (value -> ID .)
    NOT_EQUAL       reduce using rule 135 (value -> ID .)
    PLUS            reduce using rule 135 (value -> ID .)
    TIMES           reduce using rule 135 (value -> ID .)
    DIVIDE          reduce using rule 135 (value -> ID .)
    MINUS           reduce using rule 135 (value -> ID .)
    AND             reduce using rule 149 (logic_value -> ID .)
    OR              reduce using rule 149 (logic_value -> ID .)
    LCORCHE         shift and go to state 141

  ! RCORCHE         [ reduce using rule 165 (index -> ID .) ]
  ! RCORCHE         [ reduce using rule 171 (key -> ID .) ]
  ! GREATER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 196 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 196 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 196 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 196 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 196 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 196 (something_ex -> ID .) ]


state 166

    (164) array_var -> ID LCORCHE index . RCORCHE

    RCORCHE         shift and go to state 224


state 167

    (104) slice_var -> ID LCORCHE index_s . RCORCHE

    RCORCHE         shift and go to state 225


state 168

    (170) map_var -> ID LCORCHE key . RCORCHE

    RCORCHE         shift and go to state 226


state 169

    (166) index -> INTEGER .
    (106) index_s -> INTEGER .
    (39) values -> INTEGER .
    (197) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 106 (index_s -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 39 (values -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 39 (values -> INTEGER .)
    RCORCHE         reduce using rule 39 (values -> INTEGER .)
    GREATER         reduce using rule 197 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 197 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 197 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 197 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 197 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 197 (something_ex -> INTEGER .)
    PLUS            reduce using rule 197 (something_ex -> INTEGER .)
    TIMES           reduce using rule 197 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 197 (something_ex -> INTEGER .)
    MINUS           reduce using rule 197 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 166 (index -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 106 (index_s -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 197 (something_ex -> INTEGER .) ]


state 170

    (167) index -> expression .
    (107) index_s -> expression .
    (52) operations -> expression .
    (136) value -> expression .

  ! reduce/reduce conflict for RCORCHE resolved using rule 107 (index_s -> expression .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 52 (operations -> expression .)
    RCORCHE         reduce using rule 52 (operations -> expression .)
    GREATER         reduce using rule 136 (value -> expression .)
    SMALLER         reduce using rule 136 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 136 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 136 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 136 (value -> expression .)
    NOT_EQUAL       reduce using rule 136 (value -> expression .)
    PLUS            reduce using rule 136 (value -> expression .)
    TIMES           reduce using rule 136 (value -> expression .)
    DIVIDE          reduce using rule 136 (value -> expression .)
    MINUS           reduce using rule 136 (value -> expression .)

  ! RCORCHE         [ reduce using rule 167 (index -> expression .) ]
  ! RCORCHE         [ reduce using rule 107 (index_s -> expression .) ]


state 171

    (172) key -> values .

    RCORCHE         reduce using rule 172 (key -> values .)


state 172

    (173) key -> operations .

    RCORCHE         reduce using rule 173 (key -> operations .)


state 173

    (113) funciones -> APPEND LPAREN ID . COMA values RPAREN
    (114) funciones -> APPEND LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 227


state 174

    (115) funciones -> LEN LPAREN ID . RPAREN

    RPAREN          shift and go to state 228


state 175

    (116) funciones -> COPY LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 229


state 176

    (117) funciones -> DELETE LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 230


state 177

    (120) SenIF -> IF comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenStruct
    (18) codigo -> . cStruct
    (19) codigo -> . switch_statement
    (20) codigo -> . array_declaration COLON
    (21) codigo -> . array_declaration
    (22) codigo -> . array_var COLON
    (23) codigo -> . array_var
    (24) codigo -> . array_assignment COLON
    (25) codigo -> . array_assignment
    (26) codigo -> . slice_declaration COLON
    (27) codigo -> . slice_declaration
    (28) codigo -> . slice_var COLON
    (29) codigo -> . slice_var
    (30) codigo -> . slice_assignment COLON
    (31) codigo -> . slice_assignment
    (32) codigo -> . map_declaration COLON
    (33) codigo -> . map_declaration
    (34) codigo -> . map_assignment COLON
    (35) codigo -> . map_assignment
    (36) codigo -> . func_declaration
    (37) codigo -> . main_func
    (186) impresion -> . PRINT LPAREN content RPAREN
    (74) scan_func -> . SCAN LPAREN POINTER RPAREN
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (75) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (76) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (77) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (81) decVar -> . decVarOne
    (82) decVar -> . VAR ID EQUAL INTEGER
    (83) decVar -> . VAR ID EQUAL ID
    (84) decVar -> . VAR ID EQUAL FLOAT
    (85) decVar -> . VAR ID EQUAL expression
    (86) decVar -> . VAR ID EQUAL logic_operation
    (87) decVar -> . VAR ID EQUAL comparison
    (88) decVar -> . VAR ID EQUAL STRING
    (89) decVar -> . ID DEQUAL STRING
    (90) decVar -> . ID DEQUAL FLOAT
    (91) decVar -> . ID DEQUAL expression
    (92) decVar -> . ID DEQUAL logic_operation
    (93) decVar -> . ID DEQUAL comparison
    (57) var_asignation -> . ID EQUAL any
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (120) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (121) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (122) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (123) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (127) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (154) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (159) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (160) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (164) array_var -> . ID LCORCHE index RCORCHE
    (168) array_assignment -> . array_var EQUAL something
    (94) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (95) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (96) slice_declaration -> . VAR ID EQUAL funM
    (97) slice_declaration -> . ID DEQUAL funM
    (98) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (104) slice_var -> . ID LCORCHE index_s RCORCHE
    (108) slice_assignment -> . slice_var EQUAL something_s
    (169) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (174) map_assignment -> . array_var EQUAL something
    (175) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (73) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (118) decVarOne -> . ID DEQUAL ID
    (119) decVarOne -> . ID DEQUAL INTEGER
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (170) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 25
    SCAN            shift and go to state 26
    FOR             shift and go to state 28
    VAR             shift and go to state 33
    ID              shift and go to state 34
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40
    IF              shift and go to state 41
    TYPE            shift and go to state 42
    SWITCH          shift and go to state 43
    FUNC            shift and go to state 44
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    NOT             shift and go to state 46

    comparison                     shift and go to state 6
    codigo                         shift and go to state 231
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenStruct                      shift and go to state 12
    cStruct                        shift and go to state 13
    switch_statement               shift and go to state 14
    array_declaration              shift and go to state 15
    array_var                      shift and go to state 16
    array_assignment               shift and go to state 17
    slice_declaration              shift and go to state 18
    slice_var                      shift and go to state 19
    slice_assignment               shift and go to state 20
    map_declaration                shift and go to state 21
    map_assignment                 shift and go to state 22
    func_declaration               shift and go to state 23
    main_func                      shift and go to state 24
    something_ex                   shift and go to state 27
    decVarOne                      shift and go to state 29
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    data_structure                 shift and go to state 45
    map_var                        shift and go to state 47

state 178

    (121) SenIF -> IF TRUE LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenStruct
    (18) codigo -> . cStruct
    (19) codigo -> . switch_statement
    (20) codigo -> . array_declaration COLON
    (21) codigo -> . array_declaration
    (22) codigo -> . array_var COLON
    (23) codigo -> . array_var
    (24) codigo -> . array_assignment COLON
    (25) codigo -> . array_assignment
    (26) codigo -> . slice_declaration COLON
    (27) codigo -> . slice_declaration
    (28) codigo -> . slice_var COLON
    (29) codigo -> . slice_var
    (30) codigo -> . slice_assignment COLON
    (31) codigo -> . slice_assignment
    (32) codigo -> . map_declaration COLON
    (33) codigo -> . map_declaration
    (34) codigo -> . map_assignment COLON
    (35) codigo -> . map_assignment
    (36) codigo -> . func_declaration
    (37) codigo -> . main_func
    (186) impresion -> . PRINT LPAREN content RPAREN
    (74) scan_func -> . SCAN LPAREN POINTER RPAREN
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (75) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (76) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (77) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (81) decVar -> . decVarOne
    (82) decVar -> . VAR ID EQUAL INTEGER
    (83) decVar -> . VAR ID EQUAL ID
    (84) decVar -> . VAR ID EQUAL FLOAT
    (85) decVar -> . VAR ID EQUAL expression
    (86) decVar -> . VAR ID EQUAL logic_operation
    (87) decVar -> . VAR ID EQUAL comparison
    (88) decVar -> . VAR ID EQUAL STRING
    (89) decVar -> . ID DEQUAL STRING
    (90) decVar -> . ID DEQUAL FLOAT
    (91) decVar -> . ID DEQUAL expression
    (92) decVar -> . ID DEQUAL logic_operation
    (93) decVar -> . ID DEQUAL comparison
    (57) var_asignation -> . ID EQUAL any
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (120) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (121) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (122) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (123) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (127) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (154) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (159) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (160) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (164) array_var -> . ID LCORCHE index RCORCHE
    (168) array_assignment -> . array_var EQUAL something
    (94) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (95) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (96) slice_declaration -> . VAR ID EQUAL funM
    (97) slice_declaration -> . ID DEQUAL funM
    (98) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (104) slice_var -> . ID LCORCHE index_s RCORCHE
    (108) slice_assignment -> . slice_var EQUAL something_s
    (169) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (174) map_assignment -> . array_var EQUAL something
    (175) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (73) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (118) decVarOne -> . ID DEQUAL ID
    (119) decVarOne -> . ID DEQUAL INTEGER
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (170) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 25
    SCAN            shift and go to state 26
    FOR             shift and go to state 28
    VAR             shift and go to state 33
    ID              shift and go to state 34
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40
    IF              shift and go to state 41
    TYPE            shift and go to state 42
    SWITCH          shift and go to state 43
    FUNC            shift and go to state 44
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    NOT             shift and go to state 46

    codigo                         shift and go to state 232
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenStruct                      shift and go to state 12
    cStruct                        shift and go to state 13
    switch_statement               shift and go to state 14
    array_declaration              shift and go to state 15
    array_var                      shift and go to state 16
    array_assignment               shift and go to state 17
    slice_declaration              shift and go to state 18
    slice_var                      shift and go to state 19
    slice_assignment               shift and go to state 20
    map_declaration                shift and go to state 21
    map_assignment                 shift and go to state 22
    func_declaration               shift and go to state 23
    main_func                      shift and go to state 24
    something_ex                   shift and go to state 27
    decVarOne                      shift and go to state 29
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    data_structure                 shift and go to state 45
    map_var                        shift and go to state 47

state 179

    (122) SenIF -> IF FALSE LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenStruct
    (18) codigo -> . cStruct
    (19) codigo -> . switch_statement
    (20) codigo -> . array_declaration COLON
    (21) codigo -> . array_declaration
    (22) codigo -> . array_var COLON
    (23) codigo -> . array_var
    (24) codigo -> . array_assignment COLON
    (25) codigo -> . array_assignment
    (26) codigo -> . slice_declaration COLON
    (27) codigo -> . slice_declaration
    (28) codigo -> . slice_var COLON
    (29) codigo -> . slice_var
    (30) codigo -> . slice_assignment COLON
    (31) codigo -> . slice_assignment
    (32) codigo -> . map_declaration COLON
    (33) codigo -> . map_declaration
    (34) codigo -> . map_assignment COLON
    (35) codigo -> . map_assignment
    (36) codigo -> . func_declaration
    (37) codigo -> . main_func
    (186) impresion -> . PRINT LPAREN content RPAREN
    (74) scan_func -> . SCAN LPAREN POINTER RPAREN
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (75) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (76) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (77) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (81) decVar -> . decVarOne
    (82) decVar -> . VAR ID EQUAL INTEGER
    (83) decVar -> . VAR ID EQUAL ID
    (84) decVar -> . VAR ID EQUAL FLOAT
    (85) decVar -> . VAR ID EQUAL expression
    (86) decVar -> . VAR ID EQUAL logic_operation
    (87) decVar -> . VAR ID EQUAL comparison
    (88) decVar -> . VAR ID EQUAL STRING
    (89) decVar -> . ID DEQUAL STRING
    (90) decVar -> . ID DEQUAL FLOAT
    (91) decVar -> . ID DEQUAL expression
    (92) decVar -> . ID DEQUAL logic_operation
    (93) decVar -> . ID DEQUAL comparison
    (57) var_asignation -> . ID EQUAL any
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (120) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (121) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (122) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (123) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (127) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (154) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (159) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (160) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (164) array_var -> . ID LCORCHE index RCORCHE
    (168) array_assignment -> . array_var EQUAL something
    (94) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (95) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (96) slice_declaration -> . VAR ID EQUAL funM
    (97) slice_declaration -> . ID DEQUAL funM
    (98) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (104) slice_var -> . ID LCORCHE index_s RCORCHE
    (108) slice_assignment -> . slice_var EQUAL something_s
    (169) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (174) map_assignment -> . array_var EQUAL something
    (175) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (73) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (118) decVarOne -> . ID DEQUAL ID
    (119) decVarOne -> . ID DEQUAL INTEGER
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (170) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 25
    SCAN            shift and go to state 26
    FOR             shift and go to state 28
    VAR             shift and go to state 33
    ID              shift and go to state 34
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40
    IF              shift and go to state 41
    TYPE            shift and go to state 42
    SWITCH          shift and go to state 43
    FUNC            shift and go to state 44
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    NOT             shift and go to state 46

    codigo                         shift and go to state 233
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenStruct                      shift and go to state 12
    cStruct                        shift and go to state 13
    switch_statement               shift and go to state 14
    array_declaration              shift and go to state 15
    array_var                      shift and go to state 16
    array_assignment               shift and go to state 17
    slice_declaration              shift and go to state 18
    slice_var                      shift and go to state 19
    slice_assignment               shift and go to state 20
    map_declaration                shift and go to state 21
    map_assignment                 shift and go to state 22
    func_declaration               shift and go to state 23
    main_func                      shift and go to state 24
    something_ex                   shift and go to state 27
    decVarOne                      shift and go to state 29
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    data_structure                 shift and go to state 45
    map_var                        shift and go to state 47

state 180

    (123) SenStruct -> TYPE ID STRUCT . LLLAVE declaration RLLAVE

    LLLAVE          shift and go to state 234


state 181

    (154) switch_statement -> SWITCH ID LLLAVE . cases RLLAVE
    (155) cases -> . CASE values POINTS codigo
    (156) cases -> . CASE values POINTS codigo more

    CASE            shift and go to state 236

    cases                          shift and go to state 235

state 182

    (175) func_declaration -> FUNC ID LPAREN . params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> FUNC ID LPAREN . params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (183) params -> . ID data_types
    (184) params -> . more_params
    (185) more_params -> . ID data_types COMA params

    ID              shift and go to state 237

    params                         shift and go to state 238
    more_params                    shift and go to state 239

state 183

    (73) main_func -> FUNC MAIN LPAREN . RPAREN LLLAVE codigo RLLAVE

    RPAREN          shift and go to state 240


state 184

    (186) impresion -> PRINT LPAREN content RPAREN .

    COLON           reduce using rule 186 (impresion -> PRINT LPAREN content RPAREN .)
    $end            reduce using rule 186 (impresion -> PRINT LPAREN content RPAREN .)
    RLLAVE          reduce using rule 186 (impresion -> PRINT LPAREN content RPAREN .)
    DEFAULT         reduce using rule 186 (impresion -> PRINT LPAREN content RPAREN .)
    CASE            reduce using rule 186 (impresion -> PRINT LPAREN content RPAREN .)
    RETURN          reduce using rule 186 (impresion -> PRINT LPAREN content RPAREN .)


state 185

    (74) scan_func -> SCAN LPAREN POINTER RPAREN .

    COLON           reduce using rule 74 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    $end            reduce using rule 74 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    RLLAVE          reduce using rule 74 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    DEFAULT         reduce using rule 74 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    CASE            reduce using rule 74 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    RETURN          reduce using rule 74 (scan_func -> SCAN LPAREN POINTER RPAREN .)


state 186

    (195) adicionaEx -> op something_ex adicionaEx .

    COLON           reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    $end            reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    GREATER         reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    SMALLER         reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    GREATER_OR_EQUAL reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    SMALLER_OR_EQUAL reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    EQUAL_COMPARE   reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    NOT_EQUAL       reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    PLUS            reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    TIMES           reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    DIVIDE          reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    MINUS           reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    RLLAVE          reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    DEFAULT         reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    CASE            reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    RETURN          reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    RPAREN          reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    AND             reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    OR              reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    LLLAVE          reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    RCORCHE         reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)
    COMA            reduce using rule 195 (adicionaEx -> op something_ex adicionaEx .)


state 187

    (75) cicloFor -> FOR LLLAVE codigo RLLAVE .

    $end            reduce using rule 75 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 75 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 75 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 75 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 75 (cicloFor -> FOR LLLAVE codigo RLLAVE .)


state 188

    (76) cicloFor -> FOR comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 241


state 189

    (77) cicloFor -> FOR logic_operation LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 242


state 190

    (78) cicloFor -> FOR decVarOne COLON comparison . COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 243


state 191

    (118) decVarOne -> ID DEQUAL ID .

    COLON           reduce using rule 118 (decVarOne -> ID DEQUAL ID .)


state 192

    (119) decVarOne -> ID DEQUAL INTEGER .

    COLON           reduce using rule 119 (decVarOne -> ID DEQUAL INTEGER .)


state 193

    (165) index -> ID .
    (171) key -> ID .
    (196) something_ex -> ID .
    (135) value -> ID .
    (149) logic_value -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (170) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for RCORCHE resolved using rule 165 (index -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 165 (index -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 135 (value -> ID .)
    RCORCHE         reduce using rule 165 (index -> ID .)
    GREATER         reduce using rule 135 (value -> ID .)
    SMALLER         reduce using rule 135 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 135 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 135 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 135 (value -> ID .)
    NOT_EQUAL       reduce using rule 135 (value -> ID .)
    PLUS            reduce using rule 135 (value -> ID .)
    TIMES           reduce using rule 135 (value -> ID .)
    DIVIDE          reduce using rule 135 (value -> ID .)
    MINUS           reduce using rule 135 (value -> ID .)
    AND             reduce using rule 149 (logic_value -> ID .)
    OR              reduce using rule 149 (logic_value -> ID .)
    LCORCHE         shift and go to state 141

  ! RCORCHE         [ reduce using rule 171 (key -> ID .) ]
  ! GREATER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 196 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 196 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 196 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 196 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 196 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 196 (something_ex -> ID .) ]


state 194

    (166) index -> INTEGER .
    (39) values -> INTEGER .
    (197) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 39 (values -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 39 (values -> INTEGER .)
    RCORCHE         reduce using rule 39 (values -> INTEGER .)
    GREATER         reduce using rule 197 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 197 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 197 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 197 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 197 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 197 (something_ex -> INTEGER .)
    PLUS            reduce using rule 197 (something_ex -> INTEGER .)
    TIMES           reduce using rule 197 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 197 (something_ex -> INTEGER .)
    MINUS           reduce using rule 197 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 166 (index -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 197 (something_ex -> INTEGER .) ]


state 195

    (167) index -> expression .
    (52) operations -> expression .
    (136) value -> expression .

  ! reduce/reduce conflict for RCORCHE resolved using rule 52 (operations -> expression .)
    RCORCHE         reduce using rule 52 (operations -> expression .)
    GREATER         reduce using rule 136 (value -> expression .)
    SMALLER         reduce using rule 136 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 136 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 136 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 136 (value -> expression .)
    NOT_EQUAL       reduce using rule 136 (value -> expression .)
    PLUS            reduce using rule 136 (value -> expression .)
    TIMES           reduce using rule 136 (value -> expression .)
    DIVIDE          reduce using rule 136 (value -> expression .)
    MINUS           reduce using rule 136 (value -> expression .)

  ! RCORCHE         [ reduce using rule 167 (index -> expression .) ]


state 196

    (146) logic_recu -> logic_op logic_value logic_recu .

    $end            reduce using rule 146 (logic_recu -> logic_op logic_value logic_recu .)
    LLLAVE          reduce using rule 146 (logic_recu -> logic_op logic_value logic_recu .)
    COLON           reduce using rule 146 (logic_recu -> logic_op logic_value logic_recu .)
    RLLAVE          reduce using rule 146 (logic_recu -> logic_op logic_value logic_recu .)
    DEFAULT         reduce using rule 146 (logic_recu -> logic_op logic_value logic_recu .)
    CASE            reduce using rule 146 (logic_recu -> logic_op logic_value logic_recu .)
    RETURN          reduce using rule 146 (logic_recu -> logic_op logic_value logic_recu .)
    RPAREN          reduce using rule 146 (logic_recu -> logic_op logic_value logic_recu .)
    RCORCHE         reduce using rule 146 (logic_recu -> logic_op logic_value logic_recu .)
    COMA            reduce using rule 146 (logic_recu -> logic_op logic_value logic_recu .)


state 197

    (83) decVar -> VAR ID EQUAL ID .
    (196) something_ex -> ID .
    (149) logic_value -> ID .
    (135) value -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (170) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for COLON resolved using rule 83 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for $end resolved using rule 83 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 83 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 83 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for CASE resolved using rule 83 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 83 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 135 (value -> ID .)
    COLON           reduce using rule 83 (decVar -> VAR ID EQUAL ID .)
    $end            reduce using rule 83 (decVar -> VAR ID EQUAL ID .)
    RLLAVE          reduce using rule 83 (decVar -> VAR ID EQUAL ID .)
    DEFAULT         reduce using rule 83 (decVar -> VAR ID EQUAL ID .)
    CASE            reduce using rule 83 (decVar -> VAR ID EQUAL ID .)
    RETURN          reduce using rule 83 (decVar -> VAR ID EQUAL ID .)
    AND             reduce using rule 149 (logic_value -> ID .)
    OR              reduce using rule 149 (logic_value -> ID .)
    GREATER         reduce using rule 135 (value -> ID .)
    SMALLER         reduce using rule 135 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 135 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 135 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 135 (value -> ID .)
    NOT_EQUAL       reduce using rule 135 (value -> ID .)
    PLUS            reduce using rule 135 (value -> ID .)
    TIMES           reduce using rule 135 (value -> ID .)
    DIVIDE          reduce using rule 135 (value -> ID .)
    MINUS           reduce using rule 135 (value -> ID .)
    LCORCHE         shift and go to state 141

  ! GREATER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 196 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 196 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 196 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 196 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 196 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 196 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 196 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 196 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 196 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 196 (something_ex -> ID .) ]


state 198

    (82) decVar -> VAR ID EQUAL INTEGER .
    (197) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 82 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 82 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 82 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 82 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 82 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 82 (decVar -> VAR ID EQUAL INTEGER .)
    COLON           reduce using rule 82 (decVar -> VAR ID EQUAL INTEGER .)
    $end            reduce using rule 82 (decVar -> VAR ID EQUAL INTEGER .)
    RLLAVE          reduce using rule 82 (decVar -> VAR ID EQUAL INTEGER .)
    DEFAULT         reduce using rule 82 (decVar -> VAR ID EQUAL INTEGER .)
    CASE            reduce using rule 82 (decVar -> VAR ID EQUAL INTEGER .)
    RETURN          reduce using rule 82 (decVar -> VAR ID EQUAL INTEGER .)
    GREATER         reduce using rule 197 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 197 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 197 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 197 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 197 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 197 (something_ex -> INTEGER .)
    PLUS            reduce using rule 197 (something_ex -> INTEGER .)
    TIMES           reduce using rule 197 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 197 (something_ex -> INTEGER .)
    MINUS           reduce using rule 197 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 197 (something_ex -> INTEGER .) ]


state 199

    (84) decVar -> VAR ID EQUAL FLOAT .
    (198) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 84 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 84 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 84 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 84 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 84 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 84 (decVar -> VAR ID EQUAL FLOAT .)
    COLON           reduce using rule 84 (decVar -> VAR ID EQUAL FLOAT .)
    $end            reduce using rule 84 (decVar -> VAR ID EQUAL FLOAT .)
    RLLAVE          reduce using rule 84 (decVar -> VAR ID EQUAL FLOAT .)
    DEFAULT         reduce using rule 84 (decVar -> VAR ID EQUAL FLOAT .)
    CASE            reduce using rule 84 (decVar -> VAR ID EQUAL FLOAT .)
    RETURN          reduce using rule 84 (decVar -> VAR ID EQUAL FLOAT .)
    GREATER         reduce using rule 198 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 198 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 198 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 198 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 198 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 198 (something_ex -> FLOAT .)
    PLUS            reduce using rule 198 (something_ex -> FLOAT .)
    TIMES           reduce using rule 198 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 198 (something_ex -> FLOAT .)
    MINUS           reduce using rule 198 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 198 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 198 (something_ex -> FLOAT .) ]


state 200

    (85) decVar -> VAR ID EQUAL expression .
    (136) value -> expression .

    COLON           reduce using rule 85 (decVar -> VAR ID EQUAL expression .)
    $end            reduce using rule 85 (decVar -> VAR ID EQUAL expression .)
    RLLAVE          reduce using rule 85 (decVar -> VAR ID EQUAL expression .)
    DEFAULT         reduce using rule 85 (decVar -> VAR ID EQUAL expression .)
    CASE            reduce using rule 85 (decVar -> VAR ID EQUAL expression .)
    RETURN          reduce using rule 85 (decVar -> VAR ID EQUAL expression .)
    GREATER         reduce using rule 136 (value -> expression .)
    SMALLER         reduce using rule 136 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 136 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 136 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 136 (value -> expression .)
    NOT_EQUAL       reduce using rule 136 (value -> expression .)
    PLUS            reduce using rule 136 (value -> expression .)
    TIMES           reduce using rule 136 (value -> expression .)
    DIVIDE          reduce using rule 136 (value -> expression .)
    MINUS           reduce using rule 136 (value -> expression .)


state 201

    (86) decVar -> VAR ID EQUAL logic_operation .

    COLON           reduce using rule 86 (decVar -> VAR ID EQUAL logic_operation .)
    $end            reduce using rule 86 (decVar -> VAR ID EQUAL logic_operation .)
    RLLAVE          reduce using rule 86 (decVar -> VAR ID EQUAL logic_operation .)
    DEFAULT         reduce using rule 86 (decVar -> VAR ID EQUAL logic_operation .)
    CASE            reduce using rule 86 (decVar -> VAR ID EQUAL logic_operation .)
    RETURN          reduce using rule 86 (decVar -> VAR ID EQUAL logic_operation .)


state 202

    (87) decVar -> VAR ID EQUAL comparison .
    (148) logic_value -> comparison .

    COLON           reduce using rule 87 (decVar -> VAR ID EQUAL comparison .)
    $end            reduce using rule 87 (decVar -> VAR ID EQUAL comparison .)
    RLLAVE          reduce using rule 87 (decVar -> VAR ID EQUAL comparison .)
    DEFAULT         reduce using rule 87 (decVar -> VAR ID EQUAL comparison .)
    CASE            reduce using rule 87 (decVar -> VAR ID EQUAL comparison .)
    RETURN          reduce using rule 87 (decVar -> VAR ID EQUAL comparison .)
    AND             reduce using rule 148 (logic_value -> comparison .)
    OR              reduce using rule 148 (logic_value -> comparison .)


state 203

    (88) decVar -> VAR ID EQUAL STRING .

    COLON           reduce using rule 88 (decVar -> VAR ID EQUAL STRING .)
    $end            reduce using rule 88 (decVar -> VAR ID EQUAL STRING .)
    RLLAVE          reduce using rule 88 (decVar -> VAR ID EQUAL STRING .)
    DEFAULT         reduce using rule 88 (decVar -> VAR ID EQUAL STRING .)
    CASE            reduce using rule 88 (decVar -> VAR ID EQUAL STRING .)
    RETURN          reduce using rule 88 (decVar -> VAR ID EQUAL STRING .)


state 204

    (160) array_declaration -> VAR ID EQUAL LCORCHE . capacity RCORCHE data_types arr_content
    (95) slice_declaration -> VAR ID EQUAL LCORCHE . RCORCHE data_types arr_content
    (161) capacity -> . INTEGER
    (162) capacity -> . ID
    (163) capacity -> . expression
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    RCORCHE         shift and go to state 245
    INTEGER         shift and go to state 210
    ID              shift and go to state 206
    FLOAT           shift and go to state 36
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    capacity                       shift and go to state 244
    expression                     shift and go to state 211
    something_ex                   shift and go to state 27
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 205

    (96) slice_declaration -> VAR ID EQUAL funM .

    COLON           reduce using rule 96 (slice_declaration -> VAR ID EQUAL funM .)
    $end            reduce using rule 96 (slice_declaration -> VAR ID EQUAL funM .)
    RLLAVE          reduce using rule 96 (slice_declaration -> VAR ID EQUAL funM .)
    DEFAULT         reduce using rule 96 (slice_declaration -> VAR ID EQUAL funM .)
    CASE            reduce using rule 96 (slice_declaration -> VAR ID EQUAL funM .)
    RETURN          reduce using rule 96 (slice_declaration -> VAR ID EQUAL funM .)


state 206

    (162) capacity -> ID .
    (196) something_ex -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (170) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for RCORCHE resolved using rule 162 (capacity -> ID .)
    RCORCHE         reduce using rule 162 (capacity -> ID .)
    GREATER         reduce using rule 196 (something_ex -> ID .)
    SMALLER         reduce using rule 196 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 196 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 196 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 196 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 196 (something_ex -> ID .)
    PLUS            reduce using rule 196 (something_ex -> ID .)
    TIMES           reduce using rule 196 (something_ex -> ID .)
    DIVIDE          reduce using rule 196 (something_ex -> ID .)
    MINUS           reduce using rule 196 (something_ex -> ID .)
    LCORCHE         shift and go to state 141

  ! RCORCHE         [ reduce using rule 196 (something_ex -> ID .) ]


state 207

    (159) array_declaration -> VAR ID LCORCHE capacity . RCORCHE data_types

    RCORCHE         shift and go to state 246


state 208

    (94) slice_declaration -> VAR ID LCORCHE RCORCHE . data_types
    (43) data_types -> . INT32
    (44) data_types -> . INT64
    (45) data_types -> . FLOAT32
    (46) data_types -> . FLOAT64
    (47) data_types -> . BYTE
    (48) data_types -> . WINT
    (49) data_types -> . WFLOAT
    (50) data_types -> . WSTRING
    (51) data_types -> . BOOL

    INT32           shift and go to state 212
    INT64           shift and go to state 213
    FLOAT32         shift and go to state 214
    FLOAT64         shift and go to state 215
    BYTE            shift and go to state 216
    WINT            shift and go to state 217
    WFLOAT          shift and go to state 218
    WSTRING         shift and go to state 219
    BOOL            shift and go to state 220

    data_types                     shift and go to state 247

state 209

    (169) map_declaration -> VAR ID LCORCHE data_types . RCORCHE data_types

    RCORCHE         shift and go to state 248


state 210

    (161) capacity -> INTEGER .
    (197) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 161 (capacity -> INTEGER .)
    RCORCHE         reduce using rule 161 (capacity -> INTEGER .)
    GREATER         reduce using rule 197 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 197 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 197 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 197 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 197 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 197 (something_ex -> INTEGER .)
    PLUS            reduce using rule 197 (something_ex -> INTEGER .)
    TIMES           reduce using rule 197 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 197 (something_ex -> INTEGER .)
    MINUS           reduce using rule 197 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 197 (something_ex -> INTEGER .) ]


state 211

    (163) capacity -> expression .

    RCORCHE         reduce using rule 163 (capacity -> expression .)


state 212

    (43) data_types -> INT32 .

    RCORCHE         reduce using rule 43 (data_types -> INT32 .)
    COLON           reduce using rule 43 (data_types -> INT32 .)
    $end            reduce using rule 43 (data_types -> INT32 .)
    RLLAVE          reduce using rule 43 (data_types -> INT32 .)
    DEFAULT         reduce using rule 43 (data_types -> INT32 .)
    CASE            reduce using rule 43 (data_types -> INT32 .)
    RETURN          reduce using rule 43 (data_types -> INT32 .)
    LLLAVE          reduce using rule 43 (data_types -> INT32 .)
    COMA            reduce using rule 43 (data_types -> INT32 .)
    RPAREN          reduce using rule 43 (data_types -> INT32 .)
    ID              reduce using rule 43 (data_types -> INT32 .)


state 213

    (44) data_types -> INT64 .

    RCORCHE         reduce using rule 44 (data_types -> INT64 .)
    COLON           reduce using rule 44 (data_types -> INT64 .)
    $end            reduce using rule 44 (data_types -> INT64 .)
    RLLAVE          reduce using rule 44 (data_types -> INT64 .)
    DEFAULT         reduce using rule 44 (data_types -> INT64 .)
    CASE            reduce using rule 44 (data_types -> INT64 .)
    RETURN          reduce using rule 44 (data_types -> INT64 .)
    LLLAVE          reduce using rule 44 (data_types -> INT64 .)
    COMA            reduce using rule 44 (data_types -> INT64 .)
    RPAREN          reduce using rule 44 (data_types -> INT64 .)
    ID              reduce using rule 44 (data_types -> INT64 .)


state 214

    (45) data_types -> FLOAT32 .

    RCORCHE         reduce using rule 45 (data_types -> FLOAT32 .)
    COLON           reduce using rule 45 (data_types -> FLOAT32 .)
    $end            reduce using rule 45 (data_types -> FLOAT32 .)
    RLLAVE          reduce using rule 45 (data_types -> FLOAT32 .)
    DEFAULT         reduce using rule 45 (data_types -> FLOAT32 .)
    CASE            reduce using rule 45 (data_types -> FLOAT32 .)
    RETURN          reduce using rule 45 (data_types -> FLOAT32 .)
    LLLAVE          reduce using rule 45 (data_types -> FLOAT32 .)
    COMA            reduce using rule 45 (data_types -> FLOAT32 .)
    RPAREN          reduce using rule 45 (data_types -> FLOAT32 .)
    ID              reduce using rule 45 (data_types -> FLOAT32 .)


state 215

    (46) data_types -> FLOAT64 .

    RCORCHE         reduce using rule 46 (data_types -> FLOAT64 .)
    COLON           reduce using rule 46 (data_types -> FLOAT64 .)
    $end            reduce using rule 46 (data_types -> FLOAT64 .)
    RLLAVE          reduce using rule 46 (data_types -> FLOAT64 .)
    DEFAULT         reduce using rule 46 (data_types -> FLOAT64 .)
    CASE            reduce using rule 46 (data_types -> FLOAT64 .)
    RETURN          reduce using rule 46 (data_types -> FLOAT64 .)
    LLLAVE          reduce using rule 46 (data_types -> FLOAT64 .)
    COMA            reduce using rule 46 (data_types -> FLOAT64 .)
    RPAREN          reduce using rule 46 (data_types -> FLOAT64 .)
    ID              reduce using rule 46 (data_types -> FLOAT64 .)


state 216

    (47) data_types -> BYTE .

    RCORCHE         reduce using rule 47 (data_types -> BYTE .)
    COLON           reduce using rule 47 (data_types -> BYTE .)
    $end            reduce using rule 47 (data_types -> BYTE .)
    RLLAVE          reduce using rule 47 (data_types -> BYTE .)
    DEFAULT         reduce using rule 47 (data_types -> BYTE .)
    CASE            reduce using rule 47 (data_types -> BYTE .)
    RETURN          reduce using rule 47 (data_types -> BYTE .)
    LLLAVE          reduce using rule 47 (data_types -> BYTE .)
    COMA            reduce using rule 47 (data_types -> BYTE .)
    RPAREN          reduce using rule 47 (data_types -> BYTE .)
    ID              reduce using rule 47 (data_types -> BYTE .)


state 217

    (48) data_types -> WINT .

    RCORCHE         reduce using rule 48 (data_types -> WINT .)
    COLON           reduce using rule 48 (data_types -> WINT .)
    $end            reduce using rule 48 (data_types -> WINT .)
    RLLAVE          reduce using rule 48 (data_types -> WINT .)
    DEFAULT         reduce using rule 48 (data_types -> WINT .)
    CASE            reduce using rule 48 (data_types -> WINT .)
    RETURN          reduce using rule 48 (data_types -> WINT .)
    LLLAVE          reduce using rule 48 (data_types -> WINT .)
    COMA            reduce using rule 48 (data_types -> WINT .)
    RPAREN          reduce using rule 48 (data_types -> WINT .)
    ID              reduce using rule 48 (data_types -> WINT .)


state 218

    (49) data_types -> WFLOAT .

    RCORCHE         reduce using rule 49 (data_types -> WFLOAT .)
    COLON           reduce using rule 49 (data_types -> WFLOAT .)
    $end            reduce using rule 49 (data_types -> WFLOAT .)
    RLLAVE          reduce using rule 49 (data_types -> WFLOAT .)
    DEFAULT         reduce using rule 49 (data_types -> WFLOAT .)
    CASE            reduce using rule 49 (data_types -> WFLOAT .)
    RETURN          reduce using rule 49 (data_types -> WFLOAT .)
    LLLAVE          reduce using rule 49 (data_types -> WFLOAT .)
    COMA            reduce using rule 49 (data_types -> WFLOAT .)
    RPAREN          reduce using rule 49 (data_types -> WFLOAT .)
    ID              reduce using rule 49 (data_types -> WFLOAT .)


state 219

    (50) data_types -> WSTRING .

    RCORCHE         reduce using rule 50 (data_types -> WSTRING .)
    COLON           reduce using rule 50 (data_types -> WSTRING .)
    $end            reduce using rule 50 (data_types -> WSTRING .)
    RLLAVE          reduce using rule 50 (data_types -> WSTRING .)
    DEFAULT         reduce using rule 50 (data_types -> WSTRING .)
    CASE            reduce using rule 50 (data_types -> WSTRING .)
    RETURN          reduce using rule 50 (data_types -> WSTRING .)
    LLLAVE          reduce using rule 50 (data_types -> WSTRING .)
    COMA            reduce using rule 50 (data_types -> WSTRING .)
    RPAREN          reduce using rule 50 (data_types -> WSTRING .)
    ID              reduce using rule 50 (data_types -> WSTRING .)


state 220

    (51) data_types -> BOOL .

    RCORCHE         reduce using rule 51 (data_types -> BOOL .)
    COLON           reduce using rule 51 (data_types -> BOOL .)
    $end            reduce using rule 51 (data_types -> BOOL .)
    RLLAVE          reduce using rule 51 (data_types -> BOOL .)
    DEFAULT         reduce using rule 51 (data_types -> BOOL .)
    CASE            reduce using rule 51 (data_types -> BOOL .)
    RETURN          reduce using rule 51 (data_types -> BOOL .)
    LLLAVE          reduce using rule 51 (data_types -> BOOL .)
    COMA            reduce using rule 51 (data_types -> BOOL .)
    RPAREN          reduce using rule 51 (data_types -> BOOL .)
    ID              reduce using rule 51 (data_types -> BOOL .)


state 221

    (127) cStruct -> ID DEQUAL ID LLLAVE . asignaciones RLLAVE
    (128) asignaciones -> . ID POINTS valor
    (129) asignaciones -> . ID POINTS valor COMA asignaciones

    ID              shift and go to state 249

    asignaciones                   shift and go to state 250

state 222

    (98) slice_declaration -> ID DEQUAL LCORCHE RCORCHE . data_types arr_content
    (43) data_types -> . INT32
    (44) data_types -> . INT64
    (45) data_types -> . FLOAT32
    (46) data_types -> . FLOAT64
    (47) data_types -> . BYTE
    (48) data_types -> . WINT
    (49) data_types -> . WFLOAT
    (50) data_types -> . WSTRING
    (51) data_types -> . BOOL

    INT32           shift and go to state 212
    INT64           shift and go to state 213
    FLOAT32         shift and go to state 214
    FLOAT64         shift and go to state 215
    BYTE            shift and go to state 216
    WINT            shift and go to state 217
    WFLOAT          shift and go to state 218
    WSTRING         shift and go to state 219
    BOOL            shift and go to state 220

    data_types                     shift and go to state 251

state 223

    (99) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap RPAREN
    (100) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LCORCHE         shift and go to state 252


state 224

    (164) array_var -> ID LCORCHE index RCORCHE .

    COLON           reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    EQUAL           reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    $end            reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    GREATER         reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    SMALLER         reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    GREATER_OR_EQUAL reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    SMALLER_OR_EQUAL reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    EQUAL_COMPARE   reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    NOT_EQUAL       reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    PLUS            reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    TIMES           reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    DIVIDE          reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    MINUS           reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    RLLAVE          reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    DEFAULT         reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    CASE            reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    RETURN          reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    RPAREN          reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    AND             reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    OR              reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    LLLAVE          reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    RCORCHE         reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)
    COMA            reduce using rule 164 (array_var -> ID LCORCHE index RCORCHE .)


state 225

    (104) slice_var -> ID LCORCHE index_s RCORCHE .

    COLON           reduce using rule 104 (slice_var -> ID LCORCHE index_s RCORCHE .)
    EQUAL           reduce using rule 104 (slice_var -> ID LCORCHE index_s RCORCHE .)
    $end            reduce using rule 104 (slice_var -> ID LCORCHE index_s RCORCHE .)
    RLLAVE          reduce using rule 104 (slice_var -> ID LCORCHE index_s RCORCHE .)
    DEFAULT         reduce using rule 104 (slice_var -> ID LCORCHE index_s RCORCHE .)
    CASE            reduce using rule 104 (slice_var -> ID LCORCHE index_s RCORCHE .)
    RETURN          reduce using rule 104 (slice_var -> ID LCORCHE index_s RCORCHE .)


state 226

    (170) map_var -> ID LCORCHE key RCORCHE .

    GREATER         reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    SMALLER         reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    GREATER_OR_EQUAL reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    SMALLER_OR_EQUAL reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    EQUAL_COMPARE   reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    NOT_EQUAL       reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    PLUS            reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    TIMES           reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    DIVIDE          reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    MINUS           reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    COLON           reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    $end            reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    RLLAVE          reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    DEFAULT         reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    CASE            reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    RETURN          reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    RPAREN          reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    AND             reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    OR              reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    LLLAVE          reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    RCORCHE         reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)
    COMA            reduce using rule 170 (map_var -> ID LCORCHE key RCORCHE .)


state 227

    (113) funciones -> APPEND LPAREN ID COMA . values RPAREN
    (114) funciones -> APPEND LPAREN ID COMA . ID RPAREN
    (38) values -> . STRING
    (39) values -> . INTEGER
    (40) values -> . FLOAT
    (41) values -> . TRUE
    (42) values -> . FALSE

    ID              shift and go to state 253
    STRING          shift and go to state 114
    INTEGER         shift and go to state 255
    FLOAT           shift and go to state 256
    TRUE            shift and go to state 117
    FALSE           shift and go to state 118

    values                         shift and go to state 254

state 228

    (115) funciones -> LEN LPAREN ID RPAREN .

    COLON           reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    $end            reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    GREATER         reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    SMALLER         reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    NOT_EQUAL       reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    PLUS            reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    TIMES           reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    DIVIDE          reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    MINUS           reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    RLLAVE          reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    DEFAULT         reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    CASE            reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    RETURN          reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    RPAREN          reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    AND             reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    OR              reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    LLLAVE          reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    RCORCHE         reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)
    COMA            reduce using rule 115 (funciones -> LEN LPAREN ID RPAREN .)


state 229

    (116) funciones -> COPY LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 257


state 230

    (117) funciones -> DELETE LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 258


state 231

    (120) SenIF -> IF comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 259


state 232

    (121) SenIF -> IF TRUE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 260


state 233

    (122) SenIF -> IF FALSE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 261


state 234

    (123) SenStruct -> TYPE ID STRUCT LLLAVE . declaration RLLAVE
    (124) declaration -> . variable data_types
    (125) declaration -> . declaration variable data_types
    (126) variable -> . ID

    ID              shift and go to state 262

    declaration                    shift and go to state 263
    variable                       shift and go to state 264

state 235

    (154) switch_statement -> SWITCH ID LLLAVE cases . RLLAVE

    RLLAVE          shift and go to state 265


state 236

    (155) cases -> CASE . values POINTS codigo
    (156) cases -> CASE . values POINTS codigo more
    (38) values -> . STRING
    (39) values -> . INTEGER
    (40) values -> . FLOAT
    (41) values -> . TRUE
    (42) values -> . FALSE

    STRING          shift and go to state 114
    INTEGER         shift and go to state 255
    FLOAT           shift and go to state 256
    TRUE            shift and go to state 117
    FALSE           shift and go to state 118

    values                         shift and go to state 266

state 237

    (183) params -> ID . data_types
    (185) more_params -> ID . data_types COMA params
    (43) data_types -> . INT32
    (44) data_types -> . INT64
    (45) data_types -> . FLOAT32
    (46) data_types -> . FLOAT64
    (47) data_types -> . BYTE
    (48) data_types -> . WINT
    (49) data_types -> . WFLOAT
    (50) data_types -> . WSTRING
    (51) data_types -> . BOOL

    INT32           shift and go to state 212
    INT64           shift and go to state 213
    FLOAT32         shift and go to state 214
    FLOAT64         shift and go to state 215
    BYTE            shift and go to state 216
    WINT            shift and go to state 217
    WFLOAT          shift and go to state 218
    WSTRING         shift and go to state 219
    BOOL            shift and go to state 220

    data_types                     shift and go to state 267

state 238

    (175) func_declaration -> FUNC ID LPAREN params . RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> FUNC ID LPAREN params . RPAREN data_types LLLAVE RETURN return_value RLLAVE

    RPAREN          shift and go to state 268


state 239

    (184) params -> more_params .

    RPAREN          reduce using rule 184 (params -> more_params .)


state 240

    (73) main_func -> FUNC MAIN LPAREN RPAREN . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 269


state 241

    (76) cicloFor -> FOR comparison LLLAVE codigo RLLAVE .

    $end            reduce using rule 76 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 76 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 76 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 76 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 76 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)


state 242

    (77) cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .

    $end            reduce using rule 77 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 77 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 77 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 77 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 77 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)


state 243

    (78) cicloFor -> FOR decVarOne COLON comparison COLON . incre LLLAVE codigo RLLAVE
    (79) incre -> . ID INCREASE
    (80) incre -> . ID DECREASE

    ID              shift and go to state 271

    incre                          shift and go to state 270

state 244

    (160) array_declaration -> VAR ID EQUAL LCORCHE capacity . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 272


state 245

    (95) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE . data_types arr_content
    (43) data_types -> . INT32
    (44) data_types -> . INT64
    (45) data_types -> . FLOAT32
    (46) data_types -> . FLOAT64
    (47) data_types -> . BYTE
    (48) data_types -> . WINT
    (49) data_types -> . WFLOAT
    (50) data_types -> . WSTRING
    (51) data_types -> . BOOL

    INT32           shift and go to state 212
    INT64           shift and go to state 213
    FLOAT32         shift and go to state 214
    FLOAT64         shift and go to state 215
    BYTE            shift and go to state 216
    WINT            shift and go to state 217
    WFLOAT          shift and go to state 218
    WSTRING         shift and go to state 219
    BOOL            shift and go to state 220

    data_types                     shift and go to state 273

state 246

    (159) array_declaration -> VAR ID LCORCHE capacity RCORCHE . data_types
    (43) data_types -> . INT32
    (44) data_types -> . INT64
    (45) data_types -> . FLOAT32
    (46) data_types -> . FLOAT64
    (47) data_types -> . BYTE
    (48) data_types -> . WINT
    (49) data_types -> . WFLOAT
    (50) data_types -> . WSTRING
    (51) data_types -> . BOOL

    INT32           shift and go to state 212
    INT64           shift and go to state 213
    FLOAT32         shift and go to state 214
    FLOAT64         shift and go to state 215
    BYTE            shift and go to state 216
    WINT            shift and go to state 217
    WFLOAT          shift and go to state 218
    WSTRING         shift and go to state 219
    BOOL            shift and go to state 220

    data_types                     shift and go to state 274

state 247

    (94) slice_declaration -> VAR ID LCORCHE RCORCHE data_types .

    COLON           reduce using rule 94 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    $end            reduce using rule 94 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    RLLAVE          reduce using rule 94 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    DEFAULT         reduce using rule 94 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    CASE            reduce using rule 94 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    RETURN          reduce using rule 94 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)


state 248

    (169) map_declaration -> VAR ID LCORCHE data_types RCORCHE . data_types
    (43) data_types -> . INT32
    (44) data_types -> . INT64
    (45) data_types -> . FLOAT32
    (46) data_types -> . FLOAT64
    (47) data_types -> . BYTE
    (48) data_types -> . WINT
    (49) data_types -> . WFLOAT
    (50) data_types -> . WSTRING
    (51) data_types -> . BOOL

    INT32           shift and go to state 212
    INT64           shift and go to state 213
    FLOAT32         shift and go to state 214
    FLOAT64         shift and go to state 215
    BYTE            shift and go to state 216
    WINT            shift and go to state 217
    WFLOAT          shift and go to state 218
    WSTRING         shift and go to state 219
    BOOL            shift and go to state 220

    data_types                     shift and go to state 275

state 249

    (128) asignaciones -> ID . POINTS valor
    (129) asignaciones -> ID . POINTS valor COMA asignaciones

    POINTS          shift and go to state 276


state 250

    (127) cStruct -> ID DEQUAL ID LLLAVE asignaciones . RLLAVE

    RLLAVE          shift and go to state 277


state 251

    (98) slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types . arr_content
    (63) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (64) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 279

    arr_content                    shift and go to state 278

state 252

    (99) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap RPAREN
    (100) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap COMA cap RPAREN

    RCORCHE         shift and go to state 280


state 253

    (114) funciones -> APPEND LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 281


state 254

    (113) funciones -> APPEND LPAREN ID COMA values . RPAREN

    RPAREN          shift and go to state 282


state 255

    (39) values -> INTEGER .

    RPAREN          reduce using rule 39 (values -> INTEGER .)
    POINTS          reduce using rule 39 (values -> INTEGER .)


state 256

    (40) values -> FLOAT .

    RPAREN          reduce using rule 40 (values -> FLOAT .)
    POINTS          reduce using rule 40 (values -> FLOAT .)


state 257

    (116) funciones -> COPY LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 283


state 258

    (117) funciones -> DELETE LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 284


state 259

    (120) SenIF -> IF comparison LLLAVE codigo RLLAVE .

    $end            reduce using rule 120 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 120 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 120 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 120 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 120 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)


state 260

    (121) SenIF -> IF TRUE LLLAVE codigo RLLAVE .

    $end            reduce using rule 121 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 121 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 121 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 121 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 121 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)


state 261

    (122) SenIF -> IF FALSE LLLAVE codigo RLLAVE .

    $end            reduce using rule 122 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 122 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 122 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 122 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 122 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)


state 262

    (126) variable -> ID .

    INT32           reduce using rule 126 (variable -> ID .)
    INT64           reduce using rule 126 (variable -> ID .)
    FLOAT32         reduce using rule 126 (variable -> ID .)
    FLOAT64         reduce using rule 126 (variable -> ID .)
    BYTE            reduce using rule 126 (variable -> ID .)
    WINT            reduce using rule 126 (variable -> ID .)
    WFLOAT          reduce using rule 126 (variable -> ID .)
    WSTRING         reduce using rule 126 (variable -> ID .)
    BOOL            reduce using rule 126 (variable -> ID .)


state 263

    (123) SenStruct -> TYPE ID STRUCT LLLAVE declaration . RLLAVE
    (125) declaration -> declaration . variable data_types
    (126) variable -> . ID

    RLLAVE          shift and go to state 285
    ID              shift and go to state 262

    variable                       shift and go to state 286

state 264

    (124) declaration -> variable . data_types
    (43) data_types -> . INT32
    (44) data_types -> . INT64
    (45) data_types -> . FLOAT32
    (46) data_types -> . FLOAT64
    (47) data_types -> . BYTE
    (48) data_types -> . WINT
    (49) data_types -> . WFLOAT
    (50) data_types -> . WSTRING
    (51) data_types -> . BOOL

    INT32           shift and go to state 212
    INT64           shift and go to state 213
    FLOAT32         shift and go to state 214
    FLOAT64         shift and go to state 215
    BYTE            shift and go to state 216
    WINT            shift and go to state 217
    WFLOAT          shift and go to state 218
    WSTRING         shift and go to state 219
    BOOL            shift and go to state 220

    data_types                     shift and go to state 287

state 265

    (154) switch_statement -> SWITCH ID LLLAVE cases RLLAVE .

    $end            reduce using rule 154 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RLLAVE          reduce using rule 154 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    DEFAULT         reduce using rule 154 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    CASE            reduce using rule 154 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RETURN          reduce using rule 154 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)


state 266

    (155) cases -> CASE values . POINTS codigo
    (156) cases -> CASE values . POINTS codigo more

    POINTS          shift and go to state 288


state 267

    (183) params -> ID data_types .
    (185) more_params -> ID data_types . COMA params

    RPAREN          reduce using rule 183 (params -> ID data_types .)
    COMA            shift and go to state 289


state 268

    (175) func_declaration -> FUNC ID LPAREN params RPAREN . data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> FUNC ID LPAREN params RPAREN . data_types LLLAVE RETURN return_value RLLAVE
    (43) data_types -> . INT32
    (44) data_types -> . INT64
    (45) data_types -> . FLOAT32
    (46) data_types -> . FLOAT64
    (47) data_types -> . BYTE
    (48) data_types -> . WINT
    (49) data_types -> . WFLOAT
    (50) data_types -> . WSTRING
    (51) data_types -> . BOOL

    INT32           shift and go to state 212
    INT64           shift and go to state 213
    FLOAT32         shift and go to state 214
    FLOAT64         shift and go to state 215
    BYTE            shift and go to state 216
    WINT            shift and go to state 217
    WFLOAT          shift and go to state 218
    WSTRING         shift and go to state 219
    BOOL            shift and go to state 220

    data_types                     shift and go to state 290

state 269

    (73) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenStruct
    (18) codigo -> . cStruct
    (19) codigo -> . switch_statement
    (20) codigo -> . array_declaration COLON
    (21) codigo -> . array_declaration
    (22) codigo -> . array_var COLON
    (23) codigo -> . array_var
    (24) codigo -> . array_assignment COLON
    (25) codigo -> . array_assignment
    (26) codigo -> . slice_declaration COLON
    (27) codigo -> . slice_declaration
    (28) codigo -> . slice_var COLON
    (29) codigo -> . slice_var
    (30) codigo -> . slice_assignment COLON
    (31) codigo -> . slice_assignment
    (32) codigo -> . map_declaration COLON
    (33) codigo -> . map_declaration
    (34) codigo -> . map_assignment COLON
    (35) codigo -> . map_assignment
    (36) codigo -> . func_declaration
    (37) codigo -> . main_func
    (186) impresion -> . PRINT LPAREN content RPAREN
    (74) scan_func -> . SCAN LPAREN POINTER RPAREN
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (75) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (76) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (77) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (81) decVar -> . decVarOne
    (82) decVar -> . VAR ID EQUAL INTEGER
    (83) decVar -> . VAR ID EQUAL ID
    (84) decVar -> . VAR ID EQUAL FLOAT
    (85) decVar -> . VAR ID EQUAL expression
    (86) decVar -> . VAR ID EQUAL logic_operation
    (87) decVar -> . VAR ID EQUAL comparison
    (88) decVar -> . VAR ID EQUAL STRING
    (89) decVar -> . ID DEQUAL STRING
    (90) decVar -> . ID DEQUAL FLOAT
    (91) decVar -> . ID DEQUAL expression
    (92) decVar -> . ID DEQUAL logic_operation
    (93) decVar -> . ID DEQUAL comparison
    (57) var_asignation -> . ID EQUAL any
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (120) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (121) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (122) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (123) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (127) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (154) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (159) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (160) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (164) array_var -> . ID LCORCHE index RCORCHE
    (168) array_assignment -> . array_var EQUAL something
    (94) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (95) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (96) slice_declaration -> . VAR ID EQUAL funM
    (97) slice_declaration -> . ID DEQUAL funM
    (98) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (104) slice_var -> . ID LCORCHE index_s RCORCHE
    (108) slice_assignment -> . slice_var EQUAL something_s
    (169) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (174) map_assignment -> . array_var EQUAL something
    (175) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (73) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (118) decVarOne -> . ID DEQUAL ID
    (119) decVarOne -> . ID DEQUAL INTEGER
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (170) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 25
    SCAN            shift and go to state 26
    FOR             shift and go to state 28
    VAR             shift and go to state 33
    ID              shift and go to state 34
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40
    IF              shift and go to state 41
    TYPE            shift and go to state 42
    SWITCH          shift and go to state 43
    FUNC            shift and go to state 44
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    NOT             shift and go to state 46

    codigo                         shift and go to state 291
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenStruct                      shift and go to state 12
    cStruct                        shift and go to state 13
    switch_statement               shift and go to state 14
    array_declaration              shift and go to state 15
    array_var                      shift and go to state 16
    array_assignment               shift and go to state 17
    slice_declaration              shift and go to state 18
    slice_var                      shift and go to state 19
    slice_assignment               shift and go to state 20
    map_declaration                shift and go to state 21
    map_assignment                 shift and go to state 22
    func_declaration               shift and go to state 23
    main_func                      shift and go to state 24
    something_ex                   shift and go to state 27
    decVarOne                      shift and go to state 29
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    data_structure                 shift and go to state 45
    map_var                        shift and go to state 47

state 270

    (78) cicloFor -> FOR decVarOne COLON comparison COLON incre . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 292


state 271

    (79) incre -> ID . INCREASE
    (80) incre -> ID . DECREASE

    INCREASE        shift and go to state 293
    DECREASE        shift and go to state 294


state 272

    (160) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE . data_types arr_content
    (43) data_types -> . INT32
    (44) data_types -> . INT64
    (45) data_types -> . FLOAT32
    (46) data_types -> . FLOAT64
    (47) data_types -> . BYTE
    (48) data_types -> . WINT
    (49) data_types -> . WFLOAT
    (50) data_types -> . WSTRING
    (51) data_types -> . BOOL

    INT32           shift and go to state 212
    INT64           shift and go to state 213
    FLOAT32         shift and go to state 214
    FLOAT64         shift and go to state 215
    BYTE            shift and go to state 216
    WINT            shift and go to state 217
    WFLOAT          shift and go to state 218
    WSTRING         shift and go to state 219
    BOOL            shift and go to state 220

    data_types                     shift and go to state 295

state 273

    (95) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types . arr_content
    (63) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (64) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 279

    arr_content                    shift and go to state 296

state 274

    (159) array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .

    COLON           reduce using rule 159 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    $end            reduce using rule 159 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RLLAVE          reduce using rule 159 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    DEFAULT         reduce using rule 159 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    CASE            reduce using rule 159 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RETURN          reduce using rule 159 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)


state 275

    (169) map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .

    COLON           reduce using rule 169 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    $end            reduce using rule 169 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    RLLAVE          reduce using rule 169 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    DEFAULT         reduce using rule 169 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    CASE            reduce using rule 169 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    RETURN          reduce using rule 169 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)


state 276

    (128) asignaciones -> ID POINTS . valor
    (129) asignaciones -> ID POINTS . valor COMA asignaciones
    (130) valor -> . ID
    (131) valor -> . INTEGER
    (132) valor -> . TRUE
    (133) valor -> . FALSE

    ID              shift and go to state 297
    INTEGER         shift and go to state 299
    TRUE            shift and go to state 300
    FALSE           shift and go to state 301

    valor                          shift and go to state 298

state 277

    (127) cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .

    $end            reduce using rule 127 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    RLLAVE          reduce using rule 127 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    DEFAULT         reduce using rule 127 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    CASE            reduce using rule 127 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    RETURN          reduce using rule 127 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)


state 278

    (98) slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .

    COLON           reduce using rule 98 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    $end            reduce using rule 98 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 98 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 98 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    CASE            reduce using rule 98 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RETURN          reduce using rule 98 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)


state 279

    (63) arr_content -> LLLAVE . items COMA more_items RLLAVE
    (64) arr_content -> LLLAVE . items RLLAVE
    (67) items -> . values
    (68) items -> . operations
    (38) values -> . STRING
    (39) values -> . INTEGER
    (40) values -> . FLOAT
    (41) values -> . TRUE
    (42) values -> . FALSE
    (52) operations -> . expression
    (53) operations -> . comparison
    (54) operations -> . logic_operation
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    STRING          shift and go to state 114
    INTEGER         shift and go to state 115
    FLOAT           shift and go to state 116
    TRUE            shift and go to state 117
    FALSE           shift and go to state 118
    ID              shift and go to state 305
    NOT             shift and go to state 46
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    items                          shift and go to state 302
    values                         shift and go to state 303
    operations                     shift and go to state 304
    expression                     shift and go to state 119
    comparison                     shift and go to state 120
    logic_operation                shift and go to state 121
    something_ex                   shift and go to state 27
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 280

    (99) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap RPAREN
    (100) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap COMA cap RPAREN
    (43) data_types -> . INT32
    (44) data_types -> . INT64
    (45) data_types -> . FLOAT32
    (46) data_types -> . FLOAT64
    (47) data_types -> . BYTE
    (48) data_types -> . WINT
    (49) data_types -> . WFLOAT
    (50) data_types -> . WSTRING
    (51) data_types -> . BOOL

    INT32           shift and go to state 212
    INT64           shift and go to state 213
    FLOAT32         shift and go to state 214
    FLOAT64         shift and go to state 215
    BYTE            shift and go to state 216
    WINT            shift and go to state 217
    WFLOAT          shift and go to state 218
    WSTRING         shift and go to state 219
    BOOL            shift and go to state 220

    data_types                     shift and go to state 306

state 281

    (114) funciones -> APPEND LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 114 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)


state 282

    (113) funciones -> APPEND LPAREN ID COMA values RPAREN .

    COLON           reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    $end            reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    GREATER         reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SMALLER         reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    GREATER_OR_EQUAL reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    EQUAL_COMPARE   reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    NOT_EQUAL       reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    PLUS            reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    TIMES           reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DIVIDE          reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    MINUS           reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RLLAVE          reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DEFAULT         reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    CASE            reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RETURN          reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RPAREN          reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    AND             reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    OR              reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    LLLAVE          reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RCORCHE         reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    COMA            reduce using rule 113 (funciones -> APPEND LPAREN ID COMA values RPAREN .)


state 283

    (116) funciones -> COPY LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 116 (funciones -> COPY LPAREN ID COMA ID RPAREN .)


state 284

    (117) funciones -> DELETE LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 117 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)


state 285

    (123) SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .

    $end            reduce using rule 123 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RLLAVE          reduce using rule 123 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    DEFAULT         reduce using rule 123 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    CASE            reduce using rule 123 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RETURN          reduce using rule 123 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)


state 286

    (125) declaration -> declaration variable . data_types
    (43) data_types -> . INT32
    (44) data_types -> . INT64
    (45) data_types -> . FLOAT32
    (46) data_types -> . FLOAT64
    (47) data_types -> . BYTE
    (48) data_types -> . WINT
    (49) data_types -> . WFLOAT
    (50) data_types -> . WSTRING
    (51) data_types -> . BOOL

    INT32           shift and go to state 212
    INT64           shift and go to state 213
    FLOAT32         shift and go to state 214
    FLOAT64         shift and go to state 215
    BYTE            shift and go to state 216
    WINT            shift and go to state 217
    WFLOAT          shift and go to state 218
    WSTRING         shift and go to state 219
    BOOL            shift and go to state 220

    data_types                     shift and go to state 307

state 287

    (124) declaration -> variable data_types .

    RLLAVE          reduce using rule 124 (declaration -> variable data_types .)
    ID              reduce using rule 124 (declaration -> variable data_types .)


state 288

    (155) cases -> CASE values POINTS . codigo
    (156) cases -> CASE values POINTS . codigo more
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenStruct
    (18) codigo -> . cStruct
    (19) codigo -> . switch_statement
    (20) codigo -> . array_declaration COLON
    (21) codigo -> . array_declaration
    (22) codigo -> . array_var COLON
    (23) codigo -> . array_var
    (24) codigo -> . array_assignment COLON
    (25) codigo -> . array_assignment
    (26) codigo -> . slice_declaration COLON
    (27) codigo -> . slice_declaration
    (28) codigo -> . slice_var COLON
    (29) codigo -> . slice_var
    (30) codigo -> . slice_assignment COLON
    (31) codigo -> . slice_assignment
    (32) codigo -> . map_declaration COLON
    (33) codigo -> . map_declaration
    (34) codigo -> . map_assignment COLON
    (35) codigo -> . map_assignment
    (36) codigo -> . func_declaration
    (37) codigo -> . main_func
    (186) impresion -> . PRINT LPAREN content RPAREN
    (74) scan_func -> . SCAN LPAREN POINTER RPAREN
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (75) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (76) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (77) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (81) decVar -> . decVarOne
    (82) decVar -> . VAR ID EQUAL INTEGER
    (83) decVar -> . VAR ID EQUAL ID
    (84) decVar -> . VAR ID EQUAL FLOAT
    (85) decVar -> . VAR ID EQUAL expression
    (86) decVar -> . VAR ID EQUAL logic_operation
    (87) decVar -> . VAR ID EQUAL comparison
    (88) decVar -> . VAR ID EQUAL STRING
    (89) decVar -> . ID DEQUAL STRING
    (90) decVar -> . ID DEQUAL FLOAT
    (91) decVar -> . ID DEQUAL expression
    (92) decVar -> . ID DEQUAL logic_operation
    (93) decVar -> . ID DEQUAL comparison
    (57) var_asignation -> . ID EQUAL any
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (120) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (121) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (122) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (123) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (127) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (154) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (159) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (160) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (164) array_var -> . ID LCORCHE index RCORCHE
    (168) array_assignment -> . array_var EQUAL something
    (94) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (95) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (96) slice_declaration -> . VAR ID EQUAL funM
    (97) slice_declaration -> . ID DEQUAL funM
    (98) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (104) slice_var -> . ID LCORCHE index_s RCORCHE
    (108) slice_assignment -> . slice_var EQUAL something_s
    (169) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (174) map_assignment -> . array_var EQUAL something
    (175) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (73) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (118) decVarOne -> . ID DEQUAL ID
    (119) decVarOne -> . ID DEQUAL INTEGER
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (170) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 25
    SCAN            shift and go to state 26
    FOR             shift and go to state 28
    VAR             shift and go to state 33
    ID              shift and go to state 34
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40
    IF              shift and go to state 41
    TYPE            shift and go to state 42
    SWITCH          shift and go to state 43
    FUNC            shift and go to state 44
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    NOT             shift and go to state 46

    codigo                         shift and go to state 308
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenStruct                      shift and go to state 12
    cStruct                        shift and go to state 13
    switch_statement               shift and go to state 14
    array_declaration              shift and go to state 15
    array_var                      shift and go to state 16
    array_assignment               shift and go to state 17
    slice_declaration              shift and go to state 18
    slice_var                      shift and go to state 19
    slice_assignment               shift and go to state 20
    map_declaration                shift and go to state 21
    map_assignment                 shift and go to state 22
    func_declaration               shift and go to state 23
    main_func                      shift and go to state 24
    something_ex                   shift and go to state 27
    decVarOne                      shift and go to state 29
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    data_structure                 shift and go to state 45
    map_var                        shift and go to state 47

state 289

    (185) more_params -> ID data_types COMA . params
    (183) params -> . ID data_types
    (184) params -> . more_params
    (185) more_params -> . ID data_types COMA params

    ID              shift and go to state 237

    params                         shift and go to state 309
    more_params                    shift and go to state 239

state 290

    (175) func_declaration -> FUNC ID LPAREN params RPAREN data_types . LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> FUNC ID LPAREN params RPAREN data_types . LLLAVE RETURN return_value RLLAVE

    LLLAVE          shift and go to state 310


state 291

    (73) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 311


state 292

    (78) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenStruct
    (18) codigo -> . cStruct
    (19) codigo -> . switch_statement
    (20) codigo -> . array_declaration COLON
    (21) codigo -> . array_declaration
    (22) codigo -> . array_var COLON
    (23) codigo -> . array_var
    (24) codigo -> . array_assignment COLON
    (25) codigo -> . array_assignment
    (26) codigo -> . slice_declaration COLON
    (27) codigo -> . slice_declaration
    (28) codigo -> . slice_var COLON
    (29) codigo -> . slice_var
    (30) codigo -> . slice_assignment COLON
    (31) codigo -> . slice_assignment
    (32) codigo -> . map_declaration COLON
    (33) codigo -> . map_declaration
    (34) codigo -> . map_assignment COLON
    (35) codigo -> . map_assignment
    (36) codigo -> . func_declaration
    (37) codigo -> . main_func
    (186) impresion -> . PRINT LPAREN content RPAREN
    (74) scan_func -> . SCAN LPAREN POINTER RPAREN
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (75) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (76) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (77) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (81) decVar -> . decVarOne
    (82) decVar -> . VAR ID EQUAL INTEGER
    (83) decVar -> . VAR ID EQUAL ID
    (84) decVar -> . VAR ID EQUAL FLOAT
    (85) decVar -> . VAR ID EQUAL expression
    (86) decVar -> . VAR ID EQUAL logic_operation
    (87) decVar -> . VAR ID EQUAL comparison
    (88) decVar -> . VAR ID EQUAL STRING
    (89) decVar -> . ID DEQUAL STRING
    (90) decVar -> . ID DEQUAL FLOAT
    (91) decVar -> . ID DEQUAL expression
    (92) decVar -> . ID DEQUAL logic_operation
    (93) decVar -> . ID DEQUAL comparison
    (57) var_asignation -> . ID EQUAL any
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (120) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (121) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (122) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (123) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (127) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (154) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (159) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (160) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (164) array_var -> . ID LCORCHE index RCORCHE
    (168) array_assignment -> . array_var EQUAL something
    (94) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (95) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (96) slice_declaration -> . VAR ID EQUAL funM
    (97) slice_declaration -> . ID DEQUAL funM
    (98) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (104) slice_var -> . ID LCORCHE index_s RCORCHE
    (108) slice_assignment -> . slice_var EQUAL something_s
    (169) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (174) map_assignment -> . array_var EQUAL something
    (175) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (73) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (118) decVarOne -> . ID DEQUAL ID
    (119) decVarOne -> . ID DEQUAL INTEGER
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (170) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 25
    SCAN            shift and go to state 26
    FOR             shift and go to state 28
    VAR             shift and go to state 33
    ID              shift and go to state 34
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40
    IF              shift and go to state 41
    TYPE            shift and go to state 42
    SWITCH          shift and go to state 43
    FUNC            shift and go to state 44
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    NOT             shift and go to state 46

    decVarOne                      shift and go to state 29
    comparison                     shift and go to state 6
    codigo                         shift and go to state 312
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenStruct                      shift and go to state 12
    cStruct                        shift and go to state 13
    switch_statement               shift and go to state 14
    array_declaration              shift and go to state 15
    array_var                      shift and go to state 16
    array_assignment               shift and go to state 17
    slice_declaration              shift and go to state 18
    slice_var                      shift and go to state 19
    slice_assignment               shift and go to state 20
    map_declaration                shift and go to state 21
    map_assignment                 shift and go to state 22
    func_declaration               shift and go to state 23
    main_func                      shift and go to state 24
    something_ex                   shift and go to state 27
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    data_structure                 shift and go to state 45
    map_var                        shift and go to state 47

state 293

    (79) incre -> ID INCREASE .

    LLLAVE          reduce using rule 79 (incre -> ID INCREASE .)


state 294

    (80) incre -> ID DECREASE .

    LLLAVE          reduce using rule 80 (incre -> ID DECREASE .)


state 295

    (160) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types . arr_content
    (63) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (64) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 279

    arr_content                    shift and go to state 313

state 296

    (95) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .

    COLON           reduce using rule 95 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    $end            reduce using rule 95 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 95 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 95 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    CASE            reduce using rule 95 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    RETURN          reduce using rule 95 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)


state 297

    (130) valor -> ID .

    COMA            reduce using rule 130 (valor -> ID .)
    RLLAVE          reduce using rule 130 (valor -> ID .)


state 298

    (128) asignaciones -> ID POINTS valor .
    (129) asignaciones -> ID POINTS valor . COMA asignaciones

    RLLAVE          reduce using rule 128 (asignaciones -> ID POINTS valor .)
    COMA            shift and go to state 314


state 299

    (131) valor -> INTEGER .

    COMA            reduce using rule 131 (valor -> INTEGER .)
    RLLAVE          reduce using rule 131 (valor -> INTEGER .)


state 300

    (132) valor -> TRUE .

    COMA            reduce using rule 132 (valor -> TRUE .)
    RLLAVE          reduce using rule 132 (valor -> TRUE .)


state 301

    (133) valor -> FALSE .

    COMA            reduce using rule 133 (valor -> FALSE .)
    RLLAVE          reduce using rule 133 (valor -> FALSE .)


state 302

    (63) arr_content -> LLLAVE items . COMA more_items RLLAVE
    (64) arr_content -> LLLAVE items . RLLAVE

    COMA            shift and go to state 315
    RLLAVE          shift and go to state 316


state 303

    (67) items -> values .

    COMA            reduce using rule 67 (items -> values .)
    RLLAVE          reduce using rule 67 (items -> values .)


state 304

    (68) items -> operations .

    COMA            reduce using rule 68 (items -> operations .)
    RLLAVE          reduce using rule 68 (items -> operations .)


state 305

    (196) something_ex -> ID .
    (135) value -> ID .
    (149) logic_value -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (170) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 135 (value -> ID .)
    COMA            reduce using rule 196 (something_ex -> ID .)
    RLLAVE          reduce using rule 196 (something_ex -> ID .)
    GREATER         reduce using rule 135 (value -> ID .)
    SMALLER         reduce using rule 135 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 135 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 135 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 135 (value -> ID .)
    NOT_EQUAL       reduce using rule 135 (value -> ID .)
    PLUS            reduce using rule 135 (value -> ID .)
    TIMES           reduce using rule 135 (value -> ID .)
    DIVIDE          reduce using rule 135 (value -> ID .)
    MINUS           reduce using rule 135 (value -> ID .)
    AND             reduce using rule 149 (logic_value -> ID .)
    OR              reduce using rule 149 (logic_value -> ID .)
    LCORCHE         shift and go to state 141

  ! GREATER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 196 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 196 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 196 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 196 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 196 (something_ex -> ID .) ]


state 306

    (99) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap RPAREN
    (100) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap COMA cap RPAREN

    COMA            shift and go to state 317


state 307

    (125) declaration -> declaration variable data_types .

    RLLAVE          reduce using rule 125 (declaration -> declaration variable data_types .)
    ID              reduce using rule 125 (declaration -> declaration variable data_types .)


state 308

    (155) cases -> CASE values POINTS codigo .
    (156) cases -> CASE values POINTS codigo . more
    (157) more -> . cases
    (158) more -> . DEFAULT POINTS codigo
    (155) cases -> . CASE values POINTS codigo
    (156) cases -> . CASE values POINTS codigo more

    RLLAVE          reduce using rule 155 (cases -> CASE values POINTS codigo .)
    DEFAULT         shift and go to state 320
    CASE            shift and go to state 236

    more                           shift and go to state 318
    cases                          shift and go to state 319

state 309

    (185) more_params -> ID data_types COMA params .

    RPAREN          reduce using rule 185 (more_params -> ID data_types COMA params .)


state 310

    (175) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE . codigo RETURN retorno RLLAVE
    (176) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE . RETURN return_value RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenStruct
    (18) codigo -> . cStruct
    (19) codigo -> . switch_statement
    (20) codigo -> . array_declaration COLON
    (21) codigo -> . array_declaration
    (22) codigo -> . array_var COLON
    (23) codigo -> . array_var
    (24) codigo -> . array_assignment COLON
    (25) codigo -> . array_assignment
    (26) codigo -> . slice_declaration COLON
    (27) codigo -> . slice_declaration
    (28) codigo -> . slice_var COLON
    (29) codigo -> . slice_var
    (30) codigo -> . slice_assignment COLON
    (31) codigo -> . slice_assignment
    (32) codigo -> . map_declaration COLON
    (33) codigo -> . map_declaration
    (34) codigo -> . map_assignment COLON
    (35) codigo -> . map_assignment
    (36) codigo -> . func_declaration
    (37) codigo -> . main_func
    (186) impresion -> . PRINT LPAREN content RPAREN
    (74) scan_func -> . SCAN LPAREN POINTER RPAREN
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (75) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (76) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (77) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (81) decVar -> . decVarOne
    (82) decVar -> . VAR ID EQUAL INTEGER
    (83) decVar -> . VAR ID EQUAL ID
    (84) decVar -> . VAR ID EQUAL FLOAT
    (85) decVar -> . VAR ID EQUAL expression
    (86) decVar -> . VAR ID EQUAL logic_operation
    (87) decVar -> . VAR ID EQUAL comparison
    (88) decVar -> . VAR ID EQUAL STRING
    (89) decVar -> . ID DEQUAL STRING
    (90) decVar -> . ID DEQUAL FLOAT
    (91) decVar -> . ID DEQUAL expression
    (92) decVar -> . ID DEQUAL logic_operation
    (93) decVar -> . ID DEQUAL comparison
    (57) var_asignation -> . ID EQUAL any
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (120) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (121) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (122) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (123) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (127) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (154) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (159) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (160) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (164) array_var -> . ID LCORCHE index RCORCHE
    (168) array_assignment -> . array_var EQUAL something
    (94) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (95) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (96) slice_declaration -> . VAR ID EQUAL funM
    (97) slice_declaration -> . ID DEQUAL funM
    (98) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (104) slice_var -> . ID LCORCHE index_s RCORCHE
    (108) slice_assignment -> . slice_var EQUAL something_s
    (169) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (174) map_assignment -> . array_var EQUAL something
    (175) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (73) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (118) decVarOne -> . ID DEQUAL ID
    (119) decVarOne -> . ID DEQUAL INTEGER
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (170) map_var -> . ID LCORCHE key RCORCHE

    RETURN          shift and go to state 322
    PRINT           shift and go to state 25
    SCAN            shift and go to state 26
    FOR             shift and go to state 28
    VAR             shift and go to state 33
    ID              shift and go to state 34
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40
    IF              shift and go to state 41
    TYPE            shift and go to state 42
    SWITCH          shift and go to state 43
    FUNC            shift and go to state 44
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    NOT             shift and go to state 46

    codigo                         shift and go to state 321
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenStruct                      shift and go to state 12
    cStruct                        shift and go to state 13
    switch_statement               shift and go to state 14
    array_declaration              shift and go to state 15
    array_var                      shift and go to state 16
    array_assignment               shift and go to state 17
    slice_declaration              shift and go to state 18
    slice_var                      shift and go to state 19
    slice_assignment               shift and go to state 20
    map_declaration                shift and go to state 21
    map_assignment                 shift and go to state 22
    func_declaration               shift and go to state 23
    main_func                      shift and go to state 24
    something_ex                   shift and go to state 27
    decVarOne                      shift and go to state 29
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    data_structure                 shift and go to state 45
    map_var                        shift and go to state 47

state 311

    (73) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .

    $end            reduce using rule 73 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 73 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 73 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 73 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 73 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)


state 312

    (78) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 323


state 313

    (160) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .

    COLON           reduce using rule 160 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    $end            reduce using rule 160 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 160 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 160 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    CASE            reduce using rule 160 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RETURN          reduce using rule 160 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)


state 314

    (129) asignaciones -> ID POINTS valor COMA . asignaciones
    (128) asignaciones -> . ID POINTS valor
    (129) asignaciones -> . ID POINTS valor COMA asignaciones

    ID              shift and go to state 249

    asignaciones                   shift and go to state 324

state 315

    (63) arr_content -> LLLAVE items COMA . more_items RLLAVE
    (65) more_items -> . items COMA more_items
    (66) more_items -> . items
    (67) items -> . values
    (68) items -> . operations
    (38) values -> . STRING
    (39) values -> . INTEGER
    (40) values -> . FLOAT
    (41) values -> . TRUE
    (42) values -> . FALSE
    (52) operations -> . expression
    (53) operations -> . comparison
    (54) operations -> . logic_operation
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    STRING          shift and go to state 114
    INTEGER         shift and go to state 115
    FLOAT           shift and go to state 116
    TRUE            shift and go to state 117
    FALSE           shift and go to state 118
    ID              shift and go to state 305
    NOT             shift and go to state 46
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    items                          shift and go to state 325
    more_items                     shift and go to state 326
    values                         shift and go to state 303
    operations                     shift and go to state 304
    expression                     shift and go to state 119
    comparison                     shift and go to state 120
    logic_operation                shift and go to state 121
    something_ex                   shift and go to state 27
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 316

    (64) arr_content -> LLLAVE items RLLAVE .

    COLON           reduce using rule 64 (arr_content -> LLLAVE items RLLAVE .)
    $end            reduce using rule 64 (arr_content -> LLLAVE items RLLAVE .)
    RLLAVE          reduce using rule 64 (arr_content -> LLLAVE items RLLAVE .)
    DEFAULT         reduce using rule 64 (arr_content -> LLLAVE items RLLAVE .)
    CASE            reduce using rule 64 (arr_content -> LLLAVE items RLLAVE .)
    RETURN          reduce using rule 64 (arr_content -> LLLAVE items RLLAVE .)


state 317

    (99) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap RPAREN
    (100) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap COMA cap RPAREN
    (101) cap -> . INTEGER
    (102) cap -> . ID
    (103) cap -> . expression
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    INTEGER         shift and go to state 328
    ID              shift and go to state 329
    FLOAT           shift and go to state 36
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    cap                            shift and go to state 327
    expression                     shift and go to state 330
    something_ex                   shift and go to state 27
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 318

    (156) cases -> CASE values POINTS codigo more .

    RLLAVE          reduce using rule 156 (cases -> CASE values POINTS codigo more .)


state 319

    (157) more -> cases .

    RLLAVE          reduce using rule 157 (more -> cases .)


state 320

    (158) more -> DEFAULT . POINTS codigo

    POINTS          shift and go to state 331


state 321

    (175) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo . RETURN retorno RLLAVE

    RETURN          shift and go to state 332


state 322

    (176) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN . return_value RLLAVE
    (177) return_value -> . retorno COLON
    (178) return_value -> . retorno
    (179) retorno -> . ID
    (180) retorno -> . values
    (181) retorno -> . operations
    (182) retorno -> . data_structure
    (38) values -> . STRING
    (39) values -> . INTEGER
    (40) values -> . FLOAT
    (41) values -> . TRUE
    (42) values -> . FALSE
    (52) operations -> . expression
    (53) operations -> . comparison
    (54) operations -> . logic_operation
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN

    ID              shift and go to state 333
    STRING          shift and go to state 114
    INTEGER         shift and go to state 115
    FLOAT           shift and go to state 116
    TRUE            shift and go to state 117
    FALSE           shift and go to state 118
    NOT             shift and go to state 46
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    return_value                   shift and go to state 334
    retorno                        shift and go to state 335
    values                         shift and go to state 336
    operations                     shift and go to state 337
    data_structure                 shift and go to state 338
    expression                     shift and go to state 119
    comparison                     shift and go to state 120
    logic_operation                shift and go to state 121
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47
    something_ex                   shift and go to state 27
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    funciones                      shift and go to state 84

state 323

    (78) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .

    $end            reduce using rule 78 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 78 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 78 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 78 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 78 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)


state 324

    (129) asignaciones -> ID POINTS valor COMA asignaciones .

    RLLAVE          reduce using rule 129 (asignaciones -> ID POINTS valor COMA asignaciones .)


state 325

    (65) more_items -> items . COMA more_items
    (66) more_items -> items .

    COMA            shift and go to state 339
    RLLAVE          reduce using rule 66 (more_items -> items .)


state 326

    (63) arr_content -> LLLAVE items COMA more_items . RLLAVE

    RLLAVE          shift and go to state 340


state 327

    (99) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . RPAREN
    (100) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . COMA cap RPAREN

    RPAREN          shift and go to state 342
    COMA            shift and go to state 341


state 328

    (101) cap -> INTEGER .
    (197) something_ex -> INTEGER .

  ! reduce/reduce conflict for RPAREN resolved using rule 101 (cap -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 101 (cap -> INTEGER .)
    RPAREN          reduce using rule 101 (cap -> INTEGER .)
    COMA            reduce using rule 101 (cap -> INTEGER .)
    GREATER         reduce using rule 197 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 197 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 197 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 197 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 197 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 197 (something_ex -> INTEGER .)
    PLUS            reduce using rule 197 (something_ex -> INTEGER .)
    TIMES           reduce using rule 197 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 197 (something_ex -> INTEGER .)
    MINUS           reduce using rule 197 (something_ex -> INTEGER .)

  ! RPAREN          [ reduce using rule 197 (something_ex -> INTEGER .) ]
  ! COMA            [ reduce using rule 197 (something_ex -> INTEGER .) ]


state 329

    (102) cap -> ID .
    (196) something_ex -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (170) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for RPAREN resolved using rule 102 (cap -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 102 (cap -> ID .)
    RPAREN          reduce using rule 102 (cap -> ID .)
    COMA            reduce using rule 102 (cap -> ID .)
    GREATER         reduce using rule 196 (something_ex -> ID .)
    SMALLER         reduce using rule 196 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 196 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 196 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 196 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 196 (something_ex -> ID .)
    PLUS            reduce using rule 196 (something_ex -> ID .)
    TIMES           reduce using rule 196 (something_ex -> ID .)
    DIVIDE          reduce using rule 196 (something_ex -> ID .)
    MINUS           reduce using rule 196 (something_ex -> ID .)
    LCORCHE         shift and go to state 141

  ! RPAREN          [ reduce using rule 196 (something_ex -> ID .) ]
  ! COMA            [ reduce using rule 196 (something_ex -> ID .) ]


state 330

    (103) cap -> expression .

    RPAREN          reduce using rule 103 (cap -> expression .)
    COMA            reduce using rule 103 (cap -> expression .)


state 331

    (158) more -> DEFAULT POINTS . codigo
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenStruct
    (18) codigo -> . cStruct
    (19) codigo -> . switch_statement
    (20) codigo -> . array_declaration COLON
    (21) codigo -> . array_declaration
    (22) codigo -> . array_var COLON
    (23) codigo -> . array_var
    (24) codigo -> . array_assignment COLON
    (25) codigo -> . array_assignment
    (26) codigo -> . slice_declaration COLON
    (27) codigo -> . slice_declaration
    (28) codigo -> . slice_var COLON
    (29) codigo -> . slice_var
    (30) codigo -> . slice_assignment COLON
    (31) codigo -> . slice_assignment
    (32) codigo -> . map_declaration COLON
    (33) codigo -> . map_declaration
    (34) codigo -> . map_assignment COLON
    (35) codigo -> . map_assignment
    (36) codigo -> . func_declaration
    (37) codigo -> . main_func
    (186) impresion -> . PRINT LPAREN content RPAREN
    (74) scan_func -> . SCAN LPAREN POINTER RPAREN
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (75) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (76) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (77) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (81) decVar -> . decVarOne
    (82) decVar -> . VAR ID EQUAL INTEGER
    (83) decVar -> . VAR ID EQUAL ID
    (84) decVar -> . VAR ID EQUAL FLOAT
    (85) decVar -> . VAR ID EQUAL expression
    (86) decVar -> . VAR ID EQUAL logic_operation
    (87) decVar -> . VAR ID EQUAL comparison
    (88) decVar -> . VAR ID EQUAL STRING
    (89) decVar -> . ID DEQUAL STRING
    (90) decVar -> . ID DEQUAL FLOAT
    (91) decVar -> . ID DEQUAL expression
    (92) decVar -> . ID DEQUAL logic_operation
    (93) decVar -> . ID DEQUAL comparison
    (57) var_asignation -> . ID EQUAL any
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (120) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (121) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (122) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (123) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (127) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (154) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (159) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (160) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (164) array_var -> . ID LCORCHE index RCORCHE
    (168) array_assignment -> . array_var EQUAL something
    (94) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (95) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (96) slice_declaration -> . VAR ID EQUAL funM
    (97) slice_declaration -> . ID DEQUAL funM
    (98) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (104) slice_var -> . ID LCORCHE index_s RCORCHE
    (108) slice_assignment -> . slice_var EQUAL something_s
    (169) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (174) map_assignment -> . array_var EQUAL something
    (175) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (176) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (73) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (118) decVarOne -> . ID DEQUAL ID
    (119) decVarOne -> . ID DEQUAL INTEGER
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (170) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 25
    SCAN            shift and go to state 26
    FOR             shift and go to state 28
    VAR             shift and go to state 33
    ID              shift and go to state 34
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40
    IF              shift and go to state 41
    TYPE            shift and go to state 42
    SWITCH          shift and go to state 43
    FUNC            shift and go to state 44
    INTEGER         shift and go to state 35
    FLOAT           shift and go to state 36
    NOT             shift and go to state 46

    codigo                         shift and go to state 343
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenStruct                      shift and go to state 12
    cStruct                        shift and go to state 13
    switch_statement               shift and go to state 14
    array_declaration              shift and go to state 15
    array_var                      shift and go to state 16
    array_assignment               shift and go to state 17
    slice_declaration              shift and go to state 18
    slice_var                      shift and go to state 19
    slice_assignment               shift and go to state 20
    map_declaration                shift and go to state 21
    map_assignment                 shift and go to state 22
    func_declaration               shift and go to state 23
    main_func                      shift and go to state 24
    something_ex                   shift and go to state 27
    decVarOne                      shift and go to state 29
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    data_structure                 shift and go to state 45
    map_var                        shift and go to state 47

state 332

    (175) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN . retorno RLLAVE
    (179) retorno -> . ID
    (180) retorno -> . values
    (181) retorno -> . operations
    (182) retorno -> . data_structure
    (38) values -> . STRING
    (39) values -> . INTEGER
    (40) values -> . FLOAT
    (41) values -> . TRUE
    (42) values -> . FALSE
    (52) operations -> . expression
    (53) operations -> . comparison
    (54) operations -> . logic_operation
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN

    ID              shift and go to state 333
    STRING          shift and go to state 114
    INTEGER         shift and go to state 115
    FLOAT           shift and go to state 116
    TRUE            shift and go to state 117
    FALSE           shift and go to state 118
    NOT             shift and go to state 46
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    retorno                        shift and go to state 344
    values                         shift and go to state 336
    operations                     shift and go to state 337
    data_structure                 shift and go to state 338
    expression                     shift and go to state 119
    comparison                     shift and go to state 120
    logic_operation                shift and go to state 121
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47
    something_ex                   shift and go to state 27
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    funciones                      shift and go to state 84

state 333

    (179) retorno -> ID .
    (164) array_var -> ID . LCORCHE index RCORCHE
    (170) map_var -> ID . LCORCHE key RCORCHE
    (196) something_ex -> ID .
    (135) value -> ID .
    (149) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 179 (retorno -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 179 (retorno -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 135 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 135 (value -> ID .)
    COLON           reduce using rule 179 (retorno -> ID .)
    RLLAVE          reduce using rule 179 (retorno -> ID .)
    LCORCHE         shift and go to state 141
    GREATER         reduce using rule 135 (value -> ID .)
    SMALLER         reduce using rule 135 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 135 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 135 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 135 (value -> ID .)
    NOT_EQUAL       reduce using rule 135 (value -> ID .)
    PLUS            reduce using rule 135 (value -> ID .)
    TIMES           reduce using rule 135 (value -> ID .)
    DIVIDE          reduce using rule 135 (value -> ID .)
    MINUS           reduce using rule 135 (value -> ID .)
    AND             reduce using rule 149 (logic_value -> ID .)
    OR              reduce using rule 149 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 196 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 196 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 196 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 196 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 196 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 196 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 196 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 196 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 196 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 196 (something_ex -> ID .) ]


state 334

    (176) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value . RLLAVE

    RLLAVE          shift and go to state 345


state 335

    (177) return_value -> retorno . COLON
    (178) return_value -> retorno .

    COLON           shift and go to state 346
    RLLAVE          reduce using rule 178 (return_value -> retorno .)


state 336

    (180) retorno -> values .

    COLON           reduce using rule 180 (retorno -> values .)
    RLLAVE          reduce using rule 180 (retorno -> values .)


state 337

    (181) retorno -> operations .

    COLON           reduce using rule 181 (retorno -> operations .)
    RLLAVE          reduce using rule 181 (retorno -> operations .)


state 338

    (182) retorno -> data_structure .
    (199) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 182 (retorno -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 182 (retorno -> data_structure .)
    COLON           reduce using rule 182 (retorno -> data_structure .)
    RLLAVE          reduce using rule 182 (retorno -> data_structure .)
    GREATER         reduce using rule 199 (something_ex -> data_structure .)
    SMALLER         reduce using rule 199 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 199 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 199 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 199 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 199 (something_ex -> data_structure .)
    PLUS            reduce using rule 199 (something_ex -> data_structure .)
    TIMES           reduce using rule 199 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 199 (something_ex -> data_structure .)
    MINUS           reduce using rule 199 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 199 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 199 (something_ex -> data_structure .) ]


state 339

    (65) more_items -> items COMA . more_items
    (65) more_items -> . items COMA more_items
    (66) more_items -> . items
    (67) items -> . values
    (68) items -> . operations
    (38) values -> . STRING
    (39) values -> . INTEGER
    (40) values -> . FLOAT
    (41) values -> . TRUE
    (42) values -> . FALSE
    (52) operations -> . expression
    (53) operations -> . comparison
    (54) operations -> . logic_operation
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (134) comparison -> . value op value
    (143) logic_operation -> . logic_value logic_recu
    (144) logic_operation -> . negation
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (135) value -> . ID
    (136) value -> . expression
    (147) logic_value -> . negation
    (148) logic_value -> . comparison
    (149) logic_value -> . ID
    (150) negation -> . NOT comparison
    (151) negation -> . NOT ID
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    STRING          shift and go to state 114
    INTEGER         shift and go to state 115
    FLOAT           shift and go to state 116
    TRUE            shift and go to state 117
    FALSE           shift and go to state 118
    ID              shift and go to state 305
    NOT             shift and go to state 46
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    items                          shift and go to state 325
    more_items                     shift and go to state 347
    values                         shift and go to state 303
    operations                     shift and go to state 304
    expression                     shift and go to state 119
    comparison                     shift and go to state 120
    logic_operation                shift and go to state 121
    something_ex                   shift and go to state 27
    value                          shift and go to state 30
    logic_value                    shift and go to state 31
    negation                       shift and go to state 32
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 340

    (63) arr_content -> LLLAVE items COMA more_items RLLAVE .

    COLON           reduce using rule 63 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    $end            reduce using rule 63 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RLLAVE          reduce using rule 63 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    DEFAULT         reduce using rule 63 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    CASE            reduce using rule 63 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RETURN          reduce using rule 63 (arr_content -> LLLAVE items COMA more_items RLLAVE .)


state 341

    (100) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA . cap RPAREN
    (101) cap -> . INTEGER
    (102) cap -> . ID
    (103) cap -> . expression
    (192) expression -> . something_ex
    (193) expression -> . something_ex adicionaEx
    (196) something_ex -> . ID
    (197) something_ex -> . INTEGER
    (198) something_ex -> . FLOAT
    (199) something_ex -> . data_structure
    (200) something_ex -> . funciones
    (55) data_structure -> . array_var
    (56) data_structure -> . map_var
    (113) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (114) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (115) funciones -> . LEN LPAREN ID RPAREN
    (116) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (117) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (164) array_var -> . ID LCORCHE index RCORCHE
    (170) map_var -> . ID LCORCHE key RCORCHE

    INTEGER         shift and go to state 328
    ID              shift and go to state 329
    FLOAT           shift and go to state 36
    APPEND          shift and go to state 37
    LEN             shift and go to state 38
    COPY            shift and go to state 39
    DELETE          shift and go to state 40

    cap                            shift and go to state 348
    expression                     shift and go to state 330
    something_ex                   shift and go to state 27
    data_structure                 shift and go to state 45
    funciones                      shift and go to state 84
    array_var                      shift and go to state 85
    map_var                        shift and go to state 47

state 342

    (99) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .

    COLON           reduce using rule 99 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    $end            reduce using rule 99 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RLLAVE          reduce using rule 99 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    DEFAULT         reduce using rule 99 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    CASE            reduce using rule 99 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RETURN          reduce using rule 99 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)


state 343

    (158) more -> DEFAULT POINTS codigo .

    RLLAVE          reduce using rule 158 (more -> DEFAULT POINTS codigo .)


state 344

    (175) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno . RLLAVE

    RLLAVE          shift and go to state 349


state 345

    (176) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .

    $end            reduce using rule 176 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    RLLAVE          reduce using rule 176 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    DEFAULT         reduce using rule 176 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    CASE            reduce using rule 176 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    RETURN          reduce using rule 176 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)


state 346

    (177) return_value -> retorno COLON .

    RLLAVE          reduce using rule 177 (return_value -> retorno COLON .)


state 347

    (65) more_items -> items COMA more_items .

    RLLAVE          reduce using rule 65 (more_items -> items COMA more_items .)


state 348

    (100) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap . RPAREN

    RPAREN          shift and go to state 350


state 349

    (175) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .

    $end            reduce using rule 175 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    RLLAVE          reduce using rule 175 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    DEFAULT         reduce using rule 175 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    CASE            reduce using rule 175 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    RETURN          reduce using rule 175 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)


state 350

    (100) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .

    COLON           reduce using rule 100 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    $end            reduce using rule 100 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RLLAVE          reduce using rule 100 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    DEFAULT         reduce using rule 100 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    CASE            reduce using rule 100 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RETURN          reduce using rule 100 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COLON in state 10 resolved as shift
WARNING: shift/reduce conflict for COLON in state 16 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 27 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 27 resolved as shift
WARNING: shift/reduce conflict for GREATER_OR_EQUAL in state 27 resolved as shift
WARNING: shift/reduce conflict for SMALLER_OR_EQUAL in state 27 resolved as shift
WARNING: shift/reduce conflict for EQUAL_COMPARE in state 27 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 27 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 27 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 27 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 27 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 27 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 134 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 134 resolved as shift
WARNING: shift/reduce conflict for GREATER_OR_EQUAL in state 134 resolved as shift
WARNING: shift/reduce conflict for SMALLER_OR_EQUAL in state 134 resolved as shift
WARNING: shift/reduce conflict for EQUAL_COMPARE in state 134 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 134 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 134 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 134 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 134 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 134 resolved as shift
WARNING: reduce/reduce conflict in state 10 resolved using rule (codigo -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 10
WARNING: reduce/reduce conflict in state 16 resolved using rule (codigo -> array_var)
WARNING: rejected rule (data_structure -> array_var) in state 16
WARNING: reduce/reduce conflict in state 34 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 34
WARNING: reduce/reduce conflict in state 82 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 82
WARNING: reduce/reduce conflict in state 102 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 102
WARNING: reduce/reduce conflict in state 108 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 108
WARNING: reduce/reduce conflict in state 109 resolved using rule (array_assignment -> array_var EQUAL something)
WARNING: rejected rule (map_assignment -> array_var EQUAL something) in state 109
WARNING: reduce/reduce conflict in state 110 resolved using rule (something -> ID)
WARNING: rejected rule (something_ex -> ID) in state 110
WARNING: reduce/reduce conflict in state 110 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 110
WARNING: reduce/reduce conflict in state 111 resolved using rule (something -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 111
WARNING: reduce/reduce conflict in state 115 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 115
WARNING: reduce/reduce conflict in state 116 resolved using rule (values -> FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 116
WARNING: reduce/reduce conflict in state 123 resolved using rule (something_s -> ID)
WARNING: rejected rule (something_ex -> ID) in state 123
WARNING: reduce/reduce conflict in state 123 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 123
WARNING: reduce/reduce conflict in state 124 resolved using rule (data_structure -> array_var)
WARNING: rejected rule (something_s -> array_var) in state 124
WARNING: reduce/reduce conflict in state 130 resolved using rule (content -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 130
WARNING: reduce/reduce conflict in state 131 resolved using rule (content -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 131
WARNING: reduce/reduce conflict in state 132 resolved using rule (content -> ID)
WARNING: rejected rule (something_ex -> ID) in state 132
WARNING: reduce/reduce conflict in state 132 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 132
WARNING: reduce/reduce conflict in state 146 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 146
WARNING: reduce/reduce conflict in state 149 resolved using rule (decVarOne -> ID DEQUAL ID)
WARNING: rejected rule (something_ex -> ID) in state 149
WARNING: reduce/reduce conflict in state 149 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 149
WARNING: reduce/reduce conflict in state 151 resolved using rule (decVar -> ID DEQUAL FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 151
WARNING: reduce/reduce conflict in state 157 resolved using rule (decVarOne -> ID DEQUAL INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 157
WARNING: reduce/reduce conflict in state 159 resolved using rule (any -> ID)
WARNING: rejected rule (something_ex -> ID) in state 159
WARNING: reduce/reduce conflict in state 159 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 159
WARNING: reduce/reduce conflict in state 163 resolved using rule (any -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 163
WARNING: reduce/reduce conflict in state 164 resolved using rule (any -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 164
WARNING: reduce/reduce conflict in state 165 resolved using rule (index_s -> ID)
WARNING: rejected rule (index -> ID) in state 165
WARNING: reduce/reduce conflict in state 165 resolved using rule (index_s -> ID)
WARNING: rejected rule (key -> ID) in state 165
WARNING: reduce/reduce conflict in state 165 resolved using rule (index_s -> ID)
WARNING: rejected rule (something_ex -> ID) in state 165
WARNING: reduce/reduce conflict in state 165 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 165
WARNING: reduce/reduce conflict in state 169 resolved using rule (index_s -> INTEGER)
WARNING: rejected rule (index -> INTEGER) in state 169
WARNING: reduce/reduce conflict in state 169 resolved using rule (values -> INTEGER)
WARNING: rejected rule (index_s -> INTEGER) in state 169
WARNING: reduce/reduce conflict in state 169 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 169
WARNING: reduce/reduce conflict in state 170 resolved using rule (index_s -> expression)
WARNING: rejected rule (index -> expression) in state 170
WARNING: reduce/reduce conflict in state 170 resolved using rule (operations -> expression)
WARNING: rejected rule (index_s -> expression) in state 170
WARNING: reduce/reduce conflict in state 193 resolved using rule (index -> ID)
WARNING: rejected rule (key -> ID) in state 193
WARNING: reduce/reduce conflict in state 193 resolved using rule (index -> ID)
WARNING: rejected rule (something_ex -> ID) in state 193
WARNING: reduce/reduce conflict in state 193 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 193
WARNING: reduce/reduce conflict in state 194 resolved using rule (values -> INTEGER)
WARNING: rejected rule (index -> INTEGER) in state 194
WARNING: reduce/reduce conflict in state 194 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 194
WARNING: reduce/reduce conflict in state 195 resolved using rule (operations -> expression)
WARNING: rejected rule (index -> expression) in state 195
WARNING: reduce/reduce conflict in state 197 resolved using rule (decVar -> VAR ID EQUAL ID)
WARNING: rejected rule (something_ex -> ID) in state 197
WARNING: reduce/reduce conflict in state 197 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 197
WARNING: reduce/reduce conflict in state 198 resolved using rule (decVar -> VAR ID EQUAL INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 198
WARNING: reduce/reduce conflict in state 199 resolved using rule (decVar -> VAR ID EQUAL FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 199
WARNING: reduce/reduce conflict in state 206 resolved using rule (capacity -> ID)
WARNING: rejected rule (something_ex -> ID) in state 206
WARNING: reduce/reduce conflict in state 210 resolved using rule (capacity -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 210
WARNING: reduce/reduce conflict in state 305 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 305
WARNING: reduce/reduce conflict in state 328 resolved using rule (cap -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 328
WARNING: reduce/reduce conflict in state 329 resolved using rule (cap -> ID)
WARNING: rejected rule (something_ex -> ID) in state 329
WARNING: reduce/reduce conflict in state 333 resolved using rule (retorno -> ID)
WARNING: rejected rule (something_ex -> ID) in state 333
WARNING: reduce/reduce conflict in state 333 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 333
WARNING: reduce/reduce conflict in state 338 resolved using rule (retorno -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 338
WARNING: Rule (map_assignment -> array_var EQUAL something) is never reduced
WARNING: Rule (something_s -> array_var) is never reduced
WARNING: Rule (key -> ID) is never reduced
WARNING: Rule (index -> INTEGER) is never reduced
WARNING: Rule (index_s -> INTEGER) is never reduced
WARNING: Rule (index -> expression) is never reduced
WARNING: Rule (index_s -> expression) is never reduced
