Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    CAP
    CASE
    COMMENT
    CONST
    ELSE
    FALSE
    FUNC
    INTERFACE
    JOIN
    MAIN
    MAP
    MOD
    MULTI_COMMENT
    PACKAGE
    POINTER
    SCAN
    SWITCH
    TRUE

Grammar

Rule 0     S' -> codigo
Rule 1     codigo -> impresion
Rule 2     codigo -> expression
Rule 3     codigo -> cicloFor
Rule 4     codigo -> comparison
Rule 5     codigo -> logic_operation
Rule 6     codigo -> decVar
Rule 7     codigo -> funciones
Rule 8     codigo -> agrupaciones
Rule 9     codigo -> SenIF
Rule 10    codigo -> SenStruct
Rule 11    cicloFor -> FOR LLLAVE codigo RLLAVE
Rule 12    cicloFor -> FOR comparison LLLAVE codigo RLLAVE
Rule 13    cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE
Rule 14    cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
Rule 15    incre -> ID INCREASE
Rule 16    incre -> ID DECREASE
Rule 17    decVar -> decVarOne
Rule 18    decVar -> VAR ID EQUAL INTEGER
Rule 19    decVar -> VAR ID EQUAL ID
Rule 20    decVar -> VAR ID EQUAL FLOAT
Rule 21    decVar -> VAR ID EQUAL expression
Rule 22    decVar -> sliceC
Rule 23    decVar -> VAR ID EQUAL STRING
Rule 24    decVar -> ID DEQUAL STRING
Rule 25    decVar -> ID DEQUAL FLOAT
Rule 26    sliceC -> VAR ID LCORCHE RCORCHE type
Rule 27    sliceC -> ID DEQUAL funM
Rule 28    sliceC -> ID DEQUAL LCORCHE RCORCHE type agrupaciones
Rule 29    funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER RPAREN
Rule 30    funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER COMA INTEGER RPAREN
Rule 31    type -> INT32
Rule 32    type -> INT64
Rule 33    type -> FLOAT32
Rule 34    type -> FLOAT64
Rule 35    type -> BYTE
Rule 36    type -> WINT
Rule 37    type -> WFLOAT
Rule 38    type -> WSTRING
Rule 39    agrupaciones -> LLLAVE INTEGER RLLAVE
Rule 40    agrupaciones -> LLLAVE INTEGER enteros RLLAVE
Rule 41    agrupaciones -> LLLAVE FLOAT RLLAVE
Rule 42    agrupaciones -> LLLAVE FLOAT flotantes RLLAVE
Rule 43    agrupaciones -> LLLAVE STRING RLLAVE
Rule 44    agrupaciones -> LLLAVE STRING palabras RLLAVE
Rule 45    enteros -> COMA INTEGER
Rule 46    enteros -> COMA INTEGER enteros
Rule 47    flotantes -> COMA FLOAT
Rule 48    flotantes -> COMA FLOAT flotantes
Rule 49    palabras -> COMA STRING
Rule 50    palabras -> COMA STRING palabras
Rule 51    funciones -> APPEND LPAREN ID COMA INTEGER RPAREN
Rule 52    funciones -> APPEND LPAREN ID COMA FLOAT RPAREN
Rule 53    funciones -> APPEND LPAREN ID COMA STRING RPAREN
Rule 54    funciones -> APPEND LPAREN ID COMA ID RPAREN
Rule 55    funciones -> LEN LPAREN ID RPAREN
Rule 56    funciones -> COPY LPAREN ID COMA ID RPAREN
Rule 57    decVarOne -> ID DEQUAL ID
Rule 58    decVarOne -> ID DEQUAL INTEGER
Rule 59    SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
Rule 60    SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE
Rule 61    declaration -> tipo variable
Rule 62    tipo -> INT32
Rule 63    tipo -> INT64
Rule 64    tipo -> FLOAT32
Rule 65    tipo -> FLOAT64
Rule 66    tipo -> WSTRING
Rule 67    tipo -> BOOL
Rule 68    variable -> ID
Rule 69    comparison -> value op value
Rule 70    value -> ID
Rule 71    value -> expression
Rule 72    op -> GREATER
Rule 73    op -> SMALLER
Rule 74    op -> GREATER_OR_EQUAL
Rule 75    op -> SMALLER_OR_EQUAL
Rule 76    op -> EQUAL_COMPARE
Rule 77    op -> NOT_EQUAL
Rule 78    logic_operation -> logic_value logic_op logic_value
Rule 79    logic_operation -> negation
Rule 80    logic_value -> negation
Rule 81    logic_value -> comparison
Rule 82    negation -> NOT comparison
Rule 83    negation -> NOT ID
Rule 84    logic_op -> AND
Rule 85    logic_op -> OR
Rule 86    impresion -> PRINT LPAREN expression RPAREN
Rule 87    expression -> expression PLUS term
Rule 88    expression -> expression MINUS term
Rule 89    expression -> term
Rule 90    term -> term TIMES factor
Rule 91    term -> term DIVIDE factor
Rule 92    term -> factor
Rule 93    factor -> INTEGER
Rule 94    factor -> ID
Rule 95    factor -> LPAREN expression RPAREN

Terminals, with rules where they appear

AND                  : 84
APPEND               : 51 52 53 54
ARRAY                : 
BOOL                 : 67
BYTE                 : 35
CAP                  : 
CASE                 : 
COLON                : 14 14
COMA                 : 29 30 30 45 46 47 48 49 50 51 52 53 54 56
COMMENT              : 
CONST                : 
COPY                 : 56
DECREASE             : 16
DEQUAL               : 24 25 27 28 57 58
DIVIDE               : 91
ELSE                 : 
EQUAL                : 18 19 20 21 23
EQUAL_COMPARE        : 76
FALSE                : 
FLOAT                : 20 25 41 42 47 48 52
FLOAT32              : 33 64
FLOAT64              : 34 65
FOR                  : 11 12 13 14
FUNC                 : 
GREATER              : 72
GREATER_OR_EQUAL     : 74
ID                   : 15 16 18 19 19 20 21 23 24 25 26 27 28 51 52 53 54 54 55 56 56 57 57 58 60 68 70 83 94
IF                   : 59
INCREASE             : 15
INT32                : 31 62
INT64                : 32 63
INTEGER              : 18 29 30 30 39 40 45 46 51 58 93
INTERFACE            : 
JOIN                 : 
LCORCHE              : 26 28 29 30
LEN                  : 55
LLLAVE               : 11 12 13 14 39 40 41 42 43 44 59 60
LPAREN               : 29 30 51 52 53 54 55 56 59 86 95
MAIN                 : 
MAKE                 : 29 30
MAP                  : 
MINUS                : 88
MOD                  : 
MULTI_COMMENT        : 
NOT                  : 82 83
NOT_EQUAL            : 77
OR                   : 85
PACKAGE              : 
PLUS                 : 87
POINTER              : 
PRINT                : 86
RCORCHE              : 26 28 29 30
RLLAVE               : 11 12 13 14 39 40 41 42 43 44 59 60
RPAREN               : 29 30 51 52 53 54 55 56 59 86 95
SCAN                 : 
SMALLER              : 73
SMALLER_OR_EQUAL     : 75
STRING               : 23 24 43 44 49 50 53
STRUCT               : 60
SWITCH               : 
TIMES                : 90
TRUE                 : 
TYPE                 : 60
VAR                  : 18 19 20 21 23 26
WFLOAT               : 37
WINT                 : 36
WSTRING              : 38 66
error                : 

Nonterminals, with rules where they appear

SenIF                : 9
SenStruct            : 10
agrupaciones         : 8 28
cicloFor             : 3
codigo               : 11 12 13 14 59 0
comparison           : 4 12 14 59 81 82
decVar               : 6
decVarOne            : 14 17
declaration          : 60
enteros              : 40 46
expression           : 2 21 71 86 87 88 95
factor               : 90 91 92
flotantes            : 42 48
funM                 : 27
funciones            : 7
impresion            : 1
incre                : 14
logic_op             : 78
logic_operation      : 5 13
logic_value          : 78 78
negation             : 79 80
op                   : 69
palabras             : 44 50
sliceC               : 22
term                 : 87 88 89 90 91
tipo                 : 61
type                 : 26 28 29 30
value                : 69 69
variable             : 61

Parsing method: LALR

state 0

    (0) S' -> . codigo
    (1) codigo -> . impresion
    (2) codigo -> . expression
    (3) codigo -> . cicloFor
    (4) codigo -> . comparison
    (5) codigo -> . logic_operation
    (6) codigo -> . decVar
    (7) codigo -> . funciones
    (8) codigo -> . agrupaciones
    (9) codigo -> . SenIF
    (10) codigo -> . SenStruct
    (86) impresion -> . PRINT LPAREN expression RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (11) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (12) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (13) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (14) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (69) comparison -> . value op value
    (78) logic_operation -> . logic_value logic_op logic_value
    (79) logic_operation -> . negation
    (17) decVar -> . decVarOne
    (18) decVar -> . VAR ID EQUAL INTEGER
    (19) decVar -> . VAR ID EQUAL ID
    (20) decVar -> . VAR ID EQUAL FLOAT
    (21) decVar -> . VAR ID EQUAL expression
    (22) decVar -> . sliceC
    (23) decVar -> . VAR ID EQUAL STRING
    (24) decVar -> . ID DEQUAL STRING
    (25) decVar -> . ID DEQUAL FLOAT
    (51) funciones -> . APPEND LPAREN ID COMA INTEGER RPAREN
    (52) funciones -> . APPEND LPAREN ID COMA FLOAT RPAREN
    (53) funciones -> . APPEND LPAREN ID COMA STRING RPAREN
    (54) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (55) funciones -> . LEN LPAREN ID RPAREN
    (56) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (39) agrupaciones -> . LLLAVE INTEGER RLLAVE
    (40) agrupaciones -> . LLLAVE INTEGER enteros RLLAVE
    (41) agrupaciones -> . LLLAVE FLOAT RLLAVE
    (42) agrupaciones -> . LLLAVE FLOAT flotantes RLLAVE
    (43) agrupaciones -> . LLLAVE STRING RLLAVE
    (44) agrupaciones -> . LLLAVE STRING palabras RLLAVE
    (59) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (60) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (70) value -> . ID
    (71) value -> . expression
    (80) logic_value -> . negation
    (81) logic_value -> . comparison
    (82) negation -> . NOT comparison
    (83) negation -> . NOT ID
    (57) decVarOne -> . ID DEQUAL ID
    (58) decVarOne -> . ID DEQUAL INTEGER
    (26) sliceC -> . VAR ID LCORCHE RCORCHE type
    (27) sliceC -> . ID DEQUAL funM
    (28) sliceC -> . ID DEQUAL LCORCHE RCORCHE type agrupaciones
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 12
    FOR             shift and go to state 15
    VAR             shift and go to state 21
    ID              shift and go to state 22
    APPEND          shift and go to state 25
    LEN             shift and go to state 26
    COPY            shift and go to state 27
    LLLAVE          shift and go to state 16
    IF              shift and go to state 28
    TYPE            shift and go to state 29
    NOT             shift and go to state 31
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    codigo                         shift and go to state 1
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    agrupaciones                   shift and go to state 9
    SenIF                          shift and go to state 10
    SenStruct                      shift and go to state 11
    term                           shift and go to state 14
    decVarOne                      shift and go to state 17
    value                          shift and go to state 18
    logic_value                    shift and go to state 19
    negation                       shift and go to state 20
    sliceC                         shift and go to state 24
    factor                         shift and go to state 30

state 1

    (0) S' -> codigo .



state 2

    (1) codigo -> impresion .

    $end            reduce using rule 1 (codigo -> impresion .)
    RLLAVE          reduce using rule 1 (codigo -> impresion .)


state 3

    (2) codigo -> expression .
    (87) expression -> expression . PLUS term
    (88) expression -> expression . MINUS term
    (71) value -> expression .

    $end            reduce using rule 2 (codigo -> expression .)
    RLLAVE          reduce using rule 2 (codigo -> expression .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33
    GREATER         reduce using rule 71 (value -> expression .)
    SMALLER         reduce using rule 71 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 71 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 71 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 71 (value -> expression .)
    NOT_EQUAL       reduce using rule 71 (value -> expression .)


state 4

    (3) codigo -> cicloFor .

    $end            reduce using rule 3 (codigo -> cicloFor .)
    RLLAVE          reduce using rule 3 (codigo -> cicloFor .)


state 5

    (4) codigo -> comparison .
    (81) logic_value -> comparison .

    $end            reduce using rule 4 (codigo -> comparison .)
    RLLAVE          reduce using rule 4 (codigo -> comparison .)
    AND             reduce using rule 81 (logic_value -> comparison .)
    OR              reduce using rule 81 (logic_value -> comparison .)


state 6

    (5) codigo -> logic_operation .

    $end            reduce using rule 5 (codigo -> logic_operation .)
    RLLAVE          reduce using rule 5 (codigo -> logic_operation .)


state 7

    (6) codigo -> decVar .

    $end            reduce using rule 6 (codigo -> decVar .)
    RLLAVE          reduce using rule 6 (codigo -> decVar .)


state 8

    (7) codigo -> funciones .

    $end            reduce using rule 7 (codigo -> funciones .)
    RLLAVE          reduce using rule 7 (codigo -> funciones .)


state 9

    (8) codigo -> agrupaciones .

    $end            reduce using rule 8 (codigo -> agrupaciones .)
    RLLAVE          reduce using rule 8 (codigo -> agrupaciones .)


state 10

    (9) codigo -> SenIF .

    $end            reduce using rule 9 (codigo -> SenIF .)
    RLLAVE          reduce using rule 9 (codigo -> SenIF .)


state 11

    (10) codigo -> SenStruct .

    $end            reduce using rule 10 (codigo -> SenStruct .)
    RLLAVE          reduce using rule 10 (codigo -> SenStruct .)


state 12

    (86) impresion -> PRINT . LPAREN expression RPAREN

    LPAREN          shift and go to state 34


state 13

    (95) factor -> LPAREN . expression RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 23
    ID              shift and go to state 36
    LPAREN          shift and go to state 13

    expression                     shift and go to state 35
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 14

    (89) expression -> term .
    (90) term -> term . TIMES factor
    (91) term -> term . DIVIDE factor

    PLUS            reduce using rule 89 (expression -> term .)
    MINUS           reduce using rule 89 (expression -> term .)
    $end            reduce using rule 89 (expression -> term .)
    GREATER         reduce using rule 89 (expression -> term .)
    SMALLER         reduce using rule 89 (expression -> term .)
    GREATER_OR_EQUAL reduce using rule 89 (expression -> term .)
    SMALLER_OR_EQUAL reduce using rule 89 (expression -> term .)
    EQUAL_COMPARE   reduce using rule 89 (expression -> term .)
    NOT_EQUAL       reduce using rule 89 (expression -> term .)
    RPAREN          reduce using rule 89 (expression -> term .)
    RLLAVE          reduce using rule 89 (expression -> term .)
    AND             reduce using rule 89 (expression -> term .)
    OR              reduce using rule 89 (expression -> term .)
    LLLAVE          reduce using rule 89 (expression -> term .)
    COLON           reduce using rule 89 (expression -> term .)
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38


state 15

    (11) cicloFor -> FOR . LLLAVE codigo RLLAVE
    (12) cicloFor -> FOR . comparison LLLAVE codigo RLLAVE
    (13) cicloFor -> FOR . logic_operation LLLAVE codigo RLLAVE
    (14) cicloFor -> FOR . decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (69) comparison -> . value op value
    (78) logic_operation -> . logic_value logic_op logic_value
    (79) logic_operation -> . negation
    (57) decVarOne -> . ID DEQUAL ID
    (58) decVarOne -> . ID DEQUAL INTEGER
    (70) value -> . ID
    (71) value -> . expression
    (80) logic_value -> . negation
    (81) logic_value -> . comparison
    (82) negation -> . NOT comparison
    (83) negation -> . NOT ID
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    LLLAVE          shift and go to state 39
    ID              shift and go to state 43
    NOT             shift and go to state 31
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    comparison                     shift and go to state 40
    logic_operation                shift and go to state 41
    decVarOne                      shift and go to state 42
    value                          shift and go to state 18
    logic_value                    shift and go to state 19
    negation                       shift and go to state 20
    expression                     shift and go to state 44
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 16

    (39) agrupaciones -> LLLAVE . INTEGER RLLAVE
    (40) agrupaciones -> LLLAVE . INTEGER enteros RLLAVE
    (41) agrupaciones -> LLLAVE . FLOAT RLLAVE
    (42) agrupaciones -> LLLAVE . FLOAT flotantes RLLAVE
    (43) agrupaciones -> LLLAVE . STRING RLLAVE
    (44) agrupaciones -> LLLAVE . STRING palabras RLLAVE

    INTEGER         shift and go to state 45
    FLOAT           shift and go to state 46
    STRING          shift and go to state 47


state 17

    (17) decVar -> decVarOne .

    $end            reduce using rule 17 (decVar -> decVarOne .)
    RLLAVE          reduce using rule 17 (decVar -> decVarOne .)


state 18

    (69) comparison -> value . op value
    (72) op -> . GREATER
    (73) op -> . SMALLER
    (74) op -> . GREATER_OR_EQUAL
    (75) op -> . SMALLER_OR_EQUAL
    (76) op -> . EQUAL_COMPARE
    (77) op -> . NOT_EQUAL

    GREATER         shift and go to state 49
    SMALLER         shift and go to state 50
    GREATER_OR_EQUAL shift and go to state 51
    SMALLER_OR_EQUAL shift and go to state 52
    EQUAL_COMPARE   shift and go to state 53
    NOT_EQUAL       shift and go to state 54

    op                             shift and go to state 48

state 19

    (78) logic_operation -> logic_value . logic_op logic_value
    (84) logic_op -> . AND
    (85) logic_op -> . OR

    AND             shift and go to state 56
    OR              shift and go to state 57

    logic_op                       shift and go to state 55

state 20

    (79) logic_operation -> negation .
    (80) logic_value -> negation .

    $end            reduce using rule 79 (logic_operation -> negation .)
    LLLAVE          reduce using rule 79 (logic_operation -> negation .)
    RLLAVE          reduce using rule 79 (logic_operation -> negation .)
    AND             reduce using rule 80 (logic_value -> negation .)
    OR              reduce using rule 80 (logic_value -> negation .)


state 21

    (18) decVar -> VAR . ID EQUAL INTEGER
    (19) decVar -> VAR . ID EQUAL ID
    (20) decVar -> VAR . ID EQUAL FLOAT
    (21) decVar -> VAR . ID EQUAL expression
    (23) decVar -> VAR . ID EQUAL STRING
    (26) sliceC -> VAR . ID LCORCHE RCORCHE type

    ID              shift and go to state 58


state 22

    (24) decVar -> ID . DEQUAL STRING
    (25) decVar -> ID . DEQUAL FLOAT
    (70) value -> ID .
    (57) decVarOne -> ID . DEQUAL ID
    (58) decVarOne -> ID . DEQUAL INTEGER
    (27) sliceC -> ID . DEQUAL funM
    (28) sliceC -> ID . DEQUAL LCORCHE RCORCHE type agrupaciones
    (94) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 70 (value -> ID .)
    DEQUAL          shift and go to state 59
    GREATER         reduce using rule 70 (value -> ID .)
    SMALLER         reduce using rule 70 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 70 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 70 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 70 (value -> ID .)
    NOT_EQUAL       reduce using rule 70 (value -> ID .)
    TIMES           reduce using rule 94 (factor -> ID .)
    DIVIDE          reduce using rule 94 (factor -> ID .)
    PLUS            reduce using rule 94 (factor -> ID .)
    MINUS           reduce using rule 94 (factor -> ID .)
    $end            reduce using rule 94 (factor -> ID .)
    RLLAVE          reduce using rule 94 (factor -> ID .)

  ! GREATER         [ reduce using rule 94 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 94 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 94 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 94 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 94 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 94 (factor -> ID .) ]


state 23

    (93) factor -> INTEGER .

    TIMES           reduce using rule 93 (factor -> INTEGER .)
    DIVIDE          reduce using rule 93 (factor -> INTEGER .)
    PLUS            reduce using rule 93 (factor -> INTEGER .)
    MINUS           reduce using rule 93 (factor -> INTEGER .)
    $end            reduce using rule 93 (factor -> INTEGER .)
    GREATER         reduce using rule 93 (factor -> INTEGER .)
    SMALLER         reduce using rule 93 (factor -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 93 (factor -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 93 (factor -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 93 (factor -> INTEGER .)
    NOT_EQUAL       reduce using rule 93 (factor -> INTEGER .)
    RPAREN          reduce using rule 93 (factor -> INTEGER .)
    RLLAVE          reduce using rule 93 (factor -> INTEGER .)
    AND             reduce using rule 93 (factor -> INTEGER .)
    OR              reduce using rule 93 (factor -> INTEGER .)
    LLLAVE          reduce using rule 93 (factor -> INTEGER .)
    COLON           reduce using rule 93 (factor -> INTEGER .)


state 24

    (22) decVar -> sliceC .

    $end            reduce using rule 22 (decVar -> sliceC .)
    RLLAVE          reduce using rule 22 (decVar -> sliceC .)


state 25

    (51) funciones -> APPEND . LPAREN ID COMA INTEGER RPAREN
    (52) funciones -> APPEND . LPAREN ID COMA FLOAT RPAREN
    (53) funciones -> APPEND . LPAREN ID COMA STRING RPAREN
    (54) funciones -> APPEND . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 60


state 26

    (55) funciones -> LEN . LPAREN ID RPAREN

    LPAREN          shift and go to state 61


state 27

    (56) funciones -> COPY . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 62


state 28

    (59) SenIF -> IF . LPAREN comparison RPAREN LLLAVE codigo RLLAVE

    LPAREN          shift and go to state 63


state 29

    (60) SenStruct -> TYPE . ID STRUCT LLLAVE declaration RLLAVE

    ID              shift and go to state 64


state 30

    (92) term -> factor .

    TIMES           reduce using rule 92 (term -> factor .)
    DIVIDE          reduce using rule 92 (term -> factor .)
    PLUS            reduce using rule 92 (term -> factor .)
    MINUS           reduce using rule 92 (term -> factor .)
    $end            reduce using rule 92 (term -> factor .)
    GREATER         reduce using rule 92 (term -> factor .)
    SMALLER         reduce using rule 92 (term -> factor .)
    GREATER_OR_EQUAL reduce using rule 92 (term -> factor .)
    SMALLER_OR_EQUAL reduce using rule 92 (term -> factor .)
    EQUAL_COMPARE   reduce using rule 92 (term -> factor .)
    NOT_EQUAL       reduce using rule 92 (term -> factor .)
    RPAREN          reduce using rule 92 (term -> factor .)
    RLLAVE          reduce using rule 92 (term -> factor .)
    AND             reduce using rule 92 (term -> factor .)
    OR              reduce using rule 92 (term -> factor .)
    LLLAVE          reduce using rule 92 (term -> factor .)
    COLON           reduce using rule 92 (term -> factor .)


state 31

    (82) negation -> NOT . comparison
    (83) negation -> NOT . ID
    (69) comparison -> . value op value
    (70) value -> . ID
    (71) value -> . expression
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 66
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    comparison                     shift and go to state 65
    value                          shift and go to state 18
    expression                     shift and go to state 44
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 32

    (87) expression -> expression PLUS . term
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 23
    ID              shift and go to state 36
    LPAREN          shift and go to state 13

    term                           shift and go to state 67
    factor                         shift and go to state 30

state 33

    (88) expression -> expression MINUS . term
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 23
    ID              shift and go to state 36
    LPAREN          shift and go to state 13

    term                           shift and go to state 68
    factor                         shift and go to state 30

state 34

    (86) impresion -> PRINT LPAREN . expression RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 23
    ID              shift and go to state 36
    LPAREN          shift and go to state 13

    expression                     shift and go to state 69
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 35

    (95) factor -> LPAREN expression . RPAREN
    (87) expression -> expression . PLUS term
    (88) expression -> expression . MINUS term

    RPAREN          shift and go to state 70
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 36

    (94) factor -> ID .

    TIMES           reduce using rule 94 (factor -> ID .)
    DIVIDE          reduce using rule 94 (factor -> ID .)
    RPAREN          reduce using rule 94 (factor -> ID .)
    PLUS            reduce using rule 94 (factor -> ID .)
    MINUS           reduce using rule 94 (factor -> ID .)
    $end            reduce using rule 94 (factor -> ID .)
    GREATER         reduce using rule 94 (factor -> ID .)
    SMALLER         reduce using rule 94 (factor -> ID .)
    GREATER_OR_EQUAL reduce using rule 94 (factor -> ID .)
    SMALLER_OR_EQUAL reduce using rule 94 (factor -> ID .)
    EQUAL_COMPARE   reduce using rule 94 (factor -> ID .)
    NOT_EQUAL       reduce using rule 94 (factor -> ID .)
    RLLAVE          reduce using rule 94 (factor -> ID .)
    AND             reduce using rule 94 (factor -> ID .)
    OR              reduce using rule 94 (factor -> ID .)
    LLLAVE          reduce using rule 94 (factor -> ID .)
    COLON           reduce using rule 94 (factor -> ID .)


state 37

    (90) term -> term TIMES . factor
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 23
    ID              shift and go to state 36
    LPAREN          shift and go to state 13

    factor                         shift and go to state 71

state 38

    (91) term -> term DIVIDE . factor
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 23
    ID              shift and go to state 36
    LPAREN          shift and go to state 13

    factor                         shift and go to state 72

state 39

    (11) cicloFor -> FOR LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion
    (2) codigo -> . expression
    (3) codigo -> . cicloFor
    (4) codigo -> . comparison
    (5) codigo -> . logic_operation
    (6) codigo -> . decVar
    (7) codigo -> . funciones
    (8) codigo -> . agrupaciones
    (9) codigo -> . SenIF
    (10) codigo -> . SenStruct
    (86) impresion -> . PRINT LPAREN expression RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (11) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (12) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (13) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (14) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (69) comparison -> . value op value
    (78) logic_operation -> . logic_value logic_op logic_value
    (79) logic_operation -> . negation
    (17) decVar -> . decVarOne
    (18) decVar -> . VAR ID EQUAL INTEGER
    (19) decVar -> . VAR ID EQUAL ID
    (20) decVar -> . VAR ID EQUAL FLOAT
    (21) decVar -> . VAR ID EQUAL expression
    (22) decVar -> . sliceC
    (23) decVar -> . VAR ID EQUAL STRING
    (24) decVar -> . ID DEQUAL STRING
    (25) decVar -> . ID DEQUAL FLOAT
    (51) funciones -> . APPEND LPAREN ID COMA INTEGER RPAREN
    (52) funciones -> . APPEND LPAREN ID COMA FLOAT RPAREN
    (53) funciones -> . APPEND LPAREN ID COMA STRING RPAREN
    (54) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (55) funciones -> . LEN LPAREN ID RPAREN
    (56) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (39) agrupaciones -> . LLLAVE INTEGER RLLAVE
    (40) agrupaciones -> . LLLAVE INTEGER enteros RLLAVE
    (41) agrupaciones -> . LLLAVE FLOAT RLLAVE
    (42) agrupaciones -> . LLLAVE FLOAT flotantes RLLAVE
    (43) agrupaciones -> . LLLAVE STRING RLLAVE
    (44) agrupaciones -> . LLLAVE STRING palabras RLLAVE
    (59) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (60) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (70) value -> . ID
    (71) value -> . expression
    (80) logic_value -> . negation
    (81) logic_value -> . comparison
    (82) negation -> . NOT comparison
    (83) negation -> . NOT ID
    (57) decVarOne -> . ID DEQUAL ID
    (58) decVarOne -> . ID DEQUAL INTEGER
    (26) sliceC -> . VAR ID LCORCHE RCORCHE type
    (27) sliceC -> . ID DEQUAL funM
    (28) sliceC -> . ID DEQUAL LCORCHE RCORCHE type agrupaciones
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 12
    FOR             shift and go to state 15
    VAR             shift and go to state 21
    ID              shift and go to state 22
    APPEND          shift and go to state 25
    LEN             shift and go to state 26
    COPY            shift and go to state 27
    LLLAVE          shift and go to state 16
    IF              shift and go to state 28
    TYPE            shift and go to state 29
    NOT             shift and go to state 31
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    codigo                         shift and go to state 73
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    agrupaciones                   shift and go to state 9
    SenIF                          shift and go to state 10
    SenStruct                      shift and go to state 11
    term                           shift and go to state 14
    decVarOne                      shift and go to state 17
    value                          shift and go to state 18
    logic_value                    shift and go to state 19
    negation                       shift and go to state 20
    sliceC                         shift and go to state 24
    factor                         shift and go to state 30

state 40

    (12) cicloFor -> FOR comparison . LLLAVE codigo RLLAVE
    (81) logic_value -> comparison .

    LLLAVE          shift and go to state 74
    AND             reduce using rule 81 (logic_value -> comparison .)
    OR              reduce using rule 81 (logic_value -> comparison .)


state 41

    (13) cicloFor -> FOR logic_operation . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 75


state 42

    (14) cicloFor -> FOR decVarOne . COLON comparison COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 76


state 43

    (57) decVarOne -> ID . DEQUAL ID
    (58) decVarOne -> ID . DEQUAL INTEGER
    (70) value -> ID .
    (94) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 70 (value -> ID .)
    DEQUAL          shift and go to state 77
    GREATER         reduce using rule 70 (value -> ID .)
    SMALLER         reduce using rule 70 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 70 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 70 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 70 (value -> ID .)
    NOT_EQUAL       reduce using rule 70 (value -> ID .)
    TIMES           reduce using rule 94 (factor -> ID .)
    DIVIDE          reduce using rule 94 (factor -> ID .)
    PLUS            reduce using rule 94 (factor -> ID .)
    MINUS           reduce using rule 94 (factor -> ID .)

  ! GREATER         [ reduce using rule 94 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 94 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 94 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 94 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 94 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 94 (factor -> ID .) ]


state 44

    (71) value -> expression .
    (87) expression -> expression . PLUS term
    (88) expression -> expression . MINUS term

    GREATER         reduce using rule 71 (value -> expression .)
    SMALLER         reduce using rule 71 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 71 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 71 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 71 (value -> expression .)
    NOT_EQUAL       reduce using rule 71 (value -> expression .)
    $end            reduce using rule 71 (value -> expression .)
    AND             reduce using rule 71 (value -> expression .)
    OR              reduce using rule 71 (value -> expression .)
    LLLAVE          reduce using rule 71 (value -> expression .)
    RLLAVE          reduce using rule 71 (value -> expression .)
    RPAREN          reduce using rule 71 (value -> expression .)
    COLON           reduce using rule 71 (value -> expression .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 45

    (39) agrupaciones -> LLLAVE INTEGER . RLLAVE
    (40) agrupaciones -> LLLAVE INTEGER . enteros RLLAVE
    (45) enteros -> . COMA INTEGER
    (46) enteros -> . COMA INTEGER enteros

    RLLAVE          shift and go to state 78
    COMA            shift and go to state 80

    enteros                        shift and go to state 79

state 46

    (41) agrupaciones -> LLLAVE FLOAT . RLLAVE
    (42) agrupaciones -> LLLAVE FLOAT . flotantes RLLAVE
    (47) flotantes -> . COMA FLOAT
    (48) flotantes -> . COMA FLOAT flotantes

    RLLAVE          shift and go to state 81
    COMA            shift and go to state 83

    flotantes                      shift and go to state 82

state 47

    (43) agrupaciones -> LLLAVE STRING . RLLAVE
    (44) agrupaciones -> LLLAVE STRING . palabras RLLAVE
    (49) palabras -> . COMA STRING
    (50) palabras -> . COMA STRING palabras

    RLLAVE          shift and go to state 84
    COMA            shift and go to state 86

    palabras                       shift and go to state 85

state 48

    (69) comparison -> value op . value
    (70) value -> . ID
    (71) value -> . expression
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 88
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    value                          shift and go to state 87
    expression                     shift and go to state 44
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 49

    (72) op -> GREATER .

    ID              reduce using rule 72 (op -> GREATER .)
    INTEGER         reduce using rule 72 (op -> GREATER .)
    LPAREN          reduce using rule 72 (op -> GREATER .)


state 50

    (73) op -> SMALLER .

    ID              reduce using rule 73 (op -> SMALLER .)
    INTEGER         reduce using rule 73 (op -> SMALLER .)
    LPAREN          reduce using rule 73 (op -> SMALLER .)


state 51

    (74) op -> GREATER_OR_EQUAL .

    ID              reduce using rule 74 (op -> GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 74 (op -> GREATER_OR_EQUAL .)
    LPAREN          reduce using rule 74 (op -> GREATER_OR_EQUAL .)


state 52

    (75) op -> SMALLER_OR_EQUAL .

    ID              reduce using rule 75 (op -> SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 75 (op -> SMALLER_OR_EQUAL .)
    LPAREN          reduce using rule 75 (op -> SMALLER_OR_EQUAL .)


state 53

    (76) op -> EQUAL_COMPARE .

    ID              reduce using rule 76 (op -> EQUAL_COMPARE .)
    INTEGER         reduce using rule 76 (op -> EQUAL_COMPARE .)
    LPAREN          reduce using rule 76 (op -> EQUAL_COMPARE .)


state 54

    (77) op -> NOT_EQUAL .

    ID              reduce using rule 77 (op -> NOT_EQUAL .)
    INTEGER         reduce using rule 77 (op -> NOT_EQUAL .)
    LPAREN          reduce using rule 77 (op -> NOT_EQUAL .)


state 55

    (78) logic_operation -> logic_value logic_op . logic_value
    (80) logic_value -> . negation
    (81) logic_value -> . comparison
    (82) negation -> . NOT comparison
    (83) negation -> . NOT ID
    (69) comparison -> . value op value
    (70) value -> . ID
    (71) value -> . expression
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    NOT             shift and go to state 31
    ID              shift and go to state 88
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    logic_value                    shift and go to state 89
    negation                       shift and go to state 90
    comparison                     shift and go to state 91
    value                          shift and go to state 18
    expression                     shift and go to state 44
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 56

    (84) logic_op -> AND .

    NOT             reduce using rule 84 (logic_op -> AND .)
    ID              reduce using rule 84 (logic_op -> AND .)
    INTEGER         reduce using rule 84 (logic_op -> AND .)
    LPAREN          reduce using rule 84 (logic_op -> AND .)


state 57

    (85) logic_op -> OR .

    NOT             reduce using rule 85 (logic_op -> OR .)
    ID              reduce using rule 85 (logic_op -> OR .)
    INTEGER         reduce using rule 85 (logic_op -> OR .)
    LPAREN          reduce using rule 85 (logic_op -> OR .)


state 58

    (18) decVar -> VAR ID . EQUAL INTEGER
    (19) decVar -> VAR ID . EQUAL ID
    (20) decVar -> VAR ID . EQUAL FLOAT
    (21) decVar -> VAR ID . EQUAL expression
    (23) decVar -> VAR ID . EQUAL STRING
    (26) sliceC -> VAR ID . LCORCHE RCORCHE type

    EQUAL           shift and go to state 92
    LCORCHE         shift and go to state 93


state 59

    (24) decVar -> ID DEQUAL . STRING
    (25) decVar -> ID DEQUAL . FLOAT
    (57) decVarOne -> ID DEQUAL . ID
    (58) decVarOne -> ID DEQUAL . INTEGER
    (27) sliceC -> ID DEQUAL . funM
    (28) sliceC -> ID DEQUAL . LCORCHE RCORCHE type agrupaciones
    (29) funM -> . MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER RPAREN
    (30) funM -> . MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER COMA INTEGER RPAREN

    STRING          shift and go to state 95
    FLOAT           shift and go to state 96
    ID              shift and go to state 94
    INTEGER         shift and go to state 97
    LCORCHE         shift and go to state 99
    MAKE            shift and go to state 100

    funM                           shift and go to state 98

state 60

    (51) funciones -> APPEND LPAREN . ID COMA INTEGER RPAREN
    (52) funciones -> APPEND LPAREN . ID COMA FLOAT RPAREN
    (53) funciones -> APPEND LPAREN . ID COMA STRING RPAREN
    (54) funciones -> APPEND LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 101


state 61

    (55) funciones -> LEN LPAREN . ID RPAREN

    ID              shift and go to state 102


state 62

    (56) funciones -> COPY LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 103


state 63

    (59) SenIF -> IF LPAREN . comparison RPAREN LLLAVE codigo RLLAVE
    (69) comparison -> . value op value
    (70) value -> . ID
    (71) value -> . expression
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 88
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    comparison                     shift and go to state 104
    value                          shift and go to state 18
    expression                     shift and go to state 44
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 64

    (60) SenStruct -> TYPE ID . STRUCT LLLAVE declaration RLLAVE

    STRUCT          shift and go to state 105


state 65

    (82) negation -> NOT comparison .

    $end            reduce using rule 82 (negation -> NOT comparison .)
    AND             reduce using rule 82 (negation -> NOT comparison .)
    OR              reduce using rule 82 (negation -> NOT comparison .)
    LLLAVE          reduce using rule 82 (negation -> NOT comparison .)
    RLLAVE          reduce using rule 82 (negation -> NOT comparison .)


state 66

    (83) negation -> NOT ID .
    (70) value -> ID .
    (94) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 70 (value -> ID .)
    $end            reduce using rule 83 (negation -> NOT ID .)
    AND             reduce using rule 83 (negation -> NOT ID .)
    OR              reduce using rule 83 (negation -> NOT ID .)
    LLLAVE          reduce using rule 83 (negation -> NOT ID .)
    RLLAVE          reduce using rule 83 (negation -> NOT ID .)
    GREATER         reduce using rule 70 (value -> ID .)
    SMALLER         reduce using rule 70 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 70 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 70 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 70 (value -> ID .)
    NOT_EQUAL       reduce using rule 70 (value -> ID .)
    TIMES           reduce using rule 94 (factor -> ID .)
    DIVIDE          reduce using rule 94 (factor -> ID .)
    PLUS            reduce using rule 94 (factor -> ID .)
    MINUS           reduce using rule 94 (factor -> ID .)

  ! GREATER         [ reduce using rule 94 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 94 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 94 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 94 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 94 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 94 (factor -> ID .) ]


state 67

    (87) expression -> expression PLUS term .
    (90) term -> term . TIMES factor
    (91) term -> term . DIVIDE factor

    PLUS            reduce using rule 87 (expression -> expression PLUS term .)
    MINUS           reduce using rule 87 (expression -> expression PLUS term .)
    $end            reduce using rule 87 (expression -> expression PLUS term .)
    GREATER         reduce using rule 87 (expression -> expression PLUS term .)
    SMALLER         reduce using rule 87 (expression -> expression PLUS term .)
    GREATER_OR_EQUAL reduce using rule 87 (expression -> expression PLUS term .)
    SMALLER_OR_EQUAL reduce using rule 87 (expression -> expression PLUS term .)
    EQUAL_COMPARE   reduce using rule 87 (expression -> expression PLUS term .)
    NOT_EQUAL       reduce using rule 87 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 87 (expression -> expression PLUS term .)
    RLLAVE          reduce using rule 87 (expression -> expression PLUS term .)
    AND             reduce using rule 87 (expression -> expression PLUS term .)
    OR              reduce using rule 87 (expression -> expression PLUS term .)
    LLLAVE          reduce using rule 87 (expression -> expression PLUS term .)
    COLON           reduce using rule 87 (expression -> expression PLUS term .)
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38


state 68

    (88) expression -> expression MINUS term .
    (90) term -> term . TIMES factor
    (91) term -> term . DIVIDE factor

    PLUS            reduce using rule 88 (expression -> expression MINUS term .)
    MINUS           reduce using rule 88 (expression -> expression MINUS term .)
    $end            reduce using rule 88 (expression -> expression MINUS term .)
    GREATER         reduce using rule 88 (expression -> expression MINUS term .)
    SMALLER         reduce using rule 88 (expression -> expression MINUS term .)
    GREATER_OR_EQUAL reduce using rule 88 (expression -> expression MINUS term .)
    SMALLER_OR_EQUAL reduce using rule 88 (expression -> expression MINUS term .)
    EQUAL_COMPARE   reduce using rule 88 (expression -> expression MINUS term .)
    NOT_EQUAL       reduce using rule 88 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 88 (expression -> expression MINUS term .)
    RLLAVE          reduce using rule 88 (expression -> expression MINUS term .)
    AND             reduce using rule 88 (expression -> expression MINUS term .)
    OR              reduce using rule 88 (expression -> expression MINUS term .)
    LLLAVE          reduce using rule 88 (expression -> expression MINUS term .)
    COLON           reduce using rule 88 (expression -> expression MINUS term .)
    TIMES           shift and go to state 37
    DIVIDE          shift and go to state 38


state 69

    (86) impresion -> PRINT LPAREN expression . RPAREN
    (87) expression -> expression . PLUS term
    (88) expression -> expression . MINUS term

    RPAREN          shift and go to state 106
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 70

    (95) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 95 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 95 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 95 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 95 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 95 (factor -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 95 (factor -> LPAREN expression RPAREN .)
    SMALLER         reduce using rule 95 (factor -> LPAREN expression RPAREN .)
    GREATER_OR_EQUAL reduce using rule 95 (factor -> LPAREN expression RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 95 (factor -> LPAREN expression RPAREN .)
    EQUAL_COMPARE   reduce using rule 95 (factor -> LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 95 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 95 (factor -> LPAREN expression RPAREN .)
    RLLAVE          reduce using rule 95 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 95 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 95 (factor -> LPAREN expression RPAREN .)
    LLLAVE          reduce using rule 95 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 95 (factor -> LPAREN expression RPAREN .)


state 71

    (90) term -> term TIMES factor .

    TIMES           reduce using rule 90 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 90 (term -> term TIMES factor .)
    PLUS            reduce using rule 90 (term -> term TIMES factor .)
    MINUS           reduce using rule 90 (term -> term TIMES factor .)
    $end            reduce using rule 90 (term -> term TIMES factor .)
    GREATER         reduce using rule 90 (term -> term TIMES factor .)
    SMALLER         reduce using rule 90 (term -> term TIMES factor .)
    GREATER_OR_EQUAL reduce using rule 90 (term -> term TIMES factor .)
    SMALLER_OR_EQUAL reduce using rule 90 (term -> term TIMES factor .)
    EQUAL_COMPARE   reduce using rule 90 (term -> term TIMES factor .)
    NOT_EQUAL       reduce using rule 90 (term -> term TIMES factor .)
    RPAREN          reduce using rule 90 (term -> term TIMES factor .)
    RLLAVE          reduce using rule 90 (term -> term TIMES factor .)
    AND             reduce using rule 90 (term -> term TIMES factor .)
    OR              reduce using rule 90 (term -> term TIMES factor .)
    LLLAVE          reduce using rule 90 (term -> term TIMES factor .)
    COLON           reduce using rule 90 (term -> term TIMES factor .)


state 72

    (91) term -> term DIVIDE factor .

    TIMES           reduce using rule 91 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 91 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 91 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 91 (term -> term DIVIDE factor .)
    $end            reduce using rule 91 (term -> term DIVIDE factor .)
    GREATER         reduce using rule 91 (term -> term DIVIDE factor .)
    SMALLER         reduce using rule 91 (term -> term DIVIDE factor .)
    GREATER_OR_EQUAL reduce using rule 91 (term -> term DIVIDE factor .)
    SMALLER_OR_EQUAL reduce using rule 91 (term -> term DIVIDE factor .)
    EQUAL_COMPARE   reduce using rule 91 (term -> term DIVIDE factor .)
    NOT_EQUAL       reduce using rule 91 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 91 (term -> term DIVIDE factor .)
    RLLAVE          reduce using rule 91 (term -> term DIVIDE factor .)
    AND             reduce using rule 91 (term -> term DIVIDE factor .)
    OR              reduce using rule 91 (term -> term DIVIDE factor .)
    LLLAVE          reduce using rule 91 (term -> term DIVIDE factor .)
    COLON           reduce using rule 91 (term -> term DIVIDE factor .)


state 73

    (11) cicloFor -> FOR LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 107


state 74

    (12) cicloFor -> FOR comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion
    (2) codigo -> . expression
    (3) codigo -> . cicloFor
    (4) codigo -> . comparison
    (5) codigo -> . logic_operation
    (6) codigo -> . decVar
    (7) codigo -> . funciones
    (8) codigo -> . agrupaciones
    (9) codigo -> . SenIF
    (10) codigo -> . SenStruct
    (86) impresion -> . PRINT LPAREN expression RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (11) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (12) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (13) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (14) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (69) comparison -> . value op value
    (78) logic_operation -> . logic_value logic_op logic_value
    (79) logic_operation -> . negation
    (17) decVar -> . decVarOne
    (18) decVar -> . VAR ID EQUAL INTEGER
    (19) decVar -> . VAR ID EQUAL ID
    (20) decVar -> . VAR ID EQUAL FLOAT
    (21) decVar -> . VAR ID EQUAL expression
    (22) decVar -> . sliceC
    (23) decVar -> . VAR ID EQUAL STRING
    (24) decVar -> . ID DEQUAL STRING
    (25) decVar -> . ID DEQUAL FLOAT
    (51) funciones -> . APPEND LPAREN ID COMA INTEGER RPAREN
    (52) funciones -> . APPEND LPAREN ID COMA FLOAT RPAREN
    (53) funciones -> . APPEND LPAREN ID COMA STRING RPAREN
    (54) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (55) funciones -> . LEN LPAREN ID RPAREN
    (56) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (39) agrupaciones -> . LLLAVE INTEGER RLLAVE
    (40) agrupaciones -> . LLLAVE INTEGER enteros RLLAVE
    (41) agrupaciones -> . LLLAVE FLOAT RLLAVE
    (42) agrupaciones -> . LLLAVE FLOAT flotantes RLLAVE
    (43) agrupaciones -> . LLLAVE STRING RLLAVE
    (44) agrupaciones -> . LLLAVE STRING palabras RLLAVE
    (59) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (60) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (70) value -> . ID
    (71) value -> . expression
    (80) logic_value -> . negation
    (81) logic_value -> . comparison
    (82) negation -> . NOT comparison
    (83) negation -> . NOT ID
    (57) decVarOne -> . ID DEQUAL ID
    (58) decVarOne -> . ID DEQUAL INTEGER
    (26) sliceC -> . VAR ID LCORCHE RCORCHE type
    (27) sliceC -> . ID DEQUAL funM
    (28) sliceC -> . ID DEQUAL LCORCHE RCORCHE type agrupaciones
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 12
    FOR             shift and go to state 15
    VAR             shift and go to state 21
    ID              shift and go to state 22
    APPEND          shift and go to state 25
    LEN             shift and go to state 26
    COPY            shift and go to state 27
    LLLAVE          shift and go to state 16
    IF              shift and go to state 28
    TYPE            shift and go to state 29
    NOT             shift and go to state 31
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    comparison                     shift and go to state 5
    codigo                         shift and go to state 108
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    agrupaciones                   shift and go to state 9
    SenIF                          shift and go to state 10
    SenStruct                      shift and go to state 11
    term                           shift and go to state 14
    decVarOne                      shift and go to state 17
    value                          shift and go to state 18
    logic_value                    shift and go to state 19
    negation                       shift and go to state 20
    sliceC                         shift and go to state 24
    factor                         shift and go to state 30

state 75

    (13) cicloFor -> FOR logic_operation LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion
    (2) codigo -> . expression
    (3) codigo -> . cicloFor
    (4) codigo -> . comparison
    (5) codigo -> . logic_operation
    (6) codigo -> . decVar
    (7) codigo -> . funciones
    (8) codigo -> . agrupaciones
    (9) codigo -> . SenIF
    (10) codigo -> . SenStruct
    (86) impresion -> . PRINT LPAREN expression RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (11) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (12) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (13) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (14) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (69) comparison -> . value op value
    (78) logic_operation -> . logic_value logic_op logic_value
    (79) logic_operation -> . negation
    (17) decVar -> . decVarOne
    (18) decVar -> . VAR ID EQUAL INTEGER
    (19) decVar -> . VAR ID EQUAL ID
    (20) decVar -> . VAR ID EQUAL FLOAT
    (21) decVar -> . VAR ID EQUAL expression
    (22) decVar -> . sliceC
    (23) decVar -> . VAR ID EQUAL STRING
    (24) decVar -> . ID DEQUAL STRING
    (25) decVar -> . ID DEQUAL FLOAT
    (51) funciones -> . APPEND LPAREN ID COMA INTEGER RPAREN
    (52) funciones -> . APPEND LPAREN ID COMA FLOAT RPAREN
    (53) funciones -> . APPEND LPAREN ID COMA STRING RPAREN
    (54) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (55) funciones -> . LEN LPAREN ID RPAREN
    (56) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (39) agrupaciones -> . LLLAVE INTEGER RLLAVE
    (40) agrupaciones -> . LLLAVE INTEGER enteros RLLAVE
    (41) agrupaciones -> . LLLAVE FLOAT RLLAVE
    (42) agrupaciones -> . LLLAVE FLOAT flotantes RLLAVE
    (43) agrupaciones -> . LLLAVE STRING RLLAVE
    (44) agrupaciones -> . LLLAVE STRING palabras RLLAVE
    (59) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (60) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (70) value -> . ID
    (71) value -> . expression
    (80) logic_value -> . negation
    (81) logic_value -> . comparison
    (82) negation -> . NOT comparison
    (83) negation -> . NOT ID
    (57) decVarOne -> . ID DEQUAL ID
    (58) decVarOne -> . ID DEQUAL INTEGER
    (26) sliceC -> . VAR ID LCORCHE RCORCHE type
    (27) sliceC -> . ID DEQUAL funM
    (28) sliceC -> . ID DEQUAL LCORCHE RCORCHE type agrupaciones
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 12
    FOR             shift and go to state 15
    VAR             shift and go to state 21
    ID              shift and go to state 22
    APPEND          shift and go to state 25
    LEN             shift and go to state 26
    COPY            shift and go to state 27
    LLLAVE          shift and go to state 16
    IF              shift and go to state 28
    TYPE            shift and go to state 29
    NOT             shift and go to state 31
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    logic_operation                shift and go to state 6
    codigo                         shift and go to state 109
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    agrupaciones                   shift and go to state 9
    SenIF                          shift and go to state 10
    SenStruct                      shift and go to state 11
    term                           shift and go to state 14
    decVarOne                      shift and go to state 17
    value                          shift and go to state 18
    logic_value                    shift and go to state 19
    negation                       shift and go to state 20
    sliceC                         shift and go to state 24
    factor                         shift and go to state 30

state 76

    (14) cicloFor -> FOR decVarOne COLON . comparison COLON incre LLLAVE codigo RLLAVE
    (69) comparison -> . value op value
    (70) value -> . ID
    (71) value -> . expression
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 88
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    comparison                     shift and go to state 110
    value                          shift and go to state 18
    expression                     shift and go to state 44
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 77

    (57) decVarOne -> ID DEQUAL . ID
    (58) decVarOne -> ID DEQUAL . INTEGER

    ID              shift and go to state 94
    INTEGER         shift and go to state 97


state 78

    (39) agrupaciones -> LLLAVE INTEGER RLLAVE .

    $end            reduce using rule 39 (agrupaciones -> LLLAVE INTEGER RLLAVE .)
    RLLAVE          reduce using rule 39 (agrupaciones -> LLLAVE INTEGER RLLAVE .)


state 79

    (40) agrupaciones -> LLLAVE INTEGER enteros . RLLAVE

    RLLAVE          shift and go to state 111


state 80

    (45) enteros -> COMA . INTEGER
    (46) enteros -> COMA . INTEGER enteros

    INTEGER         shift and go to state 112


state 81

    (41) agrupaciones -> LLLAVE FLOAT RLLAVE .

    $end            reduce using rule 41 (agrupaciones -> LLLAVE FLOAT RLLAVE .)
    RLLAVE          reduce using rule 41 (agrupaciones -> LLLAVE FLOAT RLLAVE .)


state 82

    (42) agrupaciones -> LLLAVE FLOAT flotantes . RLLAVE

    RLLAVE          shift and go to state 113


state 83

    (47) flotantes -> COMA . FLOAT
    (48) flotantes -> COMA . FLOAT flotantes

    FLOAT           shift and go to state 114


state 84

    (43) agrupaciones -> LLLAVE STRING RLLAVE .

    $end            reduce using rule 43 (agrupaciones -> LLLAVE STRING RLLAVE .)
    RLLAVE          reduce using rule 43 (agrupaciones -> LLLAVE STRING RLLAVE .)


state 85

    (44) agrupaciones -> LLLAVE STRING palabras . RLLAVE

    RLLAVE          shift and go to state 115


state 86

    (49) palabras -> COMA . STRING
    (50) palabras -> COMA . STRING palabras

    STRING          shift and go to state 116


state 87

    (69) comparison -> value op value .

    $end            reduce using rule 69 (comparison -> value op value .)
    AND             reduce using rule 69 (comparison -> value op value .)
    OR              reduce using rule 69 (comparison -> value op value .)
    LLLAVE          reduce using rule 69 (comparison -> value op value .)
    RLLAVE          reduce using rule 69 (comparison -> value op value .)
    RPAREN          reduce using rule 69 (comparison -> value op value .)
    COLON           reduce using rule 69 (comparison -> value op value .)


state 88

    (70) value -> ID .
    (94) factor -> ID .

  ! reduce/reduce conflict for $end resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for LLLAVE resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 70 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 70 (value -> ID .)
    $end            reduce using rule 70 (value -> ID .)
    AND             reduce using rule 70 (value -> ID .)
    OR              reduce using rule 70 (value -> ID .)
    LLLAVE          reduce using rule 70 (value -> ID .)
    RLLAVE          reduce using rule 70 (value -> ID .)
    RPAREN          reduce using rule 70 (value -> ID .)
    COLON           reduce using rule 70 (value -> ID .)
    GREATER         reduce using rule 70 (value -> ID .)
    SMALLER         reduce using rule 70 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 70 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 70 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 70 (value -> ID .)
    NOT_EQUAL       reduce using rule 70 (value -> ID .)
    TIMES           reduce using rule 94 (factor -> ID .)
    DIVIDE          reduce using rule 94 (factor -> ID .)
    PLUS            reduce using rule 94 (factor -> ID .)
    MINUS           reduce using rule 94 (factor -> ID .)

  ! $end            [ reduce using rule 94 (factor -> ID .) ]
  ! AND             [ reduce using rule 94 (factor -> ID .) ]
  ! OR              [ reduce using rule 94 (factor -> ID .) ]
  ! LLLAVE          [ reduce using rule 94 (factor -> ID .) ]
  ! RLLAVE          [ reduce using rule 94 (factor -> ID .) ]
  ! RPAREN          [ reduce using rule 94 (factor -> ID .) ]
  ! COLON           [ reduce using rule 94 (factor -> ID .) ]
  ! GREATER         [ reduce using rule 94 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 94 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 94 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 94 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 94 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 94 (factor -> ID .) ]


state 89

    (78) logic_operation -> logic_value logic_op logic_value .

    $end            reduce using rule 78 (logic_operation -> logic_value logic_op logic_value .)
    LLLAVE          reduce using rule 78 (logic_operation -> logic_value logic_op logic_value .)
    RLLAVE          reduce using rule 78 (logic_operation -> logic_value logic_op logic_value .)


state 90

    (80) logic_value -> negation .

    $end            reduce using rule 80 (logic_value -> negation .)
    LLLAVE          reduce using rule 80 (logic_value -> negation .)
    RLLAVE          reduce using rule 80 (logic_value -> negation .)


state 91

    (81) logic_value -> comparison .

    $end            reduce using rule 81 (logic_value -> comparison .)
    LLLAVE          reduce using rule 81 (logic_value -> comparison .)
    RLLAVE          reduce using rule 81 (logic_value -> comparison .)


state 92

    (18) decVar -> VAR ID EQUAL . INTEGER
    (19) decVar -> VAR ID EQUAL . ID
    (20) decVar -> VAR ID EQUAL . FLOAT
    (21) decVar -> VAR ID EQUAL . expression
    (23) decVar -> VAR ID EQUAL . STRING
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 118
    ID              shift and go to state 117
    FLOAT           shift and go to state 119
    STRING          shift and go to state 121
    LPAREN          shift and go to state 13

    expression                     shift and go to state 120
    term                           shift and go to state 14
    factor                         shift and go to state 30

state 93

    (26) sliceC -> VAR ID LCORCHE . RCORCHE type

    RCORCHE         shift and go to state 122


state 94

    (57) decVarOne -> ID DEQUAL ID .

    $end            reduce using rule 57 (decVarOne -> ID DEQUAL ID .)
    COLON           reduce using rule 57 (decVarOne -> ID DEQUAL ID .)
    RLLAVE          reduce using rule 57 (decVarOne -> ID DEQUAL ID .)


state 95

    (24) decVar -> ID DEQUAL STRING .

    $end            reduce using rule 24 (decVar -> ID DEQUAL STRING .)
    RLLAVE          reduce using rule 24 (decVar -> ID DEQUAL STRING .)


state 96

    (25) decVar -> ID DEQUAL FLOAT .

    $end            reduce using rule 25 (decVar -> ID DEQUAL FLOAT .)
    RLLAVE          reduce using rule 25 (decVar -> ID DEQUAL FLOAT .)


state 97

    (58) decVarOne -> ID DEQUAL INTEGER .

    $end            reduce using rule 58 (decVarOne -> ID DEQUAL INTEGER .)
    COLON           reduce using rule 58 (decVarOne -> ID DEQUAL INTEGER .)
    RLLAVE          reduce using rule 58 (decVarOne -> ID DEQUAL INTEGER .)


state 98

    (27) sliceC -> ID DEQUAL funM .

    $end            reduce using rule 27 (sliceC -> ID DEQUAL funM .)
    RLLAVE          reduce using rule 27 (sliceC -> ID DEQUAL funM .)


state 99

    (28) sliceC -> ID DEQUAL LCORCHE . RCORCHE type agrupaciones

    RCORCHE         shift and go to state 123


state 100

    (29) funM -> MAKE . LPAREN LCORCHE RCORCHE type COMA INTEGER RPAREN
    (30) funM -> MAKE . LPAREN LCORCHE RCORCHE type COMA INTEGER COMA INTEGER RPAREN

    LPAREN          shift and go to state 124


state 101

    (51) funciones -> APPEND LPAREN ID . COMA INTEGER RPAREN
    (52) funciones -> APPEND LPAREN ID . COMA FLOAT RPAREN
    (53) funciones -> APPEND LPAREN ID . COMA STRING RPAREN
    (54) funciones -> APPEND LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 125


state 102

    (55) funciones -> LEN LPAREN ID . RPAREN

    RPAREN          shift and go to state 126


state 103

    (56) funciones -> COPY LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 127


state 104

    (59) SenIF -> IF LPAREN comparison . RPAREN LLLAVE codigo RLLAVE

    RPAREN          shift and go to state 128


state 105

    (60) SenStruct -> TYPE ID STRUCT . LLLAVE declaration RLLAVE

    LLLAVE          shift and go to state 129


state 106

    (86) impresion -> PRINT LPAREN expression RPAREN .

    $end            reduce using rule 86 (impresion -> PRINT LPAREN expression RPAREN .)
    RLLAVE          reduce using rule 86 (impresion -> PRINT LPAREN expression RPAREN .)


state 107

    (11) cicloFor -> FOR LLLAVE codigo RLLAVE .

    $end            reduce using rule 11 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 11 (cicloFor -> FOR LLLAVE codigo RLLAVE .)


state 108

    (12) cicloFor -> FOR comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 130


state 109

    (13) cicloFor -> FOR logic_operation LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 131


state 110

    (14) cicloFor -> FOR decVarOne COLON comparison . COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 132


state 111

    (40) agrupaciones -> LLLAVE INTEGER enteros RLLAVE .

    $end            reduce using rule 40 (agrupaciones -> LLLAVE INTEGER enteros RLLAVE .)
    RLLAVE          reduce using rule 40 (agrupaciones -> LLLAVE INTEGER enteros RLLAVE .)


state 112

    (45) enteros -> COMA INTEGER .
    (46) enteros -> COMA INTEGER . enteros
    (45) enteros -> . COMA INTEGER
    (46) enteros -> . COMA INTEGER enteros

    RLLAVE          reduce using rule 45 (enteros -> COMA INTEGER .)
    COMA            shift and go to state 80

    enteros                        shift and go to state 133

state 113

    (42) agrupaciones -> LLLAVE FLOAT flotantes RLLAVE .

    $end            reduce using rule 42 (agrupaciones -> LLLAVE FLOAT flotantes RLLAVE .)
    RLLAVE          reduce using rule 42 (agrupaciones -> LLLAVE FLOAT flotantes RLLAVE .)


state 114

    (47) flotantes -> COMA FLOAT .
    (48) flotantes -> COMA FLOAT . flotantes
    (47) flotantes -> . COMA FLOAT
    (48) flotantes -> . COMA FLOAT flotantes

    RLLAVE          reduce using rule 47 (flotantes -> COMA FLOAT .)
    COMA            shift and go to state 83

    flotantes                      shift and go to state 134

state 115

    (44) agrupaciones -> LLLAVE STRING palabras RLLAVE .

    $end            reduce using rule 44 (agrupaciones -> LLLAVE STRING palabras RLLAVE .)
    RLLAVE          reduce using rule 44 (agrupaciones -> LLLAVE STRING palabras RLLAVE .)


state 116

    (49) palabras -> COMA STRING .
    (50) palabras -> COMA STRING . palabras
    (49) palabras -> . COMA STRING
    (50) palabras -> . COMA STRING palabras

    RLLAVE          reduce using rule 49 (palabras -> COMA STRING .)
    COMA            shift and go to state 86

    palabras                       shift and go to state 135

state 117

    (19) decVar -> VAR ID EQUAL ID .
    (94) factor -> ID .

  ! reduce/reduce conflict for $end resolved using rule 19 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 19 (decVar -> VAR ID EQUAL ID .)
    $end            reduce using rule 19 (decVar -> VAR ID EQUAL ID .)
    RLLAVE          reduce using rule 19 (decVar -> VAR ID EQUAL ID .)
    TIMES           reduce using rule 94 (factor -> ID .)
    DIVIDE          reduce using rule 94 (factor -> ID .)
    PLUS            reduce using rule 94 (factor -> ID .)
    MINUS           reduce using rule 94 (factor -> ID .)

  ! $end            [ reduce using rule 94 (factor -> ID .) ]
  ! RLLAVE          [ reduce using rule 94 (factor -> ID .) ]


state 118

    (18) decVar -> VAR ID EQUAL INTEGER .
    (93) factor -> INTEGER .

  ! reduce/reduce conflict for $end resolved using rule 18 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 18 (decVar -> VAR ID EQUAL INTEGER .)
    $end            reduce using rule 18 (decVar -> VAR ID EQUAL INTEGER .)
    RLLAVE          reduce using rule 18 (decVar -> VAR ID EQUAL INTEGER .)
    TIMES           reduce using rule 93 (factor -> INTEGER .)
    DIVIDE          reduce using rule 93 (factor -> INTEGER .)
    PLUS            reduce using rule 93 (factor -> INTEGER .)
    MINUS           reduce using rule 93 (factor -> INTEGER .)

  ! $end            [ reduce using rule 93 (factor -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 93 (factor -> INTEGER .) ]


state 119

    (20) decVar -> VAR ID EQUAL FLOAT .

    $end            reduce using rule 20 (decVar -> VAR ID EQUAL FLOAT .)
    RLLAVE          reduce using rule 20 (decVar -> VAR ID EQUAL FLOAT .)


state 120

    (21) decVar -> VAR ID EQUAL expression .
    (87) expression -> expression . PLUS term
    (88) expression -> expression . MINUS term

    $end            reduce using rule 21 (decVar -> VAR ID EQUAL expression .)
    RLLAVE          reduce using rule 21 (decVar -> VAR ID EQUAL expression .)
    PLUS            shift and go to state 32
    MINUS           shift and go to state 33


state 121

    (23) decVar -> VAR ID EQUAL STRING .

    $end            reduce using rule 23 (decVar -> VAR ID EQUAL STRING .)
    RLLAVE          reduce using rule 23 (decVar -> VAR ID EQUAL STRING .)


state 122

    (26) sliceC -> VAR ID LCORCHE RCORCHE . type
    (31) type -> . INT32
    (32) type -> . INT64
    (33) type -> . FLOAT32
    (34) type -> . FLOAT64
    (35) type -> . BYTE
    (36) type -> . WINT
    (37) type -> . WFLOAT
    (38) type -> . WSTRING

    INT32           shift and go to state 137
    INT64           shift and go to state 138
    FLOAT32         shift and go to state 139
    FLOAT64         shift and go to state 140
    BYTE            shift and go to state 141
    WINT            shift and go to state 142
    WFLOAT          shift and go to state 143
    WSTRING         shift and go to state 144

    type                           shift and go to state 136

state 123

    (28) sliceC -> ID DEQUAL LCORCHE RCORCHE . type agrupaciones
    (31) type -> . INT32
    (32) type -> . INT64
    (33) type -> . FLOAT32
    (34) type -> . FLOAT64
    (35) type -> . BYTE
    (36) type -> . WINT
    (37) type -> . WFLOAT
    (38) type -> . WSTRING

    INT32           shift and go to state 137
    INT64           shift and go to state 138
    FLOAT32         shift and go to state 139
    FLOAT64         shift and go to state 140
    BYTE            shift and go to state 141
    WINT            shift and go to state 142
    WFLOAT          shift and go to state 143
    WSTRING         shift and go to state 144

    type                           shift and go to state 145

state 124

    (29) funM -> MAKE LPAREN . LCORCHE RCORCHE type COMA INTEGER RPAREN
    (30) funM -> MAKE LPAREN . LCORCHE RCORCHE type COMA INTEGER COMA INTEGER RPAREN

    LCORCHE         shift and go to state 146


state 125

    (51) funciones -> APPEND LPAREN ID COMA . INTEGER RPAREN
    (52) funciones -> APPEND LPAREN ID COMA . FLOAT RPAREN
    (53) funciones -> APPEND LPAREN ID COMA . STRING RPAREN
    (54) funciones -> APPEND LPAREN ID COMA . ID RPAREN

    INTEGER         shift and go to state 148
    FLOAT           shift and go to state 149
    STRING          shift and go to state 150
    ID              shift and go to state 147


state 126

    (55) funciones -> LEN LPAREN ID RPAREN .

    $end            reduce using rule 55 (funciones -> LEN LPAREN ID RPAREN .)
    RLLAVE          reduce using rule 55 (funciones -> LEN LPAREN ID RPAREN .)


state 127

    (56) funciones -> COPY LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 151


state 128

    (59) SenIF -> IF LPAREN comparison RPAREN . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 152


state 129

    (60) SenStruct -> TYPE ID STRUCT LLLAVE . declaration RLLAVE
    (61) declaration -> . tipo variable
    (62) tipo -> . INT32
    (63) tipo -> . INT64
    (64) tipo -> . FLOAT32
    (65) tipo -> . FLOAT64
    (66) tipo -> . WSTRING
    (67) tipo -> . BOOL

    INT32           shift and go to state 155
    INT64           shift and go to state 156
    FLOAT32         shift and go to state 157
    FLOAT64         shift and go to state 158
    WSTRING         shift and go to state 159
    BOOL            shift and go to state 160

    declaration                    shift and go to state 153
    tipo                           shift and go to state 154

state 130

    (12) cicloFor -> FOR comparison LLLAVE codigo RLLAVE .

    $end            reduce using rule 12 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 12 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)


state 131

    (13) cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .

    $end            reduce using rule 13 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 13 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)


state 132

    (14) cicloFor -> FOR decVarOne COLON comparison COLON . incre LLLAVE codigo RLLAVE
    (15) incre -> . ID INCREASE
    (16) incre -> . ID DECREASE

    ID              shift and go to state 162

    incre                          shift and go to state 161

state 133

    (46) enteros -> COMA INTEGER enteros .

    RLLAVE          reduce using rule 46 (enteros -> COMA INTEGER enteros .)


state 134

    (48) flotantes -> COMA FLOAT flotantes .

    RLLAVE          reduce using rule 48 (flotantes -> COMA FLOAT flotantes .)


state 135

    (50) palabras -> COMA STRING palabras .

    RLLAVE          reduce using rule 50 (palabras -> COMA STRING palabras .)


state 136

    (26) sliceC -> VAR ID LCORCHE RCORCHE type .

    $end            reduce using rule 26 (sliceC -> VAR ID LCORCHE RCORCHE type .)
    RLLAVE          reduce using rule 26 (sliceC -> VAR ID LCORCHE RCORCHE type .)


state 137

    (31) type -> INT32 .

    $end            reduce using rule 31 (type -> INT32 .)
    RLLAVE          reduce using rule 31 (type -> INT32 .)
    LLLAVE          reduce using rule 31 (type -> INT32 .)
    COMA            reduce using rule 31 (type -> INT32 .)


state 138

    (32) type -> INT64 .

    $end            reduce using rule 32 (type -> INT64 .)
    RLLAVE          reduce using rule 32 (type -> INT64 .)
    LLLAVE          reduce using rule 32 (type -> INT64 .)
    COMA            reduce using rule 32 (type -> INT64 .)


state 139

    (33) type -> FLOAT32 .

    $end            reduce using rule 33 (type -> FLOAT32 .)
    RLLAVE          reduce using rule 33 (type -> FLOAT32 .)
    LLLAVE          reduce using rule 33 (type -> FLOAT32 .)
    COMA            reduce using rule 33 (type -> FLOAT32 .)


state 140

    (34) type -> FLOAT64 .

    $end            reduce using rule 34 (type -> FLOAT64 .)
    RLLAVE          reduce using rule 34 (type -> FLOAT64 .)
    LLLAVE          reduce using rule 34 (type -> FLOAT64 .)
    COMA            reduce using rule 34 (type -> FLOAT64 .)


state 141

    (35) type -> BYTE .

    $end            reduce using rule 35 (type -> BYTE .)
    RLLAVE          reduce using rule 35 (type -> BYTE .)
    LLLAVE          reduce using rule 35 (type -> BYTE .)
    COMA            reduce using rule 35 (type -> BYTE .)


state 142

    (36) type -> WINT .

    $end            reduce using rule 36 (type -> WINT .)
    RLLAVE          reduce using rule 36 (type -> WINT .)
    LLLAVE          reduce using rule 36 (type -> WINT .)
    COMA            reduce using rule 36 (type -> WINT .)


state 143

    (37) type -> WFLOAT .

    $end            reduce using rule 37 (type -> WFLOAT .)
    RLLAVE          reduce using rule 37 (type -> WFLOAT .)
    LLLAVE          reduce using rule 37 (type -> WFLOAT .)
    COMA            reduce using rule 37 (type -> WFLOAT .)


state 144

    (38) type -> WSTRING .

    $end            reduce using rule 38 (type -> WSTRING .)
    RLLAVE          reduce using rule 38 (type -> WSTRING .)
    LLLAVE          reduce using rule 38 (type -> WSTRING .)
    COMA            reduce using rule 38 (type -> WSTRING .)


state 145

    (28) sliceC -> ID DEQUAL LCORCHE RCORCHE type . agrupaciones
    (39) agrupaciones -> . LLLAVE INTEGER RLLAVE
    (40) agrupaciones -> . LLLAVE INTEGER enteros RLLAVE
    (41) agrupaciones -> . LLLAVE FLOAT RLLAVE
    (42) agrupaciones -> . LLLAVE FLOAT flotantes RLLAVE
    (43) agrupaciones -> . LLLAVE STRING RLLAVE
    (44) agrupaciones -> . LLLAVE STRING palabras RLLAVE

    LLLAVE          shift and go to state 16

    agrupaciones                   shift and go to state 163

state 146

    (29) funM -> MAKE LPAREN LCORCHE . RCORCHE type COMA INTEGER RPAREN
    (30) funM -> MAKE LPAREN LCORCHE . RCORCHE type COMA INTEGER COMA INTEGER RPAREN

    RCORCHE         shift and go to state 164


state 147

    (54) funciones -> APPEND LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 165


state 148

    (51) funciones -> APPEND LPAREN ID COMA INTEGER . RPAREN

    RPAREN          shift and go to state 166


state 149

    (52) funciones -> APPEND LPAREN ID COMA FLOAT . RPAREN

    RPAREN          shift and go to state 167


state 150

    (53) funciones -> APPEND LPAREN ID COMA STRING . RPAREN

    RPAREN          shift and go to state 168


state 151

    (56) funciones -> COPY LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 169


state 152

    (59) SenIF -> IF LPAREN comparison RPAREN LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion
    (2) codigo -> . expression
    (3) codigo -> . cicloFor
    (4) codigo -> . comparison
    (5) codigo -> . logic_operation
    (6) codigo -> . decVar
    (7) codigo -> . funciones
    (8) codigo -> . agrupaciones
    (9) codigo -> . SenIF
    (10) codigo -> . SenStruct
    (86) impresion -> . PRINT LPAREN expression RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (11) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (12) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (13) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (14) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (69) comparison -> . value op value
    (78) logic_operation -> . logic_value logic_op logic_value
    (79) logic_operation -> . negation
    (17) decVar -> . decVarOne
    (18) decVar -> . VAR ID EQUAL INTEGER
    (19) decVar -> . VAR ID EQUAL ID
    (20) decVar -> . VAR ID EQUAL FLOAT
    (21) decVar -> . VAR ID EQUAL expression
    (22) decVar -> . sliceC
    (23) decVar -> . VAR ID EQUAL STRING
    (24) decVar -> . ID DEQUAL STRING
    (25) decVar -> . ID DEQUAL FLOAT
    (51) funciones -> . APPEND LPAREN ID COMA INTEGER RPAREN
    (52) funciones -> . APPEND LPAREN ID COMA FLOAT RPAREN
    (53) funciones -> . APPEND LPAREN ID COMA STRING RPAREN
    (54) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (55) funciones -> . LEN LPAREN ID RPAREN
    (56) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (39) agrupaciones -> . LLLAVE INTEGER RLLAVE
    (40) agrupaciones -> . LLLAVE INTEGER enteros RLLAVE
    (41) agrupaciones -> . LLLAVE FLOAT RLLAVE
    (42) agrupaciones -> . LLLAVE FLOAT flotantes RLLAVE
    (43) agrupaciones -> . LLLAVE STRING RLLAVE
    (44) agrupaciones -> . LLLAVE STRING palabras RLLAVE
    (59) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (60) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (70) value -> . ID
    (71) value -> . expression
    (80) logic_value -> . negation
    (81) logic_value -> . comparison
    (82) negation -> . NOT comparison
    (83) negation -> . NOT ID
    (57) decVarOne -> . ID DEQUAL ID
    (58) decVarOne -> . ID DEQUAL INTEGER
    (26) sliceC -> . VAR ID LCORCHE RCORCHE type
    (27) sliceC -> . ID DEQUAL funM
    (28) sliceC -> . ID DEQUAL LCORCHE RCORCHE type agrupaciones
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 12
    FOR             shift and go to state 15
    VAR             shift and go to state 21
    ID              shift and go to state 22
    APPEND          shift and go to state 25
    LEN             shift and go to state 26
    COPY            shift and go to state 27
    LLLAVE          shift and go to state 16
    IF              shift and go to state 28
    TYPE            shift and go to state 29
    NOT             shift and go to state 31
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    comparison                     shift and go to state 5
    codigo                         shift and go to state 170
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    agrupaciones                   shift and go to state 9
    SenIF                          shift and go to state 10
    SenStruct                      shift and go to state 11
    term                           shift and go to state 14
    decVarOne                      shift and go to state 17
    value                          shift and go to state 18
    logic_value                    shift and go to state 19
    negation                       shift and go to state 20
    sliceC                         shift and go to state 24
    factor                         shift and go to state 30

state 153

    (60) SenStruct -> TYPE ID STRUCT LLLAVE declaration . RLLAVE

    RLLAVE          shift and go to state 171


state 154

    (61) declaration -> tipo . variable
    (68) variable -> . ID

    ID              shift and go to state 173

    variable                       shift and go to state 172

state 155

    (62) tipo -> INT32 .

    ID              reduce using rule 62 (tipo -> INT32 .)


state 156

    (63) tipo -> INT64 .

    ID              reduce using rule 63 (tipo -> INT64 .)


state 157

    (64) tipo -> FLOAT32 .

    ID              reduce using rule 64 (tipo -> FLOAT32 .)


state 158

    (65) tipo -> FLOAT64 .

    ID              reduce using rule 65 (tipo -> FLOAT64 .)


state 159

    (66) tipo -> WSTRING .

    ID              reduce using rule 66 (tipo -> WSTRING .)


state 160

    (67) tipo -> BOOL .

    ID              reduce using rule 67 (tipo -> BOOL .)


state 161

    (14) cicloFor -> FOR decVarOne COLON comparison COLON incre . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 174


state 162

    (15) incre -> ID . INCREASE
    (16) incre -> ID . DECREASE

    INCREASE        shift and go to state 175
    DECREASE        shift and go to state 176


state 163

    (28) sliceC -> ID DEQUAL LCORCHE RCORCHE type agrupaciones .

    $end            reduce using rule 28 (sliceC -> ID DEQUAL LCORCHE RCORCHE type agrupaciones .)
    RLLAVE          reduce using rule 28 (sliceC -> ID DEQUAL LCORCHE RCORCHE type agrupaciones .)


state 164

    (29) funM -> MAKE LPAREN LCORCHE RCORCHE . type COMA INTEGER RPAREN
    (30) funM -> MAKE LPAREN LCORCHE RCORCHE . type COMA INTEGER COMA INTEGER RPAREN
    (31) type -> . INT32
    (32) type -> . INT64
    (33) type -> . FLOAT32
    (34) type -> . FLOAT64
    (35) type -> . BYTE
    (36) type -> . WINT
    (37) type -> . WFLOAT
    (38) type -> . WSTRING

    INT32           shift and go to state 137
    INT64           shift and go to state 138
    FLOAT32         shift and go to state 139
    FLOAT64         shift and go to state 140
    BYTE            shift and go to state 141
    WINT            shift and go to state 142
    WFLOAT          shift and go to state 143
    WSTRING         shift and go to state 144

    type                           shift and go to state 177

state 165

    (54) funciones -> APPEND LPAREN ID COMA ID RPAREN .

    $end            reduce using rule 54 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 54 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)


state 166

    (51) funciones -> APPEND LPAREN ID COMA INTEGER RPAREN .

    $end            reduce using rule 51 (funciones -> APPEND LPAREN ID COMA INTEGER RPAREN .)
    RLLAVE          reduce using rule 51 (funciones -> APPEND LPAREN ID COMA INTEGER RPAREN .)


state 167

    (52) funciones -> APPEND LPAREN ID COMA FLOAT RPAREN .

    $end            reduce using rule 52 (funciones -> APPEND LPAREN ID COMA FLOAT RPAREN .)
    RLLAVE          reduce using rule 52 (funciones -> APPEND LPAREN ID COMA FLOAT RPAREN .)


state 168

    (53) funciones -> APPEND LPAREN ID COMA STRING RPAREN .

    $end            reduce using rule 53 (funciones -> APPEND LPAREN ID COMA STRING RPAREN .)
    RLLAVE          reduce using rule 53 (funciones -> APPEND LPAREN ID COMA STRING RPAREN .)


state 169

    (56) funciones -> COPY LPAREN ID COMA ID RPAREN .

    $end            reduce using rule 56 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 56 (funciones -> COPY LPAREN ID COMA ID RPAREN .)


state 170

    (59) SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 178


state 171

    (60) SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .

    $end            reduce using rule 60 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RLLAVE          reduce using rule 60 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)


state 172

    (61) declaration -> tipo variable .

    RLLAVE          reduce using rule 61 (declaration -> tipo variable .)


state 173

    (68) variable -> ID .

    RLLAVE          reduce using rule 68 (variable -> ID .)


state 174

    (14) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion
    (2) codigo -> . expression
    (3) codigo -> . cicloFor
    (4) codigo -> . comparison
    (5) codigo -> . logic_operation
    (6) codigo -> . decVar
    (7) codigo -> . funciones
    (8) codigo -> . agrupaciones
    (9) codigo -> . SenIF
    (10) codigo -> . SenStruct
    (86) impresion -> . PRINT LPAREN expression RPAREN
    (87) expression -> . expression PLUS term
    (88) expression -> . expression MINUS term
    (89) expression -> . term
    (11) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (12) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (13) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (14) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (69) comparison -> . value op value
    (78) logic_operation -> . logic_value logic_op logic_value
    (79) logic_operation -> . negation
    (17) decVar -> . decVarOne
    (18) decVar -> . VAR ID EQUAL INTEGER
    (19) decVar -> . VAR ID EQUAL ID
    (20) decVar -> . VAR ID EQUAL FLOAT
    (21) decVar -> . VAR ID EQUAL expression
    (22) decVar -> . sliceC
    (23) decVar -> . VAR ID EQUAL STRING
    (24) decVar -> . ID DEQUAL STRING
    (25) decVar -> . ID DEQUAL FLOAT
    (51) funciones -> . APPEND LPAREN ID COMA INTEGER RPAREN
    (52) funciones -> . APPEND LPAREN ID COMA FLOAT RPAREN
    (53) funciones -> . APPEND LPAREN ID COMA STRING RPAREN
    (54) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (55) funciones -> . LEN LPAREN ID RPAREN
    (56) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (39) agrupaciones -> . LLLAVE INTEGER RLLAVE
    (40) agrupaciones -> . LLLAVE INTEGER enteros RLLAVE
    (41) agrupaciones -> . LLLAVE FLOAT RLLAVE
    (42) agrupaciones -> . LLLAVE FLOAT flotantes RLLAVE
    (43) agrupaciones -> . LLLAVE STRING RLLAVE
    (44) agrupaciones -> . LLLAVE STRING palabras RLLAVE
    (59) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (60) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (90) term -> . term TIMES factor
    (91) term -> . term DIVIDE factor
    (92) term -> . factor
    (70) value -> . ID
    (71) value -> . expression
    (80) logic_value -> . negation
    (81) logic_value -> . comparison
    (82) negation -> . NOT comparison
    (83) negation -> . NOT ID
    (57) decVarOne -> . ID DEQUAL ID
    (58) decVarOne -> . ID DEQUAL INTEGER
    (26) sliceC -> . VAR ID LCORCHE RCORCHE type
    (27) sliceC -> . ID DEQUAL funM
    (28) sliceC -> . ID DEQUAL LCORCHE RCORCHE type agrupaciones
    (93) factor -> . INTEGER
    (94) factor -> . ID
    (95) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 12
    FOR             shift and go to state 15
    VAR             shift and go to state 21
    ID              shift and go to state 22
    APPEND          shift and go to state 25
    LEN             shift and go to state 26
    COPY            shift and go to state 27
    LLLAVE          shift and go to state 16
    IF              shift and go to state 28
    TYPE            shift and go to state 29
    NOT             shift and go to state 31
    INTEGER         shift and go to state 23
    LPAREN          shift and go to state 13

    decVarOne                      shift and go to state 17
    comparison                     shift and go to state 5
    codigo                         shift and go to state 179
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    agrupaciones                   shift and go to state 9
    SenIF                          shift and go to state 10
    SenStruct                      shift and go to state 11
    term                           shift and go to state 14
    value                          shift and go to state 18
    logic_value                    shift and go to state 19
    negation                       shift and go to state 20
    sliceC                         shift and go to state 24
    factor                         shift and go to state 30

state 175

    (15) incre -> ID INCREASE .

    LLLAVE          reduce using rule 15 (incre -> ID INCREASE .)


state 176

    (16) incre -> ID DECREASE .

    LLLAVE          reduce using rule 16 (incre -> ID DECREASE .)


state 177

    (29) funM -> MAKE LPAREN LCORCHE RCORCHE type . COMA INTEGER RPAREN
    (30) funM -> MAKE LPAREN LCORCHE RCORCHE type . COMA INTEGER COMA INTEGER RPAREN

    COMA            shift and go to state 180


state 178

    (59) SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .

    $end            reduce using rule 59 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 59 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)


state 179

    (14) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 181


state 180

    (29) funM -> MAKE LPAREN LCORCHE RCORCHE type COMA . INTEGER RPAREN
    (30) funM -> MAKE LPAREN LCORCHE RCORCHE type COMA . INTEGER COMA INTEGER RPAREN

    INTEGER         shift and go to state 182


state 181

    (14) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .

    $end            reduce using rule 14 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 14 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)


state 182

    (29) funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER . RPAREN
    (30) funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER . COMA INTEGER RPAREN

    RPAREN          shift and go to state 184
    COMA            shift and go to state 183


state 183

    (30) funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER COMA . INTEGER RPAREN

    INTEGER         shift and go to state 185


state 184

    (29) funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER RPAREN .

    $end            reduce using rule 29 (funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER RPAREN .)
    RLLAVE          reduce using rule 29 (funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER RPAREN .)


state 185

    (30) funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER COMA INTEGER . RPAREN

    RPAREN          shift and go to state 186


state 186

    (30) funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER COMA INTEGER RPAREN .

    $end            reduce using rule 30 (funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER COMA INTEGER RPAREN .)
    RLLAVE          reduce using rule 30 (funM -> MAKE LPAREN LCORCHE RCORCHE type COMA INTEGER COMA INTEGER RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 22 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 22
WARNING: reduce/reduce conflict in state 43 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 43
WARNING: reduce/reduce conflict in state 66 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 66
WARNING: reduce/reduce conflict in state 88 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 88
WARNING: reduce/reduce conflict in state 117 resolved using rule (decVar -> VAR ID EQUAL ID)
WARNING: rejected rule (factor -> ID) in state 117
WARNING: reduce/reduce conflict in state 118 resolved using rule (decVar -> VAR ID EQUAL INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 118
