Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    APPEND
    ARRAY
    BOOL
    BYTE
    CAP
    CASE
    COLON
    COMA
    COMMENT
    CONST
    COPY
    DECREASE
    DEQUAL
    ELSE
    EQUAL
    FALSE
    FLOAT
    FLOAT32
    FLOAT64
    FUNC
    IF
    INCREASE
    INT32
    INT64
    INTERFACE
    JOIN
    LCORCHE
    LEN
    MAIN
    MAKE
    MAP
    MOD
    MULTI_COMMENT
    PACKAGE
    POINTER
    RCORCHE
    SCAN
    STRING
    STRUCT
    SWITCH
    TRUE
    TYPE
    VAR

Grammar

Rule 0     S' -> codigo
Rule 1     codigo -> impresion
Rule 2     codigo -> expression
Rule 3     codigo -> cicloFor
Rule 4     codigo -> comparison
Rule 5     codigo -> logic_operation
Rule 6     cicloFor -> FOR LLLAVE codigo RLLAVE
Rule 7     comparison -> value op value
Rule 8     value -> ID
Rule 9     value -> expression
Rule 10    op -> GREATER
Rule 11    op -> SMALLER
Rule 12    op -> GREATER_OR_EQUAL
Rule 13    op -> SMALLER_OR_EQUAL
Rule 14    op -> EQUAL_COMPARE
Rule 15    op -> NOT_EQUAL
Rule 16    logic_operation -> logic_value logic_op logic_value
Rule 17    logic_operation -> negation
Rule 18    logic_value -> negation
Rule 19    logic_value -> comparison
Rule 20    negation -> NOT comparison
Rule 21    negation -> NOT ID
Rule 22    logic_op -> AND
Rule 23    logic_op -> OR
Rule 24    impresion -> PRINT LPAREN expression RPAREN
Rule 25    expression -> expression PLUS term
Rule 26    expression -> expression MINUS term
Rule 27    expression -> term
Rule 28    term -> term TIMES factor
Rule 29    term -> term DIVIDE factor
Rule 30    term -> factor
Rule 31    factor -> INTEGER
Rule 32    factor -> ID
Rule 33    factor -> LPAREN expression RPAREN

Terminals, with rules where they appear

AND                  : 22
APPEND               : 
ARRAY                : 
BOOL                 : 
BYTE                 : 
CAP                  : 
CASE                 : 
COLON                : 
COMA                 : 
COMMENT              : 
CONST                : 
COPY                 : 
DECREASE             : 
DEQUAL               : 
DIVIDE               : 29
ELSE                 : 
EQUAL                : 
EQUAL_COMPARE        : 14
FALSE                : 
FLOAT                : 
FLOAT32              : 
FLOAT64              : 
FOR                  : 6
FUNC                 : 
GREATER              : 10
GREATER_OR_EQUAL     : 12
ID                   : 8 21 32
IF                   : 
INCREASE             : 
INT32                : 
INT64                : 
INTEGER              : 31
INTERFACE            : 
JOIN                 : 
LCORCHE              : 
LEN                  : 
LLLAVE               : 6
LPAREN               : 24 33
MAIN                 : 
MAKE                 : 
MAP                  : 
MINUS                : 26
MOD                  : 
MULTI_COMMENT        : 
NOT                  : 20 21
NOT_EQUAL            : 15
OR                   : 23
PACKAGE              : 
PLUS                 : 25
POINTER              : 
PRINT                : 24
RCORCHE              : 
RLLAVE               : 6
RPAREN               : 24 33
SCAN                 : 
SMALLER              : 11
SMALLER_OR_EQUAL     : 13
STRING               : 
STRUCT               : 
SWITCH               : 
TIMES                : 28
TRUE                 : 
TYPE                 : 
VAR                  : 
error                : 

Nonterminals, with rules where they appear

cicloFor             : 3
codigo               : 6 0
comparison           : 4 19 20
expression           : 2 9 24 25 26 33
factor               : 28 29 30
impresion            : 1
logic_op             : 16
logic_operation      : 5
logic_value          : 16 16
negation             : 17 18
op                   : 7
term                 : 25 26 27 28 29
value                : 7 7

Parsing method: LALR

state 0

    (0) S' -> . codigo
    (1) codigo -> . impresion
    (2) codigo -> . expression
    (3) codigo -> . cicloFor
    (4) codigo -> . comparison
    (5) codigo -> . logic_operation
    (24) impresion -> . PRINT LPAREN expression RPAREN
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (6) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (7) comparison -> . value op value
    (16) logic_operation -> . logic_value logic_op logic_value
    (17) logic_operation -> . negation
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (8) value -> . ID
    (9) value -> . expression
    (18) logic_value -> . negation
    (19) logic_value -> . comparison
    (20) negation -> . NOT comparison
    (21) negation -> . NOT ID
    (31) factor -> . INTEGER
    (32) factor -> . ID
    (33) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 7
    FOR             shift and go to state 10
    ID              shift and go to state 15
    NOT             shift and go to state 16
    INTEGER         shift and go to state 17
    LPAREN          shift and go to state 8

    codigo                         shift and go to state 1
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    term                           shift and go to state 9
    value                          shift and go to state 11
    logic_value                    shift and go to state 12
    negation                       shift and go to state 13
    factor                         shift and go to state 14

state 1

    (0) S' -> codigo .



state 2

    (1) codigo -> impresion .

    $end            reduce using rule 1 (codigo -> impresion .)
    RLLAVE          reduce using rule 1 (codigo -> impresion .)


state 3

    (2) codigo -> expression .
    (25) expression -> expression . PLUS term
    (26) expression -> expression . MINUS term
    (9) value -> expression .

    $end            reduce using rule 2 (codigo -> expression .)
    RLLAVE          reduce using rule 2 (codigo -> expression .)
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19
    GREATER         reduce using rule 9 (value -> expression .)
    SMALLER         reduce using rule 9 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 9 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 9 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 9 (value -> expression .)
    NOT_EQUAL       reduce using rule 9 (value -> expression .)


state 4

    (3) codigo -> cicloFor .

    $end            reduce using rule 3 (codigo -> cicloFor .)
    RLLAVE          reduce using rule 3 (codigo -> cicloFor .)


state 5

    (4) codigo -> comparison .
    (19) logic_value -> comparison .

    $end            reduce using rule 4 (codigo -> comparison .)
    RLLAVE          reduce using rule 4 (codigo -> comparison .)
    AND             reduce using rule 19 (logic_value -> comparison .)
    OR              reduce using rule 19 (logic_value -> comparison .)


state 6

    (5) codigo -> logic_operation .

    $end            reduce using rule 5 (codigo -> logic_operation .)
    RLLAVE          reduce using rule 5 (codigo -> logic_operation .)


state 7

    (24) impresion -> PRINT . LPAREN expression RPAREN

    LPAREN          shift and go to state 20


state 8

    (33) factor -> LPAREN . expression RPAREN
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . INTEGER
    (32) factor -> . ID
    (33) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 17
    ID              shift and go to state 22
    LPAREN          shift and go to state 8

    expression                     shift and go to state 21
    term                           shift and go to state 9
    factor                         shift and go to state 14

state 9

    (27) expression -> term .
    (28) term -> term . TIMES factor
    (29) term -> term . DIVIDE factor

    PLUS            reduce using rule 27 (expression -> term .)
    MINUS           reduce using rule 27 (expression -> term .)
    $end            reduce using rule 27 (expression -> term .)
    GREATER         reduce using rule 27 (expression -> term .)
    SMALLER         reduce using rule 27 (expression -> term .)
    GREATER_OR_EQUAL reduce using rule 27 (expression -> term .)
    SMALLER_OR_EQUAL reduce using rule 27 (expression -> term .)
    EQUAL_COMPARE   reduce using rule 27 (expression -> term .)
    NOT_EQUAL       reduce using rule 27 (expression -> term .)
    RPAREN          reduce using rule 27 (expression -> term .)
    RLLAVE          reduce using rule 27 (expression -> term .)
    AND             reduce using rule 27 (expression -> term .)
    OR              reduce using rule 27 (expression -> term .)
    TIMES           shift and go to state 23
    DIVIDE          shift and go to state 24


state 10

    (6) cicloFor -> FOR . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 25


state 11

    (7) comparison -> value . op value
    (10) op -> . GREATER
    (11) op -> . SMALLER
    (12) op -> . GREATER_OR_EQUAL
    (13) op -> . SMALLER_OR_EQUAL
    (14) op -> . EQUAL_COMPARE
    (15) op -> . NOT_EQUAL

    GREATER         shift and go to state 27
    SMALLER         shift and go to state 28
    GREATER_OR_EQUAL shift and go to state 29
    SMALLER_OR_EQUAL shift and go to state 30
    EQUAL_COMPARE   shift and go to state 31
    NOT_EQUAL       shift and go to state 32

    op                             shift and go to state 26

state 12

    (16) logic_operation -> logic_value . logic_op logic_value
    (22) logic_op -> . AND
    (23) logic_op -> . OR

    AND             shift and go to state 34
    OR              shift and go to state 35

    logic_op                       shift and go to state 33

state 13

    (17) logic_operation -> negation .
    (18) logic_value -> negation .

    $end            reduce using rule 17 (logic_operation -> negation .)
    RLLAVE          reduce using rule 17 (logic_operation -> negation .)
    AND             reduce using rule 18 (logic_value -> negation .)
    OR              reduce using rule 18 (logic_value -> negation .)


state 14

    (30) term -> factor .

    TIMES           reduce using rule 30 (term -> factor .)
    DIVIDE          reduce using rule 30 (term -> factor .)
    PLUS            reduce using rule 30 (term -> factor .)
    MINUS           reduce using rule 30 (term -> factor .)
    $end            reduce using rule 30 (term -> factor .)
    GREATER         reduce using rule 30 (term -> factor .)
    SMALLER         reduce using rule 30 (term -> factor .)
    GREATER_OR_EQUAL reduce using rule 30 (term -> factor .)
    SMALLER_OR_EQUAL reduce using rule 30 (term -> factor .)
    EQUAL_COMPARE   reduce using rule 30 (term -> factor .)
    NOT_EQUAL       reduce using rule 30 (term -> factor .)
    RPAREN          reduce using rule 30 (term -> factor .)
    RLLAVE          reduce using rule 30 (term -> factor .)
    AND             reduce using rule 30 (term -> factor .)
    OR              reduce using rule 30 (term -> factor .)


state 15

    (8) value -> ID .
    (32) factor -> ID .

  ! reduce/reduce conflict for $end resolved using rule 8 (value -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 8 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 8 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 8 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 8 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 8 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 8 (value -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 8 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 8 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 8 (value -> ID .)
    GREATER         reduce using rule 8 (value -> ID .)
    SMALLER         reduce using rule 8 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 8 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 8 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 8 (value -> ID .)
    NOT_EQUAL       reduce using rule 8 (value -> ID .)
    $end            reduce using rule 8 (value -> ID .)
    AND             reduce using rule 8 (value -> ID .)
    OR              reduce using rule 8 (value -> ID .)
    RLLAVE          reduce using rule 8 (value -> ID .)
    TIMES           reduce using rule 32 (factor -> ID .)
    DIVIDE          reduce using rule 32 (factor -> ID .)
    PLUS            reduce using rule 32 (factor -> ID .)
    MINUS           reduce using rule 32 (factor -> ID .)

  ! $end            [ reduce using rule 32 (factor -> ID .) ]
  ! GREATER         [ reduce using rule 32 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 32 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 32 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 32 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 32 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 32 (factor -> ID .) ]
  ! RLLAVE          [ reduce using rule 32 (factor -> ID .) ]
  ! AND             [ reduce using rule 32 (factor -> ID .) ]
  ! OR              [ reduce using rule 32 (factor -> ID .) ]


state 16

    (20) negation -> NOT . comparison
    (21) negation -> NOT . ID
    (7) comparison -> . value op value
    (8) value -> . ID
    (9) value -> . expression
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . INTEGER
    (32) factor -> . ID
    (33) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 37
    INTEGER         shift and go to state 17
    LPAREN          shift and go to state 8

    comparison                     shift and go to state 36
    value                          shift and go to state 11
    expression                     shift and go to state 38
    term                           shift and go to state 9
    factor                         shift and go to state 14

state 17

    (31) factor -> INTEGER .

    TIMES           reduce using rule 31 (factor -> INTEGER .)
    DIVIDE          reduce using rule 31 (factor -> INTEGER .)
    PLUS            reduce using rule 31 (factor -> INTEGER .)
    MINUS           reduce using rule 31 (factor -> INTEGER .)
    $end            reduce using rule 31 (factor -> INTEGER .)
    GREATER         reduce using rule 31 (factor -> INTEGER .)
    SMALLER         reduce using rule 31 (factor -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 31 (factor -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 31 (factor -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 31 (factor -> INTEGER .)
    NOT_EQUAL       reduce using rule 31 (factor -> INTEGER .)
    RPAREN          reduce using rule 31 (factor -> INTEGER .)
    RLLAVE          reduce using rule 31 (factor -> INTEGER .)
    AND             reduce using rule 31 (factor -> INTEGER .)
    OR              reduce using rule 31 (factor -> INTEGER .)


state 18

    (25) expression -> expression PLUS . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . INTEGER
    (32) factor -> . ID
    (33) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 17
    ID              shift and go to state 22
    LPAREN          shift and go to state 8

    term                           shift and go to state 39
    factor                         shift and go to state 14

state 19

    (26) expression -> expression MINUS . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . INTEGER
    (32) factor -> . ID
    (33) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 17
    ID              shift and go to state 22
    LPAREN          shift and go to state 8

    term                           shift and go to state 40
    factor                         shift and go to state 14

state 20

    (24) impresion -> PRINT LPAREN . expression RPAREN
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . INTEGER
    (32) factor -> . ID
    (33) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 17
    ID              shift and go to state 22
    LPAREN          shift and go to state 8

    expression                     shift and go to state 41
    term                           shift and go to state 9
    factor                         shift and go to state 14

state 21

    (33) factor -> LPAREN expression . RPAREN
    (25) expression -> expression . PLUS term
    (26) expression -> expression . MINUS term

    RPAREN          shift and go to state 42
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19


state 22

    (32) factor -> ID .

    TIMES           reduce using rule 32 (factor -> ID .)
    DIVIDE          reduce using rule 32 (factor -> ID .)
    RPAREN          reduce using rule 32 (factor -> ID .)
    PLUS            reduce using rule 32 (factor -> ID .)
    MINUS           reduce using rule 32 (factor -> ID .)
    $end            reduce using rule 32 (factor -> ID .)
    GREATER         reduce using rule 32 (factor -> ID .)
    SMALLER         reduce using rule 32 (factor -> ID .)
    GREATER_OR_EQUAL reduce using rule 32 (factor -> ID .)
    SMALLER_OR_EQUAL reduce using rule 32 (factor -> ID .)
    EQUAL_COMPARE   reduce using rule 32 (factor -> ID .)
    NOT_EQUAL       reduce using rule 32 (factor -> ID .)
    RLLAVE          reduce using rule 32 (factor -> ID .)
    AND             reduce using rule 32 (factor -> ID .)
    OR              reduce using rule 32 (factor -> ID .)


state 23

    (28) term -> term TIMES . factor
    (31) factor -> . INTEGER
    (32) factor -> . ID
    (33) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 17
    ID              shift and go to state 22
    LPAREN          shift and go to state 8

    factor                         shift and go to state 43

state 24

    (29) term -> term DIVIDE . factor
    (31) factor -> . INTEGER
    (32) factor -> . ID
    (33) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 17
    ID              shift and go to state 22
    LPAREN          shift and go to state 8

    factor                         shift and go to state 44

state 25

    (6) cicloFor -> FOR LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion
    (2) codigo -> . expression
    (3) codigo -> . cicloFor
    (4) codigo -> . comparison
    (5) codigo -> . logic_operation
    (24) impresion -> . PRINT LPAREN expression RPAREN
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (6) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (7) comparison -> . value op value
    (16) logic_operation -> . logic_value logic_op logic_value
    (17) logic_operation -> . negation
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (8) value -> . ID
    (9) value -> . expression
    (18) logic_value -> . negation
    (19) logic_value -> . comparison
    (20) negation -> . NOT comparison
    (21) negation -> . NOT ID
    (31) factor -> . INTEGER
    (32) factor -> . ID
    (33) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 7
    FOR             shift and go to state 10
    ID              shift and go to state 15
    NOT             shift and go to state 16
    INTEGER         shift and go to state 17
    LPAREN          shift and go to state 8

    codigo                         shift and go to state 45
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    term                           shift and go to state 9
    value                          shift and go to state 11
    logic_value                    shift and go to state 12
    negation                       shift and go to state 13
    factor                         shift and go to state 14

state 26

    (7) comparison -> value op . value
    (8) value -> . ID
    (9) value -> . expression
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . INTEGER
    (32) factor -> . ID
    (33) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 15
    INTEGER         shift and go to state 17
    LPAREN          shift and go to state 8

    value                          shift and go to state 46
    expression                     shift and go to state 38
    term                           shift and go to state 9
    factor                         shift and go to state 14

state 27

    (10) op -> GREATER .

    ID              reduce using rule 10 (op -> GREATER .)
    INTEGER         reduce using rule 10 (op -> GREATER .)
    LPAREN          reduce using rule 10 (op -> GREATER .)


state 28

    (11) op -> SMALLER .

    ID              reduce using rule 11 (op -> SMALLER .)
    INTEGER         reduce using rule 11 (op -> SMALLER .)
    LPAREN          reduce using rule 11 (op -> SMALLER .)


state 29

    (12) op -> GREATER_OR_EQUAL .

    ID              reduce using rule 12 (op -> GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 12 (op -> GREATER_OR_EQUAL .)
    LPAREN          reduce using rule 12 (op -> GREATER_OR_EQUAL .)


state 30

    (13) op -> SMALLER_OR_EQUAL .

    ID              reduce using rule 13 (op -> SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 13 (op -> SMALLER_OR_EQUAL .)
    LPAREN          reduce using rule 13 (op -> SMALLER_OR_EQUAL .)


state 31

    (14) op -> EQUAL_COMPARE .

    ID              reduce using rule 14 (op -> EQUAL_COMPARE .)
    INTEGER         reduce using rule 14 (op -> EQUAL_COMPARE .)
    LPAREN          reduce using rule 14 (op -> EQUAL_COMPARE .)


state 32

    (15) op -> NOT_EQUAL .

    ID              reduce using rule 15 (op -> NOT_EQUAL .)
    INTEGER         reduce using rule 15 (op -> NOT_EQUAL .)
    LPAREN          reduce using rule 15 (op -> NOT_EQUAL .)


state 33

    (16) logic_operation -> logic_value logic_op . logic_value
    (18) logic_value -> . negation
    (19) logic_value -> . comparison
    (20) negation -> . NOT comparison
    (21) negation -> . NOT ID
    (7) comparison -> . value op value
    (8) value -> . ID
    (9) value -> . expression
    (25) expression -> . expression PLUS term
    (26) expression -> . expression MINUS term
    (27) expression -> . term
    (28) term -> . term TIMES factor
    (29) term -> . term DIVIDE factor
    (30) term -> . factor
    (31) factor -> . INTEGER
    (32) factor -> . ID
    (33) factor -> . LPAREN expression RPAREN

    NOT             shift and go to state 16
    ID              shift and go to state 15
    INTEGER         shift and go to state 17
    LPAREN          shift and go to state 8

    logic_value                    shift and go to state 47
    negation                       shift and go to state 48
    comparison                     shift and go to state 49
    value                          shift and go to state 11
    expression                     shift and go to state 38
    term                           shift and go to state 9
    factor                         shift and go to state 14

state 34

    (22) logic_op -> AND .

    NOT             reduce using rule 22 (logic_op -> AND .)
    ID              reduce using rule 22 (logic_op -> AND .)
    INTEGER         reduce using rule 22 (logic_op -> AND .)
    LPAREN          reduce using rule 22 (logic_op -> AND .)


state 35

    (23) logic_op -> OR .

    NOT             reduce using rule 23 (logic_op -> OR .)
    ID              reduce using rule 23 (logic_op -> OR .)
    INTEGER         reduce using rule 23 (logic_op -> OR .)
    LPAREN          reduce using rule 23 (logic_op -> OR .)


state 36

    (20) negation -> NOT comparison .

    $end            reduce using rule 20 (negation -> NOT comparison .)
    AND             reduce using rule 20 (negation -> NOT comparison .)
    OR              reduce using rule 20 (negation -> NOT comparison .)
    RLLAVE          reduce using rule 20 (negation -> NOT comparison .)


state 37

    (21) negation -> NOT ID .
    (8) value -> ID .
    (32) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 8 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 8 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 8 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 8 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 8 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 8 (value -> ID .)
    $end            reduce using rule 21 (negation -> NOT ID .)
    AND             reduce using rule 21 (negation -> NOT ID .)
    OR              reduce using rule 21 (negation -> NOT ID .)
    RLLAVE          reduce using rule 21 (negation -> NOT ID .)
    GREATER         reduce using rule 8 (value -> ID .)
    SMALLER         reduce using rule 8 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 8 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 8 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 8 (value -> ID .)
    NOT_EQUAL       reduce using rule 8 (value -> ID .)
    TIMES           reduce using rule 32 (factor -> ID .)
    DIVIDE          reduce using rule 32 (factor -> ID .)
    PLUS            reduce using rule 32 (factor -> ID .)
    MINUS           reduce using rule 32 (factor -> ID .)

  ! GREATER         [ reduce using rule 32 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 32 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 32 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 32 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 32 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 32 (factor -> ID .) ]


state 38

    (9) value -> expression .
    (25) expression -> expression . PLUS term
    (26) expression -> expression . MINUS term

    GREATER         reduce using rule 9 (value -> expression .)
    SMALLER         reduce using rule 9 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 9 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 9 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 9 (value -> expression .)
    NOT_EQUAL       reduce using rule 9 (value -> expression .)
    $end            reduce using rule 9 (value -> expression .)
    AND             reduce using rule 9 (value -> expression .)
    OR              reduce using rule 9 (value -> expression .)
    RLLAVE          reduce using rule 9 (value -> expression .)
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19


state 39

    (25) expression -> expression PLUS term .
    (28) term -> term . TIMES factor
    (29) term -> term . DIVIDE factor

    PLUS            reduce using rule 25 (expression -> expression PLUS term .)
    MINUS           reduce using rule 25 (expression -> expression PLUS term .)
    $end            reduce using rule 25 (expression -> expression PLUS term .)
    GREATER         reduce using rule 25 (expression -> expression PLUS term .)
    SMALLER         reduce using rule 25 (expression -> expression PLUS term .)
    GREATER_OR_EQUAL reduce using rule 25 (expression -> expression PLUS term .)
    SMALLER_OR_EQUAL reduce using rule 25 (expression -> expression PLUS term .)
    EQUAL_COMPARE   reduce using rule 25 (expression -> expression PLUS term .)
    NOT_EQUAL       reduce using rule 25 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 25 (expression -> expression PLUS term .)
    RLLAVE          reduce using rule 25 (expression -> expression PLUS term .)
    AND             reduce using rule 25 (expression -> expression PLUS term .)
    OR              reduce using rule 25 (expression -> expression PLUS term .)
    TIMES           shift and go to state 23
    DIVIDE          shift and go to state 24


state 40

    (26) expression -> expression MINUS term .
    (28) term -> term . TIMES factor
    (29) term -> term . DIVIDE factor

    PLUS            reduce using rule 26 (expression -> expression MINUS term .)
    MINUS           reduce using rule 26 (expression -> expression MINUS term .)
    $end            reduce using rule 26 (expression -> expression MINUS term .)
    GREATER         reduce using rule 26 (expression -> expression MINUS term .)
    SMALLER         reduce using rule 26 (expression -> expression MINUS term .)
    GREATER_OR_EQUAL reduce using rule 26 (expression -> expression MINUS term .)
    SMALLER_OR_EQUAL reduce using rule 26 (expression -> expression MINUS term .)
    EQUAL_COMPARE   reduce using rule 26 (expression -> expression MINUS term .)
    NOT_EQUAL       reduce using rule 26 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 26 (expression -> expression MINUS term .)
    RLLAVE          reduce using rule 26 (expression -> expression MINUS term .)
    AND             reduce using rule 26 (expression -> expression MINUS term .)
    OR              reduce using rule 26 (expression -> expression MINUS term .)
    TIMES           shift and go to state 23
    DIVIDE          shift and go to state 24


state 41

    (24) impresion -> PRINT LPAREN expression . RPAREN
    (25) expression -> expression . PLUS term
    (26) expression -> expression . MINUS term

    RPAREN          shift and go to state 50
    PLUS            shift and go to state 18
    MINUS           shift and go to state 19


state 42

    (33) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    SMALLER         reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    GREATER_OR_EQUAL reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    EQUAL_COMPARE   reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    RLLAVE          reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 33 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 33 (factor -> LPAREN expression RPAREN .)


state 43

    (28) term -> term TIMES factor .

    TIMES           reduce using rule 28 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 28 (term -> term TIMES factor .)
    PLUS            reduce using rule 28 (term -> term TIMES factor .)
    MINUS           reduce using rule 28 (term -> term TIMES factor .)
    $end            reduce using rule 28 (term -> term TIMES factor .)
    GREATER         reduce using rule 28 (term -> term TIMES factor .)
    SMALLER         reduce using rule 28 (term -> term TIMES factor .)
    GREATER_OR_EQUAL reduce using rule 28 (term -> term TIMES factor .)
    SMALLER_OR_EQUAL reduce using rule 28 (term -> term TIMES factor .)
    EQUAL_COMPARE   reduce using rule 28 (term -> term TIMES factor .)
    NOT_EQUAL       reduce using rule 28 (term -> term TIMES factor .)
    RPAREN          reduce using rule 28 (term -> term TIMES factor .)
    RLLAVE          reduce using rule 28 (term -> term TIMES factor .)
    AND             reduce using rule 28 (term -> term TIMES factor .)
    OR              reduce using rule 28 (term -> term TIMES factor .)


state 44

    (29) term -> term DIVIDE factor .

    TIMES           reduce using rule 29 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 29 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 29 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 29 (term -> term DIVIDE factor .)
    $end            reduce using rule 29 (term -> term DIVIDE factor .)
    GREATER         reduce using rule 29 (term -> term DIVIDE factor .)
    SMALLER         reduce using rule 29 (term -> term DIVIDE factor .)
    GREATER_OR_EQUAL reduce using rule 29 (term -> term DIVIDE factor .)
    SMALLER_OR_EQUAL reduce using rule 29 (term -> term DIVIDE factor .)
    EQUAL_COMPARE   reduce using rule 29 (term -> term DIVIDE factor .)
    NOT_EQUAL       reduce using rule 29 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 29 (term -> term DIVIDE factor .)
    RLLAVE          reduce using rule 29 (term -> term DIVIDE factor .)
    AND             reduce using rule 29 (term -> term DIVIDE factor .)
    OR              reduce using rule 29 (term -> term DIVIDE factor .)


state 45

    (6) cicloFor -> FOR LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 51


state 46

    (7) comparison -> value op value .

    $end            reduce using rule 7 (comparison -> value op value .)
    AND             reduce using rule 7 (comparison -> value op value .)
    OR              reduce using rule 7 (comparison -> value op value .)
    RLLAVE          reduce using rule 7 (comparison -> value op value .)


state 47

    (16) logic_operation -> logic_value logic_op logic_value .

    $end            reduce using rule 16 (logic_operation -> logic_value logic_op logic_value .)
    RLLAVE          reduce using rule 16 (logic_operation -> logic_value logic_op logic_value .)


state 48

    (18) logic_value -> negation .

    $end            reduce using rule 18 (logic_value -> negation .)
    RLLAVE          reduce using rule 18 (logic_value -> negation .)


state 49

    (19) logic_value -> comparison .

    $end            reduce using rule 19 (logic_value -> comparison .)
    RLLAVE          reduce using rule 19 (logic_value -> comparison .)


state 50

    (24) impresion -> PRINT LPAREN expression RPAREN .

    $end            reduce using rule 24 (impresion -> PRINT LPAREN expression RPAREN .)
    RLLAVE          reduce using rule 24 (impresion -> PRINT LPAREN expression RPAREN .)


state 51

    (6) cicloFor -> FOR LLLAVE codigo RLLAVE .

    $end            reduce using rule 6 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 6 (cicloFor -> FOR LLLAVE codigo RLLAVE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 15 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 15
WARNING: reduce/reduce conflict in state 37 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 37
