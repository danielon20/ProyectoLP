Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    CAP
    COMMENT
    CONST
    INTERFACE
    JOIN
    MAP
    MOD
    MULTI_COMMENT
    PACKAGE

Grammar

Rule 0     S' -> codigo
Rule 1     codigo -> impresion COLON
Rule 2     codigo -> impresion
Rule 3     codigo -> scan_func COLON
Rule 4     codigo -> scan_func
Rule 5     codigo -> expression COLON
Rule 6     codigo -> expression
Rule 7     codigo -> cicloFor
Rule 8     codigo -> comparison
Rule 9     codigo -> logic_operation
Rule 10    codigo -> decVar COLON
Rule 11    codigo -> decVar
Rule 12    codigo -> var_asignation
Rule 13    codigo -> var_asignation COLON
Rule 14    codigo -> funciones
Rule 15    codigo -> funciones COLON
Rule 16    codigo -> SenIF
Rule 17    codigo -> SenElseIF
Rule 18    codigo -> SenElse
Rule 19    codigo -> SenStruct
Rule 20    codigo -> cStruct
Rule 21    codigo -> switch_statement
Rule 22    codigo -> array_declaration COLON
Rule 23    codigo -> array_declaration
Rule 24    codigo -> array_var COLON
Rule 25    codigo -> array_var
Rule 26    codigo -> array_assignment COLON
Rule 27    codigo -> array_assignment
Rule 28    codigo -> slice_declaration COLON
Rule 29    codigo -> slice_declaration
Rule 30    codigo -> slice_var COLON
Rule 31    codigo -> slice_var
Rule 32    codigo -> slice_assignment COLON
Rule 33    codigo -> slice_assignment
Rule 34    codigo -> map_declaration COLON
Rule 35    codigo -> map_declaration
Rule 36    codigo -> map_assignment COLON
Rule 37    codigo -> map_assignment
Rule 38    codigo -> func_declaration
Rule 39    codigo -> main_func
Rule 40    values -> STRING
Rule 41    values -> INTEGER
Rule 42    values -> FLOAT
Rule 43    values -> TRUE
Rule 44    values -> FALSE
Rule 45    data_types -> INT32
Rule 46    data_types -> INT64
Rule 47    data_types -> FLOAT32
Rule 48    data_types -> FLOAT64
Rule 49    data_types -> BYTE
Rule 50    data_types -> WINT
Rule 51    data_types -> WFLOAT
Rule 52    data_types -> WSTRING
Rule 53    data_types -> BOOL
Rule 54    operations -> expression
Rule 55    operations -> comparison
Rule 56    operations -> logic_operation
Rule 57    data_structure -> array_var
Rule 58    data_structure -> map_var
Rule 59    var_asignation -> ID EQUAL any
Rule 60    any -> values
Rule 61    any -> operations
Rule 62    any -> ID
Rule 63    any -> data_structure
Rule 64    any -> funciones
Rule 65    arr_content -> LLLAVE items COMA more_items RLLAVE
Rule 66    arr_content -> LLLAVE items RLLAVE
Rule 67    more_items -> items COMA more_items
Rule 68    more_items -> items
Rule 69    items -> values
Rule 70    items -> operations
Rule 71    something -> ID
Rule 72    something -> data_structure
Rule 73    something -> values
Rule 74    something -> operations
Rule 75    main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
Rule 76    scan_func -> SCAN LPAREN POINTER RPAREN
Rule 77    cicloFor -> FOR LLLAVE codigo RLLAVE
Rule 78    cicloFor -> FOR comparison LLLAVE codigo RLLAVE
Rule 79    cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE
Rule 80    cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
Rule 81    incre -> ID INCREASE
Rule 82    incre -> ID DECREASE
Rule 83    decVar -> decVarOne
Rule 84    decVar -> VAR ID EQUAL INTEGER
Rule 85    decVar -> VAR ID EQUAL ID
Rule 86    decVar -> VAR ID EQUAL FLOAT
Rule 87    decVar -> VAR ID EQUAL expression
Rule 88    decVar -> VAR ID EQUAL logic_operation
Rule 89    decVar -> VAR ID EQUAL comparison
Rule 90    decVar -> VAR ID EQUAL STRING
Rule 91    decVar -> ID DEQUAL STRING
Rule 92    decVar -> ID DEQUAL FLOAT
Rule 93    decVar -> ID DEQUAL expression
Rule 94    decVar -> ID DEQUAL logic_operation
Rule 95    decVar -> ID DEQUAL comparison
Rule 96    slice_declaration -> VAR ID LCORCHE RCORCHE data_types
Rule 97    slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
Rule 98    slice_declaration -> VAR ID EQUAL funM
Rule 99    slice_declaration -> ID DEQUAL funM
Rule 100   slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content
Rule 101   funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
Rule 102   funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
Rule 103   cap -> INTEGER
Rule 104   cap -> ID
Rule 105   cap -> expression
Rule 106   slice_var -> ID LCORCHE index_s RCORCHE
Rule 107   index_s -> ID
Rule 108   index_s -> INTEGER
Rule 109   index_s -> expression
Rule 110   slice_assignment -> slice_var EQUAL something_s
Rule 111   something_s -> ID
Rule 112   something_s -> array_var
Rule 113   something_s -> values
Rule 114   something_s -> operations
Rule 115   funciones -> APPEND LPAREN ID COMA values RPAREN
Rule 116   funciones -> APPEND LPAREN ID COMA ID RPAREN
Rule 117   funciones -> LEN LPAREN ID RPAREN
Rule 118   funciones -> COPY LPAREN ID COMA ID RPAREN
Rule 119   funciones -> DELETE LPAREN ID COMA ID RPAREN
Rule 120   decVarOne -> ID DEQUAL ID
Rule 121   decVarOne -> ID DEQUAL INTEGER
Rule 122   SenIF -> IF comparison LLLAVE codigo RLLAVE
Rule 123   SenIF -> IF TRUE LLLAVE codigo RLLAVE
Rule 124   SenIF -> IF FALSE LLLAVE codigo RLLAVE
Rule 125   SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE
Rule 126   SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE
Rule 127   SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE
Rule 128   SenElse -> ELSE LLLAVE codigo RLLAVE
Rule 129   SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE
Rule 130   declaration -> variable data_types
Rule 131   declaration -> declaration variable data_types
Rule 132   variable -> ID
Rule 133   cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE
Rule 134   asignaciones -> ID POINTS valor
Rule 135   asignaciones -> ID POINTS valor COMA asignaciones
Rule 136   valor -> ID
Rule 137   valor -> INTEGER
Rule 138   valor -> TRUE
Rule 139   valor -> FALSE
Rule 140   comparison -> value op value
Rule 141   value -> ID
Rule 142   value -> expression
Rule 143   op -> GREATER
Rule 144   op -> SMALLER
Rule 145   op -> GREATER_OR_EQUAL
Rule 146   op -> SMALLER_OR_EQUAL
Rule 147   op -> EQUAL_COMPARE
Rule 148   op -> NOT_EQUAL
Rule 149   logic_operation -> logic_value logic_recu
Rule 150   logic_operation -> negation
Rule 151   logic_recu -> logic_op logic_value
Rule 152   logic_recu -> logic_op logic_value logic_recu
Rule 153   logic_value -> negation
Rule 154   logic_value -> comparison
Rule 155   logic_value -> ID
Rule 156   negation -> NOT comparison
Rule 157   negation -> NOT ID
Rule 158   logic_op -> AND
Rule 159   logic_op -> OR
Rule 160   switch_statement -> SWITCH ID LLLAVE cases RLLAVE
Rule 161   cases -> CASE values POINTS codigo
Rule 162   cases -> CASE values POINTS codigo more
Rule 163   more -> cases
Rule 164   more -> DEFAULT POINTS codigo
Rule 165   array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types
Rule 166   array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
Rule 167   capacity -> INTEGER
Rule 168   capacity -> ID
Rule 169   capacity -> expression
Rule 170   array_var -> ID LCORCHE index RCORCHE
Rule 171   index -> ID
Rule 172   index -> INTEGER
Rule 173   index -> expression
Rule 174   array_assignment -> array_var EQUAL something
Rule 175   map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types
Rule 176   map_var -> ID LCORCHE key RCORCHE
Rule 177   key -> ID
Rule 178   key -> values
Rule 179   key -> operations
Rule 180   map_assignment -> array_var EQUAL something
Rule 181   func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
Rule 182   func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
Rule 183   return_value -> retorno COLON
Rule 184   return_value -> retorno
Rule 185   retorno -> ID
Rule 186   retorno -> values
Rule 187   retorno -> operations
Rule 188   retorno -> data_structure
Rule 189   params -> ID data_types
Rule 190   params -> more_params
Rule 191   more_params -> ID data_types COMA params
Rule 192   impresion -> PRINT LPAREN content RPAREN
Rule 193   content -> values
Rule 194   content -> operations
Rule 195   content -> funciones
Rule 196   content -> data_structure
Rule 197   content -> ID
Rule 198   expression -> something_ex
Rule 199   expression -> something_ex adicionaEx
Rule 200   adicionaEx -> op something_ex
Rule 201   adicionaEx -> op something_ex adicionaEx
Rule 202   something_ex -> ID
Rule 203   something_ex -> INTEGER
Rule 204   something_ex -> FLOAT
Rule 205   something_ex -> data_structure
Rule 206   something_ex -> funciones
Rule 207   op -> PLUS
Rule 208   op -> TIMES
Rule 209   op -> DIVIDE
Rule 210   op -> MINUS

Terminals, with rules where they appear

AND                  : 158
APPEND               : 115 116
ARRAY                : 
BOOL                 : 53
BYTE                 : 49
CAP                  : 
CASE                 : 161 162
COLON                : 1 3 5 10 13 15 22 24 26 28 30 32 34 36 80 80 183
COMA                 : 65 67 101 102 102 115 116 118 119 135 191
COMMENT              : 
CONST                : 
COPY                 : 118
DECREASE             : 82
DEFAULT              : 164
DELETE               : 119
DEQUAL               : 91 92 93 94 95 99 100 120 121 133
DIVIDE               : 209
ELSE                 : 125 126 127 128
EQUAL                : 59 84 85 86 87 88 89 90 97 98 110 166 174 180
EQUAL_COMPARE        : 147
FALSE                : 44 124 127 139
FLOAT                : 42 86 92 204
FLOAT32              : 47
FLOAT64              : 48
FOR                  : 77 78 79 80
FUNC                 : 75 181 182
GREATER              : 143
GREATER_OR_EQUAL     : 145
ID                   : 59 62 71 81 82 84 85 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 104 106 107 111 115 116 116 117 118 118 119 119 120 120 121 129 132 133 133 134 135 136 141 155 157 160 165 166 168 170 171 175 176 177 181 182 185 189 191 197 202
IF                   : 122 123 124 125 126 127
INCREASE             : 81
INT32                : 45
INT64                : 46
INTEGER              : 41 84 103 108 121 137 167 172 203
INTERFACE            : 
JOIN                 : 
LCORCHE              : 96 97 100 101 102 106 165 166 170 175 176
LEN                  : 117
LLLAVE               : 65 66 75 77 78 79 80 122 123 124 125 126 127 128 129 133 160 181 182
LPAREN               : 75 76 101 102 115 116 117 118 119 181 182 192
MAIN                 : 75
MAKE                 : 101 102
MAP                  : 
MINUS                : 210
MOD                  : 
MULTI_COMMENT        : 
NOT                  : 156 157
NOT_EQUAL            : 148
OR                   : 159
PACKAGE              : 
PLUS                 : 207
POINTER              : 76
POINTS               : 134 135 161 162 164
PRINT                : 192
RCORCHE              : 96 97 100 101 102 106 165 166 170 175 176
RETURN               : 181 182
RLLAVE               : 65 66 75 77 78 79 80 122 123 124 125 126 127 128 129 133 160 181 182
RPAREN               : 75 76 101 102 115 116 117 118 119 181 182 192
SCAN                 : 76
SMALLER              : 144
SMALLER_OR_EQUAL     : 146
STRING               : 40 90 91
STRUCT               : 129
SWITCH               : 160
TIMES                : 208
TRUE                 : 43 123 126 138
TYPE                 : 129
VAR                  : 84 85 86 87 88 89 90 96 97 98 165 166 175
WFLOAT               : 51
WINT                 : 50
WSTRING              : 52
error                : 

Nonterminals, with rules where they appear

SenElse              : 18
SenElseIF            : 17
SenIF                : 16
SenStruct            : 19
adicionaEx           : 199 201
any                  : 59
arr_content          : 97 100 166
array_assignment     : 26 27
array_declaration    : 22 23
array_var            : 24 25 57 112 174 180
asignaciones         : 133 135
cStruct              : 20
cap                  : 101 102 102
capacity             : 165 166
cases                : 160 163
cicloFor             : 7
codigo               : 75 77 78 79 80 122 123 124 125 126 127 128 161 162 164 181 0
comparison           : 8 55 78 80 89 95 122 125 154 156
content              : 192
data_structure       : 63 72 188 196 205
data_types           : 96 97 100 101 102 130 131 165 166 175 175 181 182 189 191
decVar               : 10 11
decVarOne            : 80 83
declaration          : 129 131
expression           : 5 6 54 87 93 105 109 142 169 173
funM                 : 98 99
func_declaration     : 38
funciones            : 14 15 64 195 206
impresion            : 1 2
incre                : 80
index                : 170
index_s              : 106
items                : 65 66 67 68
key                  : 176
logic_op             : 151 152
logic_operation      : 9 56 79 88 94
logic_recu           : 149 152
logic_value          : 149 151 152
main_func            : 39
map_assignment       : 36 37
map_declaration      : 34 35
map_var              : 58
more                 : 162
more_items           : 65 67
more_params          : 190
negation             : 150 153
op                   : 140 200 201
operations           : 61 70 74 114 179 187 194
params               : 181 182 191
retorno              : 181 183 184
return_value         : 182
scan_func            : 3 4
slice_assignment     : 32 33
slice_declaration    : 28 29
slice_var            : 30 31 110
something            : 174 180
something_ex         : 198 199 200 201
something_s          : 110
switch_statement     : 21
valor                : 134 135
value                : 140 140
values               : 60 69 73 113 115 161 162 178 186 193
var_asignation       : 12 13
variable             : 130 131

Parsing method: LALR

state 0

    (0) S' -> . codigo
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenElseIF
    (18) codigo -> . SenElse
    (19) codigo -> . SenStruct
    (20) codigo -> . cStruct
    (21) codigo -> . switch_statement
    (22) codigo -> . array_declaration COLON
    (23) codigo -> . array_declaration
    (24) codigo -> . array_var COLON
    (25) codigo -> . array_var
    (26) codigo -> . array_assignment COLON
    (27) codigo -> . array_assignment
    (28) codigo -> . slice_declaration COLON
    (29) codigo -> . slice_declaration
    (30) codigo -> . slice_var COLON
    (31) codigo -> . slice_var
    (32) codigo -> . slice_assignment COLON
    (33) codigo -> . slice_assignment
    (34) codigo -> . map_declaration COLON
    (35) codigo -> . map_declaration
    (36) codigo -> . map_assignment COLON
    (37) codigo -> . map_assignment
    (38) codigo -> . func_declaration
    (39) codigo -> . main_func
    (192) impresion -> . PRINT LPAREN content RPAREN
    (76) scan_func -> . SCAN LPAREN POINTER RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (77) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (83) decVar -> . decVarOne
    (84) decVar -> . VAR ID EQUAL INTEGER
    (85) decVar -> . VAR ID EQUAL ID
    (86) decVar -> . VAR ID EQUAL FLOAT
    (87) decVar -> . VAR ID EQUAL expression
    (88) decVar -> . VAR ID EQUAL logic_operation
    (89) decVar -> . VAR ID EQUAL comparison
    (90) decVar -> . VAR ID EQUAL STRING
    (91) decVar -> . ID DEQUAL STRING
    (92) decVar -> . ID DEQUAL FLOAT
    (93) decVar -> . ID DEQUAL expression
    (94) decVar -> . ID DEQUAL logic_operation
    (95) decVar -> . ID DEQUAL comparison
    (59) var_asignation -> . ID EQUAL any
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (122) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (123) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (125) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (129) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (160) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (165) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (170) array_var -> . ID LCORCHE index RCORCHE
    (174) array_assignment -> . array_var EQUAL something
    (96) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> . VAR ID EQUAL funM
    (99) slice_declaration -> . ID DEQUAL funM
    (100) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> . ID LCORCHE index_s RCORCHE
    (110) slice_assignment -> . slice_var EQUAL something_s
    (175) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (180) map_assignment -> . array_var EQUAL something
    (181) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (176) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 27
    SCAN            shift and go to state 28
    FOR             shift and go to state 30
    VAR             shift and go to state 35
    ID              shift and go to state 36
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 43
    ELSE            shift and go to state 44
    TYPE            shift and go to state 45
    SWITCH          shift and go to state 46
    FUNC            shift and go to state 47
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    NOT             shift and go to state 49

    codigo                         shift and go to state 1
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenElseIF                      shift and go to state 12
    SenElse                        shift and go to state 13
    SenStruct                      shift and go to state 14
    cStruct                        shift and go to state 15
    switch_statement               shift and go to state 16
    array_declaration              shift and go to state 17
    array_var                      shift and go to state 18
    array_assignment               shift and go to state 19
    slice_declaration              shift and go to state 20
    slice_var                      shift and go to state 21
    slice_assignment               shift and go to state 22
    map_declaration                shift and go to state 23
    map_assignment                 shift and go to state 24
    func_declaration               shift and go to state 25
    main_func                      shift and go to state 26
    something_ex                   shift and go to state 29
    decVarOne                      shift and go to state 31
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    map_var                        shift and go to state 50

state 1

    (0) S' -> codigo .



state 2

    (1) codigo -> impresion . COLON
    (2) codigo -> impresion .

    COLON           shift and go to state 51
    $end            reduce using rule 2 (codigo -> impresion .)
    RLLAVE          reduce using rule 2 (codigo -> impresion .)
    DEFAULT         reduce using rule 2 (codigo -> impresion .)
    CASE            reduce using rule 2 (codigo -> impresion .)
    RETURN          reduce using rule 2 (codigo -> impresion .)


state 3

    (3) codigo -> scan_func . COLON
    (4) codigo -> scan_func .

    COLON           shift and go to state 52
    $end            reduce using rule 4 (codigo -> scan_func .)
    RLLAVE          reduce using rule 4 (codigo -> scan_func .)
    DEFAULT         reduce using rule 4 (codigo -> scan_func .)
    CASE            reduce using rule 4 (codigo -> scan_func .)
    RETURN          reduce using rule 4 (codigo -> scan_func .)


state 4

    (5) codigo -> expression . COLON
    (6) codigo -> expression .
    (142) value -> expression .

    COLON           shift and go to state 53
    $end            reduce using rule 6 (codigo -> expression .)
    RLLAVE          reduce using rule 6 (codigo -> expression .)
    DEFAULT         reduce using rule 6 (codigo -> expression .)
    CASE            reduce using rule 6 (codigo -> expression .)
    RETURN          reduce using rule 6 (codigo -> expression .)
    GREATER         reduce using rule 142 (value -> expression .)
    SMALLER         reduce using rule 142 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 142 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 142 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 142 (value -> expression .)
    NOT_EQUAL       reduce using rule 142 (value -> expression .)
    PLUS            reduce using rule 142 (value -> expression .)
    TIMES           reduce using rule 142 (value -> expression .)
    DIVIDE          reduce using rule 142 (value -> expression .)
    MINUS           reduce using rule 142 (value -> expression .)


state 5

    (7) codigo -> cicloFor .

    $end            reduce using rule 7 (codigo -> cicloFor .)
    RLLAVE          reduce using rule 7 (codigo -> cicloFor .)
    DEFAULT         reduce using rule 7 (codigo -> cicloFor .)
    CASE            reduce using rule 7 (codigo -> cicloFor .)
    RETURN          reduce using rule 7 (codigo -> cicloFor .)


state 6

    (8) codigo -> comparison .
    (154) logic_value -> comparison .

    $end            reduce using rule 8 (codigo -> comparison .)
    RLLAVE          reduce using rule 8 (codigo -> comparison .)
    DEFAULT         reduce using rule 8 (codigo -> comparison .)
    CASE            reduce using rule 8 (codigo -> comparison .)
    RETURN          reduce using rule 8 (codigo -> comparison .)
    AND             reduce using rule 154 (logic_value -> comparison .)
    OR              reduce using rule 154 (logic_value -> comparison .)


state 7

    (9) codigo -> logic_operation .

    $end            reduce using rule 9 (codigo -> logic_operation .)
    RLLAVE          reduce using rule 9 (codigo -> logic_operation .)
    DEFAULT         reduce using rule 9 (codigo -> logic_operation .)
    CASE            reduce using rule 9 (codigo -> logic_operation .)
    RETURN          reduce using rule 9 (codigo -> logic_operation .)


state 8

    (10) codigo -> decVar . COLON
    (11) codigo -> decVar .

    COLON           shift and go to state 54
    $end            reduce using rule 11 (codigo -> decVar .)
    RLLAVE          reduce using rule 11 (codigo -> decVar .)
    DEFAULT         reduce using rule 11 (codigo -> decVar .)
    CASE            reduce using rule 11 (codigo -> decVar .)
    RETURN          reduce using rule 11 (codigo -> decVar .)


state 9

    (12) codigo -> var_asignation .
    (13) codigo -> var_asignation . COLON

    $end            reduce using rule 12 (codigo -> var_asignation .)
    RLLAVE          reduce using rule 12 (codigo -> var_asignation .)
    DEFAULT         reduce using rule 12 (codigo -> var_asignation .)
    CASE            reduce using rule 12 (codigo -> var_asignation .)
    RETURN          reduce using rule 12 (codigo -> var_asignation .)
    COLON           shift and go to state 55


state 10

    (14) codigo -> funciones .
    (15) codigo -> funciones . COLON
    (206) something_ex -> funciones .

  ! shift/reduce conflict for COLON resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 14 (codigo -> funciones .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 14 (codigo -> funciones .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 14 (codigo -> funciones .)
  ! reduce/reduce conflict for CASE resolved using rule 14 (codigo -> funciones .)
  ! reduce/reduce conflict for RETURN resolved using rule 14 (codigo -> funciones .)
    $end            reduce using rule 14 (codigo -> funciones .)
    RLLAVE          reduce using rule 14 (codigo -> funciones .)
    DEFAULT         reduce using rule 14 (codigo -> funciones .)
    CASE            reduce using rule 14 (codigo -> funciones .)
    RETURN          reduce using rule 14 (codigo -> funciones .)
    COLON           shift and go to state 56
    GREATER         reduce using rule 206 (something_ex -> funciones .)
    SMALLER         reduce using rule 206 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 206 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 206 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 206 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 206 (something_ex -> funciones .)
    PLUS            reduce using rule 206 (something_ex -> funciones .)
    TIMES           reduce using rule 206 (something_ex -> funciones .)
    DIVIDE          reduce using rule 206 (something_ex -> funciones .)
    MINUS           reduce using rule 206 (something_ex -> funciones .)

  ! COLON           [ reduce using rule 206 (something_ex -> funciones .) ]
  ! $end            [ reduce using rule 206 (something_ex -> funciones .) ]
  ! RLLAVE          [ reduce using rule 206 (something_ex -> funciones .) ]
  ! DEFAULT         [ reduce using rule 206 (something_ex -> funciones .) ]
  ! CASE            [ reduce using rule 206 (something_ex -> funciones .) ]
  ! RETURN          [ reduce using rule 206 (something_ex -> funciones .) ]


state 11

    (16) codigo -> SenIF .

    $end            reduce using rule 16 (codigo -> SenIF .)
    RLLAVE          reduce using rule 16 (codigo -> SenIF .)
    DEFAULT         reduce using rule 16 (codigo -> SenIF .)
    CASE            reduce using rule 16 (codigo -> SenIF .)
    RETURN          reduce using rule 16 (codigo -> SenIF .)


state 12

    (17) codigo -> SenElseIF .

    $end            reduce using rule 17 (codigo -> SenElseIF .)
    RLLAVE          reduce using rule 17 (codigo -> SenElseIF .)
    DEFAULT         reduce using rule 17 (codigo -> SenElseIF .)
    CASE            reduce using rule 17 (codigo -> SenElseIF .)
    RETURN          reduce using rule 17 (codigo -> SenElseIF .)


state 13

    (18) codigo -> SenElse .

    $end            reduce using rule 18 (codigo -> SenElse .)
    RLLAVE          reduce using rule 18 (codigo -> SenElse .)
    DEFAULT         reduce using rule 18 (codigo -> SenElse .)
    CASE            reduce using rule 18 (codigo -> SenElse .)
    RETURN          reduce using rule 18 (codigo -> SenElse .)


state 14

    (19) codigo -> SenStruct .

    $end            reduce using rule 19 (codigo -> SenStruct .)
    RLLAVE          reduce using rule 19 (codigo -> SenStruct .)
    DEFAULT         reduce using rule 19 (codigo -> SenStruct .)
    CASE            reduce using rule 19 (codigo -> SenStruct .)
    RETURN          reduce using rule 19 (codigo -> SenStruct .)


state 15

    (20) codigo -> cStruct .

    $end            reduce using rule 20 (codigo -> cStruct .)
    RLLAVE          reduce using rule 20 (codigo -> cStruct .)
    DEFAULT         reduce using rule 20 (codigo -> cStruct .)
    CASE            reduce using rule 20 (codigo -> cStruct .)
    RETURN          reduce using rule 20 (codigo -> cStruct .)


state 16

    (21) codigo -> switch_statement .

    $end            reduce using rule 21 (codigo -> switch_statement .)
    RLLAVE          reduce using rule 21 (codigo -> switch_statement .)
    DEFAULT         reduce using rule 21 (codigo -> switch_statement .)
    CASE            reduce using rule 21 (codigo -> switch_statement .)
    RETURN          reduce using rule 21 (codigo -> switch_statement .)


state 17

    (22) codigo -> array_declaration . COLON
    (23) codigo -> array_declaration .

    COLON           shift and go to state 57
    $end            reduce using rule 23 (codigo -> array_declaration .)
    RLLAVE          reduce using rule 23 (codigo -> array_declaration .)
    DEFAULT         reduce using rule 23 (codigo -> array_declaration .)
    CASE            reduce using rule 23 (codigo -> array_declaration .)
    RETURN          reduce using rule 23 (codigo -> array_declaration .)


state 18

    (24) codigo -> array_var . COLON
    (25) codigo -> array_var .
    (174) array_assignment -> array_var . EQUAL something
    (180) map_assignment -> array_var . EQUAL something
    (57) data_structure -> array_var .

  ! shift/reduce conflict for COLON resolved as shift
  ! reduce/reduce conflict for $end resolved using rule 25 (codigo -> array_var .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 25 (codigo -> array_var .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 25 (codigo -> array_var .)
  ! reduce/reduce conflict for CASE resolved using rule 25 (codigo -> array_var .)
  ! reduce/reduce conflict for RETURN resolved using rule 25 (codigo -> array_var .)
    COLON           shift and go to state 58
    $end            reduce using rule 25 (codigo -> array_var .)
    RLLAVE          reduce using rule 25 (codigo -> array_var .)
    DEFAULT         reduce using rule 25 (codigo -> array_var .)
    CASE            reduce using rule 25 (codigo -> array_var .)
    RETURN          reduce using rule 25 (codigo -> array_var .)
    EQUAL           shift and go to state 59
    GREATER         reduce using rule 57 (data_structure -> array_var .)
    SMALLER         reduce using rule 57 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 57 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 57 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 57 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 57 (data_structure -> array_var .)
    PLUS            reduce using rule 57 (data_structure -> array_var .)
    TIMES           reduce using rule 57 (data_structure -> array_var .)
    DIVIDE          reduce using rule 57 (data_structure -> array_var .)
    MINUS           reduce using rule 57 (data_structure -> array_var .)

  ! COLON           [ reduce using rule 57 (data_structure -> array_var .) ]
  ! $end            [ reduce using rule 57 (data_structure -> array_var .) ]
  ! RLLAVE          [ reduce using rule 57 (data_structure -> array_var .) ]
  ! DEFAULT         [ reduce using rule 57 (data_structure -> array_var .) ]
  ! CASE            [ reduce using rule 57 (data_structure -> array_var .) ]
  ! RETURN          [ reduce using rule 57 (data_structure -> array_var .) ]


state 19

    (26) codigo -> array_assignment . COLON
    (27) codigo -> array_assignment .

    COLON           shift and go to state 60
    $end            reduce using rule 27 (codigo -> array_assignment .)
    RLLAVE          reduce using rule 27 (codigo -> array_assignment .)
    DEFAULT         reduce using rule 27 (codigo -> array_assignment .)
    CASE            reduce using rule 27 (codigo -> array_assignment .)
    RETURN          reduce using rule 27 (codigo -> array_assignment .)


state 20

    (28) codigo -> slice_declaration . COLON
    (29) codigo -> slice_declaration .

    COLON           shift and go to state 61
    $end            reduce using rule 29 (codigo -> slice_declaration .)
    RLLAVE          reduce using rule 29 (codigo -> slice_declaration .)
    DEFAULT         reduce using rule 29 (codigo -> slice_declaration .)
    CASE            reduce using rule 29 (codigo -> slice_declaration .)
    RETURN          reduce using rule 29 (codigo -> slice_declaration .)


state 21

    (30) codigo -> slice_var . COLON
    (31) codigo -> slice_var .
    (110) slice_assignment -> slice_var . EQUAL something_s

    COLON           shift and go to state 62
    $end            reduce using rule 31 (codigo -> slice_var .)
    RLLAVE          reduce using rule 31 (codigo -> slice_var .)
    DEFAULT         reduce using rule 31 (codigo -> slice_var .)
    CASE            reduce using rule 31 (codigo -> slice_var .)
    RETURN          reduce using rule 31 (codigo -> slice_var .)
    EQUAL           shift and go to state 63


state 22

    (32) codigo -> slice_assignment . COLON
    (33) codigo -> slice_assignment .

    COLON           shift and go to state 64
    $end            reduce using rule 33 (codigo -> slice_assignment .)
    RLLAVE          reduce using rule 33 (codigo -> slice_assignment .)
    DEFAULT         reduce using rule 33 (codigo -> slice_assignment .)
    CASE            reduce using rule 33 (codigo -> slice_assignment .)
    RETURN          reduce using rule 33 (codigo -> slice_assignment .)


state 23

    (34) codigo -> map_declaration . COLON
    (35) codigo -> map_declaration .

    COLON           shift and go to state 65
    $end            reduce using rule 35 (codigo -> map_declaration .)
    RLLAVE          reduce using rule 35 (codigo -> map_declaration .)
    DEFAULT         reduce using rule 35 (codigo -> map_declaration .)
    CASE            reduce using rule 35 (codigo -> map_declaration .)
    RETURN          reduce using rule 35 (codigo -> map_declaration .)


state 24

    (36) codigo -> map_assignment . COLON
    (37) codigo -> map_assignment .

    COLON           shift and go to state 66
    $end            reduce using rule 37 (codigo -> map_assignment .)
    RLLAVE          reduce using rule 37 (codigo -> map_assignment .)
    DEFAULT         reduce using rule 37 (codigo -> map_assignment .)
    CASE            reduce using rule 37 (codigo -> map_assignment .)
    RETURN          reduce using rule 37 (codigo -> map_assignment .)


state 25

    (38) codigo -> func_declaration .

    $end            reduce using rule 38 (codigo -> func_declaration .)
    RLLAVE          reduce using rule 38 (codigo -> func_declaration .)
    DEFAULT         reduce using rule 38 (codigo -> func_declaration .)
    CASE            reduce using rule 38 (codigo -> func_declaration .)
    RETURN          reduce using rule 38 (codigo -> func_declaration .)


state 26

    (39) codigo -> main_func .

    $end            reduce using rule 39 (codigo -> main_func .)
    RLLAVE          reduce using rule 39 (codigo -> main_func .)
    DEFAULT         reduce using rule 39 (codigo -> main_func .)
    CASE            reduce using rule 39 (codigo -> main_func .)
    RETURN          reduce using rule 39 (codigo -> main_func .)


state 27

    (192) impresion -> PRINT . LPAREN content RPAREN

    LPAREN          shift and go to state 67


state 28

    (76) scan_func -> SCAN . LPAREN POINTER RPAREN

    LPAREN          shift and go to state 68


state 29

    (198) expression -> something_ex .
    (199) expression -> something_ex . adicionaEx
    (200) adicionaEx -> . op something_ex
    (201) adicionaEx -> . op something_ex adicionaEx
    (143) op -> . GREATER
    (144) op -> . SMALLER
    (145) op -> . GREATER_OR_EQUAL
    (146) op -> . SMALLER_OR_EQUAL
    (147) op -> . EQUAL_COMPARE
    (148) op -> . NOT_EQUAL
    (207) op -> . PLUS
    (208) op -> . TIMES
    (209) op -> . DIVIDE
    (210) op -> . MINUS

  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL_COMPARE resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    COLON           reduce using rule 198 (expression -> something_ex .)
    $end            reduce using rule 198 (expression -> something_ex .)
    RLLAVE          reduce using rule 198 (expression -> something_ex .)
    DEFAULT         reduce using rule 198 (expression -> something_ex .)
    CASE            reduce using rule 198 (expression -> something_ex .)
    RETURN          reduce using rule 198 (expression -> something_ex .)
    RPAREN          reduce using rule 198 (expression -> something_ex .)
    AND             reduce using rule 198 (expression -> something_ex .)
    OR              reduce using rule 198 (expression -> something_ex .)
    LLLAVE          reduce using rule 198 (expression -> something_ex .)
    RCORCHE         reduce using rule 198 (expression -> something_ex .)
    COMA            reduce using rule 198 (expression -> something_ex .)
    GREATER         shift and go to state 71
    SMALLER         shift and go to state 72
    GREATER_OR_EQUAL shift and go to state 73
    SMALLER_OR_EQUAL shift and go to state 74
    EQUAL_COMPARE   shift and go to state 75
    NOT_EQUAL       shift and go to state 76
    PLUS            shift and go to state 77
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 79
    MINUS           shift and go to state 80

  ! GREATER         [ reduce using rule 198 (expression -> something_ex .) ]
  ! SMALLER         [ reduce using rule 198 (expression -> something_ex .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 198 (expression -> something_ex .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 198 (expression -> something_ex .) ]
  ! EQUAL_COMPARE   [ reduce using rule 198 (expression -> something_ex .) ]
  ! NOT_EQUAL       [ reduce using rule 198 (expression -> something_ex .) ]
  ! PLUS            [ reduce using rule 198 (expression -> something_ex .) ]
  ! TIMES           [ reduce using rule 198 (expression -> something_ex .) ]
  ! DIVIDE          [ reduce using rule 198 (expression -> something_ex .) ]
  ! MINUS           [ reduce using rule 198 (expression -> something_ex .) ]

    adicionaEx                     shift and go to state 69
    op                             shift and go to state 70

state 30

    (77) cicloFor -> FOR . LLLAVE codigo RLLAVE
    (78) cicloFor -> FOR . comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> FOR . logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> FOR . decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    LLLAVE          shift and go to state 81
    ID              shift and go to state 85
    NOT             shift and go to state 49
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    comparison                     shift and go to state 82
    logic_operation                shift and go to state 83
    decVarOne                      shift and go to state 84
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    expression                     shift and go to state 86
    something_ex                   shift and go to state 29
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 31

    (83) decVar -> decVarOne .

    COLON           reduce using rule 83 (decVar -> decVarOne .)
    $end            reduce using rule 83 (decVar -> decVarOne .)
    RLLAVE          reduce using rule 83 (decVar -> decVarOne .)
    DEFAULT         reduce using rule 83 (decVar -> decVarOne .)
    CASE            reduce using rule 83 (decVar -> decVarOne .)
    RETURN          reduce using rule 83 (decVar -> decVarOne .)


state 32

    (140) comparison -> value . op value
    (143) op -> . GREATER
    (144) op -> . SMALLER
    (145) op -> . GREATER_OR_EQUAL
    (146) op -> . SMALLER_OR_EQUAL
    (147) op -> . EQUAL_COMPARE
    (148) op -> . NOT_EQUAL
    (207) op -> . PLUS
    (208) op -> . TIMES
    (209) op -> . DIVIDE
    (210) op -> . MINUS

    GREATER         shift and go to state 71
    SMALLER         shift and go to state 72
    GREATER_OR_EQUAL shift and go to state 73
    SMALLER_OR_EQUAL shift and go to state 74
    EQUAL_COMPARE   shift and go to state 75
    NOT_EQUAL       shift and go to state 76
    PLUS            shift and go to state 77
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 79
    MINUS           shift and go to state 80

    op                             shift and go to state 89

state 33

    (149) logic_operation -> logic_value . logic_recu
    (151) logic_recu -> . logic_op logic_value
    (152) logic_recu -> . logic_op logic_value logic_recu
    (158) logic_op -> . AND
    (159) logic_op -> . OR

    AND             shift and go to state 92
    OR              shift and go to state 93

    logic_recu                     shift and go to state 90
    logic_op                       shift and go to state 91

state 34

    (150) logic_operation -> negation .
    (153) logic_value -> negation .

    $end            reduce using rule 150 (logic_operation -> negation .)
    LLLAVE          reduce using rule 150 (logic_operation -> negation .)
    COLON           reduce using rule 150 (logic_operation -> negation .)
    RLLAVE          reduce using rule 150 (logic_operation -> negation .)
    DEFAULT         reduce using rule 150 (logic_operation -> negation .)
    CASE            reduce using rule 150 (logic_operation -> negation .)
    RETURN          reduce using rule 150 (logic_operation -> negation .)
    RPAREN          reduce using rule 150 (logic_operation -> negation .)
    RCORCHE         reduce using rule 150 (logic_operation -> negation .)
    COMA            reduce using rule 150 (logic_operation -> negation .)
    AND             reduce using rule 153 (logic_value -> negation .)
    OR              reduce using rule 153 (logic_value -> negation .)


state 35

    (84) decVar -> VAR . ID EQUAL INTEGER
    (85) decVar -> VAR . ID EQUAL ID
    (86) decVar -> VAR . ID EQUAL FLOAT
    (87) decVar -> VAR . ID EQUAL expression
    (88) decVar -> VAR . ID EQUAL logic_operation
    (89) decVar -> VAR . ID EQUAL comparison
    (90) decVar -> VAR . ID EQUAL STRING
    (165) array_declaration -> VAR . ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> VAR . ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (96) slice_declaration -> VAR . ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> VAR . ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> VAR . ID EQUAL funM
    (175) map_declaration -> VAR . ID LCORCHE data_types RCORCHE data_types

    ID              shift and go to state 94


state 36

    (91) decVar -> ID . DEQUAL STRING
    (92) decVar -> ID . DEQUAL FLOAT
    (93) decVar -> ID . DEQUAL expression
    (94) decVar -> ID . DEQUAL logic_operation
    (95) decVar -> ID . DEQUAL comparison
    (59) var_asignation -> ID . EQUAL any
    (133) cStruct -> ID . DEQUAL ID LLLAVE asignaciones RLLAVE
    (170) array_var -> ID . LCORCHE index RCORCHE
    (99) slice_declaration -> ID . DEQUAL funM
    (100) slice_declaration -> ID . DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> ID . LCORCHE index_s RCORCHE
    (202) something_ex -> ID .
    (141) value -> ID .
    (155) logic_value -> ID .
    (120) decVarOne -> ID . DEQUAL ID
    (121) decVarOne -> ID . DEQUAL INTEGER
    (176) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 141 (value -> ID .)
    DEQUAL          shift and go to state 95
    EQUAL           shift and go to state 96
    LCORCHE         shift and go to state 97
    COLON           reduce using rule 202 (something_ex -> ID .)
    $end            reduce using rule 202 (something_ex -> ID .)
    RLLAVE          reduce using rule 202 (something_ex -> ID .)
    DEFAULT         reduce using rule 202 (something_ex -> ID .)
    CASE            reduce using rule 202 (something_ex -> ID .)
    RETURN          reduce using rule 202 (something_ex -> ID .)
    GREATER         reduce using rule 141 (value -> ID .)
    SMALLER         reduce using rule 141 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 141 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 141 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 141 (value -> ID .)
    NOT_EQUAL       reduce using rule 141 (value -> ID .)
    PLUS            reduce using rule 141 (value -> ID .)
    TIMES           reduce using rule 141 (value -> ID .)
    DIVIDE          reduce using rule 141 (value -> ID .)
    MINUS           reduce using rule 141 (value -> ID .)
    AND             reduce using rule 155 (logic_value -> ID .)
    OR              reduce using rule 155 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 202 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 202 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 202 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 202 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 202 (something_ex -> ID .) ]


state 37

    (203) something_ex -> INTEGER .

    GREATER         reduce using rule 203 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 203 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 203 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 203 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 203 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 203 (something_ex -> INTEGER .)
    PLUS            reduce using rule 203 (something_ex -> INTEGER .)
    TIMES           reduce using rule 203 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 203 (something_ex -> INTEGER .)
    MINUS           reduce using rule 203 (something_ex -> INTEGER .)
    COLON           reduce using rule 203 (something_ex -> INTEGER .)
    $end            reduce using rule 203 (something_ex -> INTEGER .)
    RLLAVE          reduce using rule 203 (something_ex -> INTEGER .)
    DEFAULT         reduce using rule 203 (something_ex -> INTEGER .)
    CASE            reduce using rule 203 (something_ex -> INTEGER .)
    RETURN          reduce using rule 203 (something_ex -> INTEGER .)
    RPAREN          reduce using rule 203 (something_ex -> INTEGER .)
    AND             reduce using rule 203 (something_ex -> INTEGER .)
    OR              reduce using rule 203 (something_ex -> INTEGER .)
    LLLAVE          reduce using rule 203 (something_ex -> INTEGER .)
    RCORCHE         reduce using rule 203 (something_ex -> INTEGER .)
    COMA            reduce using rule 203 (something_ex -> INTEGER .)


state 38

    (204) something_ex -> FLOAT .

    GREATER         reduce using rule 204 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 204 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 204 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 204 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 204 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 204 (something_ex -> FLOAT .)
    PLUS            reduce using rule 204 (something_ex -> FLOAT .)
    TIMES           reduce using rule 204 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 204 (something_ex -> FLOAT .)
    MINUS           reduce using rule 204 (something_ex -> FLOAT .)
    COLON           reduce using rule 204 (something_ex -> FLOAT .)
    $end            reduce using rule 204 (something_ex -> FLOAT .)
    RLLAVE          reduce using rule 204 (something_ex -> FLOAT .)
    DEFAULT         reduce using rule 204 (something_ex -> FLOAT .)
    CASE            reduce using rule 204 (something_ex -> FLOAT .)
    RETURN          reduce using rule 204 (something_ex -> FLOAT .)
    RPAREN          reduce using rule 204 (something_ex -> FLOAT .)
    AND             reduce using rule 204 (something_ex -> FLOAT .)
    OR              reduce using rule 204 (something_ex -> FLOAT .)
    LLLAVE          reduce using rule 204 (something_ex -> FLOAT .)
    RCORCHE         reduce using rule 204 (something_ex -> FLOAT .)
    COMA            reduce using rule 204 (something_ex -> FLOAT .)


state 39

    (115) funciones -> APPEND . LPAREN ID COMA values RPAREN
    (116) funciones -> APPEND . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 98


state 40

    (117) funciones -> LEN . LPAREN ID RPAREN

    LPAREN          shift and go to state 99


state 41

    (118) funciones -> COPY . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 100


state 42

    (119) funciones -> DELETE . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 101


state 43

    (122) SenIF -> IF . comparison LLLAVE codigo RLLAVE
    (123) SenIF -> IF . TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> IF . FALSE LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (141) value -> . ID
    (142) value -> . expression
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    TRUE            shift and go to state 103
    FALSE           shift and go to state 104
    ID              shift and go to state 105
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    comparison                     shift and go to state 102
    value                          shift and go to state 32
    expression                     shift and go to state 86
    something_ex                   shift and go to state 29
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 44

    (125) SenElseIF -> ELSE . IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> ELSE . IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> ELSE . IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> ELSE . LLLAVE codigo RLLAVE

    IF              shift and go to state 106
    LLLAVE          shift and go to state 107


state 45

    (129) SenStruct -> TYPE . ID STRUCT LLLAVE declaration RLLAVE

    ID              shift and go to state 108


state 46

    (160) switch_statement -> SWITCH . ID LLLAVE cases RLLAVE

    ID              shift and go to state 109


state 47

    (181) func_declaration -> FUNC . ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> FUNC . ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> FUNC . MAIN LPAREN RPAREN LLLAVE codigo RLLAVE

    ID              shift and go to state 110
    MAIN            shift and go to state 111


state 48

    (205) something_ex -> data_structure .

    GREATER         reduce using rule 205 (something_ex -> data_structure .)
    SMALLER         reduce using rule 205 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 205 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 205 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 205 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 205 (something_ex -> data_structure .)
    PLUS            reduce using rule 205 (something_ex -> data_structure .)
    TIMES           reduce using rule 205 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 205 (something_ex -> data_structure .)
    MINUS           reduce using rule 205 (something_ex -> data_structure .)
    COLON           reduce using rule 205 (something_ex -> data_structure .)
    $end            reduce using rule 205 (something_ex -> data_structure .)
    RLLAVE          reduce using rule 205 (something_ex -> data_structure .)
    DEFAULT         reduce using rule 205 (something_ex -> data_structure .)
    CASE            reduce using rule 205 (something_ex -> data_structure .)
    RETURN          reduce using rule 205 (something_ex -> data_structure .)
    RPAREN          reduce using rule 205 (something_ex -> data_structure .)
    AND             reduce using rule 205 (something_ex -> data_structure .)
    OR              reduce using rule 205 (something_ex -> data_structure .)
    LLLAVE          reduce using rule 205 (something_ex -> data_structure .)
    RCORCHE         reduce using rule 205 (something_ex -> data_structure .)
    COMA            reduce using rule 205 (something_ex -> data_structure .)


state 49

    (156) negation -> NOT . comparison
    (157) negation -> NOT . ID
    (140) comparison -> . value op value
    (141) value -> . ID
    (142) value -> . expression
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 113
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    comparison                     shift and go to state 112
    value                          shift and go to state 32
    expression                     shift and go to state 86
    something_ex                   shift and go to state 29
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 50

    (58) data_structure -> map_var .

    GREATER         reduce using rule 58 (data_structure -> map_var .)
    SMALLER         reduce using rule 58 (data_structure -> map_var .)
    GREATER_OR_EQUAL reduce using rule 58 (data_structure -> map_var .)
    SMALLER_OR_EQUAL reduce using rule 58 (data_structure -> map_var .)
    EQUAL_COMPARE   reduce using rule 58 (data_structure -> map_var .)
    NOT_EQUAL       reduce using rule 58 (data_structure -> map_var .)
    PLUS            reduce using rule 58 (data_structure -> map_var .)
    TIMES           reduce using rule 58 (data_structure -> map_var .)
    DIVIDE          reduce using rule 58 (data_structure -> map_var .)
    MINUS           reduce using rule 58 (data_structure -> map_var .)
    COLON           reduce using rule 58 (data_structure -> map_var .)
    $end            reduce using rule 58 (data_structure -> map_var .)
    RLLAVE          reduce using rule 58 (data_structure -> map_var .)
    DEFAULT         reduce using rule 58 (data_structure -> map_var .)
    CASE            reduce using rule 58 (data_structure -> map_var .)
    RETURN          reduce using rule 58 (data_structure -> map_var .)
    RPAREN          reduce using rule 58 (data_structure -> map_var .)
    AND             reduce using rule 58 (data_structure -> map_var .)
    OR              reduce using rule 58 (data_structure -> map_var .)
    LLLAVE          reduce using rule 58 (data_structure -> map_var .)
    RCORCHE         reduce using rule 58 (data_structure -> map_var .)
    COMA            reduce using rule 58 (data_structure -> map_var .)


state 51

    (1) codigo -> impresion COLON .

    $end            reduce using rule 1 (codigo -> impresion COLON .)
    RLLAVE          reduce using rule 1 (codigo -> impresion COLON .)
    DEFAULT         reduce using rule 1 (codigo -> impresion COLON .)
    CASE            reduce using rule 1 (codigo -> impresion COLON .)
    RETURN          reduce using rule 1 (codigo -> impresion COLON .)


state 52

    (3) codigo -> scan_func COLON .

    $end            reduce using rule 3 (codigo -> scan_func COLON .)
    RLLAVE          reduce using rule 3 (codigo -> scan_func COLON .)
    DEFAULT         reduce using rule 3 (codigo -> scan_func COLON .)
    CASE            reduce using rule 3 (codigo -> scan_func COLON .)
    RETURN          reduce using rule 3 (codigo -> scan_func COLON .)


state 53

    (5) codigo -> expression COLON .

    $end            reduce using rule 5 (codigo -> expression COLON .)
    RLLAVE          reduce using rule 5 (codigo -> expression COLON .)
    DEFAULT         reduce using rule 5 (codigo -> expression COLON .)
    CASE            reduce using rule 5 (codigo -> expression COLON .)
    RETURN          reduce using rule 5 (codigo -> expression COLON .)


state 54

    (10) codigo -> decVar COLON .

    $end            reduce using rule 10 (codigo -> decVar COLON .)
    RLLAVE          reduce using rule 10 (codigo -> decVar COLON .)
    DEFAULT         reduce using rule 10 (codigo -> decVar COLON .)
    CASE            reduce using rule 10 (codigo -> decVar COLON .)
    RETURN          reduce using rule 10 (codigo -> decVar COLON .)


state 55

    (13) codigo -> var_asignation COLON .

    $end            reduce using rule 13 (codigo -> var_asignation COLON .)
    RLLAVE          reduce using rule 13 (codigo -> var_asignation COLON .)
    DEFAULT         reduce using rule 13 (codigo -> var_asignation COLON .)
    CASE            reduce using rule 13 (codigo -> var_asignation COLON .)
    RETURN          reduce using rule 13 (codigo -> var_asignation COLON .)


state 56

    (15) codigo -> funciones COLON .

    $end            reduce using rule 15 (codigo -> funciones COLON .)
    RLLAVE          reduce using rule 15 (codigo -> funciones COLON .)
    DEFAULT         reduce using rule 15 (codigo -> funciones COLON .)
    CASE            reduce using rule 15 (codigo -> funciones COLON .)
    RETURN          reduce using rule 15 (codigo -> funciones COLON .)


state 57

    (22) codigo -> array_declaration COLON .

    $end            reduce using rule 22 (codigo -> array_declaration COLON .)
    RLLAVE          reduce using rule 22 (codigo -> array_declaration COLON .)
    DEFAULT         reduce using rule 22 (codigo -> array_declaration COLON .)
    CASE            reduce using rule 22 (codigo -> array_declaration COLON .)
    RETURN          reduce using rule 22 (codigo -> array_declaration COLON .)


state 58

    (24) codigo -> array_var COLON .

    $end            reduce using rule 24 (codigo -> array_var COLON .)
    RLLAVE          reduce using rule 24 (codigo -> array_var COLON .)
    DEFAULT         reduce using rule 24 (codigo -> array_var COLON .)
    CASE            reduce using rule 24 (codigo -> array_var COLON .)
    RETURN          reduce using rule 24 (codigo -> array_var COLON .)


state 59

    (174) array_assignment -> array_var EQUAL . something
    (180) map_assignment -> array_var EQUAL . something
    (71) something -> . ID
    (72) something -> . data_structure
    (73) something -> . values
    (74) something -> . operations
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (40) values -> . STRING
    (41) values -> . INTEGER
    (42) values -> . FLOAT
    (43) values -> . TRUE
    (44) values -> . FALSE
    (54) operations -> . expression
    (55) operations -> . comparison
    (56) operations -> . logic_operation
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN

    ID              shift and go to state 115
    STRING          shift and go to state 119
    INTEGER         shift and go to state 120
    FLOAT           shift and go to state 121
    TRUE            shift and go to state 122
    FALSE           shift and go to state 123
    NOT             shift and go to state 49
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    array_var                      shift and go to state 88
    something                      shift and go to state 114
    data_structure                 shift and go to state 116
    values                         shift and go to state 117
    operations                     shift and go to state 118
    map_var                        shift and go to state 50
    expression                     shift and go to state 124
    comparison                     shift and go to state 125
    logic_operation                shift and go to state 126
    something_ex                   shift and go to state 29
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    funciones                      shift and go to state 87

state 60

    (26) codigo -> array_assignment COLON .

    $end            reduce using rule 26 (codigo -> array_assignment COLON .)
    RLLAVE          reduce using rule 26 (codigo -> array_assignment COLON .)
    DEFAULT         reduce using rule 26 (codigo -> array_assignment COLON .)
    CASE            reduce using rule 26 (codigo -> array_assignment COLON .)
    RETURN          reduce using rule 26 (codigo -> array_assignment COLON .)


state 61

    (28) codigo -> slice_declaration COLON .

    $end            reduce using rule 28 (codigo -> slice_declaration COLON .)
    RLLAVE          reduce using rule 28 (codigo -> slice_declaration COLON .)
    DEFAULT         reduce using rule 28 (codigo -> slice_declaration COLON .)
    CASE            reduce using rule 28 (codigo -> slice_declaration COLON .)
    RETURN          reduce using rule 28 (codigo -> slice_declaration COLON .)


state 62

    (30) codigo -> slice_var COLON .

    $end            reduce using rule 30 (codigo -> slice_var COLON .)
    RLLAVE          reduce using rule 30 (codigo -> slice_var COLON .)
    DEFAULT         reduce using rule 30 (codigo -> slice_var COLON .)
    CASE            reduce using rule 30 (codigo -> slice_var COLON .)
    RETURN          reduce using rule 30 (codigo -> slice_var COLON .)


state 63

    (110) slice_assignment -> slice_var EQUAL . something_s
    (111) something_s -> . ID
    (112) something_s -> . array_var
    (113) something_s -> . values
    (114) something_s -> . operations
    (170) array_var -> . ID LCORCHE index RCORCHE
    (40) values -> . STRING
    (41) values -> . INTEGER
    (42) values -> . FLOAT
    (43) values -> . TRUE
    (44) values -> . FALSE
    (54) operations -> . expression
    (55) operations -> . comparison
    (56) operations -> . logic_operation
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (176) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 128
    STRING          shift and go to state 119
    INTEGER         shift and go to state 120
    FLOAT           shift and go to state 121
    TRUE            shift and go to state 122
    FALSE           shift and go to state 123
    NOT             shift and go to state 49
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    something_s                    shift and go to state 127
    array_var                      shift and go to state 129
    values                         shift and go to state 130
    operations                     shift and go to state 131
    expression                     shift and go to state 124
    comparison                     shift and go to state 125
    logic_operation                shift and go to state 126
    something_ex                   shift and go to state 29
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    map_var                        shift and go to state 50

state 64

    (32) codigo -> slice_assignment COLON .

    $end            reduce using rule 32 (codigo -> slice_assignment COLON .)
    RLLAVE          reduce using rule 32 (codigo -> slice_assignment COLON .)
    DEFAULT         reduce using rule 32 (codigo -> slice_assignment COLON .)
    CASE            reduce using rule 32 (codigo -> slice_assignment COLON .)
    RETURN          reduce using rule 32 (codigo -> slice_assignment COLON .)


state 65

    (34) codigo -> map_declaration COLON .

    $end            reduce using rule 34 (codigo -> map_declaration COLON .)
    RLLAVE          reduce using rule 34 (codigo -> map_declaration COLON .)
    DEFAULT         reduce using rule 34 (codigo -> map_declaration COLON .)
    CASE            reduce using rule 34 (codigo -> map_declaration COLON .)
    RETURN          reduce using rule 34 (codigo -> map_declaration COLON .)


state 66

    (36) codigo -> map_assignment COLON .

    $end            reduce using rule 36 (codigo -> map_assignment COLON .)
    RLLAVE          reduce using rule 36 (codigo -> map_assignment COLON .)
    DEFAULT         reduce using rule 36 (codigo -> map_assignment COLON .)
    CASE            reduce using rule 36 (codigo -> map_assignment COLON .)
    RETURN          reduce using rule 36 (codigo -> map_assignment COLON .)


state 67

    (192) impresion -> PRINT LPAREN . content RPAREN
    (193) content -> . values
    (194) content -> . operations
    (195) content -> . funciones
    (196) content -> . data_structure
    (197) content -> . ID
    (40) values -> . STRING
    (41) values -> . INTEGER
    (42) values -> . FLOAT
    (43) values -> . TRUE
    (44) values -> . FALSE
    (54) operations -> . expression
    (55) operations -> . comparison
    (56) operations -> . logic_operation
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID

    ID              shift and go to state 137
    STRING          shift and go to state 119
    INTEGER         shift and go to state 120
    FLOAT           shift and go to state 121
    TRUE            shift and go to state 122
    FALSE           shift and go to state 123
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    NOT             shift and go to state 49

    content                        shift and go to state 132
    values                         shift and go to state 133
    operations                     shift and go to state 134
    funciones                      shift and go to state 135
    data_structure                 shift and go to state 136
    expression                     shift and go to state 124
    comparison                     shift and go to state 125
    logic_operation                shift and go to state 126
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50
    something_ex                   shift and go to state 29
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34

state 68

    (76) scan_func -> SCAN LPAREN . POINTER RPAREN

    POINTER         shift and go to state 138


state 69

    (199) expression -> something_ex adicionaEx .

    COLON           reduce using rule 199 (expression -> something_ex adicionaEx .)
    $end            reduce using rule 199 (expression -> something_ex adicionaEx .)
    GREATER         reduce using rule 199 (expression -> something_ex adicionaEx .)
    SMALLER         reduce using rule 199 (expression -> something_ex adicionaEx .)
    GREATER_OR_EQUAL reduce using rule 199 (expression -> something_ex adicionaEx .)
    SMALLER_OR_EQUAL reduce using rule 199 (expression -> something_ex adicionaEx .)
    EQUAL_COMPARE   reduce using rule 199 (expression -> something_ex adicionaEx .)
    NOT_EQUAL       reduce using rule 199 (expression -> something_ex adicionaEx .)
    PLUS            reduce using rule 199 (expression -> something_ex adicionaEx .)
    TIMES           reduce using rule 199 (expression -> something_ex adicionaEx .)
    DIVIDE          reduce using rule 199 (expression -> something_ex adicionaEx .)
    MINUS           reduce using rule 199 (expression -> something_ex adicionaEx .)
    RLLAVE          reduce using rule 199 (expression -> something_ex adicionaEx .)
    DEFAULT         reduce using rule 199 (expression -> something_ex adicionaEx .)
    CASE            reduce using rule 199 (expression -> something_ex adicionaEx .)
    RETURN          reduce using rule 199 (expression -> something_ex adicionaEx .)
    RPAREN          reduce using rule 199 (expression -> something_ex adicionaEx .)
    AND             reduce using rule 199 (expression -> something_ex adicionaEx .)
    OR              reduce using rule 199 (expression -> something_ex adicionaEx .)
    LLLAVE          reduce using rule 199 (expression -> something_ex adicionaEx .)
    RCORCHE         reduce using rule 199 (expression -> something_ex adicionaEx .)
    COMA            reduce using rule 199 (expression -> something_ex adicionaEx .)


state 70

    (200) adicionaEx -> op . something_ex
    (201) adicionaEx -> op . something_ex adicionaEx
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 140
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    something_ex                   shift and go to state 139
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 71

    (143) op -> GREATER .

    ID              reduce using rule 143 (op -> GREATER .)
    INTEGER         reduce using rule 143 (op -> GREATER .)
    FLOAT           reduce using rule 143 (op -> GREATER .)
    APPEND          reduce using rule 143 (op -> GREATER .)
    LEN             reduce using rule 143 (op -> GREATER .)
    COPY            reduce using rule 143 (op -> GREATER .)
    DELETE          reduce using rule 143 (op -> GREATER .)


state 72

    (144) op -> SMALLER .

    ID              reduce using rule 144 (op -> SMALLER .)
    INTEGER         reduce using rule 144 (op -> SMALLER .)
    FLOAT           reduce using rule 144 (op -> SMALLER .)
    APPEND          reduce using rule 144 (op -> SMALLER .)
    LEN             reduce using rule 144 (op -> SMALLER .)
    COPY            reduce using rule 144 (op -> SMALLER .)
    DELETE          reduce using rule 144 (op -> SMALLER .)


state 73

    (145) op -> GREATER_OR_EQUAL .

    ID              reduce using rule 145 (op -> GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 145 (op -> GREATER_OR_EQUAL .)
    FLOAT           reduce using rule 145 (op -> GREATER_OR_EQUAL .)
    APPEND          reduce using rule 145 (op -> GREATER_OR_EQUAL .)
    LEN             reduce using rule 145 (op -> GREATER_OR_EQUAL .)
    COPY            reduce using rule 145 (op -> GREATER_OR_EQUAL .)
    DELETE          reduce using rule 145 (op -> GREATER_OR_EQUAL .)


state 74

    (146) op -> SMALLER_OR_EQUAL .

    ID              reduce using rule 146 (op -> SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 146 (op -> SMALLER_OR_EQUAL .)
    FLOAT           reduce using rule 146 (op -> SMALLER_OR_EQUAL .)
    APPEND          reduce using rule 146 (op -> SMALLER_OR_EQUAL .)
    LEN             reduce using rule 146 (op -> SMALLER_OR_EQUAL .)
    COPY            reduce using rule 146 (op -> SMALLER_OR_EQUAL .)
    DELETE          reduce using rule 146 (op -> SMALLER_OR_EQUAL .)


state 75

    (147) op -> EQUAL_COMPARE .

    ID              reduce using rule 147 (op -> EQUAL_COMPARE .)
    INTEGER         reduce using rule 147 (op -> EQUAL_COMPARE .)
    FLOAT           reduce using rule 147 (op -> EQUAL_COMPARE .)
    APPEND          reduce using rule 147 (op -> EQUAL_COMPARE .)
    LEN             reduce using rule 147 (op -> EQUAL_COMPARE .)
    COPY            reduce using rule 147 (op -> EQUAL_COMPARE .)
    DELETE          reduce using rule 147 (op -> EQUAL_COMPARE .)


state 76

    (148) op -> NOT_EQUAL .

    ID              reduce using rule 148 (op -> NOT_EQUAL .)
    INTEGER         reduce using rule 148 (op -> NOT_EQUAL .)
    FLOAT           reduce using rule 148 (op -> NOT_EQUAL .)
    APPEND          reduce using rule 148 (op -> NOT_EQUAL .)
    LEN             reduce using rule 148 (op -> NOT_EQUAL .)
    COPY            reduce using rule 148 (op -> NOT_EQUAL .)
    DELETE          reduce using rule 148 (op -> NOT_EQUAL .)


state 77

    (207) op -> PLUS .

    ID              reduce using rule 207 (op -> PLUS .)
    INTEGER         reduce using rule 207 (op -> PLUS .)
    FLOAT           reduce using rule 207 (op -> PLUS .)
    APPEND          reduce using rule 207 (op -> PLUS .)
    LEN             reduce using rule 207 (op -> PLUS .)
    COPY            reduce using rule 207 (op -> PLUS .)
    DELETE          reduce using rule 207 (op -> PLUS .)


state 78

    (208) op -> TIMES .

    ID              reduce using rule 208 (op -> TIMES .)
    INTEGER         reduce using rule 208 (op -> TIMES .)
    FLOAT           reduce using rule 208 (op -> TIMES .)
    APPEND          reduce using rule 208 (op -> TIMES .)
    LEN             reduce using rule 208 (op -> TIMES .)
    COPY            reduce using rule 208 (op -> TIMES .)
    DELETE          reduce using rule 208 (op -> TIMES .)


state 79

    (209) op -> DIVIDE .

    ID              reduce using rule 209 (op -> DIVIDE .)
    INTEGER         reduce using rule 209 (op -> DIVIDE .)
    FLOAT           reduce using rule 209 (op -> DIVIDE .)
    APPEND          reduce using rule 209 (op -> DIVIDE .)
    LEN             reduce using rule 209 (op -> DIVIDE .)
    COPY            reduce using rule 209 (op -> DIVIDE .)
    DELETE          reduce using rule 209 (op -> DIVIDE .)


state 80

    (210) op -> MINUS .

    ID              reduce using rule 210 (op -> MINUS .)
    INTEGER         reduce using rule 210 (op -> MINUS .)
    FLOAT           reduce using rule 210 (op -> MINUS .)
    APPEND          reduce using rule 210 (op -> MINUS .)
    LEN             reduce using rule 210 (op -> MINUS .)
    COPY            reduce using rule 210 (op -> MINUS .)
    DELETE          reduce using rule 210 (op -> MINUS .)


state 81

    (77) cicloFor -> FOR LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenElseIF
    (18) codigo -> . SenElse
    (19) codigo -> . SenStruct
    (20) codigo -> . cStruct
    (21) codigo -> . switch_statement
    (22) codigo -> . array_declaration COLON
    (23) codigo -> . array_declaration
    (24) codigo -> . array_var COLON
    (25) codigo -> . array_var
    (26) codigo -> . array_assignment COLON
    (27) codigo -> . array_assignment
    (28) codigo -> . slice_declaration COLON
    (29) codigo -> . slice_declaration
    (30) codigo -> . slice_var COLON
    (31) codigo -> . slice_var
    (32) codigo -> . slice_assignment COLON
    (33) codigo -> . slice_assignment
    (34) codigo -> . map_declaration COLON
    (35) codigo -> . map_declaration
    (36) codigo -> . map_assignment COLON
    (37) codigo -> . map_assignment
    (38) codigo -> . func_declaration
    (39) codigo -> . main_func
    (192) impresion -> . PRINT LPAREN content RPAREN
    (76) scan_func -> . SCAN LPAREN POINTER RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (77) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (83) decVar -> . decVarOne
    (84) decVar -> . VAR ID EQUAL INTEGER
    (85) decVar -> . VAR ID EQUAL ID
    (86) decVar -> . VAR ID EQUAL FLOAT
    (87) decVar -> . VAR ID EQUAL expression
    (88) decVar -> . VAR ID EQUAL logic_operation
    (89) decVar -> . VAR ID EQUAL comparison
    (90) decVar -> . VAR ID EQUAL STRING
    (91) decVar -> . ID DEQUAL STRING
    (92) decVar -> . ID DEQUAL FLOAT
    (93) decVar -> . ID DEQUAL expression
    (94) decVar -> . ID DEQUAL logic_operation
    (95) decVar -> . ID DEQUAL comparison
    (59) var_asignation -> . ID EQUAL any
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (122) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (123) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (125) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (129) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (160) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (165) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (170) array_var -> . ID LCORCHE index RCORCHE
    (174) array_assignment -> . array_var EQUAL something
    (96) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> . VAR ID EQUAL funM
    (99) slice_declaration -> . ID DEQUAL funM
    (100) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> . ID LCORCHE index_s RCORCHE
    (110) slice_assignment -> . slice_var EQUAL something_s
    (175) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (180) map_assignment -> . array_var EQUAL something
    (181) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (176) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 27
    SCAN            shift and go to state 28
    FOR             shift and go to state 30
    VAR             shift and go to state 35
    ID              shift and go to state 36
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 43
    ELSE            shift and go to state 44
    TYPE            shift and go to state 45
    SWITCH          shift and go to state 46
    FUNC            shift and go to state 47
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    NOT             shift and go to state 49

    codigo                         shift and go to state 141
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenElseIF                      shift and go to state 12
    SenElse                        shift and go to state 13
    SenStruct                      shift and go to state 14
    cStruct                        shift and go to state 15
    switch_statement               shift and go to state 16
    array_declaration              shift and go to state 17
    array_var                      shift and go to state 18
    array_assignment               shift and go to state 19
    slice_declaration              shift and go to state 20
    slice_var                      shift and go to state 21
    slice_assignment               shift and go to state 22
    map_declaration                shift and go to state 23
    map_assignment                 shift and go to state 24
    func_declaration               shift and go to state 25
    main_func                      shift and go to state 26
    something_ex                   shift and go to state 29
    decVarOne                      shift and go to state 31
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    map_var                        shift and go to state 50

state 82

    (78) cicloFor -> FOR comparison . LLLAVE codigo RLLAVE
    (154) logic_value -> comparison .

    LLLAVE          shift and go to state 142
    AND             reduce using rule 154 (logic_value -> comparison .)
    OR              reduce using rule 154 (logic_value -> comparison .)


state 83

    (79) cicloFor -> FOR logic_operation . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 143


state 84

    (80) cicloFor -> FOR decVarOne . COLON comparison COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 144


state 85

    (120) decVarOne -> ID . DEQUAL ID
    (121) decVarOne -> ID . DEQUAL INTEGER
    (141) value -> ID .
    (155) logic_value -> ID .
    (202) something_ex -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (176) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 141 (value -> ID .)
    DEQUAL          shift and go to state 145
    GREATER         reduce using rule 141 (value -> ID .)
    SMALLER         reduce using rule 141 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 141 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 141 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 141 (value -> ID .)
    NOT_EQUAL       reduce using rule 141 (value -> ID .)
    PLUS            reduce using rule 141 (value -> ID .)
    TIMES           reduce using rule 141 (value -> ID .)
    DIVIDE          reduce using rule 141 (value -> ID .)
    MINUS           reduce using rule 141 (value -> ID .)
    AND             reduce using rule 155 (logic_value -> ID .)
    OR              reduce using rule 155 (logic_value -> ID .)
    LCORCHE         shift and go to state 146

  ! GREATER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 202 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 202 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 202 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 202 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 202 (something_ex -> ID .) ]


state 86

    (142) value -> expression .

    GREATER         reduce using rule 142 (value -> expression .)
    SMALLER         reduce using rule 142 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 142 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 142 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 142 (value -> expression .)
    NOT_EQUAL       reduce using rule 142 (value -> expression .)
    PLUS            reduce using rule 142 (value -> expression .)
    TIMES           reduce using rule 142 (value -> expression .)
    DIVIDE          reduce using rule 142 (value -> expression .)
    MINUS           reduce using rule 142 (value -> expression .)
    $end            reduce using rule 142 (value -> expression .)
    AND             reduce using rule 142 (value -> expression .)
    OR              reduce using rule 142 (value -> expression .)
    LLLAVE          reduce using rule 142 (value -> expression .)
    COLON           reduce using rule 142 (value -> expression .)
    RLLAVE          reduce using rule 142 (value -> expression .)
    DEFAULT         reduce using rule 142 (value -> expression .)
    CASE            reduce using rule 142 (value -> expression .)
    RETURN          reduce using rule 142 (value -> expression .)
    RPAREN          reduce using rule 142 (value -> expression .)
    RCORCHE         reduce using rule 142 (value -> expression .)
    COMA            reduce using rule 142 (value -> expression .)


state 87

    (206) something_ex -> funciones .

    GREATER         reduce using rule 206 (something_ex -> funciones .)
    SMALLER         reduce using rule 206 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 206 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 206 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 206 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 206 (something_ex -> funciones .)
    PLUS            reduce using rule 206 (something_ex -> funciones .)
    TIMES           reduce using rule 206 (something_ex -> funciones .)
    DIVIDE          reduce using rule 206 (something_ex -> funciones .)
    MINUS           reduce using rule 206 (something_ex -> funciones .)
    COLON           reduce using rule 206 (something_ex -> funciones .)
    $end            reduce using rule 206 (something_ex -> funciones .)
    RLLAVE          reduce using rule 206 (something_ex -> funciones .)
    DEFAULT         reduce using rule 206 (something_ex -> funciones .)
    CASE            reduce using rule 206 (something_ex -> funciones .)
    RETURN          reduce using rule 206 (something_ex -> funciones .)
    RPAREN          reduce using rule 206 (something_ex -> funciones .)
    AND             reduce using rule 206 (something_ex -> funciones .)
    OR              reduce using rule 206 (something_ex -> funciones .)
    LLLAVE          reduce using rule 206 (something_ex -> funciones .)
    RCORCHE         reduce using rule 206 (something_ex -> funciones .)
    COMA            reduce using rule 206 (something_ex -> funciones .)


state 88

    (57) data_structure -> array_var .

    GREATER         reduce using rule 57 (data_structure -> array_var .)
    SMALLER         reduce using rule 57 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 57 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 57 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 57 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 57 (data_structure -> array_var .)
    PLUS            reduce using rule 57 (data_structure -> array_var .)
    TIMES           reduce using rule 57 (data_structure -> array_var .)
    DIVIDE          reduce using rule 57 (data_structure -> array_var .)
    MINUS           reduce using rule 57 (data_structure -> array_var .)
    COLON           reduce using rule 57 (data_structure -> array_var .)
    $end            reduce using rule 57 (data_structure -> array_var .)
    RLLAVE          reduce using rule 57 (data_structure -> array_var .)
    DEFAULT         reduce using rule 57 (data_structure -> array_var .)
    CASE            reduce using rule 57 (data_structure -> array_var .)
    RETURN          reduce using rule 57 (data_structure -> array_var .)
    RPAREN          reduce using rule 57 (data_structure -> array_var .)
    AND             reduce using rule 57 (data_structure -> array_var .)
    OR              reduce using rule 57 (data_structure -> array_var .)
    LLLAVE          reduce using rule 57 (data_structure -> array_var .)
    RCORCHE         reduce using rule 57 (data_structure -> array_var .)
    COMA            reduce using rule 57 (data_structure -> array_var .)


state 89

    (140) comparison -> value op . value
    (141) value -> . ID
    (142) value -> . expression
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 105
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    value                          shift and go to state 147
    expression                     shift and go to state 86
    something_ex                   shift and go to state 29
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 90

    (149) logic_operation -> logic_value logic_recu .

    $end            reduce using rule 149 (logic_operation -> logic_value logic_recu .)
    LLLAVE          reduce using rule 149 (logic_operation -> logic_value logic_recu .)
    COLON           reduce using rule 149 (logic_operation -> logic_value logic_recu .)
    RLLAVE          reduce using rule 149 (logic_operation -> logic_value logic_recu .)
    DEFAULT         reduce using rule 149 (logic_operation -> logic_value logic_recu .)
    CASE            reduce using rule 149 (logic_operation -> logic_value logic_recu .)
    RETURN          reduce using rule 149 (logic_operation -> logic_value logic_recu .)
    RPAREN          reduce using rule 149 (logic_operation -> logic_value logic_recu .)
    RCORCHE         reduce using rule 149 (logic_operation -> logic_value logic_recu .)
    COMA            reduce using rule 149 (logic_operation -> logic_value logic_recu .)


state 91

    (151) logic_recu -> logic_op . logic_value
    (152) logic_recu -> logic_op . logic_value logic_recu
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (140) comparison -> . value op value
    (141) value -> . ID
    (142) value -> . expression
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 151
    NOT             shift and go to state 49
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    logic_value                    shift and go to state 148
    negation                       shift and go to state 149
    comparison                     shift and go to state 150
    value                          shift and go to state 32
    expression                     shift and go to state 86
    something_ex                   shift and go to state 29
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 92

    (158) logic_op -> AND .

    ID              reduce using rule 158 (logic_op -> AND .)
    NOT             reduce using rule 158 (logic_op -> AND .)
    INTEGER         reduce using rule 158 (logic_op -> AND .)
    FLOAT           reduce using rule 158 (logic_op -> AND .)
    APPEND          reduce using rule 158 (logic_op -> AND .)
    LEN             reduce using rule 158 (logic_op -> AND .)
    COPY            reduce using rule 158 (logic_op -> AND .)
    DELETE          reduce using rule 158 (logic_op -> AND .)


state 93

    (159) logic_op -> OR .

    ID              reduce using rule 159 (logic_op -> OR .)
    NOT             reduce using rule 159 (logic_op -> OR .)
    INTEGER         reduce using rule 159 (logic_op -> OR .)
    FLOAT           reduce using rule 159 (logic_op -> OR .)
    APPEND          reduce using rule 159 (logic_op -> OR .)
    LEN             reduce using rule 159 (logic_op -> OR .)
    COPY            reduce using rule 159 (logic_op -> OR .)
    DELETE          reduce using rule 159 (logic_op -> OR .)


state 94

    (84) decVar -> VAR ID . EQUAL INTEGER
    (85) decVar -> VAR ID . EQUAL ID
    (86) decVar -> VAR ID . EQUAL FLOAT
    (87) decVar -> VAR ID . EQUAL expression
    (88) decVar -> VAR ID . EQUAL logic_operation
    (89) decVar -> VAR ID . EQUAL comparison
    (90) decVar -> VAR ID . EQUAL STRING
    (165) array_declaration -> VAR ID . LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> VAR ID . EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (96) slice_declaration -> VAR ID . LCORCHE RCORCHE data_types
    (97) slice_declaration -> VAR ID . EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> VAR ID . EQUAL funM
    (175) map_declaration -> VAR ID . LCORCHE data_types RCORCHE data_types

    EQUAL           shift and go to state 152
    LCORCHE         shift and go to state 153


state 95

    (91) decVar -> ID DEQUAL . STRING
    (92) decVar -> ID DEQUAL . FLOAT
    (93) decVar -> ID DEQUAL . expression
    (94) decVar -> ID DEQUAL . logic_operation
    (95) decVar -> ID DEQUAL . comparison
    (133) cStruct -> ID DEQUAL . ID LLLAVE asignaciones RLLAVE
    (99) slice_declaration -> ID DEQUAL . funM
    (100) slice_declaration -> ID DEQUAL . LCORCHE RCORCHE data_types arr_content
    (120) decVarOne -> ID DEQUAL . ID
    (121) decVarOne -> ID DEQUAL . INTEGER
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (140) comparison -> . value op value
    (101) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (102) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (141) value -> . ID
    (142) value -> . expression
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    STRING          shift and go to state 155
    FLOAT           shift and go to state 156
    ID              shift and go to state 154
    LCORCHE         shift and go to state 161
    INTEGER         shift and go to state 162
    MAKE            shift and go to state 163
    NOT             shift and go to state 49
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    expression                     shift and go to state 157
    logic_operation                shift and go to state 158
    comparison                     shift and go to state 159
    funM                           shift and go to state 160
    something_ex                   shift and go to state 29
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    value                          shift and go to state 32
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 96

    (59) var_asignation -> ID EQUAL . any
    (60) any -> . values
    (61) any -> . operations
    (62) any -> . ID
    (63) any -> . data_structure
    (64) any -> . funciones
    (40) values -> . STRING
    (41) values -> . INTEGER
    (42) values -> . FLOAT
    (43) values -> . TRUE
    (44) values -> . FALSE
    (54) operations -> . expression
    (55) operations -> . comparison
    (56) operations -> . logic_operation
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID

    ID              shift and go to state 164
    STRING          shift and go to state 119
    INTEGER         shift and go to state 120
    FLOAT           shift and go to state 121
    TRUE            shift and go to state 122
    FALSE           shift and go to state 123
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    NOT             shift and go to state 49

    any                            shift and go to state 165
    values                         shift and go to state 166
    operations                     shift and go to state 167
    data_structure                 shift and go to state 168
    funciones                      shift and go to state 169
    expression                     shift and go to state 124
    comparison                     shift and go to state 125
    logic_operation                shift and go to state 126
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50
    something_ex                   shift and go to state 29
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34

state 97

    (170) array_var -> ID LCORCHE . index RCORCHE
    (106) slice_var -> ID LCORCHE . index_s RCORCHE
    (176) map_var -> ID LCORCHE . key RCORCHE
    (171) index -> . ID
    (172) index -> . INTEGER
    (173) index -> . expression
    (107) index_s -> . ID
    (108) index_s -> . INTEGER
    (109) index_s -> . expression
    (177) key -> . ID
    (178) key -> . values
    (179) key -> . operations
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (40) values -> . STRING
    (41) values -> . INTEGER
    (42) values -> . FLOAT
    (43) values -> . TRUE
    (44) values -> . FALSE
    (54) operations -> . expression
    (55) operations -> . comparison
    (56) operations -> . logic_operation
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 170
    INTEGER         shift and go to state 174
    STRING          shift and go to state 119
    FLOAT           shift and go to state 121
    TRUE            shift and go to state 122
    FALSE           shift and go to state 123
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    NOT             shift and go to state 49

    index                          shift and go to state 171
    index_s                        shift and go to state 172
    key                            shift and go to state 173
    expression                     shift and go to state 175
    values                         shift and go to state 176
    operations                     shift and go to state 177
    something_ex                   shift and go to state 29
    comparison                     shift and go to state 125
    logic_operation                shift and go to state 126
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 98

    (115) funciones -> APPEND LPAREN . ID COMA values RPAREN
    (116) funciones -> APPEND LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 178


state 99

    (117) funciones -> LEN LPAREN . ID RPAREN

    ID              shift and go to state 179


state 100

    (118) funciones -> COPY LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 180


state 101

    (119) funciones -> DELETE LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 181


state 102

    (122) SenIF -> IF comparison . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 182


state 103

    (123) SenIF -> IF TRUE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 183


state 104

    (124) SenIF -> IF FALSE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 184


state 105

    (141) value -> ID .
    (202) something_ex -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (176) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for LLLAVE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 141 (value -> ID .)
    GREATER         reduce using rule 141 (value -> ID .)
    SMALLER         reduce using rule 141 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 141 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 141 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 141 (value -> ID .)
    NOT_EQUAL       reduce using rule 141 (value -> ID .)
    PLUS            reduce using rule 141 (value -> ID .)
    TIMES           reduce using rule 141 (value -> ID .)
    DIVIDE          reduce using rule 141 (value -> ID .)
    MINUS           reduce using rule 141 (value -> ID .)
    $end            reduce using rule 141 (value -> ID .)
    AND             reduce using rule 141 (value -> ID .)
    OR              reduce using rule 141 (value -> ID .)
    LLLAVE          reduce using rule 141 (value -> ID .)
    COLON           reduce using rule 141 (value -> ID .)
    RLLAVE          reduce using rule 141 (value -> ID .)
    DEFAULT         reduce using rule 141 (value -> ID .)
    CASE            reduce using rule 141 (value -> ID .)
    RETURN          reduce using rule 141 (value -> ID .)
    RPAREN          reduce using rule 141 (value -> ID .)
    RCORCHE         reduce using rule 141 (value -> ID .)
    COMA            reduce using rule 141 (value -> ID .)
    LCORCHE         shift and go to state 146

  ! GREATER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 202 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 202 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 202 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 202 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 202 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 202 (something_ex -> ID .) ]
  ! AND             [ reduce using rule 202 (something_ex -> ID .) ]
  ! OR              [ reduce using rule 202 (something_ex -> ID .) ]
  ! LLLAVE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 202 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 202 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 202 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 202 (something_ex -> ID .) ]
  ! RPAREN          [ reduce using rule 202 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 202 (something_ex -> ID .) ]
  ! COMA            [ reduce using rule 202 (something_ex -> ID .) ]


state 106

    (125) SenElseIF -> ELSE IF . comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> ELSE IF . TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> ELSE IF . FALSE LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (141) value -> . ID
    (142) value -> . expression
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    TRUE            shift and go to state 186
    FALSE           shift and go to state 187
    ID              shift and go to state 105
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    comparison                     shift and go to state 185
    value                          shift and go to state 32
    expression                     shift and go to state 86
    something_ex                   shift and go to state 29
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 107

    (128) SenElse -> ELSE LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenElseIF
    (18) codigo -> . SenElse
    (19) codigo -> . SenStruct
    (20) codigo -> . cStruct
    (21) codigo -> . switch_statement
    (22) codigo -> . array_declaration COLON
    (23) codigo -> . array_declaration
    (24) codigo -> . array_var COLON
    (25) codigo -> . array_var
    (26) codigo -> . array_assignment COLON
    (27) codigo -> . array_assignment
    (28) codigo -> . slice_declaration COLON
    (29) codigo -> . slice_declaration
    (30) codigo -> . slice_var COLON
    (31) codigo -> . slice_var
    (32) codigo -> . slice_assignment COLON
    (33) codigo -> . slice_assignment
    (34) codigo -> . map_declaration COLON
    (35) codigo -> . map_declaration
    (36) codigo -> . map_assignment COLON
    (37) codigo -> . map_assignment
    (38) codigo -> . func_declaration
    (39) codigo -> . main_func
    (192) impresion -> . PRINT LPAREN content RPAREN
    (76) scan_func -> . SCAN LPAREN POINTER RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (77) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (83) decVar -> . decVarOne
    (84) decVar -> . VAR ID EQUAL INTEGER
    (85) decVar -> . VAR ID EQUAL ID
    (86) decVar -> . VAR ID EQUAL FLOAT
    (87) decVar -> . VAR ID EQUAL expression
    (88) decVar -> . VAR ID EQUAL logic_operation
    (89) decVar -> . VAR ID EQUAL comparison
    (90) decVar -> . VAR ID EQUAL STRING
    (91) decVar -> . ID DEQUAL STRING
    (92) decVar -> . ID DEQUAL FLOAT
    (93) decVar -> . ID DEQUAL expression
    (94) decVar -> . ID DEQUAL logic_operation
    (95) decVar -> . ID DEQUAL comparison
    (59) var_asignation -> . ID EQUAL any
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (122) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (123) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (125) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (129) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (160) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (165) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (170) array_var -> . ID LCORCHE index RCORCHE
    (174) array_assignment -> . array_var EQUAL something
    (96) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> . VAR ID EQUAL funM
    (99) slice_declaration -> . ID DEQUAL funM
    (100) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> . ID LCORCHE index_s RCORCHE
    (110) slice_assignment -> . slice_var EQUAL something_s
    (175) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (180) map_assignment -> . array_var EQUAL something
    (181) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (176) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 27
    SCAN            shift and go to state 28
    FOR             shift and go to state 30
    VAR             shift and go to state 35
    ID              shift and go to state 36
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 43
    ELSE            shift and go to state 44
    TYPE            shift and go to state 45
    SWITCH          shift and go to state 46
    FUNC            shift and go to state 47
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    NOT             shift and go to state 49

    codigo                         shift and go to state 188
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenElseIF                      shift and go to state 12
    SenElse                        shift and go to state 13
    SenStruct                      shift and go to state 14
    cStruct                        shift and go to state 15
    switch_statement               shift and go to state 16
    array_declaration              shift and go to state 17
    array_var                      shift and go to state 18
    array_assignment               shift and go to state 19
    slice_declaration              shift and go to state 20
    slice_var                      shift and go to state 21
    slice_assignment               shift and go to state 22
    map_declaration                shift and go to state 23
    map_assignment                 shift and go to state 24
    func_declaration               shift and go to state 25
    main_func                      shift and go to state 26
    something_ex                   shift and go to state 29
    decVarOne                      shift and go to state 31
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    map_var                        shift and go to state 50

state 108

    (129) SenStruct -> TYPE ID . STRUCT LLLAVE declaration RLLAVE

    STRUCT          shift and go to state 189


state 109

    (160) switch_statement -> SWITCH ID . LLLAVE cases RLLAVE

    LLLAVE          shift and go to state 190


state 110

    (181) func_declaration -> FUNC ID . LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> FUNC ID . LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE

    LPAREN          shift and go to state 191


state 111

    (75) main_func -> FUNC MAIN . LPAREN RPAREN LLLAVE codigo RLLAVE

    LPAREN          shift and go to state 192


state 112

    (156) negation -> NOT comparison .

    $end            reduce using rule 156 (negation -> NOT comparison .)
    AND             reduce using rule 156 (negation -> NOT comparison .)
    OR              reduce using rule 156 (negation -> NOT comparison .)
    LLLAVE          reduce using rule 156 (negation -> NOT comparison .)
    COLON           reduce using rule 156 (negation -> NOT comparison .)
    RLLAVE          reduce using rule 156 (negation -> NOT comparison .)
    DEFAULT         reduce using rule 156 (negation -> NOT comparison .)
    CASE            reduce using rule 156 (negation -> NOT comparison .)
    RETURN          reduce using rule 156 (negation -> NOT comparison .)
    RPAREN          reduce using rule 156 (negation -> NOT comparison .)
    RCORCHE         reduce using rule 156 (negation -> NOT comparison .)
    COMA            reduce using rule 156 (negation -> NOT comparison .)


state 113

    (157) negation -> NOT ID .
    (141) value -> ID .
    (202) something_ex -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (176) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 141 (value -> ID .)
    $end            reduce using rule 157 (negation -> NOT ID .)
    AND             reduce using rule 157 (negation -> NOT ID .)
    OR              reduce using rule 157 (negation -> NOT ID .)
    LLLAVE          reduce using rule 157 (negation -> NOT ID .)
    COLON           reduce using rule 157 (negation -> NOT ID .)
    RLLAVE          reduce using rule 157 (negation -> NOT ID .)
    DEFAULT         reduce using rule 157 (negation -> NOT ID .)
    CASE            reduce using rule 157 (negation -> NOT ID .)
    RETURN          reduce using rule 157 (negation -> NOT ID .)
    RPAREN          reduce using rule 157 (negation -> NOT ID .)
    RCORCHE         reduce using rule 157 (negation -> NOT ID .)
    COMA            reduce using rule 157 (negation -> NOT ID .)
    GREATER         reduce using rule 141 (value -> ID .)
    SMALLER         reduce using rule 141 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 141 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 141 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 141 (value -> ID .)
    NOT_EQUAL       reduce using rule 141 (value -> ID .)
    PLUS            reduce using rule 141 (value -> ID .)
    TIMES           reduce using rule 141 (value -> ID .)
    DIVIDE          reduce using rule 141 (value -> ID .)
    MINUS           reduce using rule 141 (value -> ID .)
    LCORCHE         shift and go to state 146

  ! GREATER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 202 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 202 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 202 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 202 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 202 (something_ex -> ID .) ]


state 114

    (174) array_assignment -> array_var EQUAL something .
    (180) map_assignment -> array_var EQUAL something .

  ! reduce/reduce conflict for COLON resolved using rule 174 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for $end resolved using rule 174 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 174 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 174 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for CASE resolved using rule 174 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for RETURN resolved using rule 174 (array_assignment -> array_var EQUAL something .)
    COLON           reduce using rule 174 (array_assignment -> array_var EQUAL something .)
    $end            reduce using rule 174 (array_assignment -> array_var EQUAL something .)
    RLLAVE          reduce using rule 174 (array_assignment -> array_var EQUAL something .)
    DEFAULT         reduce using rule 174 (array_assignment -> array_var EQUAL something .)
    CASE            reduce using rule 174 (array_assignment -> array_var EQUAL something .)
    RETURN          reduce using rule 174 (array_assignment -> array_var EQUAL something .)

  ! COLON           [ reduce using rule 180 (map_assignment -> array_var EQUAL something .) ]
  ! $end            [ reduce using rule 180 (map_assignment -> array_var EQUAL something .) ]
  ! RLLAVE          [ reduce using rule 180 (map_assignment -> array_var EQUAL something .) ]
  ! DEFAULT         [ reduce using rule 180 (map_assignment -> array_var EQUAL something .) ]
  ! CASE            [ reduce using rule 180 (map_assignment -> array_var EQUAL something .) ]
  ! RETURN          [ reduce using rule 180 (map_assignment -> array_var EQUAL something .) ]


state 115

    (71) something -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (176) map_var -> ID . LCORCHE key RCORCHE
    (202) something_ex -> ID .
    (141) value -> ID .
    (155) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 71 (something -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 71 (something -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 71 (something -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 71 (something -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 71 (something -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 71 (something -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 141 (value -> ID .)
    COLON           reduce using rule 71 (something -> ID .)
    $end            reduce using rule 71 (something -> ID .)
    RLLAVE          reduce using rule 71 (something -> ID .)
    DEFAULT         reduce using rule 71 (something -> ID .)
    CASE            reduce using rule 71 (something -> ID .)
    RETURN          reduce using rule 71 (something -> ID .)
    LCORCHE         shift and go to state 146
    GREATER         reduce using rule 141 (value -> ID .)
    SMALLER         reduce using rule 141 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 141 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 141 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 141 (value -> ID .)
    NOT_EQUAL       reduce using rule 141 (value -> ID .)
    PLUS            reduce using rule 141 (value -> ID .)
    TIMES           reduce using rule 141 (value -> ID .)
    DIVIDE          reduce using rule 141 (value -> ID .)
    MINUS           reduce using rule 141 (value -> ID .)
    AND             reduce using rule 155 (logic_value -> ID .)
    OR              reduce using rule 155 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 202 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 202 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 202 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 202 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 202 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 202 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 202 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 202 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 202 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 202 (something_ex -> ID .) ]


state 116

    (72) something -> data_structure .
    (205) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 72 (something -> data_structure .)
  ! reduce/reduce conflict for $end resolved using rule 72 (something -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 72 (something -> data_structure .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 72 (something -> data_structure .)
  ! reduce/reduce conflict for CASE resolved using rule 72 (something -> data_structure .)
  ! reduce/reduce conflict for RETURN resolved using rule 72 (something -> data_structure .)
    COLON           reduce using rule 72 (something -> data_structure .)
    $end            reduce using rule 72 (something -> data_structure .)
    RLLAVE          reduce using rule 72 (something -> data_structure .)
    DEFAULT         reduce using rule 72 (something -> data_structure .)
    CASE            reduce using rule 72 (something -> data_structure .)
    RETURN          reduce using rule 72 (something -> data_structure .)
    GREATER         reduce using rule 205 (something_ex -> data_structure .)
    SMALLER         reduce using rule 205 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 205 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 205 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 205 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 205 (something_ex -> data_structure .)
    PLUS            reduce using rule 205 (something_ex -> data_structure .)
    TIMES           reduce using rule 205 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 205 (something_ex -> data_structure .)
    MINUS           reduce using rule 205 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 205 (something_ex -> data_structure .) ]
  ! $end            [ reduce using rule 205 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 205 (something_ex -> data_structure .) ]
  ! DEFAULT         [ reduce using rule 205 (something_ex -> data_structure .) ]
  ! CASE            [ reduce using rule 205 (something_ex -> data_structure .) ]
  ! RETURN          [ reduce using rule 205 (something_ex -> data_structure .) ]


state 117

    (73) something -> values .

    COLON           reduce using rule 73 (something -> values .)
    $end            reduce using rule 73 (something -> values .)
    RLLAVE          reduce using rule 73 (something -> values .)
    DEFAULT         reduce using rule 73 (something -> values .)
    CASE            reduce using rule 73 (something -> values .)
    RETURN          reduce using rule 73 (something -> values .)


state 118

    (74) something -> operations .

    COLON           reduce using rule 74 (something -> operations .)
    $end            reduce using rule 74 (something -> operations .)
    RLLAVE          reduce using rule 74 (something -> operations .)
    DEFAULT         reduce using rule 74 (something -> operations .)
    CASE            reduce using rule 74 (something -> operations .)
    RETURN          reduce using rule 74 (something -> operations .)


state 119

    (40) values -> STRING .

    COLON           reduce using rule 40 (values -> STRING .)
    $end            reduce using rule 40 (values -> STRING .)
    RLLAVE          reduce using rule 40 (values -> STRING .)
    DEFAULT         reduce using rule 40 (values -> STRING .)
    CASE            reduce using rule 40 (values -> STRING .)
    RETURN          reduce using rule 40 (values -> STRING .)
    RPAREN          reduce using rule 40 (values -> STRING .)
    RCORCHE         reduce using rule 40 (values -> STRING .)
    POINTS          reduce using rule 40 (values -> STRING .)
    COMA            reduce using rule 40 (values -> STRING .)


state 120

    (41) values -> INTEGER .
    (203) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 41 (values -> INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 41 (values -> INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 41 (values -> INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 41 (values -> INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 41 (values -> INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 41 (values -> INTEGER .)
  ! reduce/reduce conflict for RPAREN resolved using rule 41 (values -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 41 (values -> INTEGER .)
    COLON           reduce using rule 41 (values -> INTEGER .)
    $end            reduce using rule 41 (values -> INTEGER .)
    RLLAVE          reduce using rule 41 (values -> INTEGER .)
    DEFAULT         reduce using rule 41 (values -> INTEGER .)
    CASE            reduce using rule 41 (values -> INTEGER .)
    RETURN          reduce using rule 41 (values -> INTEGER .)
    RPAREN          reduce using rule 41 (values -> INTEGER .)
    COMA            reduce using rule 41 (values -> INTEGER .)
    GREATER         reduce using rule 203 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 203 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 203 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 203 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 203 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 203 (something_ex -> INTEGER .)
    PLUS            reduce using rule 203 (something_ex -> INTEGER .)
    TIMES           reduce using rule 203 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 203 (something_ex -> INTEGER .)
    MINUS           reduce using rule 203 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! RPAREN          [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! COMA            [ reduce using rule 203 (something_ex -> INTEGER .) ]


state 121

    (42) values -> FLOAT .
    (204) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 42 (values -> FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 42 (values -> FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 42 (values -> FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 42 (values -> FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 42 (values -> FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 42 (values -> FLOAT .)
  ! reduce/reduce conflict for RPAREN resolved using rule 42 (values -> FLOAT .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 42 (values -> FLOAT .)
  ! reduce/reduce conflict for COMA resolved using rule 42 (values -> FLOAT .)
    COLON           reduce using rule 42 (values -> FLOAT .)
    $end            reduce using rule 42 (values -> FLOAT .)
    RLLAVE          reduce using rule 42 (values -> FLOAT .)
    DEFAULT         reduce using rule 42 (values -> FLOAT .)
    CASE            reduce using rule 42 (values -> FLOAT .)
    RETURN          reduce using rule 42 (values -> FLOAT .)
    RPAREN          reduce using rule 42 (values -> FLOAT .)
    RCORCHE         reduce using rule 42 (values -> FLOAT .)
    COMA            reduce using rule 42 (values -> FLOAT .)
    GREATER         reduce using rule 204 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 204 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 204 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 204 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 204 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 204 (something_ex -> FLOAT .)
    PLUS            reduce using rule 204 (something_ex -> FLOAT .)
    TIMES           reduce using rule 204 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 204 (something_ex -> FLOAT .)
    MINUS           reduce using rule 204 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! RPAREN          [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! RCORCHE         [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! COMA            [ reduce using rule 204 (something_ex -> FLOAT .) ]


state 122

    (43) values -> TRUE .

    COLON           reduce using rule 43 (values -> TRUE .)
    $end            reduce using rule 43 (values -> TRUE .)
    RLLAVE          reduce using rule 43 (values -> TRUE .)
    DEFAULT         reduce using rule 43 (values -> TRUE .)
    CASE            reduce using rule 43 (values -> TRUE .)
    RETURN          reduce using rule 43 (values -> TRUE .)
    RPAREN          reduce using rule 43 (values -> TRUE .)
    RCORCHE         reduce using rule 43 (values -> TRUE .)
    POINTS          reduce using rule 43 (values -> TRUE .)
    COMA            reduce using rule 43 (values -> TRUE .)


state 123

    (44) values -> FALSE .

    COLON           reduce using rule 44 (values -> FALSE .)
    $end            reduce using rule 44 (values -> FALSE .)
    RLLAVE          reduce using rule 44 (values -> FALSE .)
    DEFAULT         reduce using rule 44 (values -> FALSE .)
    CASE            reduce using rule 44 (values -> FALSE .)
    RETURN          reduce using rule 44 (values -> FALSE .)
    RPAREN          reduce using rule 44 (values -> FALSE .)
    RCORCHE         reduce using rule 44 (values -> FALSE .)
    POINTS          reduce using rule 44 (values -> FALSE .)
    COMA            reduce using rule 44 (values -> FALSE .)


state 124

    (54) operations -> expression .
    (142) value -> expression .

    COLON           reduce using rule 54 (operations -> expression .)
    $end            reduce using rule 54 (operations -> expression .)
    RLLAVE          reduce using rule 54 (operations -> expression .)
    DEFAULT         reduce using rule 54 (operations -> expression .)
    CASE            reduce using rule 54 (operations -> expression .)
    RETURN          reduce using rule 54 (operations -> expression .)
    RPAREN          reduce using rule 54 (operations -> expression .)
    COMA            reduce using rule 54 (operations -> expression .)
    GREATER         reduce using rule 142 (value -> expression .)
    SMALLER         reduce using rule 142 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 142 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 142 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 142 (value -> expression .)
    NOT_EQUAL       reduce using rule 142 (value -> expression .)
    PLUS            reduce using rule 142 (value -> expression .)
    TIMES           reduce using rule 142 (value -> expression .)
    DIVIDE          reduce using rule 142 (value -> expression .)
    MINUS           reduce using rule 142 (value -> expression .)


state 125

    (55) operations -> comparison .
    (154) logic_value -> comparison .

    COLON           reduce using rule 55 (operations -> comparison .)
    $end            reduce using rule 55 (operations -> comparison .)
    RLLAVE          reduce using rule 55 (operations -> comparison .)
    DEFAULT         reduce using rule 55 (operations -> comparison .)
    CASE            reduce using rule 55 (operations -> comparison .)
    RETURN          reduce using rule 55 (operations -> comparison .)
    RPAREN          reduce using rule 55 (operations -> comparison .)
    RCORCHE         reduce using rule 55 (operations -> comparison .)
    COMA            reduce using rule 55 (operations -> comparison .)
    AND             reduce using rule 154 (logic_value -> comparison .)
    OR              reduce using rule 154 (logic_value -> comparison .)


state 126

    (56) operations -> logic_operation .

    COLON           reduce using rule 56 (operations -> logic_operation .)
    $end            reduce using rule 56 (operations -> logic_operation .)
    RLLAVE          reduce using rule 56 (operations -> logic_operation .)
    DEFAULT         reduce using rule 56 (operations -> logic_operation .)
    CASE            reduce using rule 56 (operations -> logic_operation .)
    RETURN          reduce using rule 56 (operations -> logic_operation .)
    RPAREN          reduce using rule 56 (operations -> logic_operation .)
    RCORCHE         reduce using rule 56 (operations -> logic_operation .)
    COMA            reduce using rule 56 (operations -> logic_operation .)


state 127

    (110) slice_assignment -> slice_var EQUAL something_s .

    COLON           reduce using rule 110 (slice_assignment -> slice_var EQUAL something_s .)
    $end            reduce using rule 110 (slice_assignment -> slice_var EQUAL something_s .)
    RLLAVE          reduce using rule 110 (slice_assignment -> slice_var EQUAL something_s .)
    DEFAULT         reduce using rule 110 (slice_assignment -> slice_var EQUAL something_s .)
    CASE            reduce using rule 110 (slice_assignment -> slice_var EQUAL something_s .)
    RETURN          reduce using rule 110 (slice_assignment -> slice_var EQUAL something_s .)


state 128

    (111) something_s -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (202) something_ex -> ID .
    (141) value -> ID .
    (155) logic_value -> ID .
    (176) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for COLON resolved using rule 111 (something_s -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 111 (something_s -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 111 (something_s -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 111 (something_s -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 111 (something_s -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 111 (something_s -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 141 (value -> ID .)
    COLON           reduce using rule 111 (something_s -> ID .)
    $end            reduce using rule 111 (something_s -> ID .)
    RLLAVE          reduce using rule 111 (something_s -> ID .)
    DEFAULT         reduce using rule 111 (something_s -> ID .)
    CASE            reduce using rule 111 (something_s -> ID .)
    RETURN          reduce using rule 111 (something_s -> ID .)
    LCORCHE         shift and go to state 146
    GREATER         reduce using rule 141 (value -> ID .)
    SMALLER         reduce using rule 141 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 141 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 141 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 141 (value -> ID .)
    NOT_EQUAL       reduce using rule 141 (value -> ID .)
    PLUS            reduce using rule 141 (value -> ID .)
    TIMES           reduce using rule 141 (value -> ID .)
    DIVIDE          reduce using rule 141 (value -> ID .)
    MINUS           reduce using rule 141 (value -> ID .)
    AND             reduce using rule 155 (logic_value -> ID .)
    OR              reduce using rule 155 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 202 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 202 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 202 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 202 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 202 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 202 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 202 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 202 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 202 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 202 (something_ex -> ID .) ]


state 129

    (112) something_s -> array_var .
    (57) data_structure -> array_var .

  ! reduce/reduce conflict for COLON resolved using rule 57 (data_structure -> array_var .)
  ! reduce/reduce conflict for $end resolved using rule 57 (data_structure -> array_var .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 57 (data_structure -> array_var .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 57 (data_structure -> array_var .)
  ! reduce/reduce conflict for CASE resolved using rule 57 (data_structure -> array_var .)
  ! reduce/reduce conflict for RETURN resolved using rule 57 (data_structure -> array_var .)
    GREATER         reduce using rule 57 (data_structure -> array_var .)
    SMALLER         reduce using rule 57 (data_structure -> array_var .)
    GREATER_OR_EQUAL reduce using rule 57 (data_structure -> array_var .)
    SMALLER_OR_EQUAL reduce using rule 57 (data_structure -> array_var .)
    EQUAL_COMPARE   reduce using rule 57 (data_structure -> array_var .)
    NOT_EQUAL       reduce using rule 57 (data_structure -> array_var .)
    PLUS            reduce using rule 57 (data_structure -> array_var .)
    TIMES           reduce using rule 57 (data_structure -> array_var .)
    DIVIDE          reduce using rule 57 (data_structure -> array_var .)
    MINUS           reduce using rule 57 (data_structure -> array_var .)
    COLON           reduce using rule 57 (data_structure -> array_var .)
    $end            reduce using rule 57 (data_structure -> array_var .)
    RLLAVE          reduce using rule 57 (data_structure -> array_var .)
    DEFAULT         reduce using rule 57 (data_structure -> array_var .)
    CASE            reduce using rule 57 (data_structure -> array_var .)
    RETURN          reduce using rule 57 (data_structure -> array_var .)

  ! COLON           [ reduce using rule 112 (something_s -> array_var .) ]
  ! $end            [ reduce using rule 112 (something_s -> array_var .) ]
  ! RLLAVE          [ reduce using rule 112 (something_s -> array_var .) ]
  ! DEFAULT         [ reduce using rule 112 (something_s -> array_var .) ]
  ! CASE            [ reduce using rule 112 (something_s -> array_var .) ]
  ! RETURN          [ reduce using rule 112 (something_s -> array_var .) ]


state 130

    (113) something_s -> values .

    COLON           reduce using rule 113 (something_s -> values .)
    $end            reduce using rule 113 (something_s -> values .)
    RLLAVE          reduce using rule 113 (something_s -> values .)
    DEFAULT         reduce using rule 113 (something_s -> values .)
    CASE            reduce using rule 113 (something_s -> values .)
    RETURN          reduce using rule 113 (something_s -> values .)


state 131

    (114) something_s -> operations .

    COLON           reduce using rule 114 (something_s -> operations .)
    $end            reduce using rule 114 (something_s -> operations .)
    RLLAVE          reduce using rule 114 (something_s -> operations .)
    DEFAULT         reduce using rule 114 (something_s -> operations .)
    CASE            reduce using rule 114 (something_s -> operations .)
    RETURN          reduce using rule 114 (something_s -> operations .)


state 132

    (192) impresion -> PRINT LPAREN content . RPAREN

    RPAREN          shift and go to state 193


state 133

    (193) content -> values .

    RPAREN          reduce using rule 193 (content -> values .)


state 134

    (194) content -> operations .

    RPAREN          reduce using rule 194 (content -> operations .)


state 135

    (195) content -> funciones .
    (206) something_ex -> funciones .

  ! reduce/reduce conflict for RPAREN resolved using rule 195 (content -> funciones .)
    RPAREN          reduce using rule 195 (content -> funciones .)
    GREATER         reduce using rule 206 (something_ex -> funciones .)
    SMALLER         reduce using rule 206 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 206 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 206 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 206 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 206 (something_ex -> funciones .)
    PLUS            reduce using rule 206 (something_ex -> funciones .)
    TIMES           reduce using rule 206 (something_ex -> funciones .)
    DIVIDE          reduce using rule 206 (something_ex -> funciones .)
    MINUS           reduce using rule 206 (something_ex -> funciones .)

  ! RPAREN          [ reduce using rule 206 (something_ex -> funciones .) ]


state 136

    (196) content -> data_structure .
    (205) something_ex -> data_structure .

  ! reduce/reduce conflict for RPAREN resolved using rule 196 (content -> data_structure .)
    RPAREN          reduce using rule 196 (content -> data_structure .)
    GREATER         reduce using rule 205 (something_ex -> data_structure .)
    SMALLER         reduce using rule 205 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 205 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 205 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 205 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 205 (something_ex -> data_structure .)
    PLUS            reduce using rule 205 (something_ex -> data_structure .)
    TIMES           reduce using rule 205 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 205 (something_ex -> data_structure .)
    MINUS           reduce using rule 205 (something_ex -> data_structure .)

  ! RPAREN          [ reduce using rule 205 (something_ex -> data_structure .) ]


state 137

    (197) content -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (176) map_var -> ID . LCORCHE key RCORCHE
    (202) something_ex -> ID .
    (141) value -> ID .
    (155) logic_value -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 197 (content -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 141 (value -> ID .)
    RPAREN          reduce using rule 197 (content -> ID .)
    LCORCHE         shift and go to state 146
    GREATER         reduce using rule 141 (value -> ID .)
    SMALLER         reduce using rule 141 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 141 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 141 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 141 (value -> ID .)
    NOT_EQUAL       reduce using rule 141 (value -> ID .)
    PLUS            reduce using rule 141 (value -> ID .)
    TIMES           reduce using rule 141 (value -> ID .)
    DIVIDE          reduce using rule 141 (value -> ID .)
    MINUS           reduce using rule 141 (value -> ID .)
    AND             reduce using rule 155 (logic_value -> ID .)
    OR              reduce using rule 155 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 202 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 202 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 202 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 202 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 202 (something_ex -> ID .) ]
  ! RPAREN          [ reduce using rule 202 (something_ex -> ID .) ]


state 138

    (76) scan_func -> SCAN LPAREN POINTER . RPAREN

    RPAREN          shift and go to state 194


state 139

    (200) adicionaEx -> op something_ex .
    (201) adicionaEx -> op something_ex . adicionaEx
    (200) adicionaEx -> . op something_ex
    (201) adicionaEx -> . op something_ex adicionaEx
    (143) op -> . GREATER
    (144) op -> . SMALLER
    (145) op -> . GREATER_OR_EQUAL
    (146) op -> . SMALLER_OR_EQUAL
    (147) op -> . EQUAL_COMPARE
    (148) op -> . NOT_EQUAL
    (207) op -> . PLUS
    (208) op -> . TIMES
    (209) op -> . DIVIDE
    (210) op -> . MINUS

  ! shift/reduce conflict for GREATER resolved as shift
  ! shift/reduce conflict for SMALLER resolved as shift
  ! shift/reduce conflict for GREATER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for SMALLER_OR_EQUAL resolved as shift
  ! shift/reduce conflict for EQUAL_COMPARE resolved as shift
  ! shift/reduce conflict for NOT_EQUAL resolved as shift
  ! shift/reduce conflict for PLUS resolved as shift
  ! shift/reduce conflict for TIMES resolved as shift
  ! shift/reduce conflict for DIVIDE resolved as shift
  ! shift/reduce conflict for MINUS resolved as shift
    COLON           reduce using rule 200 (adicionaEx -> op something_ex .)
    $end            reduce using rule 200 (adicionaEx -> op something_ex .)
    RLLAVE          reduce using rule 200 (adicionaEx -> op something_ex .)
    DEFAULT         reduce using rule 200 (adicionaEx -> op something_ex .)
    CASE            reduce using rule 200 (adicionaEx -> op something_ex .)
    RETURN          reduce using rule 200 (adicionaEx -> op something_ex .)
    RPAREN          reduce using rule 200 (adicionaEx -> op something_ex .)
    AND             reduce using rule 200 (adicionaEx -> op something_ex .)
    OR              reduce using rule 200 (adicionaEx -> op something_ex .)
    LLLAVE          reduce using rule 200 (adicionaEx -> op something_ex .)
    RCORCHE         reduce using rule 200 (adicionaEx -> op something_ex .)
    COMA            reduce using rule 200 (adicionaEx -> op something_ex .)
    GREATER         shift and go to state 71
    SMALLER         shift and go to state 72
    GREATER_OR_EQUAL shift and go to state 73
    SMALLER_OR_EQUAL shift and go to state 74
    EQUAL_COMPARE   shift and go to state 75
    NOT_EQUAL       shift and go to state 76
    PLUS            shift and go to state 77
    TIMES           shift and go to state 78
    DIVIDE          shift and go to state 79
    MINUS           shift and go to state 80

  ! GREATER         [ reduce using rule 200 (adicionaEx -> op something_ex .) ]
  ! SMALLER         [ reduce using rule 200 (adicionaEx -> op something_ex .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 200 (adicionaEx -> op something_ex .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 200 (adicionaEx -> op something_ex .) ]
  ! EQUAL_COMPARE   [ reduce using rule 200 (adicionaEx -> op something_ex .) ]
  ! NOT_EQUAL       [ reduce using rule 200 (adicionaEx -> op something_ex .) ]
  ! PLUS            [ reduce using rule 200 (adicionaEx -> op something_ex .) ]
  ! TIMES           [ reduce using rule 200 (adicionaEx -> op something_ex .) ]
  ! DIVIDE          [ reduce using rule 200 (adicionaEx -> op something_ex .) ]
  ! MINUS           [ reduce using rule 200 (adicionaEx -> op something_ex .) ]

    op                             shift and go to state 70
    adicionaEx                     shift and go to state 195

state 140

    (202) something_ex -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (176) map_var -> ID . LCORCHE key RCORCHE

    GREATER         reduce using rule 202 (something_ex -> ID .)
    SMALLER         reduce using rule 202 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 202 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 202 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 202 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 202 (something_ex -> ID .)
    PLUS            reduce using rule 202 (something_ex -> ID .)
    TIMES           reduce using rule 202 (something_ex -> ID .)
    DIVIDE          reduce using rule 202 (something_ex -> ID .)
    MINUS           reduce using rule 202 (something_ex -> ID .)
    COLON           reduce using rule 202 (something_ex -> ID .)
    $end            reduce using rule 202 (something_ex -> ID .)
    RLLAVE          reduce using rule 202 (something_ex -> ID .)
    DEFAULT         reduce using rule 202 (something_ex -> ID .)
    CASE            reduce using rule 202 (something_ex -> ID .)
    RETURN          reduce using rule 202 (something_ex -> ID .)
    RPAREN          reduce using rule 202 (something_ex -> ID .)
    AND             reduce using rule 202 (something_ex -> ID .)
    OR              reduce using rule 202 (something_ex -> ID .)
    LLLAVE          reduce using rule 202 (something_ex -> ID .)
    RCORCHE         reduce using rule 202 (something_ex -> ID .)
    COMA            reduce using rule 202 (something_ex -> ID .)
    LCORCHE         shift and go to state 146


state 141

    (77) cicloFor -> FOR LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 196


state 142

    (78) cicloFor -> FOR comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenElseIF
    (18) codigo -> . SenElse
    (19) codigo -> . SenStruct
    (20) codigo -> . cStruct
    (21) codigo -> . switch_statement
    (22) codigo -> . array_declaration COLON
    (23) codigo -> . array_declaration
    (24) codigo -> . array_var COLON
    (25) codigo -> . array_var
    (26) codigo -> . array_assignment COLON
    (27) codigo -> . array_assignment
    (28) codigo -> . slice_declaration COLON
    (29) codigo -> . slice_declaration
    (30) codigo -> . slice_var COLON
    (31) codigo -> . slice_var
    (32) codigo -> . slice_assignment COLON
    (33) codigo -> . slice_assignment
    (34) codigo -> . map_declaration COLON
    (35) codigo -> . map_declaration
    (36) codigo -> . map_assignment COLON
    (37) codigo -> . map_assignment
    (38) codigo -> . func_declaration
    (39) codigo -> . main_func
    (192) impresion -> . PRINT LPAREN content RPAREN
    (76) scan_func -> . SCAN LPAREN POINTER RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (77) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (83) decVar -> . decVarOne
    (84) decVar -> . VAR ID EQUAL INTEGER
    (85) decVar -> . VAR ID EQUAL ID
    (86) decVar -> . VAR ID EQUAL FLOAT
    (87) decVar -> . VAR ID EQUAL expression
    (88) decVar -> . VAR ID EQUAL logic_operation
    (89) decVar -> . VAR ID EQUAL comparison
    (90) decVar -> . VAR ID EQUAL STRING
    (91) decVar -> . ID DEQUAL STRING
    (92) decVar -> . ID DEQUAL FLOAT
    (93) decVar -> . ID DEQUAL expression
    (94) decVar -> . ID DEQUAL logic_operation
    (95) decVar -> . ID DEQUAL comparison
    (59) var_asignation -> . ID EQUAL any
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (122) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (123) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (125) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (129) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (160) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (165) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (170) array_var -> . ID LCORCHE index RCORCHE
    (174) array_assignment -> . array_var EQUAL something
    (96) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> . VAR ID EQUAL funM
    (99) slice_declaration -> . ID DEQUAL funM
    (100) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> . ID LCORCHE index_s RCORCHE
    (110) slice_assignment -> . slice_var EQUAL something_s
    (175) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (180) map_assignment -> . array_var EQUAL something
    (181) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (176) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 27
    SCAN            shift and go to state 28
    FOR             shift and go to state 30
    VAR             shift and go to state 35
    ID              shift and go to state 36
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 43
    ELSE            shift and go to state 44
    TYPE            shift and go to state 45
    SWITCH          shift and go to state 46
    FUNC            shift and go to state 47
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    NOT             shift and go to state 49

    comparison                     shift and go to state 6
    codigo                         shift and go to state 197
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenElseIF                      shift and go to state 12
    SenElse                        shift and go to state 13
    SenStruct                      shift and go to state 14
    cStruct                        shift and go to state 15
    switch_statement               shift and go to state 16
    array_declaration              shift and go to state 17
    array_var                      shift and go to state 18
    array_assignment               shift and go to state 19
    slice_declaration              shift and go to state 20
    slice_var                      shift and go to state 21
    slice_assignment               shift and go to state 22
    map_declaration                shift and go to state 23
    map_assignment                 shift and go to state 24
    func_declaration               shift and go to state 25
    main_func                      shift and go to state 26
    something_ex                   shift and go to state 29
    decVarOne                      shift and go to state 31
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    map_var                        shift and go to state 50

state 143

    (79) cicloFor -> FOR logic_operation LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenElseIF
    (18) codigo -> . SenElse
    (19) codigo -> . SenStruct
    (20) codigo -> . cStruct
    (21) codigo -> . switch_statement
    (22) codigo -> . array_declaration COLON
    (23) codigo -> . array_declaration
    (24) codigo -> . array_var COLON
    (25) codigo -> . array_var
    (26) codigo -> . array_assignment COLON
    (27) codigo -> . array_assignment
    (28) codigo -> . slice_declaration COLON
    (29) codigo -> . slice_declaration
    (30) codigo -> . slice_var COLON
    (31) codigo -> . slice_var
    (32) codigo -> . slice_assignment COLON
    (33) codigo -> . slice_assignment
    (34) codigo -> . map_declaration COLON
    (35) codigo -> . map_declaration
    (36) codigo -> . map_assignment COLON
    (37) codigo -> . map_assignment
    (38) codigo -> . func_declaration
    (39) codigo -> . main_func
    (192) impresion -> . PRINT LPAREN content RPAREN
    (76) scan_func -> . SCAN LPAREN POINTER RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (77) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (83) decVar -> . decVarOne
    (84) decVar -> . VAR ID EQUAL INTEGER
    (85) decVar -> . VAR ID EQUAL ID
    (86) decVar -> . VAR ID EQUAL FLOAT
    (87) decVar -> . VAR ID EQUAL expression
    (88) decVar -> . VAR ID EQUAL logic_operation
    (89) decVar -> . VAR ID EQUAL comparison
    (90) decVar -> . VAR ID EQUAL STRING
    (91) decVar -> . ID DEQUAL STRING
    (92) decVar -> . ID DEQUAL FLOAT
    (93) decVar -> . ID DEQUAL expression
    (94) decVar -> . ID DEQUAL logic_operation
    (95) decVar -> . ID DEQUAL comparison
    (59) var_asignation -> . ID EQUAL any
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (122) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (123) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (125) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (129) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (160) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (165) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (170) array_var -> . ID LCORCHE index RCORCHE
    (174) array_assignment -> . array_var EQUAL something
    (96) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> . VAR ID EQUAL funM
    (99) slice_declaration -> . ID DEQUAL funM
    (100) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> . ID LCORCHE index_s RCORCHE
    (110) slice_assignment -> . slice_var EQUAL something_s
    (175) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (180) map_assignment -> . array_var EQUAL something
    (181) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (176) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 27
    SCAN            shift and go to state 28
    FOR             shift and go to state 30
    VAR             shift and go to state 35
    ID              shift and go to state 36
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 43
    ELSE            shift and go to state 44
    TYPE            shift and go to state 45
    SWITCH          shift and go to state 46
    FUNC            shift and go to state 47
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    NOT             shift and go to state 49

    logic_operation                shift and go to state 7
    codigo                         shift and go to state 198
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenElseIF                      shift and go to state 12
    SenElse                        shift and go to state 13
    SenStruct                      shift and go to state 14
    cStruct                        shift and go to state 15
    switch_statement               shift and go to state 16
    array_declaration              shift and go to state 17
    array_var                      shift and go to state 18
    array_assignment               shift and go to state 19
    slice_declaration              shift and go to state 20
    slice_var                      shift and go to state 21
    slice_assignment               shift and go to state 22
    map_declaration                shift and go to state 23
    map_assignment                 shift and go to state 24
    func_declaration               shift and go to state 25
    main_func                      shift and go to state 26
    something_ex                   shift and go to state 29
    decVarOne                      shift and go to state 31
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    map_var                        shift and go to state 50

state 144

    (80) cicloFor -> FOR decVarOne COLON . comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (141) value -> . ID
    (142) value -> . expression
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 105
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    comparison                     shift and go to state 199
    value                          shift and go to state 32
    expression                     shift and go to state 86
    something_ex                   shift and go to state 29
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 145

    (120) decVarOne -> ID DEQUAL . ID
    (121) decVarOne -> ID DEQUAL . INTEGER

    ID              shift and go to state 200
    INTEGER         shift and go to state 201


state 146

    (170) array_var -> ID LCORCHE . index RCORCHE
    (176) map_var -> ID LCORCHE . key RCORCHE
    (171) index -> . ID
    (172) index -> . INTEGER
    (173) index -> . expression
    (177) key -> . ID
    (178) key -> . values
    (179) key -> . operations
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (40) values -> . STRING
    (41) values -> . INTEGER
    (42) values -> . FLOAT
    (43) values -> . TRUE
    (44) values -> . FALSE
    (54) operations -> . expression
    (55) operations -> . comparison
    (56) operations -> . logic_operation
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    ID              shift and go to state 202
    INTEGER         shift and go to state 203
    STRING          shift and go to state 119
    FLOAT           shift and go to state 121
    TRUE            shift and go to state 122
    FALSE           shift and go to state 123
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    NOT             shift and go to state 49

    index                          shift and go to state 171
    key                            shift and go to state 173
    expression                     shift and go to state 204
    values                         shift and go to state 176
    operations                     shift and go to state 177
    something_ex                   shift and go to state 29
    comparison                     shift and go to state 125
    logic_operation                shift and go to state 126
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 147

    (140) comparison -> value op value .

    $end            reduce using rule 140 (comparison -> value op value .)
    AND             reduce using rule 140 (comparison -> value op value .)
    OR              reduce using rule 140 (comparison -> value op value .)
    LLLAVE          reduce using rule 140 (comparison -> value op value .)
    COLON           reduce using rule 140 (comparison -> value op value .)
    RLLAVE          reduce using rule 140 (comparison -> value op value .)
    DEFAULT         reduce using rule 140 (comparison -> value op value .)
    CASE            reduce using rule 140 (comparison -> value op value .)
    RETURN          reduce using rule 140 (comparison -> value op value .)
    RPAREN          reduce using rule 140 (comparison -> value op value .)
    RCORCHE         reduce using rule 140 (comparison -> value op value .)
    COMA            reduce using rule 140 (comparison -> value op value .)


state 148

    (151) logic_recu -> logic_op logic_value .
    (152) logic_recu -> logic_op logic_value . logic_recu
    (151) logic_recu -> . logic_op logic_value
    (152) logic_recu -> . logic_op logic_value logic_recu
    (158) logic_op -> . AND
    (159) logic_op -> . OR

    $end            reduce using rule 151 (logic_recu -> logic_op logic_value .)
    LLLAVE          reduce using rule 151 (logic_recu -> logic_op logic_value .)
    COLON           reduce using rule 151 (logic_recu -> logic_op logic_value .)
    RLLAVE          reduce using rule 151 (logic_recu -> logic_op logic_value .)
    DEFAULT         reduce using rule 151 (logic_recu -> logic_op logic_value .)
    CASE            reduce using rule 151 (logic_recu -> logic_op logic_value .)
    RETURN          reduce using rule 151 (logic_recu -> logic_op logic_value .)
    RPAREN          reduce using rule 151 (logic_recu -> logic_op logic_value .)
    RCORCHE         reduce using rule 151 (logic_recu -> logic_op logic_value .)
    COMA            reduce using rule 151 (logic_recu -> logic_op logic_value .)
    AND             shift and go to state 92
    OR              shift and go to state 93

    logic_op                       shift and go to state 91
    logic_recu                     shift and go to state 205

state 149

    (153) logic_value -> negation .

    AND             reduce using rule 153 (logic_value -> negation .)
    OR              reduce using rule 153 (logic_value -> negation .)
    $end            reduce using rule 153 (logic_value -> negation .)
    LLLAVE          reduce using rule 153 (logic_value -> negation .)
    COLON           reduce using rule 153 (logic_value -> negation .)
    RLLAVE          reduce using rule 153 (logic_value -> negation .)
    DEFAULT         reduce using rule 153 (logic_value -> negation .)
    CASE            reduce using rule 153 (logic_value -> negation .)
    RETURN          reduce using rule 153 (logic_value -> negation .)
    RPAREN          reduce using rule 153 (logic_value -> negation .)
    RCORCHE         reduce using rule 153 (logic_value -> negation .)
    COMA            reduce using rule 153 (logic_value -> negation .)


state 150

    (154) logic_value -> comparison .

    AND             reduce using rule 154 (logic_value -> comparison .)
    OR              reduce using rule 154 (logic_value -> comparison .)
    $end            reduce using rule 154 (logic_value -> comparison .)
    LLLAVE          reduce using rule 154 (logic_value -> comparison .)
    COLON           reduce using rule 154 (logic_value -> comparison .)
    RLLAVE          reduce using rule 154 (logic_value -> comparison .)
    DEFAULT         reduce using rule 154 (logic_value -> comparison .)
    CASE            reduce using rule 154 (logic_value -> comparison .)
    RETURN          reduce using rule 154 (logic_value -> comparison .)
    RPAREN          reduce using rule 154 (logic_value -> comparison .)
    RCORCHE         reduce using rule 154 (logic_value -> comparison .)
    COMA            reduce using rule 154 (logic_value -> comparison .)


state 151

    (155) logic_value -> ID .
    (141) value -> ID .
    (202) something_ex -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (176) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 141 (value -> ID .)
    AND             reduce using rule 155 (logic_value -> ID .)
    OR              reduce using rule 155 (logic_value -> ID .)
    $end            reduce using rule 155 (logic_value -> ID .)
    LLLAVE          reduce using rule 155 (logic_value -> ID .)
    COLON           reduce using rule 155 (logic_value -> ID .)
    RLLAVE          reduce using rule 155 (logic_value -> ID .)
    DEFAULT         reduce using rule 155 (logic_value -> ID .)
    CASE            reduce using rule 155 (logic_value -> ID .)
    RETURN          reduce using rule 155 (logic_value -> ID .)
    RPAREN          reduce using rule 155 (logic_value -> ID .)
    RCORCHE         reduce using rule 155 (logic_value -> ID .)
    COMA            reduce using rule 155 (logic_value -> ID .)
    GREATER         reduce using rule 141 (value -> ID .)
    SMALLER         reduce using rule 141 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 141 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 141 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 141 (value -> ID .)
    NOT_EQUAL       reduce using rule 141 (value -> ID .)
    PLUS            reduce using rule 141 (value -> ID .)
    TIMES           reduce using rule 141 (value -> ID .)
    DIVIDE          reduce using rule 141 (value -> ID .)
    MINUS           reduce using rule 141 (value -> ID .)
    LCORCHE         shift and go to state 146

  ! GREATER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 202 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 202 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 202 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 202 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 202 (something_ex -> ID .) ]


state 152

    (84) decVar -> VAR ID EQUAL . INTEGER
    (85) decVar -> VAR ID EQUAL . ID
    (86) decVar -> VAR ID EQUAL . FLOAT
    (87) decVar -> VAR ID EQUAL . expression
    (88) decVar -> VAR ID EQUAL . logic_operation
    (89) decVar -> VAR ID EQUAL . comparison
    (90) decVar -> VAR ID EQUAL . STRING
    (166) array_declaration -> VAR ID EQUAL . LCORCHE capacity RCORCHE data_types arr_content
    (97) slice_declaration -> VAR ID EQUAL . LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> VAR ID EQUAL . funM
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (140) comparison -> . value op value
    (101) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (102) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (141) value -> . ID
    (142) value -> . expression
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    INTEGER         shift and go to state 207
    ID              shift and go to state 206
    FLOAT           shift and go to state 208
    STRING          shift and go to state 212
    LCORCHE         shift and go to state 213
    MAKE            shift and go to state 163
    NOT             shift and go to state 49
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    expression                     shift and go to state 209
    logic_operation                shift and go to state 210
    comparison                     shift and go to state 211
    funM                           shift and go to state 214
    something_ex                   shift and go to state 29
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    value                          shift and go to state 32
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 153

    (165) array_declaration -> VAR ID LCORCHE . capacity RCORCHE data_types
    (96) slice_declaration -> VAR ID LCORCHE . RCORCHE data_types
    (175) map_declaration -> VAR ID LCORCHE . data_types RCORCHE data_types
    (167) capacity -> . INTEGER
    (168) capacity -> . ID
    (169) capacity -> . expression
    (45) data_types -> . INT32
    (46) data_types -> . INT64
    (47) data_types -> . FLOAT32
    (48) data_types -> . FLOAT64
    (49) data_types -> . BYTE
    (50) data_types -> . WINT
    (51) data_types -> . WFLOAT
    (52) data_types -> . WSTRING
    (53) data_types -> . BOOL
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    RCORCHE         shift and go to state 217
    INTEGER         shift and go to state 219
    ID              shift and go to state 215
    INT32           shift and go to state 221
    INT64           shift and go to state 222
    FLOAT32         shift and go to state 223
    FLOAT64         shift and go to state 224
    BYTE            shift and go to state 225
    WINT            shift and go to state 226
    WFLOAT          shift and go to state 227
    WSTRING         shift and go to state 228
    BOOL            shift and go to state 229
    FLOAT           shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    capacity                       shift and go to state 216
    data_types                     shift and go to state 218
    expression                     shift and go to state 220
    something_ex                   shift and go to state 29
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 154

    (133) cStruct -> ID DEQUAL ID . LLLAVE asignaciones RLLAVE
    (120) decVarOne -> ID DEQUAL ID .
    (202) something_ex -> ID .
    (155) logic_value -> ID .
    (141) value -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (176) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for COLON resolved using rule 120 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for $end resolved using rule 120 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 120 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 120 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for CASE resolved using rule 120 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 120 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 141 (value -> ID .)
    LLLAVE          shift and go to state 230
    COLON           reduce using rule 120 (decVarOne -> ID DEQUAL ID .)
    $end            reduce using rule 120 (decVarOne -> ID DEQUAL ID .)
    RLLAVE          reduce using rule 120 (decVarOne -> ID DEQUAL ID .)
    DEFAULT         reduce using rule 120 (decVarOne -> ID DEQUAL ID .)
    CASE            reduce using rule 120 (decVarOne -> ID DEQUAL ID .)
    RETURN          reduce using rule 120 (decVarOne -> ID DEQUAL ID .)
    AND             reduce using rule 155 (logic_value -> ID .)
    OR              reduce using rule 155 (logic_value -> ID .)
    GREATER         reduce using rule 141 (value -> ID .)
    SMALLER         reduce using rule 141 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 141 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 141 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 141 (value -> ID .)
    NOT_EQUAL       reduce using rule 141 (value -> ID .)
    PLUS            reduce using rule 141 (value -> ID .)
    TIMES           reduce using rule 141 (value -> ID .)
    DIVIDE          reduce using rule 141 (value -> ID .)
    MINUS           reduce using rule 141 (value -> ID .)
    LCORCHE         shift and go to state 146

  ! GREATER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 202 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 202 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 202 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 202 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 202 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 202 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 202 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 202 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 202 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 202 (something_ex -> ID .) ]


state 155

    (91) decVar -> ID DEQUAL STRING .

    COLON           reduce using rule 91 (decVar -> ID DEQUAL STRING .)
    $end            reduce using rule 91 (decVar -> ID DEQUAL STRING .)
    RLLAVE          reduce using rule 91 (decVar -> ID DEQUAL STRING .)
    DEFAULT         reduce using rule 91 (decVar -> ID DEQUAL STRING .)
    CASE            reduce using rule 91 (decVar -> ID DEQUAL STRING .)
    RETURN          reduce using rule 91 (decVar -> ID DEQUAL STRING .)


state 156

    (92) decVar -> ID DEQUAL FLOAT .
    (204) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 92 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 92 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 92 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 92 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 92 (decVar -> ID DEQUAL FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 92 (decVar -> ID DEQUAL FLOAT .)
    COLON           reduce using rule 92 (decVar -> ID DEQUAL FLOAT .)
    $end            reduce using rule 92 (decVar -> ID DEQUAL FLOAT .)
    RLLAVE          reduce using rule 92 (decVar -> ID DEQUAL FLOAT .)
    DEFAULT         reduce using rule 92 (decVar -> ID DEQUAL FLOAT .)
    CASE            reduce using rule 92 (decVar -> ID DEQUAL FLOAT .)
    RETURN          reduce using rule 92 (decVar -> ID DEQUAL FLOAT .)
    GREATER         reduce using rule 204 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 204 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 204 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 204 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 204 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 204 (something_ex -> FLOAT .)
    PLUS            reduce using rule 204 (something_ex -> FLOAT .)
    TIMES           reduce using rule 204 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 204 (something_ex -> FLOAT .)
    MINUS           reduce using rule 204 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 204 (something_ex -> FLOAT .) ]


state 157

    (93) decVar -> ID DEQUAL expression .
    (142) value -> expression .

    COLON           reduce using rule 93 (decVar -> ID DEQUAL expression .)
    $end            reduce using rule 93 (decVar -> ID DEQUAL expression .)
    RLLAVE          reduce using rule 93 (decVar -> ID DEQUAL expression .)
    DEFAULT         reduce using rule 93 (decVar -> ID DEQUAL expression .)
    CASE            reduce using rule 93 (decVar -> ID DEQUAL expression .)
    RETURN          reduce using rule 93 (decVar -> ID DEQUAL expression .)
    GREATER         reduce using rule 142 (value -> expression .)
    SMALLER         reduce using rule 142 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 142 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 142 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 142 (value -> expression .)
    NOT_EQUAL       reduce using rule 142 (value -> expression .)
    PLUS            reduce using rule 142 (value -> expression .)
    TIMES           reduce using rule 142 (value -> expression .)
    DIVIDE          reduce using rule 142 (value -> expression .)
    MINUS           reduce using rule 142 (value -> expression .)


state 158

    (94) decVar -> ID DEQUAL logic_operation .

    COLON           reduce using rule 94 (decVar -> ID DEQUAL logic_operation .)
    $end            reduce using rule 94 (decVar -> ID DEQUAL logic_operation .)
    RLLAVE          reduce using rule 94 (decVar -> ID DEQUAL logic_operation .)
    DEFAULT         reduce using rule 94 (decVar -> ID DEQUAL logic_operation .)
    CASE            reduce using rule 94 (decVar -> ID DEQUAL logic_operation .)
    RETURN          reduce using rule 94 (decVar -> ID DEQUAL logic_operation .)


state 159

    (95) decVar -> ID DEQUAL comparison .
    (154) logic_value -> comparison .

    COLON           reduce using rule 95 (decVar -> ID DEQUAL comparison .)
    $end            reduce using rule 95 (decVar -> ID DEQUAL comparison .)
    RLLAVE          reduce using rule 95 (decVar -> ID DEQUAL comparison .)
    DEFAULT         reduce using rule 95 (decVar -> ID DEQUAL comparison .)
    CASE            reduce using rule 95 (decVar -> ID DEQUAL comparison .)
    RETURN          reduce using rule 95 (decVar -> ID DEQUAL comparison .)
    AND             reduce using rule 154 (logic_value -> comparison .)
    OR              reduce using rule 154 (logic_value -> comparison .)


state 160

    (99) slice_declaration -> ID DEQUAL funM .

    COLON           reduce using rule 99 (slice_declaration -> ID DEQUAL funM .)
    $end            reduce using rule 99 (slice_declaration -> ID DEQUAL funM .)
    RLLAVE          reduce using rule 99 (slice_declaration -> ID DEQUAL funM .)
    DEFAULT         reduce using rule 99 (slice_declaration -> ID DEQUAL funM .)
    CASE            reduce using rule 99 (slice_declaration -> ID DEQUAL funM .)
    RETURN          reduce using rule 99 (slice_declaration -> ID DEQUAL funM .)


state 161

    (100) slice_declaration -> ID DEQUAL LCORCHE . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 231


state 162

    (121) decVarOne -> ID DEQUAL INTEGER .
    (203) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 121 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 121 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 121 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 121 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 121 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 121 (decVarOne -> ID DEQUAL INTEGER .)
    COLON           reduce using rule 121 (decVarOne -> ID DEQUAL INTEGER .)
    $end            reduce using rule 121 (decVarOne -> ID DEQUAL INTEGER .)
    RLLAVE          reduce using rule 121 (decVarOne -> ID DEQUAL INTEGER .)
    DEFAULT         reduce using rule 121 (decVarOne -> ID DEQUAL INTEGER .)
    CASE            reduce using rule 121 (decVarOne -> ID DEQUAL INTEGER .)
    RETURN          reduce using rule 121 (decVarOne -> ID DEQUAL INTEGER .)
    GREATER         reduce using rule 203 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 203 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 203 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 203 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 203 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 203 (something_ex -> INTEGER .)
    PLUS            reduce using rule 203 (something_ex -> INTEGER .)
    TIMES           reduce using rule 203 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 203 (something_ex -> INTEGER .)
    MINUS           reduce using rule 203 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 203 (something_ex -> INTEGER .) ]


state 163

    (101) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (102) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LPAREN          shift and go to state 232


state 164

    (62) any -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (176) map_var -> ID . LCORCHE key RCORCHE
    (202) something_ex -> ID .
    (141) value -> ID .
    (155) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 62 (any -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 62 (any -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 62 (any -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 62 (any -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 62 (any -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 62 (any -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 141 (value -> ID .)
    COLON           reduce using rule 62 (any -> ID .)
    $end            reduce using rule 62 (any -> ID .)
    RLLAVE          reduce using rule 62 (any -> ID .)
    DEFAULT         reduce using rule 62 (any -> ID .)
    CASE            reduce using rule 62 (any -> ID .)
    RETURN          reduce using rule 62 (any -> ID .)
    LCORCHE         shift and go to state 146
    GREATER         reduce using rule 141 (value -> ID .)
    SMALLER         reduce using rule 141 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 141 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 141 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 141 (value -> ID .)
    NOT_EQUAL       reduce using rule 141 (value -> ID .)
    PLUS            reduce using rule 141 (value -> ID .)
    TIMES           reduce using rule 141 (value -> ID .)
    DIVIDE          reduce using rule 141 (value -> ID .)
    MINUS           reduce using rule 141 (value -> ID .)
    AND             reduce using rule 155 (logic_value -> ID .)
    OR              reduce using rule 155 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 202 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 202 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 202 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 202 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 202 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 202 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 202 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 202 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 202 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 202 (something_ex -> ID .) ]


state 165

    (59) var_asignation -> ID EQUAL any .

    COLON           reduce using rule 59 (var_asignation -> ID EQUAL any .)
    $end            reduce using rule 59 (var_asignation -> ID EQUAL any .)
    RLLAVE          reduce using rule 59 (var_asignation -> ID EQUAL any .)
    DEFAULT         reduce using rule 59 (var_asignation -> ID EQUAL any .)
    CASE            reduce using rule 59 (var_asignation -> ID EQUAL any .)
    RETURN          reduce using rule 59 (var_asignation -> ID EQUAL any .)


state 166

    (60) any -> values .

    COLON           reduce using rule 60 (any -> values .)
    $end            reduce using rule 60 (any -> values .)
    RLLAVE          reduce using rule 60 (any -> values .)
    DEFAULT         reduce using rule 60 (any -> values .)
    CASE            reduce using rule 60 (any -> values .)
    RETURN          reduce using rule 60 (any -> values .)


state 167

    (61) any -> operations .

    COLON           reduce using rule 61 (any -> operations .)
    $end            reduce using rule 61 (any -> operations .)
    RLLAVE          reduce using rule 61 (any -> operations .)
    DEFAULT         reduce using rule 61 (any -> operations .)
    CASE            reduce using rule 61 (any -> operations .)
    RETURN          reduce using rule 61 (any -> operations .)


state 168

    (63) any -> data_structure .
    (205) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 63 (any -> data_structure .)
  ! reduce/reduce conflict for $end resolved using rule 63 (any -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 63 (any -> data_structure .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 63 (any -> data_structure .)
  ! reduce/reduce conflict for CASE resolved using rule 63 (any -> data_structure .)
  ! reduce/reduce conflict for RETURN resolved using rule 63 (any -> data_structure .)
    COLON           reduce using rule 63 (any -> data_structure .)
    $end            reduce using rule 63 (any -> data_structure .)
    RLLAVE          reduce using rule 63 (any -> data_structure .)
    DEFAULT         reduce using rule 63 (any -> data_structure .)
    CASE            reduce using rule 63 (any -> data_structure .)
    RETURN          reduce using rule 63 (any -> data_structure .)
    GREATER         reduce using rule 205 (something_ex -> data_structure .)
    SMALLER         reduce using rule 205 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 205 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 205 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 205 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 205 (something_ex -> data_structure .)
    PLUS            reduce using rule 205 (something_ex -> data_structure .)
    TIMES           reduce using rule 205 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 205 (something_ex -> data_structure .)
    MINUS           reduce using rule 205 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 205 (something_ex -> data_structure .) ]
  ! $end            [ reduce using rule 205 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 205 (something_ex -> data_structure .) ]
  ! DEFAULT         [ reduce using rule 205 (something_ex -> data_structure .) ]
  ! CASE            [ reduce using rule 205 (something_ex -> data_structure .) ]
  ! RETURN          [ reduce using rule 205 (something_ex -> data_structure .) ]


state 169

    (64) any -> funciones .
    (206) something_ex -> funciones .

  ! reduce/reduce conflict for COLON resolved using rule 64 (any -> funciones .)
  ! reduce/reduce conflict for $end resolved using rule 64 (any -> funciones .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 64 (any -> funciones .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 64 (any -> funciones .)
  ! reduce/reduce conflict for CASE resolved using rule 64 (any -> funciones .)
  ! reduce/reduce conflict for RETURN resolved using rule 64 (any -> funciones .)
    COLON           reduce using rule 64 (any -> funciones .)
    $end            reduce using rule 64 (any -> funciones .)
    RLLAVE          reduce using rule 64 (any -> funciones .)
    DEFAULT         reduce using rule 64 (any -> funciones .)
    CASE            reduce using rule 64 (any -> funciones .)
    RETURN          reduce using rule 64 (any -> funciones .)
    GREATER         reduce using rule 206 (something_ex -> funciones .)
    SMALLER         reduce using rule 206 (something_ex -> funciones .)
    GREATER_OR_EQUAL reduce using rule 206 (something_ex -> funciones .)
    SMALLER_OR_EQUAL reduce using rule 206 (something_ex -> funciones .)
    EQUAL_COMPARE   reduce using rule 206 (something_ex -> funciones .)
    NOT_EQUAL       reduce using rule 206 (something_ex -> funciones .)
    PLUS            reduce using rule 206 (something_ex -> funciones .)
    TIMES           reduce using rule 206 (something_ex -> funciones .)
    DIVIDE          reduce using rule 206 (something_ex -> funciones .)
    MINUS           reduce using rule 206 (something_ex -> funciones .)

  ! COLON           [ reduce using rule 206 (something_ex -> funciones .) ]
  ! $end            [ reduce using rule 206 (something_ex -> funciones .) ]
  ! RLLAVE          [ reduce using rule 206 (something_ex -> funciones .) ]
  ! DEFAULT         [ reduce using rule 206 (something_ex -> funciones .) ]
  ! CASE            [ reduce using rule 206 (something_ex -> funciones .) ]
  ! RETURN          [ reduce using rule 206 (something_ex -> funciones .) ]


state 170

    (171) index -> ID .
    (107) index_s -> ID .
    (177) key -> ID .
    (202) something_ex -> ID .
    (141) value -> ID .
    (155) logic_value -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (176) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for RCORCHE resolved using rule 107 (index_s -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 107 (index_s -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 107 (index_s -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 141 (value -> ID .)
    RCORCHE         reduce using rule 107 (index_s -> ID .)
    GREATER         reduce using rule 141 (value -> ID .)
    SMALLER         reduce using rule 141 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 141 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 141 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 141 (value -> ID .)
    NOT_EQUAL       reduce using rule 141 (value -> ID .)
    PLUS            reduce using rule 141 (value -> ID .)
    TIMES           reduce using rule 141 (value -> ID .)
    DIVIDE          reduce using rule 141 (value -> ID .)
    MINUS           reduce using rule 141 (value -> ID .)
    AND             reduce using rule 155 (logic_value -> ID .)
    OR              reduce using rule 155 (logic_value -> ID .)
    LCORCHE         shift and go to state 146

  ! RCORCHE         [ reduce using rule 171 (index -> ID .) ]
  ! RCORCHE         [ reduce using rule 177 (key -> ID .) ]
  ! GREATER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 202 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 202 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 202 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 202 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 202 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 202 (something_ex -> ID .) ]


state 171

    (170) array_var -> ID LCORCHE index . RCORCHE

    RCORCHE         shift and go to state 233


state 172

    (106) slice_var -> ID LCORCHE index_s . RCORCHE

    RCORCHE         shift and go to state 234


state 173

    (176) map_var -> ID LCORCHE key . RCORCHE

    RCORCHE         shift and go to state 235


state 174

    (172) index -> INTEGER .
    (108) index_s -> INTEGER .
    (41) values -> INTEGER .
    (203) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 108 (index_s -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 41 (values -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 41 (values -> INTEGER .)
    RCORCHE         reduce using rule 41 (values -> INTEGER .)
    GREATER         reduce using rule 203 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 203 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 203 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 203 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 203 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 203 (something_ex -> INTEGER .)
    PLUS            reduce using rule 203 (something_ex -> INTEGER .)
    TIMES           reduce using rule 203 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 203 (something_ex -> INTEGER .)
    MINUS           reduce using rule 203 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 172 (index -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 108 (index_s -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 203 (something_ex -> INTEGER .) ]


state 175

    (173) index -> expression .
    (109) index_s -> expression .
    (54) operations -> expression .
    (142) value -> expression .

  ! reduce/reduce conflict for RCORCHE resolved using rule 109 (index_s -> expression .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 54 (operations -> expression .)
    RCORCHE         reduce using rule 54 (operations -> expression .)
    GREATER         reduce using rule 142 (value -> expression .)
    SMALLER         reduce using rule 142 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 142 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 142 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 142 (value -> expression .)
    NOT_EQUAL       reduce using rule 142 (value -> expression .)
    PLUS            reduce using rule 142 (value -> expression .)
    TIMES           reduce using rule 142 (value -> expression .)
    DIVIDE          reduce using rule 142 (value -> expression .)
    MINUS           reduce using rule 142 (value -> expression .)

  ! RCORCHE         [ reduce using rule 173 (index -> expression .) ]
  ! RCORCHE         [ reduce using rule 109 (index_s -> expression .) ]


state 176

    (178) key -> values .

    RCORCHE         reduce using rule 178 (key -> values .)


state 177

    (179) key -> operations .

    RCORCHE         reduce using rule 179 (key -> operations .)


state 178

    (115) funciones -> APPEND LPAREN ID . COMA values RPAREN
    (116) funciones -> APPEND LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 236


state 179

    (117) funciones -> LEN LPAREN ID . RPAREN

    RPAREN          shift and go to state 237


state 180

    (118) funciones -> COPY LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 238


state 181

    (119) funciones -> DELETE LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 239


state 182

    (122) SenIF -> IF comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenElseIF
    (18) codigo -> . SenElse
    (19) codigo -> . SenStruct
    (20) codigo -> . cStruct
    (21) codigo -> . switch_statement
    (22) codigo -> . array_declaration COLON
    (23) codigo -> . array_declaration
    (24) codigo -> . array_var COLON
    (25) codigo -> . array_var
    (26) codigo -> . array_assignment COLON
    (27) codigo -> . array_assignment
    (28) codigo -> . slice_declaration COLON
    (29) codigo -> . slice_declaration
    (30) codigo -> . slice_var COLON
    (31) codigo -> . slice_var
    (32) codigo -> . slice_assignment COLON
    (33) codigo -> . slice_assignment
    (34) codigo -> . map_declaration COLON
    (35) codigo -> . map_declaration
    (36) codigo -> . map_assignment COLON
    (37) codigo -> . map_assignment
    (38) codigo -> . func_declaration
    (39) codigo -> . main_func
    (192) impresion -> . PRINT LPAREN content RPAREN
    (76) scan_func -> . SCAN LPAREN POINTER RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (77) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (83) decVar -> . decVarOne
    (84) decVar -> . VAR ID EQUAL INTEGER
    (85) decVar -> . VAR ID EQUAL ID
    (86) decVar -> . VAR ID EQUAL FLOAT
    (87) decVar -> . VAR ID EQUAL expression
    (88) decVar -> . VAR ID EQUAL logic_operation
    (89) decVar -> . VAR ID EQUAL comparison
    (90) decVar -> . VAR ID EQUAL STRING
    (91) decVar -> . ID DEQUAL STRING
    (92) decVar -> . ID DEQUAL FLOAT
    (93) decVar -> . ID DEQUAL expression
    (94) decVar -> . ID DEQUAL logic_operation
    (95) decVar -> . ID DEQUAL comparison
    (59) var_asignation -> . ID EQUAL any
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (122) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (123) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (125) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (129) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (160) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (165) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (170) array_var -> . ID LCORCHE index RCORCHE
    (174) array_assignment -> . array_var EQUAL something
    (96) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> . VAR ID EQUAL funM
    (99) slice_declaration -> . ID DEQUAL funM
    (100) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> . ID LCORCHE index_s RCORCHE
    (110) slice_assignment -> . slice_var EQUAL something_s
    (175) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (180) map_assignment -> . array_var EQUAL something
    (181) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (176) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 27
    SCAN            shift and go to state 28
    FOR             shift and go to state 30
    VAR             shift and go to state 35
    ID              shift and go to state 36
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 43
    ELSE            shift and go to state 44
    TYPE            shift and go to state 45
    SWITCH          shift and go to state 46
    FUNC            shift and go to state 47
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    NOT             shift and go to state 49

    comparison                     shift and go to state 6
    codigo                         shift and go to state 240
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenElseIF                      shift and go to state 12
    SenElse                        shift and go to state 13
    SenStruct                      shift and go to state 14
    cStruct                        shift and go to state 15
    switch_statement               shift and go to state 16
    array_declaration              shift and go to state 17
    array_var                      shift and go to state 18
    array_assignment               shift and go to state 19
    slice_declaration              shift and go to state 20
    slice_var                      shift and go to state 21
    slice_assignment               shift and go to state 22
    map_declaration                shift and go to state 23
    map_assignment                 shift and go to state 24
    func_declaration               shift and go to state 25
    main_func                      shift and go to state 26
    something_ex                   shift and go to state 29
    decVarOne                      shift and go to state 31
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    map_var                        shift and go to state 50

state 183

    (123) SenIF -> IF TRUE LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenElseIF
    (18) codigo -> . SenElse
    (19) codigo -> . SenStruct
    (20) codigo -> . cStruct
    (21) codigo -> . switch_statement
    (22) codigo -> . array_declaration COLON
    (23) codigo -> . array_declaration
    (24) codigo -> . array_var COLON
    (25) codigo -> . array_var
    (26) codigo -> . array_assignment COLON
    (27) codigo -> . array_assignment
    (28) codigo -> . slice_declaration COLON
    (29) codigo -> . slice_declaration
    (30) codigo -> . slice_var COLON
    (31) codigo -> . slice_var
    (32) codigo -> . slice_assignment COLON
    (33) codigo -> . slice_assignment
    (34) codigo -> . map_declaration COLON
    (35) codigo -> . map_declaration
    (36) codigo -> . map_assignment COLON
    (37) codigo -> . map_assignment
    (38) codigo -> . func_declaration
    (39) codigo -> . main_func
    (192) impresion -> . PRINT LPAREN content RPAREN
    (76) scan_func -> . SCAN LPAREN POINTER RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (77) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (83) decVar -> . decVarOne
    (84) decVar -> . VAR ID EQUAL INTEGER
    (85) decVar -> . VAR ID EQUAL ID
    (86) decVar -> . VAR ID EQUAL FLOAT
    (87) decVar -> . VAR ID EQUAL expression
    (88) decVar -> . VAR ID EQUAL logic_operation
    (89) decVar -> . VAR ID EQUAL comparison
    (90) decVar -> . VAR ID EQUAL STRING
    (91) decVar -> . ID DEQUAL STRING
    (92) decVar -> . ID DEQUAL FLOAT
    (93) decVar -> . ID DEQUAL expression
    (94) decVar -> . ID DEQUAL logic_operation
    (95) decVar -> . ID DEQUAL comparison
    (59) var_asignation -> . ID EQUAL any
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (122) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (123) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (125) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (129) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (160) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (165) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (170) array_var -> . ID LCORCHE index RCORCHE
    (174) array_assignment -> . array_var EQUAL something
    (96) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> . VAR ID EQUAL funM
    (99) slice_declaration -> . ID DEQUAL funM
    (100) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> . ID LCORCHE index_s RCORCHE
    (110) slice_assignment -> . slice_var EQUAL something_s
    (175) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (180) map_assignment -> . array_var EQUAL something
    (181) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (176) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 27
    SCAN            shift and go to state 28
    FOR             shift and go to state 30
    VAR             shift and go to state 35
    ID              shift and go to state 36
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 43
    ELSE            shift and go to state 44
    TYPE            shift and go to state 45
    SWITCH          shift and go to state 46
    FUNC            shift and go to state 47
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    NOT             shift and go to state 49

    codigo                         shift and go to state 241
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenElseIF                      shift and go to state 12
    SenElse                        shift and go to state 13
    SenStruct                      shift and go to state 14
    cStruct                        shift and go to state 15
    switch_statement               shift and go to state 16
    array_declaration              shift and go to state 17
    array_var                      shift and go to state 18
    array_assignment               shift and go to state 19
    slice_declaration              shift and go to state 20
    slice_var                      shift and go to state 21
    slice_assignment               shift and go to state 22
    map_declaration                shift and go to state 23
    map_assignment                 shift and go to state 24
    func_declaration               shift and go to state 25
    main_func                      shift and go to state 26
    something_ex                   shift and go to state 29
    decVarOne                      shift and go to state 31
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    map_var                        shift and go to state 50

state 184

    (124) SenIF -> IF FALSE LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenElseIF
    (18) codigo -> . SenElse
    (19) codigo -> . SenStruct
    (20) codigo -> . cStruct
    (21) codigo -> . switch_statement
    (22) codigo -> . array_declaration COLON
    (23) codigo -> . array_declaration
    (24) codigo -> . array_var COLON
    (25) codigo -> . array_var
    (26) codigo -> . array_assignment COLON
    (27) codigo -> . array_assignment
    (28) codigo -> . slice_declaration COLON
    (29) codigo -> . slice_declaration
    (30) codigo -> . slice_var COLON
    (31) codigo -> . slice_var
    (32) codigo -> . slice_assignment COLON
    (33) codigo -> . slice_assignment
    (34) codigo -> . map_declaration COLON
    (35) codigo -> . map_declaration
    (36) codigo -> . map_assignment COLON
    (37) codigo -> . map_assignment
    (38) codigo -> . func_declaration
    (39) codigo -> . main_func
    (192) impresion -> . PRINT LPAREN content RPAREN
    (76) scan_func -> . SCAN LPAREN POINTER RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (77) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (83) decVar -> . decVarOne
    (84) decVar -> . VAR ID EQUAL INTEGER
    (85) decVar -> . VAR ID EQUAL ID
    (86) decVar -> . VAR ID EQUAL FLOAT
    (87) decVar -> . VAR ID EQUAL expression
    (88) decVar -> . VAR ID EQUAL logic_operation
    (89) decVar -> . VAR ID EQUAL comparison
    (90) decVar -> . VAR ID EQUAL STRING
    (91) decVar -> . ID DEQUAL STRING
    (92) decVar -> . ID DEQUAL FLOAT
    (93) decVar -> . ID DEQUAL expression
    (94) decVar -> . ID DEQUAL logic_operation
    (95) decVar -> . ID DEQUAL comparison
    (59) var_asignation -> . ID EQUAL any
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (122) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (123) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (125) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (129) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (160) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (165) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (170) array_var -> . ID LCORCHE index RCORCHE
    (174) array_assignment -> . array_var EQUAL something
    (96) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> . VAR ID EQUAL funM
    (99) slice_declaration -> . ID DEQUAL funM
    (100) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> . ID LCORCHE index_s RCORCHE
    (110) slice_assignment -> . slice_var EQUAL something_s
    (175) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (180) map_assignment -> . array_var EQUAL something
    (181) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (176) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 27
    SCAN            shift and go to state 28
    FOR             shift and go to state 30
    VAR             shift and go to state 35
    ID              shift and go to state 36
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 43
    ELSE            shift and go to state 44
    TYPE            shift and go to state 45
    SWITCH          shift and go to state 46
    FUNC            shift and go to state 47
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    NOT             shift and go to state 49

    codigo                         shift and go to state 242
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenElseIF                      shift and go to state 12
    SenElse                        shift and go to state 13
    SenStruct                      shift and go to state 14
    cStruct                        shift and go to state 15
    switch_statement               shift and go to state 16
    array_declaration              shift and go to state 17
    array_var                      shift and go to state 18
    array_assignment               shift and go to state 19
    slice_declaration              shift and go to state 20
    slice_var                      shift and go to state 21
    slice_assignment               shift and go to state 22
    map_declaration                shift and go to state 23
    map_assignment                 shift and go to state 24
    func_declaration               shift and go to state 25
    main_func                      shift and go to state 26
    something_ex                   shift and go to state 29
    decVarOne                      shift and go to state 31
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    map_var                        shift and go to state 50

state 185

    (125) SenElseIF -> ELSE IF comparison . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 243


state 186

    (126) SenElseIF -> ELSE IF TRUE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 244


state 187

    (127) SenElseIF -> ELSE IF FALSE . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 245


state 188

    (128) SenElse -> ELSE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 246


state 189

    (129) SenStruct -> TYPE ID STRUCT . LLLAVE declaration RLLAVE

    LLLAVE          shift and go to state 247


state 190

    (160) switch_statement -> SWITCH ID LLLAVE . cases RLLAVE
    (161) cases -> . CASE values POINTS codigo
    (162) cases -> . CASE values POINTS codigo more

    CASE            shift and go to state 249

    cases                          shift and go to state 248

state 191

    (181) func_declaration -> FUNC ID LPAREN . params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> FUNC ID LPAREN . params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (189) params -> . ID data_types
    (190) params -> . more_params
    (191) more_params -> . ID data_types COMA params

    ID              shift and go to state 250

    params                         shift and go to state 251
    more_params                    shift and go to state 252

state 192

    (75) main_func -> FUNC MAIN LPAREN . RPAREN LLLAVE codigo RLLAVE

    RPAREN          shift and go to state 253


state 193

    (192) impresion -> PRINT LPAREN content RPAREN .

    COLON           reduce using rule 192 (impresion -> PRINT LPAREN content RPAREN .)
    $end            reduce using rule 192 (impresion -> PRINT LPAREN content RPAREN .)
    RLLAVE          reduce using rule 192 (impresion -> PRINT LPAREN content RPAREN .)
    DEFAULT         reduce using rule 192 (impresion -> PRINT LPAREN content RPAREN .)
    CASE            reduce using rule 192 (impresion -> PRINT LPAREN content RPAREN .)
    RETURN          reduce using rule 192 (impresion -> PRINT LPAREN content RPAREN .)


state 194

    (76) scan_func -> SCAN LPAREN POINTER RPAREN .

    COLON           reduce using rule 76 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    $end            reduce using rule 76 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    RLLAVE          reduce using rule 76 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    DEFAULT         reduce using rule 76 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    CASE            reduce using rule 76 (scan_func -> SCAN LPAREN POINTER RPAREN .)
    RETURN          reduce using rule 76 (scan_func -> SCAN LPAREN POINTER RPAREN .)


state 195

    (201) adicionaEx -> op something_ex adicionaEx .

    COLON           reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    $end            reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    GREATER         reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    SMALLER         reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    GREATER_OR_EQUAL reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    SMALLER_OR_EQUAL reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    EQUAL_COMPARE   reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    NOT_EQUAL       reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    PLUS            reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    TIMES           reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    DIVIDE          reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    MINUS           reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    RLLAVE          reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    DEFAULT         reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    CASE            reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    RETURN          reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    RPAREN          reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    AND             reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    OR              reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    LLLAVE          reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    RCORCHE         reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)
    COMA            reduce using rule 201 (adicionaEx -> op something_ex adicionaEx .)


state 196

    (77) cicloFor -> FOR LLLAVE codigo RLLAVE .

    $end            reduce using rule 77 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 77 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 77 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 77 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 77 (cicloFor -> FOR LLLAVE codigo RLLAVE .)


state 197

    (78) cicloFor -> FOR comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 254


state 198

    (79) cicloFor -> FOR logic_operation LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 255


state 199

    (80) cicloFor -> FOR decVarOne COLON comparison . COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 256


state 200

    (120) decVarOne -> ID DEQUAL ID .

    COLON           reduce using rule 120 (decVarOne -> ID DEQUAL ID .)


state 201

    (121) decVarOne -> ID DEQUAL INTEGER .

    COLON           reduce using rule 121 (decVarOne -> ID DEQUAL INTEGER .)


state 202

    (171) index -> ID .
    (177) key -> ID .
    (202) something_ex -> ID .
    (141) value -> ID .
    (155) logic_value -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (176) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for RCORCHE resolved using rule 171 (index -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 171 (index -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 141 (value -> ID .)
    RCORCHE         reduce using rule 171 (index -> ID .)
    GREATER         reduce using rule 141 (value -> ID .)
    SMALLER         reduce using rule 141 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 141 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 141 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 141 (value -> ID .)
    NOT_EQUAL       reduce using rule 141 (value -> ID .)
    PLUS            reduce using rule 141 (value -> ID .)
    TIMES           reduce using rule 141 (value -> ID .)
    DIVIDE          reduce using rule 141 (value -> ID .)
    MINUS           reduce using rule 141 (value -> ID .)
    AND             reduce using rule 155 (logic_value -> ID .)
    OR              reduce using rule 155 (logic_value -> ID .)
    LCORCHE         shift and go to state 146

  ! RCORCHE         [ reduce using rule 177 (key -> ID .) ]
  ! GREATER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 202 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 202 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 202 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 202 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 202 (something_ex -> ID .) ]
  ! RCORCHE         [ reduce using rule 202 (something_ex -> ID .) ]


state 203

    (172) index -> INTEGER .
    (41) values -> INTEGER .
    (203) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 41 (values -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 41 (values -> INTEGER .)
    RCORCHE         reduce using rule 41 (values -> INTEGER .)
    GREATER         reduce using rule 203 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 203 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 203 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 203 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 203 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 203 (something_ex -> INTEGER .)
    PLUS            reduce using rule 203 (something_ex -> INTEGER .)
    TIMES           reduce using rule 203 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 203 (something_ex -> INTEGER .)
    MINUS           reduce using rule 203 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 172 (index -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 203 (something_ex -> INTEGER .) ]


state 204

    (173) index -> expression .
    (54) operations -> expression .
    (142) value -> expression .

  ! reduce/reduce conflict for RCORCHE resolved using rule 54 (operations -> expression .)
    RCORCHE         reduce using rule 54 (operations -> expression .)
    GREATER         reduce using rule 142 (value -> expression .)
    SMALLER         reduce using rule 142 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 142 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 142 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 142 (value -> expression .)
    NOT_EQUAL       reduce using rule 142 (value -> expression .)
    PLUS            reduce using rule 142 (value -> expression .)
    TIMES           reduce using rule 142 (value -> expression .)
    DIVIDE          reduce using rule 142 (value -> expression .)
    MINUS           reduce using rule 142 (value -> expression .)

  ! RCORCHE         [ reduce using rule 173 (index -> expression .) ]


state 205

    (152) logic_recu -> logic_op logic_value logic_recu .

    $end            reduce using rule 152 (logic_recu -> logic_op logic_value logic_recu .)
    LLLAVE          reduce using rule 152 (logic_recu -> logic_op logic_value logic_recu .)
    COLON           reduce using rule 152 (logic_recu -> logic_op logic_value logic_recu .)
    RLLAVE          reduce using rule 152 (logic_recu -> logic_op logic_value logic_recu .)
    DEFAULT         reduce using rule 152 (logic_recu -> logic_op logic_value logic_recu .)
    CASE            reduce using rule 152 (logic_recu -> logic_op logic_value logic_recu .)
    RETURN          reduce using rule 152 (logic_recu -> logic_op logic_value logic_recu .)
    RPAREN          reduce using rule 152 (logic_recu -> logic_op logic_value logic_recu .)
    RCORCHE         reduce using rule 152 (logic_recu -> logic_op logic_value logic_recu .)
    COMA            reduce using rule 152 (logic_recu -> logic_op logic_value logic_recu .)


state 206

    (85) decVar -> VAR ID EQUAL ID .
    (202) something_ex -> ID .
    (155) logic_value -> ID .
    (141) value -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (176) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for COLON resolved using rule 85 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for $end resolved using rule 85 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 85 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 85 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for CASE resolved using rule 85 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 85 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 141 (value -> ID .)
    COLON           reduce using rule 85 (decVar -> VAR ID EQUAL ID .)
    $end            reduce using rule 85 (decVar -> VAR ID EQUAL ID .)
    RLLAVE          reduce using rule 85 (decVar -> VAR ID EQUAL ID .)
    DEFAULT         reduce using rule 85 (decVar -> VAR ID EQUAL ID .)
    CASE            reduce using rule 85 (decVar -> VAR ID EQUAL ID .)
    RETURN          reduce using rule 85 (decVar -> VAR ID EQUAL ID .)
    AND             reduce using rule 155 (logic_value -> ID .)
    OR              reduce using rule 155 (logic_value -> ID .)
    GREATER         reduce using rule 141 (value -> ID .)
    SMALLER         reduce using rule 141 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 141 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 141 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 141 (value -> ID .)
    NOT_EQUAL       reduce using rule 141 (value -> ID .)
    PLUS            reduce using rule 141 (value -> ID .)
    TIMES           reduce using rule 141 (value -> ID .)
    DIVIDE          reduce using rule 141 (value -> ID .)
    MINUS           reduce using rule 141 (value -> ID .)
    LCORCHE         shift and go to state 146

  ! GREATER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 202 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 202 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 202 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 202 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 202 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 202 (something_ex -> ID .) ]
  ! $end            [ reduce using rule 202 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! DEFAULT         [ reduce using rule 202 (something_ex -> ID .) ]
  ! CASE            [ reduce using rule 202 (something_ex -> ID .) ]
  ! RETURN          [ reduce using rule 202 (something_ex -> ID .) ]


state 207

    (84) decVar -> VAR ID EQUAL INTEGER .
    (203) something_ex -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 84 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 84 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 84 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 84 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 84 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 84 (decVar -> VAR ID EQUAL INTEGER .)
    COLON           reduce using rule 84 (decVar -> VAR ID EQUAL INTEGER .)
    $end            reduce using rule 84 (decVar -> VAR ID EQUAL INTEGER .)
    RLLAVE          reduce using rule 84 (decVar -> VAR ID EQUAL INTEGER .)
    DEFAULT         reduce using rule 84 (decVar -> VAR ID EQUAL INTEGER .)
    CASE            reduce using rule 84 (decVar -> VAR ID EQUAL INTEGER .)
    RETURN          reduce using rule 84 (decVar -> VAR ID EQUAL INTEGER .)
    GREATER         reduce using rule 203 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 203 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 203 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 203 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 203 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 203 (something_ex -> INTEGER .)
    PLUS            reduce using rule 203 (something_ex -> INTEGER .)
    TIMES           reduce using rule 203 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 203 (something_ex -> INTEGER .)
    MINUS           reduce using rule 203 (something_ex -> INTEGER .)

  ! COLON           [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! $end            [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! CASE            [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! RETURN          [ reduce using rule 203 (something_ex -> INTEGER .) ]


state 208

    (86) decVar -> VAR ID EQUAL FLOAT .
    (204) something_ex -> FLOAT .

  ! reduce/reduce conflict for COLON resolved using rule 86 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for $end resolved using rule 86 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 86 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 86 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for CASE resolved using rule 86 (decVar -> VAR ID EQUAL FLOAT .)
  ! reduce/reduce conflict for RETURN resolved using rule 86 (decVar -> VAR ID EQUAL FLOAT .)
    COLON           reduce using rule 86 (decVar -> VAR ID EQUAL FLOAT .)
    $end            reduce using rule 86 (decVar -> VAR ID EQUAL FLOAT .)
    RLLAVE          reduce using rule 86 (decVar -> VAR ID EQUAL FLOAT .)
    DEFAULT         reduce using rule 86 (decVar -> VAR ID EQUAL FLOAT .)
    CASE            reduce using rule 86 (decVar -> VAR ID EQUAL FLOAT .)
    RETURN          reduce using rule 86 (decVar -> VAR ID EQUAL FLOAT .)
    GREATER         reduce using rule 204 (something_ex -> FLOAT .)
    SMALLER         reduce using rule 204 (something_ex -> FLOAT .)
    GREATER_OR_EQUAL reduce using rule 204 (something_ex -> FLOAT .)
    SMALLER_OR_EQUAL reduce using rule 204 (something_ex -> FLOAT .)
    EQUAL_COMPARE   reduce using rule 204 (something_ex -> FLOAT .)
    NOT_EQUAL       reduce using rule 204 (something_ex -> FLOAT .)
    PLUS            reduce using rule 204 (something_ex -> FLOAT .)
    TIMES           reduce using rule 204 (something_ex -> FLOAT .)
    DIVIDE          reduce using rule 204 (something_ex -> FLOAT .)
    MINUS           reduce using rule 204 (something_ex -> FLOAT .)

  ! COLON           [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! $end            [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! RLLAVE          [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! DEFAULT         [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! CASE            [ reduce using rule 204 (something_ex -> FLOAT .) ]
  ! RETURN          [ reduce using rule 204 (something_ex -> FLOAT .) ]


state 209

    (87) decVar -> VAR ID EQUAL expression .
    (142) value -> expression .

    COLON           reduce using rule 87 (decVar -> VAR ID EQUAL expression .)
    $end            reduce using rule 87 (decVar -> VAR ID EQUAL expression .)
    RLLAVE          reduce using rule 87 (decVar -> VAR ID EQUAL expression .)
    DEFAULT         reduce using rule 87 (decVar -> VAR ID EQUAL expression .)
    CASE            reduce using rule 87 (decVar -> VAR ID EQUAL expression .)
    RETURN          reduce using rule 87 (decVar -> VAR ID EQUAL expression .)
    GREATER         reduce using rule 142 (value -> expression .)
    SMALLER         reduce using rule 142 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 142 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 142 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 142 (value -> expression .)
    NOT_EQUAL       reduce using rule 142 (value -> expression .)
    PLUS            reduce using rule 142 (value -> expression .)
    TIMES           reduce using rule 142 (value -> expression .)
    DIVIDE          reduce using rule 142 (value -> expression .)
    MINUS           reduce using rule 142 (value -> expression .)


state 210

    (88) decVar -> VAR ID EQUAL logic_operation .

    COLON           reduce using rule 88 (decVar -> VAR ID EQUAL logic_operation .)
    $end            reduce using rule 88 (decVar -> VAR ID EQUAL logic_operation .)
    RLLAVE          reduce using rule 88 (decVar -> VAR ID EQUAL logic_operation .)
    DEFAULT         reduce using rule 88 (decVar -> VAR ID EQUAL logic_operation .)
    CASE            reduce using rule 88 (decVar -> VAR ID EQUAL logic_operation .)
    RETURN          reduce using rule 88 (decVar -> VAR ID EQUAL logic_operation .)


state 211

    (89) decVar -> VAR ID EQUAL comparison .
    (154) logic_value -> comparison .

    COLON           reduce using rule 89 (decVar -> VAR ID EQUAL comparison .)
    $end            reduce using rule 89 (decVar -> VAR ID EQUAL comparison .)
    RLLAVE          reduce using rule 89 (decVar -> VAR ID EQUAL comparison .)
    DEFAULT         reduce using rule 89 (decVar -> VAR ID EQUAL comparison .)
    CASE            reduce using rule 89 (decVar -> VAR ID EQUAL comparison .)
    RETURN          reduce using rule 89 (decVar -> VAR ID EQUAL comparison .)
    AND             reduce using rule 154 (logic_value -> comparison .)
    OR              reduce using rule 154 (logic_value -> comparison .)


state 212

    (90) decVar -> VAR ID EQUAL STRING .

    COLON           reduce using rule 90 (decVar -> VAR ID EQUAL STRING .)
    $end            reduce using rule 90 (decVar -> VAR ID EQUAL STRING .)
    RLLAVE          reduce using rule 90 (decVar -> VAR ID EQUAL STRING .)
    DEFAULT         reduce using rule 90 (decVar -> VAR ID EQUAL STRING .)
    CASE            reduce using rule 90 (decVar -> VAR ID EQUAL STRING .)
    RETURN          reduce using rule 90 (decVar -> VAR ID EQUAL STRING .)


state 213

    (166) array_declaration -> VAR ID EQUAL LCORCHE . capacity RCORCHE data_types arr_content
    (97) slice_declaration -> VAR ID EQUAL LCORCHE . RCORCHE data_types arr_content
    (167) capacity -> . INTEGER
    (168) capacity -> . ID
    (169) capacity -> . expression
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    RCORCHE         shift and go to state 258
    INTEGER         shift and go to state 219
    ID              shift and go to state 215
    FLOAT           shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    capacity                       shift and go to state 257
    expression                     shift and go to state 220
    something_ex                   shift and go to state 29
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 214

    (98) slice_declaration -> VAR ID EQUAL funM .

    COLON           reduce using rule 98 (slice_declaration -> VAR ID EQUAL funM .)
    $end            reduce using rule 98 (slice_declaration -> VAR ID EQUAL funM .)
    RLLAVE          reduce using rule 98 (slice_declaration -> VAR ID EQUAL funM .)
    DEFAULT         reduce using rule 98 (slice_declaration -> VAR ID EQUAL funM .)
    CASE            reduce using rule 98 (slice_declaration -> VAR ID EQUAL funM .)
    RETURN          reduce using rule 98 (slice_declaration -> VAR ID EQUAL funM .)


state 215

    (168) capacity -> ID .
    (202) something_ex -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (176) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for RCORCHE resolved using rule 168 (capacity -> ID .)
    RCORCHE         reduce using rule 168 (capacity -> ID .)
    GREATER         reduce using rule 202 (something_ex -> ID .)
    SMALLER         reduce using rule 202 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 202 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 202 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 202 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 202 (something_ex -> ID .)
    PLUS            reduce using rule 202 (something_ex -> ID .)
    TIMES           reduce using rule 202 (something_ex -> ID .)
    DIVIDE          reduce using rule 202 (something_ex -> ID .)
    MINUS           reduce using rule 202 (something_ex -> ID .)
    LCORCHE         shift and go to state 146

  ! RCORCHE         [ reduce using rule 202 (something_ex -> ID .) ]


state 216

    (165) array_declaration -> VAR ID LCORCHE capacity . RCORCHE data_types

    RCORCHE         shift and go to state 259


state 217

    (96) slice_declaration -> VAR ID LCORCHE RCORCHE . data_types
    (45) data_types -> . INT32
    (46) data_types -> . INT64
    (47) data_types -> . FLOAT32
    (48) data_types -> . FLOAT64
    (49) data_types -> . BYTE
    (50) data_types -> . WINT
    (51) data_types -> . WFLOAT
    (52) data_types -> . WSTRING
    (53) data_types -> . BOOL

    INT32           shift and go to state 221
    INT64           shift and go to state 222
    FLOAT32         shift and go to state 223
    FLOAT64         shift and go to state 224
    BYTE            shift and go to state 225
    WINT            shift and go to state 226
    WFLOAT          shift and go to state 227
    WSTRING         shift and go to state 228
    BOOL            shift and go to state 229

    data_types                     shift and go to state 260

state 218

    (175) map_declaration -> VAR ID LCORCHE data_types . RCORCHE data_types

    RCORCHE         shift and go to state 261


state 219

    (167) capacity -> INTEGER .
    (203) something_ex -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 167 (capacity -> INTEGER .)
    RCORCHE         reduce using rule 167 (capacity -> INTEGER .)
    GREATER         reduce using rule 203 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 203 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 203 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 203 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 203 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 203 (something_ex -> INTEGER .)
    PLUS            reduce using rule 203 (something_ex -> INTEGER .)
    TIMES           reduce using rule 203 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 203 (something_ex -> INTEGER .)
    MINUS           reduce using rule 203 (something_ex -> INTEGER .)

  ! RCORCHE         [ reduce using rule 203 (something_ex -> INTEGER .) ]


state 220

    (169) capacity -> expression .

    RCORCHE         reduce using rule 169 (capacity -> expression .)


state 221

    (45) data_types -> INT32 .

    RCORCHE         reduce using rule 45 (data_types -> INT32 .)
    COLON           reduce using rule 45 (data_types -> INT32 .)
    $end            reduce using rule 45 (data_types -> INT32 .)
    RLLAVE          reduce using rule 45 (data_types -> INT32 .)
    DEFAULT         reduce using rule 45 (data_types -> INT32 .)
    CASE            reduce using rule 45 (data_types -> INT32 .)
    RETURN          reduce using rule 45 (data_types -> INT32 .)
    LLLAVE          reduce using rule 45 (data_types -> INT32 .)
    COMA            reduce using rule 45 (data_types -> INT32 .)
    RPAREN          reduce using rule 45 (data_types -> INT32 .)
    ID              reduce using rule 45 (data_types -> INT32 .)


state 222

    (46) data_types -> INT64 .

    RCORCHE         reduce using rule 46 (data_types -> INT64 .)
    COLON           reduce using rule 46 (data_types -> INT64 .)
    $end            reduce using rule 46 (data_types -> INT64 .)
    RLLAVE          reduce using rule 46 (data_types -> INT64 .)
    DEFAULT         reduce using rule 46 (data_types -> INT64 .)
    CASE            reduce using rule 46 (data_types -> INT64 .)
    RETURN          reduce using rule 46 (data_types -> INT64 .)
    LLLAVE          reduce using rule 46 (data_types -> INT64 .)
    COMA            reduce using rule 46 (data_types -> INT64 .)
    RPAREN          reduce using rule 46 (data_types -> INT64 .)
    ID              reduce using rule 46 (data_types -> INT64 .)


state 223

    (47) data_types -> FLOAT32 .

    RCORCHE         reduce using rule 47 (data_types -> FLOAT32 .)
    COLON           reduce using rule 47 (data_types -> FLOAT32 .)
    $end            reduce using rule 47 (data_types -> FLOAT32 .)
    RLLAVE          reduce using rule 47 (data_types -> FLOAT32 .)
    DEFAULT         reduce using rule 47 (data_types -> FLOAT32 .)
    CASE            reduce using rule 47 (data_types -> FLOAT32 .)
    RETURN          reduce using rule 47 (data_types -> FLOAT32 .)
    LLLAVE          reduce using rule 47 (data_types -> FLOAT32 .)
    COMA            reduce using rule 47 (data_types -> FLOAT32 .)
    RPAREN          reduce using rule 47 (data_types -> FLOAT32 .)
    ID              reduce using rule 47 (data_types -> FLOAT32 .)


state 224

    (48) data_types -> FLOAT64 .

    RCORCHE         reduce using rule 48 (data_types -> FLOAT64 .)
    COLON           reduce using rule 48 (data_types -> FLOAT64 .)
    $end            reduce using rule 48 (data_types -> FLOAT64 .)
    RLLAVE          reduce using rule 48 (data_types -> FLOAT64 .)
    DEFAULT         reduce using rule 48 (data_types -> FLOAT64 .)
    CASE            reduce using rule 48 (data_types -> FLOAT64 .)
    RETURN          reduce using rule 48 (data_types -> FLOAT64 .)
    LLLAVE          reduce using rule 48 (data_types -> FLOAT64 .)
    COMA            reduce using rule 48 (data_types -> FLOAT64 .)
    RPAREN          reduce using rule 48 (data_types -> FLOAT64 .)
    ID              reduce using rule 48 (data_types -> FLOAT64 .)


state 225

    (49) data_types -> BYTE .

    RCORCHE         reduce using rule 49 (data_types -> BYTE .)
    COLON           reduce using rule 49 (data_types -> BYTE .)
    $end            reduce using rule 49 (data_types -> BYTE .)
    RLLAVE          reduce using rule 49 (data_types -> BYTE .)
    DEFAULT         reduce using rule 49 (data_types -> BYTE .)
    CASE            reduce using rule 49 (data_types -> BYTE .)
    RETURN          reduce using rule 49 (data_types -> BYTE .)
    LLLAVE          reduce using rule 49 (data_types -> BYTE .)
    COMA            reduce using rule 49 (data_types -> BYTE .)
    RPAREN          reduce using rule 49 (data_types -> BYTE .)
    ID              reduce using rule 49 (data_types -> BYTE .)


state 226

    (50) data_types -> WINT .

    RCORCHE         reduce using rule 50 (data_types -> WINT .)
    COLON           reduce using rule 50 (data_types -> WINT .)
    $end            reduce using rule 50 (data_types -> WINT .)
    RLLAVE          reduce using rule 50 (data_types -> WINT .)
    DEFAULT         reduce using rule 50 (data_types -> WINT .)
    CASE            reduce using rule 50 (data_types -> WINT .)
    RETURN          reduce using rule 50 (data_types -> WINT .)
    LLLAVE          reduce using rule 50 (data_types -> WINT .)
    COMA            reduce using rule 50 (data_types -> WINT .)
    RPAREN          reduce using rule 50 (data_types -> WINT .)
    ID              reduce using rule 50 (data_types -> WINT .)


state 227

    (51) data_types -> WFLOAT .

    RCORCHE         reduce using rule 51 (data_types -> WFLOAT .)
    COLON           reduce using rule 51 (data_types -> WFLOAT .)
    $end            reduce using rule 51 (data_types -> WFLOAT .)
    RLLAVE          reduce using rule 51 (data_types -> WFLOAT .)
    DEFAULT         reduce using rule 51 (data_types -> WFLOAT .)
    CASE            reduce using rule 51 (data_types -> WFLOAT .)
    RETURN          reduce using rule 51 (data_types -> WFLOAT .)
    LLLAVE          reduce using rule 51 (data_types -> WFLOAT .)
    COMA            reduce using rule 51 (data_types -> WFLOAT .)
    RPAREN          reduce using rule 51 (data_types -> WFLOAT .)
    ID              reduce using rule 51 (data_types -> WFLOAT .)


state 228

    (52) data_types -> WSTRING .

    RCORCHE         reduce using rule 52 (data_types -> WSTRING .)
    COLON           reduce using rule 52 (data_types -> WSTRING .)
    $end            reduce using rule 52 (data_types -> WSTRING .)
    RLLAVE          reduce using rule 52 (data_types -> WSTRING .)
    DEFAULT         reduce using rule 52 (data_types -> WSTRING .)
    CASE            reduce using rule 52 (data_types -> WSTRING .)
    RETURN          reduce using rule 52 (data_types -> WSTRING .)
    LLLAVE          reduce using rule 52 (data_types -> WSTRING .)
    COMA            reduce using rule 52 (data_types -> WSTRING .)
    RPAREN          reduce using rule 52 (data_types -> WSTRING .)
    ID              reduce using rule 52 (data_types -> WSTRING .)


state 229

    (53) data_types -> BOOL .

    RCORCHE         reduce using rule 53 (data_types -> BOOL .)
    COLON           reduce using rule 53 (data_types -> BOOL .)
    $end            reduce using rule 53 (data_types -> BOOL .)
    RLLAVE          reduce using rule 53 (data_types -> BOOL .)
    DEFAULT         reduce using rule 53 (data_types -> BOOL .)
    CASE            reduce using rule 53 (data_types -> BOOL .)
    RETURN          reduce using rule 53 (data_types -> BOOL .)
    LLLAVE          reduce using rule 53 (data_types -> BOOL .)
    COMA            reduce using rule 53 (data_types -> BOOL .)
    RPAREN          reduce using rule 53 (data_types -> BOOL .)
    ID              reduce using rule 53 (data_types -> BOOL .)


state 230

    (133) cStruct -> ID DEQUAL ID LLLAVE . asignaciones RLLAVE
    (134) asignaciones -> . ID POINTS valor
    (135) asignaciones -> . ID POINTS valor COMA asignaciones

    ID              shift and go to state 262

    asignaciones                   shift and go to state 263

state 231

    (100) slice_declaration -> ID DEQUAL LCORCHE RCORCHE . data_types arr_content
    (45) data_types -> . INT32
    (46) data_types -> . INT64
    (47) data_types -> . FLOAT32
    (48) data_types -> . FLOAT64
    (49) data_types -> . BYTE
    (50) data_types -> . WINT
    (51) data_types -> . WFLOAT
    (52) data_types -> . WSTRING
    (53) data_types -> . BOOL

    INT32           shift and go to state 221
    INT64           shift and go to state 222
    FLOAT32         shift and go to state 223
    FLOAT64         shift and go to state 224
    BYTE            shift and go to state 225
    WINT            shift and go to state 226
    WFLOAT          shift and go to state 227
    WSTRING         shift and go to state 228
    BOOL            shift and go to state 229

    data_types                     shift and go to state 264

state 232

    (101) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap RPAREN
    (102) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LCORCHE         shift and go to state 265


state 233

    (170) array_var -> ID LCORCHE index RCORCHE .

    COLON           reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    EQUAL           reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    $end            reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    GREATER         reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    SMALLER         reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    GREATER_OR_EQUAL reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    SMALLER_OR_EQUAL reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    EQUAL_COMPARE   reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    NOT_EQUAL       reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    PLUS            reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    TIMES           reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    DIVIDE          reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    MINUS           reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    RLLAVE          reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    DEFAULT         reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    CASE            reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    RETURN          reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    RPAREN          reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    AND             reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    OR              reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    LLLAVE          reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    RCORCHE         reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)
    COMA            reduce using rule 170 (array_var -> ID LCORCHE index RCORCHE .)


state 234

    (106) slice_var -> ID LCORCHE index_s RCORCHE .

    COLON           reduce using rule 106 (slice_var -> ID LCORCHE index_s RCORCHE .)
    EQUAL           reduce using rule 106 (slice_var -> ID LCORCHE index_s RCORCHE .)
    $end            reduce using rule 106 (slice_var -> ID LCORCHE index_s RCORCHE .)
    RLLAVE          reduce using rule 106 (slice_var -> ID LCORCHE index_s RCORCHE .)
    DEFAULT         reduce using rule 106 (slice_var -> ID LCORCHE index_s RCORCHE .)
    CASE            reduce using rule 106 (slice_var -> ID LCORCHE index_s RCORCHE .)
    RETURN          reduce using rule 106 (slice_var -> ID LCORCHE index_s RCORCHE .)


state 235

    (176) map_var -> ID LCORCHE key RCORCHE .

    GREATER         reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    SMALLER         reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    GREATER_OR_EQUAL reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    SMALLER_OR_EQUAL reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    EQUAL_COMPARE   reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    NOT_EQUAL       reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    PLUS            reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    TIMES           reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    DIVIDE          reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    MINUS           reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    COLON           reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    $end            reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    RLLAVE          reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    DEFAULT         reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    CASE            reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    RETURN          reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    RPAREN          reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    AND             reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    OR              reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    LLLAVE          reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    RCORCHE         reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)
    COMA            reduce using rule 176 (map_var -> ID LCORCHE key RCORCHE .)


state 236

    (115) funciones -> APPEND LPAREN ID COMA . values RPAREN
    (116) funciones -> APPEND LPAREN ID COMA . ID RPAREN
    (40) values -> . STRING
    (41) values -> . INTEGER
    (42) values -> . FLOAT
    (43) values -> . TRUE
    (44) values -> . FALSE

    ID              shift and go to state 266
    STRING          shift and go to state 119
    INTEGER         shift and go to state 268
    FLOAT           shift and go to state 269
    TRUE            shift and go to state 122
    FALSE           shift and go to state 123

    values                         shift and go to state 267

state 237

    (117) funciones -> LEN LPAREN ID RPAREN .

    COLON           reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    $end            reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    GREATER         reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    SMALLER         reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    NOT_EQUAL       reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    PLUS            reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    TIMES           reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    DIVIDE          reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    MINUS           reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    RLLAVE          reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    DEFAULT         reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    CASE            reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    RETURN          reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    RPAREN          reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    AND             reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    OR              reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    LLLAVE          reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    RCORCHE         reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)
    COMA            reduce using rule 117 (funciones -> LEN LPAREN ID RPAREN .)


state 238

    (118) funciones -> COPY LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 270


state 239

    (119) funciones -> DELETE LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 271


state 240

    (122) SenIF -> IF comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 272


state 241

    (123) SenIF -> IF TRUE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 273


state 242

    (124) SenIF -> IF FALSE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 274


state 243

    (125) SenElseIF -> ELSE IF comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenElseIF
    (18) codigo -> . SenElse
    (19) codigo -> . SenStruct
    (20) codigo -> . cStruct
    (21) codigo -> . switch_statement
    (22) codigo -> . array_declaration COLON
    (23) codigo -> . array_declaration
    (24) codigo -> . array_var COLON
    (25) codigo -> . array_var
    (26) codigo -> . array_assignment COLON
    (27) codigo -> . array_assignment
    (28) codigo -> . slice_declaration COLON
    (29) codigo -> . slice_declaration
    (30) codigo -> . slice_var COLON
    (31) codigo -> . slice_var
    (32) codigo -> . slice_assignment COLON
    (33) codigo -> . slice_assignment
    (34) codigo -> . map_declaration COLON
    (35) codigo -> . map_declaration
    (36) codigo -> . map_assignment COLON
    (37) codigo -> . map_assignment
    (38) codigo -> . func_declaration
    (39) codigo -> . main_func
    (192) impresion -> . PRINT LPAREN content RPAREN
    (76) scan_func -> . SCAN LPAREN POINTER RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (77) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (83) decVar -> . decVarOne
    (84) decVar -> . VAR ID EQUAL INTEGER
    (85) decVar -> . VAR ID EQUAL ID
    (86) decVar -> . VAR ID EQUAL FLOAT
    (87) decVar -> . VAR ID EQUAL expression
    (88) decVar -> . VAR ID EQUAL logic_operation
    (89) decVar -> . VAR ID EQUAL comparison
    (90) decVar -> . VAR ID EQUAL STRING
    (91) decVar -> . ID DEQUAL STRING
    (92) decVar -> . ID DEQUAL FLOAT
    (93) decVar -> . ID DEQUAL expression
    (94) decVar -> . ID DEQUAL logic_operation
    (95) decVar -> . ID DEQUAL comparison
    (59) var_asignation -> . ID EQUAL any
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (122) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (123) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (125) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (129) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (160) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (165) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (170) array_var -> . ID LCORCHE index RCORCHE
    (174) array_assignment -> . array_var EQUAL something
    (96) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> . VAR ID EQUAL funM
    (99) slice_declaration -> . ID DEQUAL funM
    (100) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> . ID LCORCHE index_s RCORCHE
    (110) slice_assignment -> . slice_var EQUAL something_s
    (175) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (180) map_assignment -> . array_var EQUAL something
    (181) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (176) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 27
    SCAN            shift and go to state 28
    FOR             shift and go to state 30
    VAR             shift and go to state 35
    ID              shift and go to state 36
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 43
    ELSE            shift and go to state 44
    TYPE            shift and go to state 45
    SWITCH          shift and go to state 46
    FUNC            shift and go to state 47
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    NOT             shift and go to state 49

    comparison                     shift and go to state 6
    codigo                         shift and go to state 275
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenElseIF                      shift and go to state 12
    SenElse                        shift and go to state 13
    SenStruct                      shift and go to state 14
    cStruct                        shift and go to state 15
    switch_statement               shift and go to state 16
    array_declaration              shift and go to state 17
    array_var                      shift and go to state 18
    array_assignment               shift and go to state 19
    slice_declaration              shift and go to state 20
    slice_var                      shift and go to state 21
    slice_assignment               shift and go to state 22
    map_declaration                shift and go to state 23
    map_assignment                 shift and go to state 24
    func_declaration               shift and go to state 25
    main_func                      shift and go to state 26
    something_ex                   shift and go to state 29
    decVarOne                      shift and go to state 31
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    map_var                        shift and go to state 50

state 244

    (126) SenElseIF -> ELSE IF TRUE LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenElseIF
    (18) codigo -> . SenElse
    (19) codigo -> . SenStruct
    (20) codigo -> . cStruct
    (21) codigo -> . switch_statement
    (22) codigo -> . array_declaration COLON
    (23) codigo -> . array_declaration
    (24) codigo -> . array_var COLON
    (25) codigo -> . array_var
    (26) codigo -> . array_assignment COLON
    (27) codigo -> . array_assignment
    (28) codigo -> . slice_declaration COLON
    (29) codigo -> . slice_declaration
    (30) codigo -> . slice_var COLON
    (31) codigo -> . slice_var
    (32) codigo -> . slice_assignment COLON
    (33) codigo -> . slice_assignment
    (34) codigo -> . map_declaration COLON
    (35) codigo -> . map_declaration
    (36) codigo -> . map_assignment COLON
    (37) codigo -> . map_assignment
    (38) codigo -> . func_declaration
    (39) codigo -> . main_func
    (192) impresion -> . PRINT LPAREN content RPAREN
    (76) scan_func -> . SCAN LPAREN POINTER RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (77) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (83) decVar -> . decVarOne
    (84) decVar -> . VAR ID EQUAL INTEGER
    (85) decVar -> . VAR ID EQUAL ID
    (86) decVar -> . VAR ID EQUAL FLOAT
    (87) decVar -> . VAR ID EQUAL expression
    (88) decVar -> . VAR ID EQUAL logic_operation
    (89) decVar -> . VAR ID EQUAL comparison
    (90) decVar -> . VAR ID EQUAL STRING
    (91) decVar -> . ID DEQUAL STRING
    (92) decVar -> . ID DEQUAL FLOAT
    (93) decVar -> . ID DEQUAL expression
    (94) decVar -> . ID DEQUAL logic_operation
    (95) decVar -> . ID DEQUAL comparison
    (59) var_asignation -> . ID EQUAL any
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (122) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (123) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (125) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (129) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (160) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (165) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (170) array_var -> . ID LCORCHE index RCORCHE
    (174) array_assignment -> . array_var EQUAL something
    (96) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> . VAR ID EQUAL funM
    (99) slice_declaration -> . ID DEQUAL funM
    (100) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> . ID LCORCHE index_s RCORCHE
    (110) slice_assignment -> . slice_var EQUAL something_s
    (175) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (180) map_assignment -> . array_var EQUAL something
    (181) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (176) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 27
    SCAN            shift and go to state 28
    FOR             shift and go to state 30
    VAR             shift and go to state 35
    ID              shift and go to state 36
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 43
    ELSE            shift and go to state 44
    TYPE            shift and go to state 45
    SWITCH          shift and go to state 46
    FUNC            shift and go to state 47
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    NOT             shift and go to state 49

    codigo                         shift and go to state 276
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenElseIF                      shift and go to state 12
    SenElse                        shift and go to state 13
    SenStruct                      shift and go to state 14
    cStruct                        shift and go to state 15
    switch_statement               shift and go to state 16
    array_declaration              shift and go to state 17
    array_var                      shift and go to state 18
    array_assignment               shift and go to state 19
    slice_declaration              shift and go to state 20
    slice_var                      shift and go to state 21
    slice_assignment               shift and go to state 22
    map_declaration                shift and go to state 23
    map_assignment                 shift and go to state 24
    func_declaration               shift and go to state 25
    main_func                      shift and go to state 26
    something_ex                   shift and go to state 29
    decVarOne                      shift and go to state 31
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    map_var                        shift and go to state 50

state 245

    (127) SenElseIF -> ELSE IF FALSE LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenElseIF
    (18) codigo -> . SenElse
    (19) codigo -> . SenStruct
    (20) codigo -> . cStruct
    (21) codigo -> . switch_statement
    (22) codigo -> . array_declaration COLON
    (23) codigo -> . array_declaration
    (24) codigo -> . array_var COLON
    (25) codigo -> . array_var
    (26) codigo -> . array_assignment COLON
    (27) codigo -> . array_assignment
    (28) codigo -> . slice_declaration COLON
    (29) codigo -> . slice_declaration
    (30) codigo -> . slice_var COLON
    (31) codigo -> . slice_var
    (32) codigo -> . slice_assignment COLON
    (33) codigo -> . slice_assignment
    (34) codigo -> . map_declaration COLON
    (35) codigo -> . map_declaration
    (36) codigo -> . map_assignment COLON
    (37) codigo -> . map_assignment
    (38) codigo -> . func_declaration
    (39) codigo -> . main_func
    (192) impresion -> . PRINT LPAREN content RPAREN
    (76) scan_func -> . SCAN LPAREN POINTER RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (77) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (83) decVar -> . decVarOne
    (84) decVar -> . VAR ID EQUAL INTEGER
    (85) decVar -> . VAR ID EQUAL ID
    (86) decVar -> . VAR ID EQUAL FLOAT
    (87) decVar -> . VAR ID EQUAL expression
    (88) decVar -> . VAR ID EQUAL logic_operation
    (89) decVar -> . VAR ID EQUAL comparison
    (90) decVar -> . VAR ID EQUAL STRING
    (91) decVar -> . ID DEQUAL STRING
    (92) decVar -> . ID DEQUAL FLOAT
    (93) decVar -> . ID DEQUAL expression
    (94) decVar -> . ID DEQUAL logic_operation
    (95) decVar -> . ID DEQUAL comparison
    (59) var_asignation -> . ID EQUAL any
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (122) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (123) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (125) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (129) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (160) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (165) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (170) array_var -> . ID LCORCHE index RCORCHE
    (174) array_assignment -> . array_var EQUAL something
    (96) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> . VAR ID EQUAL funM
    (99) slice_declaration -> . ID DEQUAL funM
    (100) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> . ID LCORCHE index_s RCORCHE
    (110) slice_assignment -> . slice_var EQUAL something_s
    (175) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (180) map_assignment -> . array_var EQUAL something
    (181) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (176) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 27
    SCAN            shift and go to state 28
    FOR             shift and go to state 30
    VAR             shift and go to state 35
    ID              shift and go to state 36
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 43
    ELSE            shift and go to state 44
    TYPE            shift and go to state 45
    SWITCH          shift and go to state 46
    FUNC            shift and go to state 47
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    NOT             shift and go to state 49

    codigo                         shift and go to state 277
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenElseIF                      shift and go to state 12
    SenElse                        shift and go to state 13
    SenStruct                      shift and go to state 14
    cStruct                        shift and go to state 15
    switch_statement               shift and go to state 16
    array_declaration              shift and go to state 17
    array_var                      shift and go to state 18
    array_assignment               shift and go to state 19
    slice_declaration              shift and go to state 20
    slice_var                      shift and go to state 21
    slice_assignment               shift and go to state 22
    map_declaration                shift and go to state 23
    map_assignment                 shift and go to state 24
    func_declaration               shift and go to state 25
    main_func                      shift and go to state 26
    something_ex                   shift and go to state 29
    decVarOne                      shift and go to state 31
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    map_var                        shift and go to state 50

state 246

    (128) SenElse -> ELSE LLLAVE codigo RLLAVE .

    $end            reduce using rule 128 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 128 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 128 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 128 (SenElse -> ELSE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 128 (SenElse -> ELSE LLLAVE codigo RLLAVE .)


state 247

    (129) SenStruct -> TYPE ID STRUCT LLLAVE . declaration RLLAVE
    (130) declaration -> . variable data_types
    (131) declaration -> . declaration variable data_types
    (132) variable -> . ID

    ID              shift and go to state 278

    declaration                    shift and go to state 279
    variable                       shift and go to state 280

state 248

    (160) switch_statement -> SWITCH ID LLLAVE cases . RLLAVE

    RLLAVE          shift and go to state 281


state 249

    (161) cases -> CASE . values POINTS codigo
    (162) cases -> CASE . values POINTS codigo more
    (40) values -> . STRING
    (41) values -> . INTEGER
    (42) values -> . FLOAT
    (43) values -> . TRUE
    (44) values -> . FALSE

    STRING          shift and go to state 119
    INTEGER         shift and go to state 268
    FLOAT           shift and go to state 269
    TRUE            shift and go to state 122
    FALSE           shift and go to state 123

    values                         shift and go to state 282

state 250

    (189) params -> ID . data_types
    (191) more_params -> ID . data_types COMA params
    (45) data_types -> . INT32
    (46) data_types -> . INT64
    (47) data_types -> . FLOAT32
    (48) data_types -> . FLOAT64
    (49) data_types -> . BYTE
    (50) data_types -> . WINT
    (51) data_types -> . WFLOAT
    (52) data_types -> . WSTRING
    (53) data_types -> . BOOL

    INT32           shift and go to state 221
    INT64           shift and go to state 222
    FLOAT32         shift and go to state 223
    FLOAT64         shift and go to state 224
    BYTE            shift and go to state 225
    WINT            shift and go to state 226
    WFLOAT          shift and go to state 227
    WSTRING         shift and go to state 228
    BOOL            shift and go to state 229

    data_types                     shift and go to state 283

state 251

    (181) func_declaration -> FUNC ID LPAREN params . RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> FUNC ID LPAREN params . RPAREN data_types LLLAVE RETURN return_value RLLAVE

    RPAREN          shift and go to state 284


state 252

    (190) params -> more_params .

    RPAREN          reduce using rule 190 (params -> more_params .)


state 253

    (75) main_func -> FUNC MAIN LPAREN RPAREN . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 285


state 254

    (78) cicloFor -> FOR comparison LLLAVE codigo RLLAVE .

    $end            reduce using rule 78 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 78 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 78 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 78 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 78 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)


state 255

    (79) cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .

    $end            reduce using rule 79 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 79 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 79 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 79 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 79 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)


state 256

    (80) cicloFor -> FOR decVarOne COLON comparison COLON . incre LLLAVE codigo RLLAVE
    (81) incre -> . ID INCREASE
    (82) incre -> . ID DECREASE

    ID              shift and go to state 287

    incre                          shift and go to state 286

state 257

    (166) array_declaration -> VAR ID EQUAL LCORCHE capacity . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 288


state 258

    (97) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE . data_types arr_content
    (45) data_types -> . INT32
    (46) data_types -> . INT64
    (47) data_types -> . FLOAT32
    (48) data_types -> . FLOAT64
    (49) data_types -> . BYTE
    (50) data_types -> . WINT
    (51) data_types -> . WFLOAT
    (52) data_types -> . WSTRING
    (53) data_types -> . BOOL

    INT32           shift and go to state 221
    INT64           shift and go to state 222
    FLOAT32         shift and go to state 223
    FLOAT64         shift and go to state 224
    BYTE            shift and go to state 225
    WINT            shift and go to state 226
    WFLOAT          shift and go to state 227
    WSTRING         shift and go to state 228
    BOOL            shift and go to state 229

    data_types                     shift and go to state 289

state 259

    (165) array_declaration -> VAR ID LCORCHE capacity RCORCHE . data_types
    (45) data_types -> . INT32
    (46) data_types -> . INT64
    (47) data_types -> . FLOAT32
    (48) data_types -> . FLOAT64
    (49) data_types -> . BYTE
    (50) data_types -> . WINT
    (51) data_types -> . WFLOAT
    (52) data_types -> . WSTRING
    (53) data_types -> . BOOL

    INT32           shift and go to state 221
    INT64           shift and go to state 222
    FLOAT32         shift and go to state 223
    FLOAT64         shift and go to state 224
    BYTE            shift and go to state 225
    WINT            shift and go to state 226
    WFLOAT          shift and go to state 227
    WSTRING         shift and go to state 228
    BOOL            shift and go to state 229

    data_types                     shift and go to state 290

state 260

    (96) slice_declaration -> VAR ID LCORCHE RCORCHE data_types .

    COLON           reduce using rule 96 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    $end            reduce using rule 96 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    RLLAVE          reduce using rule 96 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    DEFAULT         reduce using rule 96 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    CASE            reduce using rule 96 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)
    RETURN          reduce using rule 96 (slice_declaration -> VAR ID LCORCHE RCORCHE data_types .)


state 261

    (175) map_declaration -> VAR ID LCORCHE data_types RCORCHE . data_types
    (45) data_types -> . INT32
    (46) data_types -> . INT64
    (47) data_types -> . FLOAT32
    (48) data_types -> . FLOAT64
    (49) data_types -> . BYTE
    (50) data_types -> . WINT
    (51) data_types -> . WFLOAT
    (52) data_types -> . WSTRING
    (53) data_types -> . BOOL

    INT32           shift and go to state 221
    INT64           shift and go to state 222
    FLOAT32         shift and go to state 223
    FLOAT64         shift and go to state 224
    BYTE            shift and go to state 225
    WINT            shift and go to state 226
    WFLOAT          shift and go to state 227
    WSTRING         shift and go to state 228
    BOOL            shift and go to state 229

    data_types                     shift and go to state 291

state 262

    (134) asignaciones -> ID . POINTS valor
    (135) asignaciones -> ID . POINTS valor COMA asignaciones

    POINTS          shift and go to state 292


state 263

    (133) cStruct -> ID DEQUAL ID LLLAVE asignaciones . RLLAVE

    RLLAVE          shift and go to state 293


state 264

    (100) slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types . arr_content
    (65) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (66) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 295

    arr_content                    shift and go to state 294

state 265

    (101) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap RPAREN
    (102) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap COMA cap RPAREN

    RCORCHE         shift and go to state 296


state 266

    (116) funciones -> APPEND LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 297


state 267

    (115) funciones -> APPEND LPAREN ID COMA values . RPAREN

    RPAREN          shift and go to state 298


state 268

    (41) values -> INTEGER .

    RPAREN          reduce using rule 41 (values -> INTEGER .)
    POINTS          reduce using rule 41 (values -> INTEGER .)


state 269

    (42) values -> FLOAT .

    RPAREN          reduce using rule 42 (values -> FLOAT .)
    POINTS          reduce using rule 42 (values -> FLOAT .)


state 270

    (118) funciones -> COPY LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 299


state 271

    (119) funciones -> DELETE LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 300


state 272

    (122) SenIF -> IF comparison LLLAVE codigo RLLAVE .

    $end            reduce using rule 122 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 122 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 122 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 122 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 122 (SenIF -> IF comparison LLLAVE codigo RLLAVE .)


state 273

    (123) SenIF -> IF TRUE LLLAVE codigo RLLAVE .

    $end            reduce using rule 123 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 123 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 123 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 123 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 123 (SenIF -> IF TRUE LLLAVE codigo RLLAVE .)


state 274

    (124) SenIF -> IF FALSE LLLAVE codigo RLLAVE .

    $end            reduce using rule 124 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 124 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 124 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 124 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 124 (SenIF -> IF FALSE LLLAVE codigo RLLAVE .)


state 275

    (125) SenElseIF -> ELSE IF comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 301


state 276

    (126) SenElseIF -> ELSE IF TRUE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 302


state 277

    (127) SenElseIF -> ELSE IF FALSE LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 303


state 278

    (132) variable -> ID .

    INT32           reduce using rule 132 (variable -> ID .)
    INT64           reduce using rule 132 (variable -> ID .)
    FLOAT32         reduce using rule 132 (variable -> ID .)
    FLOAT64         reduce using rule 132 (variable -> ID .)
    BYTE            reduce using rule 132 (variable -> ID .)
    WINT            reduce using rule 132 (variable -> ID .)
    WFLOAT          reduce using rule 132 (variable -> ID .)
    WSTRING         reduce using rule 132 (variable -> ID .)
    BOOL            reduce using rule 132 (variable -> ID .)


state 279

    (129) SenStruct -> TYPE ID STRUCT LLLAVE declaration . RLLAVE
    (131) declaration -> declaration . variable data_types
    (132) variable -> . ID

    RLLAVE          shift and go to state 304
    ID              shift and go to state 278

    variable                       shift and go to state 305

state 280

    (130) declaration -> variable . data_types
    (45) data_types -> . INT32
    (46) data_types -> . INT64
    (47) data_types -> . FLOAT32
    (48) data_types -> . FLOAT64
    (49) data_types -> . BYTE
    (50) data_types -> . WINT
    (51) data_types -> . WFLOAT
    (52) data_types -> . WSTRING
    (53) data_types -> . BOOL

    INT32           shift and go to state 221
    INT64           shift and go to state 222
    FLOAT32         shift and go to state 223
    FLOAT64         shift and go to state 224
    BYTE            shift and go to state 225
    WINT            shift and go to state 226
    WFLOAT          shift and go to state 227
    WSTRING         shift and go to state 228
    BOOL            shift and go to state 229

    data_types                     shift and go to state 306

state 281

    (160) switch_statement -> SWITCH ID LLLAVE cases RLLAVE .

    $end            reduce using rule 160 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RLLAVE          reduce using rule 160 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    DEFAULT         reduce using rule 160 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    CASE            reduce using rule 160 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RETURN          reduce using rule 160 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)


state 282

    (161) cases -> CASE values . POINTS codigo
    (162) cases -> CASE values . POINTS codigo more

    POINTS          shift and go to state 307


state 283

    (189) params -> ID data_types .
    (191) more_params -> ID data_types . COMA params

    RPAREN          reduce using rule 189 (params -> ID data_types .)
    COMA            shift and go to state 308


state 284

    (181) func_declaration -> FUNC ID LPAREN params RPAREN . data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> FUNC ID LPAREN params RPAREN . data_types LLLAVE RETURN return_value RLLAVE
    (45) data_types -> . INT32
    (46) data_types -> . INT64
    (47) data_types -> . FLOAT32
    (48) data_types -> . FLOAT64
    (49) data_types -> . BYTE
    (50) data_types -> . WINT
    (51) data_types -> . WFLOAT
    (52) data_types -> . WSTRING
    (53) data_types -> . BOOL

    INT32           shift and go to state 221
    INT64           shift and go to state 222
    FLOAT32         shift and go to state 223
    FLOAT64         shift and go to state 224
    BYTE            shift and go to state 225
    WINT            shift and go to state 226
    WFLOAT          shift and go to state 227
    WSTRING         shift and go to state 228
    BOOL            shift and go to state 229

    data_types                     shift and go to state 309

state 285

    (75) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenElseIF
    (18) codigo -> . SenElse
    (19) codigo -> . SenStruct
    (20) codigo -> . cStruct
    (21) codigo -> . switch_statement
    (22) codigo -> . array_declaration COLON
    (23) codigo -> . array_declaration
    (24) codigo -> . array_var COLON
    (25) codigo -> . array_var
    (26) codigo -> . array_assignment COLON
    (27) codigo -> . array_assignment
    (28) codigo -> . slice_declaration COLON
    (29) codigo -> . slice_declaration
    (30) codigo -> . slice_var COLON
    (31) codigo -> . slice_var
    (32) codigo -> . slice_assignment COLON
    (33) codigo -> . slice_assignment
    (34) codigo -> . map_declaration COLON
    (35) codigo -> . map_declaration
    (36) codigo -> . map_assignment COLON
    (37) codigo -> . map_assignment
    (38) codigo -> . func_declaration
    (39) codigo -> . main_func
    (192) impresion -> . PRINT LPAREN content RPAREN
    (76) scan_func -> . SCAN LPAREN POINTER RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (77) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (83) decVar -> . decVarOne
    (84) decVar -> . VAR ID EQUAL INTEGER
    (85) decVar -> . VAR ID EQUAL ID
    (86) decVar -> . VAR ID EQUAL FLOAT
    (87) decVar -> . VAR ID EQUAL expression
    (88) decVar -> . VAR ID EQUAL logic_operation
    (89) decVar -> . VAR ID EQUAL comparison
    (90) decVar -> . VAR ID EQUAL STRING
    (91) decVar -> . ID DEQUAL STRING
    (92) decVar -> . ID DEQUAL FLOAT
    (93) decVar -> . ID DEQUAL expression
    (94) decVar -> . ID DEQUAL logic_operation
    (95) decVar -> . ID DEQUAL comparison
    (59) var_asignation -> . ID EQUAL any
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (122) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (123) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (125) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (129) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (160) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (165) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (170) array_var -> . ID LCORCHE index RCORCHE
    (174) array_assignment -> . array_var EQUAL something
    (96) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> . VAR ID EQUAL funM
    (99) slice_declaration -> . ID DEQUAL funM
    (100) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> . ID LCORCHE index_s RCORCHE
    (110) slice_assignment -> . slice_var EQUAL something_s
    (175) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (180) map_assignment -> . array_var EQUAL something
    (181) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (176) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 27
    SCAN            shift and go to state 28
    FOR             shift and go to state 30
    VAR             shift and go to state 35
    ID              shift and go to state 36
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 43
    ELSE            shift and go to state 44
    TYPE            shift and go to state 45
    SWITCH          shift and go to state 46
    FUNC            shift and go to state 47
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    NOT             shift and go to state 49

    codigo                         shift and go to state 310
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenElseIF                      shift and go to state 12
    SenElse                        shift and go to state 13
    SenStruct                      shift and go to state 14
    cStruct                        shift and go to state 15
    switch_statement               shift and go to state 16
    array_declaration              shift and go to state 17
    array_var                      shift and go to state 18
    array_assignment               shift and go to state 19
    slice_declaration              shift and go to state 20
    slice_var                      shift and go to state 21
    slice_assignment               shift and go to state 22
    map_declaration                shift and go to state 23
    map_assignment                 shift and go to state 24
    func_declaration               shift and go to state 25
    main_func                      shift and go to state 26
    something_ex                   shift and go to state 29
    decVarOne                      shift and go to state 31
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    map_var                        shift and go to state 50

state 286

    (80) cicloFor -> FOR decVarOne COLON comparison COLON incre . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 311


state 287

    (81) incre -> ID . INCREASE
    (82) incre -> ID . DECREASE

    INCREASE        shift and go to state 312
    DECREASE        shift and go to state 313


state 288

    (166) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE . data_types arr_content
    (45) data_types -> . INT32
    (46) data_types -> . INT64
    (47) data_types -> . FLOAT32
    (48) data_types -> . FLOAT64
    (49) data_types -> . BYTE
    (50) data_types -> . WINT
    (51) data_types -> . WFLOAT
    (52) data_types -> . WSTRING
    (53) data_types -> . BOOL

    INT32           shift and go to state 221
    INT64           shift and go to state 222
    FLOAT32         shift and go to state 223
    FLOAT64         shift and go to state 224
    BYTE            shift and go to state 225
    WINT            shift and go to state 226
    WFLOAT          shift and go to state 227
    WSTRING         shift and go to state 228
    BOOL            shift and go to state 229

    data_types                     shift and go to state 314

state 289

    (97) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types . arr_content
    (65) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (66) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 295

    arr_content                    shift and go to state 315

state 290

    (165) array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .

    COLON           reduce using rule 165 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    $end            reduce using rule 165 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RLLAVE          reduce using rule 165 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    DEFAULT         reduce using rule 165 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    CASE            reduce using rule 165 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RETURN          reduce using rule 165 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)


state 291

    (175) map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .

    COLON           reduce using rule 175 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    $end            reduce using rule 175 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    RLLAVE          reduce using rule 175 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    DEFAULT         reduce using rule 175 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    CASE            reduce using rule 175 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    RETURN          reduce using rule 175 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)


state 292

    (134) asignaciones -> ID POINTS . valor
    (135) asignaciones -> ID POINTS . valor COMA asignaciones
    (136) valor -> . ID
    (137) valor -> . INTEGER
    (138) valor -> . TRUE
    (139) valor -> . FALSE

    ID              shift and go to state 316
    INTEGER         shift and go to state 318
    TRUE            shift and go to state 319
    FALSE           shift and go to state 320

    valor                          shift and go to state 317

state 293

    (133) cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .

    $end            reduce using rule 133 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    RLLAVE          reduce using rule 133 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    DEFAULT         reduce using rule 133 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    CASE            reduce using rule 133 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)
    RETURN          reduce using rule 133 (cStruct -> ID DEQUAL ID LLLAVE asignaciones RLLAVE .)


state 294

    (100) slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .

    COLON           reduce using rule 100 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    $end            reduce using rule 100 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 100 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 100 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    CASE            reduce using rule 100 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RETURN          reduce using rule 100 (slice_declaration -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)


state 295

    (65) arr_content -> LLLAVE . items COMA more_items RLLAVE
    (66) arr_content -> LLLAVE . items RLLAVE
    (69) items -> . values
    (70) items -> . operations
    (40) values -> . STRING
    (41) values -> . INTEGER
    (42) values -> . FLOAT
    (43) values -> . TRUE
    (44) values -> . FALSE
    (54) operations -> . expression
    (55) operations -> . comparison
    (56) operations -> . logic_operation
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    STRING          shift and go to state 119
    INTEGER         shift and go to state 120
    FLOAT           shift and go to state 121
    TRUE            shift and go to state 122
    FALSE           shift and go to state 123
    ID              shift and go to state 324
    NOT             shift and go to state 49
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    items                          shift and go to state 321
    values                         shift and go to state 322
    operations                     shift and go to state 323
    expression                     shift and go to state 124
    comparison                     shift and go to state 125
    logic_operation                shift and go to state 126
    something_ex                   shift and go to state 29
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 296

    (101) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap RPAREN
    (102) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap COMA cap RPAREN
    (45) data_types -> . INT32
    (46) data_types -> . INT64
    (47) data_types -> . FLOAT32
    (48) data_types -> . FLOAT64
    (49) data_types -> . BYTE
    (50) data_types -> . WINT
    (51) data_types -> . WFLOAT
    (52) data_types -> . WSTRING
    (53) data_types -> . BOOL

    INT32           shift and go to state 221
    INT64           shift and go to state 222
    FLOAT32         shift and go to state 223
    FLOAT64         shift and go to state 224
    BYTE            shift and go to state 225
    WINT            shift and go to state 226
    WFLOAT          shift and go to state 227
    WSTRING         shift and go to state 228
    BOOL            shift and go to state 229

    data_types                     shift and go to state 325

state 297

    (116) funciones -> APPEND LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 116 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)


state 298

    (115) funciones -> APPEND LPAREN ID COMA values RPAREN .

    COLON           reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    $end            reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    GREATER         reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SMALLER         reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    GREATER_OR_EQUAL reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    EQUAL_COMPARE   reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    NOT_EQUAL       reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    PLUS            reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    TIMES           reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DIVIDE          reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    MINUS           reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RLLAVE          reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DEFAULT         reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    CASE            reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RETURN          reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RPAREN          reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    AND             reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    OR              reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    LLLAVE          reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RCORCHE         reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    COMA            reduce using rule 115 (funciones -> APPEND LPAREN ID COMA values RPAREN .)


state 299

    (118) funciones -> COPY LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 118 (funciones -> COPY LPAREN ID COMA ID RPAREN .)


state 300

    (119) funciones -> DELETE LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    GREATER         reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SMALLER         reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    GREATER_OR_EQUAL reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    EQUAL_COMPARE   reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    NOT_EQUAL       reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    PLUS            reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    TIMES           reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DIVIDE          reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    MINUS           reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RPAREN          reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    AND             reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    OR              reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    LLLAVE          reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RCORCHE         reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    COMA            reduce using rule 119 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)


state 301

    (125) SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .

    $end            reduce using rule 125 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 125 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 125 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 125 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 125 (SenElseIF -> ELSE IF comparison LLLAVE codigo RLLAVE .)


state 302

    (126) SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .

    $end            reduce using rule 126 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 126 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 126 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 126 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 126 (SenElseIF -> ELSE IF TRUE LLLAVE codigo RLLAVE .)


state 303

    (127) SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .

    $end            reduce using rule 127 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 127 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 127 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 127 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 127 (SenElseIF -> ELSE IF FALSE LLLAVE codigo RLLAVE .)


state 304

    (129) SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .

    $end            reduce using rule 129 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RLLAVE          reduce using rule 129 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    DEFAULT         reduce using rule 129 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    CASE            reduce using rule 129 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RETURN          reduce using rule 129 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)


state 305

    (131) declaration -> declaration variable . data_types
    (45) data_types -> . INT32
    (46) data_types -> . INT64
    (47) data_types -> . FLOAT32
    (48) data_types -> . FLOAT64
    (49) data_types -> . BYTE
    (50) data_types -> . WINT
    (51) data_types -> . WFLOAT
    (52) data_types -> . WSTRING
    (53) data_types -> . BOOL

    INT32           shift and go to state 221
    INT64           shift and go to state 222
    FLOAT32         shift and go to state 223
    FLOAT64         shift and go to state 224
    BYTE            shift and go to state 225
    WINT            shift and go to state 226
    WFLOAT          shift and go to state 227
    WSTRING         shift and go to state 228
    BOOL            shift and go to state 229

    data_types                     shift and go to state 326

state 306

    (130) declaration -> variable data_types .

    RLLAVE          reduce using rule 130 (declaration -> variable data_types .)
    ID              reduce using rule 130 (declaration -> variable data_types .)


state 307

    (161) cases -> CASE values POINTS . codigo
    (162) cases -> CASE values POINTS . codigo more
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenElseIF
    (18) codigo -> . SenElse
    (19) codigo -> . SenStruct
    (20) codigo -> . cStruct
    (21) codigo -> . switch_statement
    (22) codigo -> . array_declaration COLON
    (23) codigo -> . array_declaration
    (24) codigo -> . array_var COLON
    (25) codigo -> . array_var
    (26) codigo -> . array_assignment COLON
    (27) codigo -> . array_assignment
    (28) codigo -> . slice_declaration COLON
    (29) codigo -> . slice_declaration
    (30) codigo -> . slice_var COLON
    (31) codigo -> . slice_var
    (32) codigo -> . slice_assignment COLON
    (33) codigo -> . slice_assignment
    (34) codigo -> . map_declaration COLON
    (35) codigo -> . map_declaration
    (36) codigo -> . map_assignment COLON
    (37) codigo -> . map_assignment
    (38) codigo -> . func_declaration
    (39) codigo -> . main_func
    (192) impresion -> . PRINT LPAREN content RPAREN
    (76) scan_func -> . SCAN LPAREN POINTER RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (77) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (83) decVar -> . decVarOne
    (84) decVar -> . VAR ID EQUAL INTEGER
    (85) decVar -> . VAR ID EQUAL ID
    (86) decVar -> . VAR ID EQUAL FLOAT
    (87) decVar -> . VAR ID EQUAL expression
    (88) decVar -> . VAR ID EQUAL logic_operation
    (89) decVar -> . VAR ID EQUAL comparison
    (90) decVar -> . VAR ID EQUAL STRING
    (91) decVar -> . ID DEQUAL STRING
    (92) decVar -> . ID DEQUAL FLOAT
    (93) decVar -> . ID DEQUAL expression
    (94) decVar -> . ID DEQUAL logic_operation
    (95) decVar -> . ID DEQUAL comparison
    (59) var_asignation -> . ID EQUAL any
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (122) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (123) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (125) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (129) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (160) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (165) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (170) array_var -> . ID LCORCHE index RCORCHE
    (174) array_assignment -> . array_var EQUAL something
    (96) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> . VAR ID EQUAL funM
    (99) slice_declaration -> . ID DEQUAL funM
    (100) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> . ID LCORCHE index_s RCORCHE
    (110) slice_assignment -> . slice_var EQUAL something_s
    (175) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (180) map_assignment -> . array_var EQUAL something
    (181) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (176) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 27
    SCAN            shift and go to state 28
    FOR             shift and go to state 30
    VAR             shift and go to state 35
    ID              shift and go to state 36
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 43
    ELSE            shift and go to state 44
    TYPE            shift and go to state 45
    SWITCH          shift and go to state 46
    FUNC            shift and go to state 47
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    NOT             shift and go to state 49

    codigo                         shift and go to state 327
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenElseIF                      shift and go to state 12
    SenElse                        shift and go to state 13
    SenStruct                      shift and go to state 14
    cStruct                        shift and go to state 15
    switch_statement               shift and go to state 16
    array_declaration              shift and go to state 17
    array_var                      shift and go to state 18
    array_assignment               shift and go to state 19
    slice_declaration              shift and go to state 20
    slice_var                      shift and go to state 21
    slice_assignment               shift and go to state 22
    map_declaration                shift and go to state 23
    map_assignment                 shift and go to state 24
    func_declaration               shift and go to state 25
    main_func                      shift and go to state 26
    something_ex                   shift and go to state 29
    decVarOne                      shift and go to state 31
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    map_var                        shift and go to state 50

state 308

    (191) more_params -> ID data_types COMA . params
    (189) params -> . ID data_types
    (190) params -> . more_params
    (191) more_params -> . ID data_types COMA params

    ID              shift and go to state 250

    params                         shift and go to state 328
    more_params                    shift and go to state 252

state 309

    (181) func_declaration -> FUNC ID LPAREN params RPAREN data_types . LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> FUNC ID LPAREN params RPAREN data_types . LLLAVE RETURN return_value RLLAVE

    LLLAVE          shift and go to state 329


state 310

    (75) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 330


state 311

    (80) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenElseIF
    (18) codigo -> . SenElse
    (19) codigo -> . SenStruct
    (20) codigo -> . cStruct
    (21) codigo -> . switch_statement
    (22) codigo -> . array_declaration COLON
    (23) codigo -> . array_declaration
    (24) codigo -> . array_var COLON
    (25) codigo -> . array_var
    (26) codigo -> . array_assignment COLON
    (27) codigo -> . array_assignment
    (28) codigo -> . slice_declaration COLON
    (29) codigo -> . slice_declaration
    (30) codigo -> . slice_var COLON
    (31) codigo -> . slice_var
    (32) codigo -> . slice_assignment COLON
    (33) codigo -> . slice_assignment
    (34) codigo -> . map_declaration COLON
    (35) codigo -> . map_declaration
    (36) codigo -> . map_assignment COLON
    (37) codigo -> . map_assignment
    (38) codigo -> . func_declaration
    (39) codigo -> . main_func
    (192) impresion -> . PRINT LPAREN content RPAREN
    (76) scan_func -> . SCAN LPAREN POINTER RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (77) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (83) decVar -> . decVarOne
    (84) decVar -> . VAR ID EQUAL INTEGER
    (85) decVar -> . VAR ID EQUAL ID
    (86) decVar -> . VAR ID EQUAL FLOAT
    (87) decVar -> . VAR ID EQUAL expression
    (88) decVar -> . VAR ID EQUAL logic_operation
    (89) decVar -> . VAR ID EQUAL comparison
    (90) decVar -> . VAR ID EQUAL STRING
    (91) decVar -> . ID DEQUAL STRING
    (92) decVar -> . ID DEQUAL FLOAT
    (93) decVar -> . ID DEQUAL expression
    (94) decVar -> . ID DEQUAL logic_operation
    (95) decVar -> . ID DEQUAL comparison
    (59) var_asignation -> . ID EQUAL any
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (122) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (123) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (125) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (129) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (160) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (165) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (170) array_var -> . ID LCORCHE index RCORCHE
    (174) array_assignment -> . array_var EQUAL something
    (96) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> . VAR ID EQUAL funM
    (99) slice_declaration -> . ID DEQUAL funM
    (100) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> . ID LCORCHE index_s RCORCHE
    (110) slice_assignment -> . slice_var EQUAL something_s
    (175) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (180) map_assignment -> . array_var EQUAL something
    (181) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (176) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 27
    SCAN            shift and go to state 28
    FOR             shift and go to state 30
    VAR             shift and go to state 35
    ID              shift and go to state 36
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 43
    ELSE            shift and go to state 44
    TYPE            shift and go to state 45
    SWITCH          shift and go to state 46
    FUNC            shift and go to state 47
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    NOT             shift and go to state 49

    decVarOne                      shift and go to state 31
    comparison                     shift and go to state 6
    codigo                         shift and go to state 331
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenElseIF                      shift and go to state 12
    SenElse                        shift and go to state 13
    SenStruct                      shift and go to state 14
    cStruct                        shift and go to state 15
    switch_statement               shift and go to state 16
    array_declaration              shift and go to state 17
    array_var                      shift and go to state 18
    array_assignment               shift and go to state 19
    slice_declaration              shift and go to state 20
    slice_var                      shift and go to state 21
    slice_assignment               shift and go to state 22
    map_declaration                shift and go to state 23
    map_assignment                 shift and go to state 24
    func_declaration               shift and go to state 25
    main_func                      shift and go to state 26
    something_ex                   shift and go to state 29
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    map_var                        shift and go to state 50

state 312

    (81) incre -> ID INCREASE .

    LLLAVE          reduce using rule 81 (incre -> ID INCREASE .)


state 313

    (82) incre -> ID DECREASE .

    LLLAVE          reduce using rule 82 (incre -> ID DECREASE .)


state 314

    (166) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types . arr_content
    (65) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (66) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 295

    arr_content                    shift and go to state 332

state 315

    (97) slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .

    COLON           reduce using rule 97 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    $end            reduce using rule 97 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 97 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 97 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    CASE            reduce using rule 97 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)
    RETURN          reduce using rule 97 (slice_declaration -> VAR ID EQUAL LCORCHE RCORCHE data_types arr_content .)


state 316

    (136) valor -> ID .

    COMA            reduce using rule 136 (valor -> ID .)
    RLLAVE          reduce using rule 136 (valor -> ID .)


state 317

    (134) asignaciones -> ID POINTS valor .
    (135) asignaciones -> ID POINTS valor . COMA asignaciones

    RLLAVE          reduce using rule 134 (asignaciones -> ID POINTS valor .)
    COMA            shift and go to state 333


state 318

    (137) valor -> INTEGER .

    COMA            reduce using rule 137 (valor -> INTEGER .)
    RLLAVE          reduce using rule 137 (valor -> INTEGER .)


state 319

    (138) valor -> TRUE .

    COMA            reduce using rule 138 (valor -> TRUE .)
    RLLAVE          reduce using rule 138 (valor -> TRUE .)


state 320

    (139) valor -> FALSE .

    COMA            reduce using rule 139 (valor -> FALSE .)
    RLLAVE          reduce using rule 139 (valor -> FALSE .)


state 321

    (65) arr_content -> LLLAVE items . COMA more_items RLLAVE
    (66) arr_content -> LLLAVE items . RLLAVE

    COMA            shift and go to state 334
    RLLAVE          shift and go to state 335


state 322

    (69) items -> values .

    COMA            reduce using rule 69 (items -> values .)
    RLLAVE          reduce using rule 69 (items -> values .)


state 323

    (70) items -> operations .

    COMA            reduce using rule 70 (items -> operations .)
    RLLAVE          reduce using rule 70 (items -> operations .)


state 324

    (202) something_ex -> ID .
    (141) value -> ID .
    (155) logic_value -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (176) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for GREATER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 141 (value -> ID .)
    COMA            reduce using rule 202 (something_ex -> ID .)
    RLLAVE          reduce using rule 202 (something_ex -> ID .)
    GREATER         reduce using rule 141 (value -> ID .)
    SMALLER         reduce using rule 141 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 141 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 141 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 141 (value -> ID .)
    NOT_EQUAL       reduce using rule 141 (value -> ID .)
    PLUS            reduce using rule 141 (value -> ID .)
    TIMES           reduce using rule 141 (value -> ID .)
    DIVIDE          reduce using rule 141 (value -> ID .)
    MINUS           reduce using rule 141 (value -> ID .)
    AND             reduce using rule 155 (logic_value -> ID .)
    OR              reduce using rule 155 (logic_value -> ID .)
    LCORCHE         shift and go to state 146

  ! GREATER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 202 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 202 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 202 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 202 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 202 (something_ex -> ID .) ]


state 325

    (101) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap RPAREN
    (102) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap COMA cap RPAREN

    COMA            shift and go to state 336


state 326

    (131) declaration -> declaration variable data_types .

    RLLAVE          reduce using rule 131 (declaration -> declaration variable data_types .)
    ID              reduce using rule 131 (declaration -> declaration variable data_types .)


state 327

    (161) cases -> CASE values POINTS codigo .
    (162) cases -> CASE values POINTS codigo . more
    (163) more -> . cases
    (164) more -> . DEFAULT POINTS codigo
    (161) cases -> . CASE values POINTS codigo
    (162) cases -> . CASE values POINTS codigo more

    RLLAVE          reduce using rule 161 (cases -> CASE values POINTS codigo .)
    DEFAULT         shift and go to state 339
    CASE            shift and go to state 249

    more                           shift and go to state 337
    cases                          shift and go to state 338

state 328

    (191) more_params -> ID data_types COMA params .

    RPAREN          reduce using rule 191 (more_params -> ID data_types COMA params .)


state 329

    (181) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE . codigo RETURN retorno RLLAVE
    (182) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE . RETURN return_value RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenElseIF
    (18) codigo -> . SenElse
    (19) codigo -> . SenStruct
    (20) codigo -> . cStruct
    (21) codigo -> . switch_statement
    (22) codigo -> . array_declaration COLON
    (23) codigo -> . array_declaration
    (24) codigo -> . array_var COLON
    (25) codigo -> . array_var
    (26) codigo -> . array_assignment COLON
    (27) codigo -> . array_assignment
    (28) codigo -> . slice_declaration COLON
    (29) codigo -> . slice_declaration
    (30) codigo -> . slice_var COLON
    (31) codigo -> . slice_var
    (32) codigo -> . slice_assignment COLON
    (33) codigo -> . slice_assignment
    (34) codigo -> . map_declaration COLON
    (35) codigo -> . map_declaration
    (36) codigo -> . map_assignment COLON
    (37) codigo -> . map_assignment
    (38) codigo -> . func_declaration
    (39) codigo -> . main_func
    (192) impresion -> . PRINT LPAREN content RPAREN
    (76) scan_func -> . SCAN LPAREN POINTER RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (77) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (83) decVar -> . decVarOne
    (84) decVar -> . VAR ID EQUAL INTEGER
    (85) decVar -> . VAR ID EQUAL ID
    (86) decVar -> . VAR ID EQUAL FLOAT
    (87) decVar -> . VAR ID EQUAL expression
    (88) decVar -> . VAR ID EQUAL logic_operation
    (89) decVar -> . VAR ID EQUAL comparison
    (90) decVar -> . VAR ID EQUAL STRING
    (91) decVar -> . ID DEQUAL STRING
    (92) decVar -> . ID DEQUAL FLOAT
    (93) decVar -> . ID DEQUAL expression
    (94) decVar -> . ID DEQUAL logic_operation
    (95) decVar -> . ID DEQUAL comparison
    (59) var_asignation -> . ID EQUAL any
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (122) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (123) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (125) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (129) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (160) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (165) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (170) array_var -> . ID LCORCHE index RCORCHE
    (174) array_assignment -> . array_var EQUAL something
    (96) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> . VAR ID EQUAL funM
    (99) slice_declaration -> . ID DEQUAL funM
    (100) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> . ID LCORCHE index_s RCORCHE
    (110) slice_assignment -> . slice_var EQUAL something_s
    (175) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (180) map_assignment -> . array_var EQUAL something
    (181) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (176) map_var -> . ID LCORCHE key RCORCHE

    RETURN          shift and go to state 341
    PRINT           shift and go to state 27
    SCAN            shift and go to state 28
    FOR             shift and go to state 30
    VAR             shift and go to state 35
    ID              shift and go to state 36
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 43
    ELSE            shift and go to state 44
    TYPE            shift and go to state 45
    SWITCH          shift and go to state 46
    FUNC            shift and go to state 47
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    NOT             shift and go to state 49

    codigo                         shift and go to state 340
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenElseIF                      shift and go to state 12
    SenElse                        shift and go to state 13
    SenStruct                      shift and go to state 14
    cStruct                        shift and go to state 15
    switch_statement               shift and go to state 16
    array_declaration              shift and go to state 17
    array_var                      shift and go to state 18
    array_assignment               shift and go to state 19
    slice_declaration              shift and go to state 20
    slice_var                      shift and go to state 21
    slice_assignment               shift and go to state 22
    map_declaration                shift and go to state 23
    map_assignment                 shift and go to state 24
    func_declaration               shift and go to state 25
    main_func                      shift and go to state 26
    something_ex                   shift and go to state 29
    decVarOne                      shift and go to state 31
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    map_var                        shift and go to state 50

state 330

    (75) main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .

    $end            reduce using rule 75 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 75 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 75 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 75 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 75 (main_func -> FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE .)


state 331

    (80) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 342


state 332

    (166) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .

    COLON           reduce using rule 166 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    $end            reduce using rule 166 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 166 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 166 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    CASE            reduce using rule 166 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RETURN          reduce using rule 166 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)


state 333

    (135) asignaciones -> ID POINTS valor COMA . asignaciones
    (134) asignaciones -> . ID POINTS valor
    (135) asignaciones -> . ID POINTS valor COMA asignaciones

    ID              shift and go to state 262

    asignaciones                   shift and go to state 343

state 334

    (65) arr_content -> LLLAVE items COMA . more_items RLLAVE
    (67) more_items -> . items COMA more_items
    (68) more_items -> . items
    (69) items -> . values
    (70) items -> . operations
    (40) values -> . STRING
    (41) values -> . INTEGER
    (42) values -> . FLOAT
    (43) values -> . TRUE
    (44) values -> . FALSE
    (54) operations -> . expression
    (55) operations -> . comparison
    (56) operations -> . logic_operation
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    STRING          shift and go to state 119
    INTEGER         shift and go to state 120
    FLOAT           shift and go to state 121
    TRUE            shift and go to state 122
    FALSE           shift and go to state 123
    ID              shift and go to state 324
    NOT             shift and go to state 49
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    items                          shift and go to state 344
    more_items                     shift and go to state 345
    values                         shift and go to state 322
    operations                     shift and go to state 323
    expression                     shift and go to state 124
    comparison                     shift and go to state 125
    logic_operation                shift and go to state 126
    something_ex                   shift and go to state 29
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 335

    (66) arr_content -> LLLAVE items RLLAVE .

    COLON           reduce using rule 66 (arr_content -> LLLAVE items RLLAVE .)
    $end            reduce using rule 66 (arr_content -> LLLAVE items RLLAVE .)
    RLLAVE          reduce using rule 66 (arr_content -> LLLAVE items RLLAVE .)
    DEFAULT         reduce using rule 66 (arr_content -> LLLAVE items RLLAVE .)
    CASE            reduce using rule 66 (arr_content -> LLLAVE items RLLAVE .)
    RETURN          reduce using rule 66 (arr_content -> LLLAVE items RLLAVE .)


state 336

    (101) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap RPAREN
    (102) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap COMA cap RPAREN
    (103) cap -> . INTEGER
    (104) cap -> . ID
    (105) cap -> . expression
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    INTEGER         shift and go to state 347
    ID              shift and go to state 348
    FLOAT           shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    cap                            shift and go to state 346
    expression                     shift and go to state 349
    something_ex                   shift and go to state 29
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 337

    (162) cases -> CASE values POINTS codigo more .

    RLLAVE          reduce using rule 162 (cases -> CASE values POINTS codigo more .)


state 338

    (163) more -> cases .

    RLLAVE          reduce using rule 163 (more -> cases .)


state 339

    (164) more -> DEFAULT . POINTS codigo

    POINTS          shift and go to state 350


state 340

    (181) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo . RETURN retorno RLLAVE

    RETURN          shift and go to state 351


state 341

    (182) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN . return_value RLLAVE
    (183) return_value -> . retorno COLON
    (184) return_value -> . retorno
    (185) retorno -> . ID
    (186) retorno -> . values
    (187) retorno -> . operations
    (188) retorno -> . data_structure
    (40) values -> . STRING
    (41) values -> . INTEGER
    (42) values -> . FLOAT
    (43) values -> . TRUE
    (44) values -> . FALSE
    (54) operations -> . expression
    (55) operations -> . comparison
    (56) operations -> . logic_operation
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN

    ID              shift and go to state 352
    STRING          shift and go to state 119
    INTEGER         shift and go to state 120
    FLOAT           shift and go to state 121
    TRUE            shift and go to state 122
    FALSE           shift and go to state 123
    NOT             shift and go to state 49
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    return_value                   shift and go to state 353
    retorno                        shift and go to state 354
    values                         shift and go to state 355
    operations                     shift and go to state 356
    data_structure                 shift and go to state 357
    expression                     shift and go to state 124
    comparison                     shift and go to state 125
    logic_operation                shift and go to state 126
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50
    something_ex                   shift and go to state 29
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    funciones                      shift and go to state 87

state 342

    (80) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .

    $end            reduce using rule 80 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 80 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 80 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 80 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 80 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)


state 343

    (135) asignaciones -> ID POINTS valor COMA asignaciones .

    RLLAVE          reduce using rule 135 (asignaciones -> ID POINTS valor COMA asignaciones .)


state 344

    (67) more_items -> items . COMA more_items
    (68) more_items -> items .

    COMA            shift and go to state 358
    RLLAVE          reduce using rule 68 (more_items -> items .)


state 345

    (65) arr_content -> LLLAVE items COMA more_items . RLLAVE

    RLLAVE          shift and go to state 359


state 346

    (101) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . RPAREN
    (102) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . COMA cap RPAREN

    RPAREN          shift and go to state 361
    COMA            shift and go to state 360


state 347

    (103) cap -> INTEGER .
    (203) something_ex -> INTEGER .

  ! reduce/reduce conflict for RPAREN resolved using rule 103 (cap -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 103 (cap -> INTEGER .)
    RPAREN          reduce using rule 103 (cap -> INTEGER .)
    COMA            reduce using rule 103 (cap -> INTEGER .)
    GREATER         reduce using rule 203 (something_ex -> INTEGER .)
    SMALLER         reduce using rule 203 (something_ex -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 203 (something_ex -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 203 (something_ex -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 203 (something_ex -> INTEGER .)
    NOT_EQUAL       reduce using rule 203 (something_ex -> INTEGER .)
    PLUS            reduce using rule 203 (something_ex -> INTEGER .)
    TIMES           reduce using rule 203 (something_ex -> INTEGER .)
    DIVIDE          reduce using rule 203 (something_ex -> INTEGER .)
    MINUS           reduce using rule 203 (something_ex -> INTEGER .)

  ! RPAREN          [ reduce using rule 203 (something_ex -> INTEGER .) ]
  ! COMA            [ reduce using rule 203 (something_ex -> INTEGER .) ]


state 348

    (104) cap -> ID .
    (202) something_ex -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (176) map_var -> ID . LCORCHE key RCORCHE

  ! reduce/reduce conflict for RPAREN resolved using rule 104 (cap -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 104 (cap -> ID .)
    RPAREN          reduce using rule 104 (cap -> ID .)
    COMA            reduce using rule 104 (cap -> ID .)
    GREATER         reduce using rule 202 (something_ex -> ID .)
    SMALLER         reduce using rule 202 (something_ex -> ID .)
    GREATER_OR_EQUAL reduce using rule 202 (something_ex -> ID .)
    SMALLER_OR_EQUAL reduce using rule 202 (something_ex -> ID .)
    EQUAL_COMPARE   reduce using rule 202 (something_ex -> ID .)
    NOT_EQUAL       reduce using rule 202 (something_ex -> ID .)
    PLUS            reduce using rule 202 (something_ex -> ID .)
    TIMES           reduce using rule 202 (something_ex -> ID .)
    DIVIDE          reduce using rule 202 (something_ex -> ID .)
    MINUS           reduce using rule 202 (something_ex -> ID .)
    LCORCHE         shift and go to state 146

  ! RPAREN          [ reduce using rule 202 (something_ex -> ID .) ]
  ! COMA            [ reduce using rule 202 (something_ex -> ID .) ]


state 349

    (105) cap -> expression .

    RPAREN          reduce using rule 105 (cap -> expression .)
    COMA            reduce using rule 105 (cap -> expression .)


state 350

    (164) more -> DEFAULT POINTS . codigo
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . scan_func COLON
    (4) codigo -> . scan_func
    (5) codigo -> . expression COLON
    (6) codigo -> . expression
    (7) codigo -> . cicloFor
    (8) codigo -> . comparison
    (9) codigo -> . logic_operation
    (10) codigo -> . decVar COLON
    (11) codigo -> . decVar
    (12) codigo -> . var_asignation
    (13) codigo -> . var_asignation COLON
    (14) codigo -> . funciones
    (15) codigo -> . funciones COLON
    (16) codigo -> . SenIF
    (17) codigo -> . SenElseIF
    (18) codigo -> . SenElse
    (19) codigo -> . SenStruct
    (20) codigo -> . cStruct
    (21) codigo -> . switch_statement
    (22) codigo -> . array_declaration COLON
    (23) codigo -> . array_declaration
    (24) codigo -> . array_var COLON
    (25) codigo -> . array_var
    (26) codigo -> . array_assignment COLON
    (27) codigo -> . array_assignment
    (28) codigo -> . slice_declaration COLON
    (29) codigo -> . slice_declaration
    (30) codigo -> . slice_var COLON
    (31) codigo -> . slice_var
    (32) codigo -> . slice_assignment COLON
    (33) codigo -> . slice_assignment
    (34) codigo -> . map_declaration COLON
    (35) codigo -> . map_declaration
    (36) codigo -> . map_assignment COLON
    (37) codigo -> . map_assignment
    (38) codigo -> . func_declaration
    (39) codigo -> . main_func
    (192) impresion -> . PRINT LPAREN content RPAREN
    (76) scan_func -> . SCAN LPAREN POINTER RPAREN
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (77) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (78) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (79) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (80) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (83) decVar -> . decVarOne
    (84) decVar -> . VAR ID EQUAL INTEGER
    (85) decVar -> . VAR ID EQUAL ID
    (86) decVar -> . VAR ID EQUAL FLOAT
    (87) decVar -> . VAR ID EQUAL expression
    (88) decVar -> . VAR ID EQUAL logic_operation
    (89) decVar -> . VAR ID EQUAL comparison
    (90) decVar -> . VAR ID EQUAL STRING
    (91) decVar -> . ID DEQUAL STRING
    (92) decVar -> . ID DEQUAL FLOAT
    (93) decVar -> . ID DEQUAL expression
    (94) decVar -> . ID DEQUAL logic_operation
    (95) decVar -> . ID DEQUAL comparison
    (59) var_asignation -> . ID EQUAL any
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (122) SenIF -> . IF comparison LLLAVE codigo RLLAVE
    (123) SenIF -> . IF TRUE LLLAVE codigo RLLAVE
    (124) SenIF -> . IF FALSE LLLAVE codigo RLLAVE
    (125) SenElseIF -> . ELSE IF comparison LLLAVE codigo RLLAVE
    (126) SenElseIF -> . ELSE IF TRUE LLLAVE codigo RLLAVE
    (127) SenElseIF -> . ELSE IF FALSE LLLAVE codigo RLLAVE
    (128) SenElse -> . ELSE LLLAVE codigo RLLAVE
    (129) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (133) cStruct -> . ID DEQUAL ID LLLAVE asignaciones RLLAVE
    (160) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (165) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (166) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (170) array_var -> . ID LCORCHE index RCORCHE
    (174) array_assignment -> . array_var EQUAL something
    (96) slice_declaration -> . VAR ID LCORCHE RCORCHE data_types
    (97) slice_declaration -> . VAR ID EQUAL LCORCHE RCORCHE data_types arr_content
    (98) slice_declaration -> . VAR ID EQUAL funM
    (99) slice_declaration -> . ID DEQUAL funM
    (100) slice_declaration -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (106) slice_var -> . ID LCORCHE index_s RCORCHE
    (110) slice_assignment -> . slice_var EQUAL something_s
    (175) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (180) map_assignment -> . array_var EQUAL something
    (181) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (182) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (75) main_func -> . FUNC MAIN LPAREN RPAREN LLLAVE codigo RLLAVE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (120) decVarOne -> . ID DEQUAL ID
    (121) decVarOne -> . ID DEQUAL INTEGER
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (176) map_var -> . ID LCORCHE key RCORCHE

    PRINT           shift and go to state 27
    SCAN            shift and go to state 28
    FOR             shift and go to state 30
    VAR             shift and go to state 35
    ID              shift and go to state 36
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42
    IF              shift and go to state 43
    ELSE            shift and go to state 44
    TYPE            shift and go to state 45
    SWITCH          shift and go to state 46
    FUNC            shift and go to state 47
    INTEGER         shift and go to state 37
    FLOAT           shift and go to state 38
    NOT             shift and go to state 49

    codigo                         shift and go to state 362
    impresion                      shift and go to state 2
    scan_func                      shift and go to state 3
    expression                     shift and go to state 4
    cicloFor                       shift and go to state 5
    comparison                     shift and go to state 6
    logic_operation                shift and go to state 7
    decVar                         shift and go to state 8
    var_asignation                 shift and go to state 9
    funciones                      shift and go to state 10
    SenIF                          shift and go to state 11
    SenElseIF                      shift and go to state 12
    SenElse                        shift and go to state 13
    SenStruct                      shift and go to state 14
    cStruct                        shift and go to state 15
    switch_statement               shift and go to state 16
    array_declaration              shift and go to state 17
    array_var                      shift and go to state 18
    array_assignment               shift and go to state 19
    slice_declaration              shift and go to state 20
    slice_var                      shift and go to state 21
    slice_assignment               shift and go to state 22
    map_declaration                shift and go to state 23
    map_assignment                 shift and go to state 24
    func_declaration               shift and go to state 25
    main_func                      shift and go to state 26
    something_ex                   shift and go to state 29
    decVarOne                      shift and go to state 31
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    map_var                        shift and go to state 50

state 351

    (181) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN . retorno RLLAVE
    (185) retorno -> . ID
    (186) retorno -> . values
    (187) retorno -> . operations
    (188) retorno -> . data_structure
    (40) values -> . STRING
    (41) values -> . INTEGER
    (42) values -> . FLOAT
    (43) values -> . TRUE
    (44) values -> . FALSE
    (54) operations -> . expression
    (55) operations -> . comparison
    (56) operations -> . logic_operation
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN

    ID              shift and go to state 352
    STRING          shift and go to state 119
    INTEGER         shift and go to state 120
    FLOAT           shift and go to state 121
    TRUE            shift and go to state 122
    FALSE           shift and go to state 123
    NOT             shift and go to state 49
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    retorno                        shift and go to state 363
    values                         shift and go to state 355
    operations                     shift and go to state 356
    data_structure                 shift and go to state 357
    expression                     shift and go to state 124
    comparison                     shift and go to state 125
    logic_operation                shift and go to state 126
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50
    something_ex                   shift and go to state 29
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    funciones                      shift and go to state 87

state 352

    (185) retorno -> ID .
    (170) array_var -> ID . LCORCHE index RCORCHE
    (176) map_var -> ID . LCORCHE key RCORCHE
    (202) something_ex -> ID .
    (141) value -> ID .
    (155) logic_value -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 185 (retorno -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 185 (retorno -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for PLUS resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for TIMES resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for DIVIDE resolved using rule 141 (value -> ID .)
  ! reduce/reduce conflict for MINUS resolved using rule 141 (value -> ID .)
    COLON           reduce using rule 185 (retorno -> ID .)
    RLLAVE          reduce using rule 185 (retorno -> ID .)
    LCORCHE         shift and go to state 146
    GREATER         reduce using rule 141 (value -> ID .)
    SMALLER         reduce using rule 141 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 141 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 141 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 141 (value -> ID .)
    NOT_EQUAL       reduce using rule 141 (value -> ID .)
    PLUS            reduce using rule 141 (value -> ID .)
    TIMES           reduce using rule 141 (value -> ID .)
    DIVIDE          reduce using rule 141 (value -> ID .)
    MINUS           reduce using rule 141 (value -> ID .)
    AND             reduce using rule 155 (logic_value -> ID .)
    OR              reduce using rule 155 (logic_value -> ID .)

  ! GREATER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER         [ reduce using rule 202 (something_ex -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 202 (something_ex -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 202 (something_ex -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 202 (something_ex -> ID .) ]
  ! PLUS            [ reduce using rule 202 (something_ex -> ID .) ]
  ! TIMES           [ reduce using rule 202 (something_ex -> ID .) ]
  ! DIVIDE          [ reduce using rule 202 (something_ex -> ID .) ]
  ! MINUS           [ reduce using rule 202 (something_ex -> ID .) ]
  ! COLON           [ reduce using rule 202 (something_ex -> ID .) ]
  ! RLLAVE          [ reduce using rule 202 (something_ex -> ID .) ]


state 353

    (182) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value . RLLAVE

    RLLAVE          shift and go to state 364


state 354

    (183) return_value -> retorno . COLON
    (184) return_value -> retorno .

    COLON           shift and go to state 365
    RLLAVE          reduce using rule 184 (return_value -> retorno .)


state 355

    (186) retorno -> values .

    COLON           reduce using rule 186 (retorno -> values .)
    RLLAVE          reduce using rule 186 (retorno -> values .)


state 356

    (187) retorno -> operations .

    COLON           reduce using rule 187 (retorno -> operations .)
    RLLAVE          reduce using rule 187 (retorno -> operations .)


state 357

    (188) retorno -> data_structure .
    (205) something_ex -> data_structure .

  ! reduce/reduce conflict for COLON resolved using rule 188 (retorno -> data_structure .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 188 (retorno -> data_structure .)
    COLON           reduce using rule 188 (retorno -> data_structure .)
    RLLAVE          reduce using rule 188 (retorno -> data_structure .)
    GREATER         reduce using rule 205 (something_ex -> data_structure .)
    SMALLER         reduce using rule 205 (something_ex -> data_structure .)
    GREATER_OR_EQUAL reduce using rule 205 (something_ex -> data_structure .)
    SMALLER_OR_EQUAL reduce using rule 205 (something_ex -> data_structure .)
    EQUAL_COMPARE   reduce using rule 205 (something_ex -> data_structure .)
    NOT_EQUAL       reduce using rule 205 (something_ex -> data_structure .)
    PLUS            reduce using rule 205 (something_ex -> data_structure .)
    TIMES           reduce using rule 205 (something_ex -> data_structure .)
    DIVIDE          reduce using rule 205 (something_ex -> data_structure .)
    MINUS           reduce using rule 205 (something_ex -> data_structure .)

  ! COLON           [ reduce using rule 205 (something_ex -> data_structure .) ]
  ! RLLAVE          [ reduce using rule 205 (something_ex -> data_structure .) ]


state 358

    (67) more_items -> items COMA . more_items
    (67) more_items -> . items COMA more_items
    (68) more_items -> . items
    (69) items -> . values
    (70) items -> . operations
    (40) values -> . STRING
    (41) values -> . INTEGER
    (42) values -> . FLOAT
    (43) values -> . TRUE
    (44) values -> . FALSE
    (54) operations -> . expression
    (55) operations -> . comparison
    (56) operations -> . logic_operation
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (140) comparison -> . value op value
    (149) logic_operation -> . logic_value logic_recu
    (150) logic_operation -> . negation
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (141) value -> . ID
    (142) value -> . expression
    (153) logic_value -> . negation
    (154) logic_value -> . comparison
    (155) logic_value -> . ID
    (156) negation -> . NOT comparison
    (157) negation -> . NOT ID
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    STRING          shift and go to state 119
    INTEGER         shift and go to state 120
    FLOAT           shift and go to state 121
    TRUE            shift and go to state 122
    FALSE           shift and go to state 123
    ID              shift and go to state 324
    NOT             shift and go to state 49
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    items                          shift and go to state 344
    more_items                     shift and go to state 366
    values                         shift and go to state 322
    operations                     shift and go to state 323
    expression                     shift and go to state 124
    comparison                     shift and go to state 125
    logic_operation                shift and go to state 126
    something_ex                   shift and go to state 29
    value                          shift and go to state 32
    logic_value                    shift and go to state 33
    negation                       shift and go to state 34
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 359

    (65) arr_content -> LLLAVE items COMA more_items RLLAVE .

    COLON           reduce using rule 65 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    $end            reduce using rule 65 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RLLAVE          reduce using rule 65 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    DEFAULT         reduce using rule 65 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    CASE            reduce using rule 65 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RETURN          reduce using rule 65 (arr_content -> LLLAVE items COMA more_items RLLAVE .)


state 360

    (102) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA . cap RPAREN
    (103) cap -> . INTEGER
    (104) cap -> . ID
    (105) cap -> . expression
    (198) expression -> . something_ex
    (199) expression -> . something_ex adicionaEx
    (202) something_ex -> . ID
    (203) something_ex -> . INTEGER
    (204) something_ex -> . FLOAT
    (205) something_ex -> . data_structure
    (206) something_ex -> . funciones
    (57) data_structure -> . array_var
    (58) data_structure -> . map_var
    (115) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (116) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (117) funciones -> . LEN LPAREN ID RPAREN
    (118) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (119) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (170) array_var -> . ID LCORCHE index RCORCHE
    (176) map_var -> . ID LCORCHE key RCORCHE

    INTEGER         shift and go to state 347
    ID              shift and go to state 348
    FLOAT           shift and go to state 38
    APPEND          shift and go to state 39
    LEN             shift and go to state 40
    COPY            shift and go to state 41
    DELETE          shift and go to state 42

    cap                            shift and go to state 367
    expression                     shift and go to state 349
    something_ex                   shift and go to state 29
    data_structure                 shift and go to state 48
    funciones                      shift and go to state 87
    array_var                      shift and go to state 88
    map_var                        shift and go to state 50

state 361

    (101) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .

    COLON           reduce using rule 101 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    $end            reduce using rule 101 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RLLAVE          reduce using rule 101 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    DEFAULT         reduce using rule 101 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    CASE            reduce using rule 101 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RETURN          reduce using rule 101 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)


state 362

    (164) more -> DEFAULT POINTS codigo .

    RLLAVE          reduce using rule 164 (more -> DEFAULT POINTS codigo .)


state 363

    (181) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno . RLLAVE

    RLLAVE          shift and go to state 368


state 364

    (182) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .

    $end            reduce using rule 182 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    RLLAVE          reduce using rule 182 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    DEFAULT         reduce using rule 182 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    CASE            reduce using rule 182 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    RETURN          reduce using rule 182 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)


state 365

    (183) return_value -> retorno COLON .

    RLLAVE          reduce using rule 183 (return_value -> retorno COLON .)


state 366

    (67) more_items -> items COMA more_items .

    RLLAVE          reduce using rule 67 (more_items -> items COMA more_items .)


state 367

    (102) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap . RPAREN

    RPAREN          shift and go to state 369


state 368

    (181) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .

    $end            reduce using rule 181 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    RLLAVE          reduce using rule 181 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    DEFAULT         reduce using rule 181 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    CASE            reduce using rule 181 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    RETURN          reduce using rule 181 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)


state 369

    (102) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .

    COLON           reduce using rule 102 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    $end            reduce using rule 102 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RLLAVE          reduce using rule 102 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    DEFAULT         reduce using rule 102 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    CASE            reduce using rule 102 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RETURN          reduce using rule 102 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for COLON in state 10 resolved as shift
WARNING: shift/reduce conflict for COLON in state 18 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 29 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 29 resolved as shift
WARNING: shift/reduce conflict for GREATER_OR_EQUAL in state 29 resolved as shift
WARNING: shift/reduce conflict for SMALLER_OR_EQUAL in state 29 resolved as shift
WARNING: shift/reduce conflict for EQUAL_COMPARE in state 29 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 29 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 29 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 29 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 29 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 29 resolved as shift
WARNING: shift/reduce conflict for GREATER in state 139 resolved as shift
WARNING: shift/reduce conflict for SMALLER in state 139 resolved as shift
WARNING: shift/reduce conflict for GREATER_OR_EQUAL in state 139 resolved as shift
WARNING: shift/reduce conflict for SMALLER_OR_EQUAL in state 139 resolved as shift
WARNING: shift/reduce conflict for EQUAL_COMPARE in state 139 resolved as shift
WARNING: shift/reduce conflict for NOT_EQUAL in state 139 resolved as shift
WARNING: shift/reduce conflict for PLUS in state 139 resolved as shift
WARNING: shift/reduce conflict for TIMES in state 139 resolved as shift
WARNING: shift/reduce conflict for DIVIDE in state 139 resolved as shift
WARNING: shift/reduce conflict for MINUS in state 139 resolved as shift
WARNING: reduce/reduce conflict in state 10 resolved using rule (codigo -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 10
WARNING: reduce/reduce conflict in state 18 resolved using rule (codigo -> array_var)
WARNING: rejected rule (data_structure -> array_var) in state 18
WARNING: reduce/reduce conflict in state 36 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 36
WARNING: reduce/reduce conflict in state 85 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 85
WARNING: reduce/reduce conflict in state 105 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 105
WARNING: reduce/reduce conflict in state 113 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 113
WARNING: reduce/reduce conflict in state 114 resolved using rule (array_assignment -> array_var EQUAL something)
WARNING: rejected rule (map_assignment -> array_var EQUAL something) in state 114
WARNING: reduce/reduce conflict in state 115 resolved using rule (something -> ID)
WARNING: rejected rule (something_ex -> ID) in state 115
WARNING: reduce/reduce conflict in state 115 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 115
WARNING: reduce/reduce conflict in state 116 resolved using rule (something -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 116
WARNING: reduce/reduce conflict in state 120 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 120
WARNING: reduce/reduce conflict in state 121 resolved using rule (values -> FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 121
WARNING: reduce/reduce conflict in state 128 resolved using rule (something_s -> ID)
WARNING: rejected rule (something_ex -> ID) in state 128
WARNING: reduce/reduce conflict in state 128 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 128
WARNING: reduce/reduce conflict in state 129 resolved using rule (data_structure -> array_var)
WARNING: rejected rule (something_s -> array_var) in state 129
WARNING: reduce/reduce conflict in state 135 resolved using rule (content -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 135
WARNING: reduce/reduce conflict in state 136 resolved using rule (content -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 136
WARNING: reduce/reduce conflict in state 137 resolved using rule (content -> ID)
WARNING: rejected rule (something_ex -> ID) in state 137
WARNING: reduce/reduce conflict in state 137 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 137
WARNING: reduce/reduce conflict in state 151 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 151
WARNING: reduce/reduce conflict in state 154 resolved using rule (decVarOne -> ID DEQUAL ID)
WARNING: rejected rule (something_ex -> ID) in state 154
WARNING: reduce/reduce conflict in state 154 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 154
WARNING: reduce/reduce conflict in state 156 resolved using rule (decVar -> ID DEQUAL FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 156
WARNING: reduce/reduce conflict in state 162 resolved using rule (decVarOne -> ID DEQUAL INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 162
WARNING: reduce/reduce conflict in state 164 resolved using rule (any -> ID)
WARNING: rejected rule (something_ex -> ID) in state 164
WARNING: reduce/reduce conflict in state 164 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 164
WARNING: reduce/reduce conflict in state 168 resolved using rule (any -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 168
WARNING: reduce/reduce conflict in state 169 resolved using rule (any -> funciones)
WARNING: rejected rule (something_ex -> funciones) in state 169
WARNING: reduce/reduce conflict in state 170 resolved using rule (index_s -> ID)
WARNING: rejected rule (index -> ID) in state 170
WARNING: reduce/reduce conflict in state 170 resolved using rule (index_s -> ID)
WARNING: rejected rule (key -> ID) in state 170
WARNING: reduce/reduce conflict in state 170 resolved using rule (index_s -> ID)
WARNING: rejected rule (something_ex -> ID) in state 170
WARNING: reduce/reduce conflict in state 170 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 170
WARNING: reduce/reduce conflict in state 174 resolved using rule (index_s -> INTEGER)
WARNING: rejected rule (index -> INTEGER) in state 174
WARNING: reduce/reduce conflict in state 174 resolved using rule (values -> INTEGER)
WARNING: rejected rule (index_s -> INTEGER) in state 174
WARNING: reduce/reduce conflict in state 174 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 174
WARNING: reduce/reduce conflict in state 175 resolved using rule (index_s -> expression)
WARNING: rejected rule (index -> expression) in state 175
WARNING: reduce/reduce conflict in state 175 resolved using rule (operations -> expression)
WARNING: rejected rule (index_s -> expression) in state 175
WARNING: reduce/reduce conflict in state 202 resolved using rule (index -> ID)
WARNING: rejected rule (key -> ID) in state 202
WARNING: reduce/reduce conflict in state 202 resolved using rule (index -> ID)
WARNING: rejected rule (something_ex -> ID) in state 202
WARNING: reduce/reduce conflict in state 202 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 202
WARNING: reduce/reduce conflict in state 203 resolved using rule (values -> INTEGER)
WARNING: rejected rule (index -> INTEGER) in state 203
WARNING: reduce/reduce conflict in state 203 resolved using rule (values -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 203
WARNING: reduce/reduce conflict in state 204 resolved using rule (operations -> expression)
WARNING: rejected rule (index -> expression) in state 204
WARNING: reduce/reduce conflict in state 206 resolved using rule (decVar -> VAR ID EQUAL ID)
WARNING: rejected rule (something_ex -> ID) in state 206
WARNING: reduce/reduce conflict in state 206 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 206
WARNING: reduce/reduce conflict in state 207 resolved using rule (decVar -> VAR ID EQUAL INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 207
WARNING: reduce/reduce conflict in state 208 resolved using rule (decVar -> VAR ID EQUAL FLOAT)
WARNING: rejected rule (something_ex -> FLOAT) in state 208
WARNING: reduce/reduce conflict in state 215 resolved using rule (capacity -> ID)
WARNING: rejected rule (something_ex -> ID) in state 215
WARNING: reduce/reduce conflict in state 219 resolved using rule (capacity -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 219
WARNING: reduce/reduce conflict in state 324 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 324
WARNING: reduce/reduce conflict in state 347 resolved using rule (cap -> INTEGER)
WARNING: rejected rule (something_ex -> INTEGER) in state 347
WARNING: reduce/reduce conflict in state 348 resolved using rule (cap -> ID)
WARNING: rejected rule (something_ex -> ID) in state 348
WARNING: reduce/reduce conflict in state 352 resolved using rule (retorno -> ID)
WARNING: rejected rule (something_ex -> ID) in state 352
WARNING: reduce/reduce conflict in state 352 resolved using rule (value -> ID)
WARNING: rejected rule (something_ex -> ID) in state 352
WARNING: reduce/reduce conflict in state 357 resolved using rule (retorno -> data_structure)
WARNING: rejected rule (something_ex -> data_structure) in state 357
WARNING: Rule (map_assignment -> array_var EQUAL something) is never reduced
WARNING: Rule (something_s -> array_var) is never reduced
WARNING: Rule (key -> ID) is never reduced
WARNING: Rule (index -> INTEGER) is never reduced
WARNING: Rule (index_s -> INTEGER) is never reduced
WARNING: Rule (index -> expression) is never reduced
WARNING: Rule (index_s -> expression) is never reduced
