Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    APPEND
    ARRAY
    BYTE
    CAP
    CASE
    COLON
    COMA
    COMMENT
    CONST
    COPY
    DECREASE
    DEQUAL
    ELSE
    EQUAL
    FALSE
    FLOAT
    FUNC
    INCREASE
    INTERFACE
    JOIN
    LCORCHE
    LEN
    MAIN
    MAKE
    MAP
    MOD
    MULTI_COMMENT
    PACKAGE
    POINTER
    RCORCHE
    SCAN
    SWITCH
    TRUE
    VAR

Grammar

Rule 0     S' -> codigo
Rule 1     codigo -> impresion
Rule 2     codigo -> expression
Rule 3     codigo -> cicloFor
Rule 4     codigo -> comparison
Rule 5     codigo -> logic_operation
Rule 6     codigo -> SenIF
Rule 7     codigo -> SenStruct
Rule 8     cicloFor -> FOR LLLAVE codigo RLLAVE
Rule 9     comparison -> value op value
Rule 10    value -> ID
Rule 11    value -> expression
Rule 12    op -> GREATER
Rule 13    op -> SMALLER
Rule 14    op -> GREATER_OR_EQUAL
Rule 15    op -> SMALLER_OR_EQUAL
Rule 16    op -> EQUAL_COMPARE
Rule 17    op -> NOT_EQUAL
Rule 18    logic_operation -> logic_value logic_op logic_value
Rule 19    logic_operation -> negation
Rule 20    logic_value -> negation
Rule 21    logic_value -> comparison
Rule 22    negation -> NOT comparison
Rule 23    negation -> NOT ID
Rule 24    logic_op -> AND
Rule 25    logic_op -> OR
Rule 26    SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
Rule 27    SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE
Rule 28    declaration -> tipo variable
Rule 29    tipo -> INT32
Rule 30    tipo -> INT64
Rule 31    tipo -> FLOAT32
Rule 32    tipo -> FLOAT64
Rule 33    tipo -> STRING
Rule 34    tipo -> BOOL
Rule 35    variable -> ID
Rule 36    impresion -> PRINT LPAREN expression RPAREN
Rule 37    expression -> expression PLUS term
Rule 38    expression -> expression MINUS term
Rule 39    expression -> term
Rule 40    term -> term TIMES factor
Rule 41    term -> term DIVIDE factor
Rule 42    term -> factor
Rule 43    factor -> INTEGER
Rule 44    factor -> ID
Rule 45    factor -> LPAREN expression RPAREN

Terminals, with rules where they appear

AND                  : 24
APPEND               : 
ARRAY                : 
BOOL                 : 34
BYTE                 : 
CAP                  : 
CASE                 : 
COLON                : 
COMA                 : 
COMMENT              : 
CONST                : 
COPY                 : 
DECREASE             : 
DEQUAL               : 
DIVIDE               : 41
ELSE                 : 
EQUAL                : 
EQUAL_COMPARE        : 16
FALSE                : 
FLOAT                : 
FLOAT32              : 31
FLOAT64              : 32
FOR                  : 8
FUNC                 : 
GREATER              : 12
GREATER_OR_EQUAL     : 14
ID                   : 10 23 27 35 44
IF                   : 26
INCREASE             : 
INT32                : 29
INT64                : 30
INTEGER              : 43
INTERFACE            : 
JOIN                 : 
LCORCHE              : 
LEN                  : 
LLLAVE               : 8 26 27
LPAREN               : 26 36 45
MAIN                 : 
MAKE                 : 
MAP                  : 
MINUS                : 38
MOD                  : 
MULTI_COMMENT        : 
NOT                  : 22 23
NOT_EQUAL            : 17
OR                   : 25
PACKAGE              : 
PLUS                 : 37
POINTER              : 
PRINT                : 36
RCORCHE              : 
RLLAVE               : 8 26 27
RPAREN               : 26 36 45
SCAN                 : 
SMALLER              : 13
SMALLER_OR_EQUAL     : 15
STRING               : 33
STRUCT               : 27
SWITCH               : 
TIMES                : 40
TRUE                 : 
TYPE                 : 27
VAR                  : 
error                : 

Nonterminals, with rules where they appear

SenIF                : 6
SenStruct            : 7
cicloFor             : 3
codigo               : 8 26 0
comparison           : 4 21 22 26
declaration          : 27
expression           : 2 11 36 37 38 45
factor               : 40 41 42
impresion            : 1
logic_op             : 18
logic_operation      : 5
logic_value          : 18 18
negation             : 19 20
op                   : 9
term                 : 37 38 39 40 41
tipo                 : 28
value                : 9 9
variable             : 28

Parsing method: LALR

state 0

    (0) S' -> . codigo
    (1) codigo -> . impresion
    (2) codigo -> . expression
    (3) codigo -> . cicloFor
    (4) codigo -> . comparison
    (5) codigo -> . logic_operation
    (6) codigo -> . SenIF
    (7) codigo -> . SenStruct
    (36) impresion -> . PRINT LPAREN expression RPAREN
    (37) expression -> . expression PLUS term
    (38) expression -> . expression MINUS term
    (39) expression -> . term
    (8) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (9) comparison -> . value op value
    (18) logic_operation -> . logic_value logic_op logic_value
    (19) logic_operation -> . negation
    (26) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (27) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (10) value -> . ID
    (11) value -> . expression
    (20) logic_value -> . negation
    (21) logic_value -> . comparison
    (22) negation -> . NOT comparison
    (23) negation -> . NOT ID
    (43) factor -> . INTEGER
    (44) factor -> . ID
    (45) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 9
    FOR             shift and go to state 12
    IF              shift and go to state 16
    TYPE            shift and go to state 17
    ID              shift and go to state 18
    NOT             shift and go to state 20
    INTEGER         shift and go to state 21
    LPAREN          shift and go to state 10

    codigo                         shift and go to state 1
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    SenIF                          shift and go to state 7
    SenStruct                      shift and go to state 8
    term                           shift and go to state 11
    value                          shift and go to state 13
    logic_value                    shift and go to state 14
    negation                       shift and go to state 15
    factor                         shift and go to state 19

state 1

    (0) S' -> codigo .



state 2

    (1) codigo -> impresion .

    $end            reduce using rule 1 (codigo -> impresion .)
    RLLAVE          reduce using rule 1 (codigo -> impresion .)


state 3

    (2) codigo -> expression .
    (37) expression -> expression . PLUS term
    (38) expression -> expression . MINUS term
    (11) value -> expression .

    $end            reduce using rule 2 (codigo -> expression .)
    RLLAVE          reduce using rule 2 (codigo -> expression .)
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23
    GREATER         reduce using rule 11 (value -> expression .)
    SMALLER         reduce using rule 11 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 11 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 11 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 11 (value -> expression .)
    NOT_EQUAL       reduce using rule 11 (value -> expression .)


state 4

    (3) codigo -> cicloFor .

    $end            reduce using rule 3 (codigo -> cicloFor .)
    RLLAVE          reduce using rule 3 (codigo -> cicloFor .)


state 5

    (4) codigo -> comparison .
    (21) logic_value -> comparison .

    $end            reduce using rule 4 (codigo -> comparison .)
    RLLAVE          reduce using rule 4 (codigo -> comparison .)
    AND             reduce using rule 21 (logic_value -> comparison .)
    OR              reduce using rule 21 (logic_value -> comparison .)


state 6

    (5) codigo -> logic_operation .

    $end            reduce using rule 5 (codigo -> logic_operation .)
    RLLAVE          reduce using rule 5 (codigo -> logic_operation .)


state 7

    (6) codigo -> SenIF .

    $end            reduce using rule 6 (codigo -> SenIF .)
    RLLAVE          reduce using rule 6 (codigo -> SenIF .)


state 8

    (7) codigo -> SenStruct .

    $end            reduce using rule 7 (codigo -> SenStruct .)
    RLLAVE          reduce using rule 7 (codigo -> SenStruct .)


state 9

    (36) impresion -> PRINT . LPAREN expression RPAREN

    LPAREN          shift and go to state 24


state 10

    (45) factor -> LPAREN . expression RPAREN
    (37) expression -> . expression PLUS term
    (38) expression -> . expression MINUS term
    (39) expression -> . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . ID
    (45) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    ID              shift and go to state 26
    LPAREN          shift and go to state 10

    expression                     shift and go to state 25
    term                           shift and go to state 11
    factor                         shift and go to state 19

state 11

    (39) expression -> term .
    (40) term -> term . TIMES factor
    (41) term -> term . DIVIDE factor

    PLUS            reduce using rule 39 (expression -> term .)
    MINUS           reduce using rule 39 (expression -> term .)
    $end            reduce using rule 39 (expression -> term .)
    GREATER         reduce using rule 39 (expression -> term .)
    SMALLER         reduce using rule 39 (expression -> term .)
    GREATER_OR_EQUAL reduce using rule 39 (expression -> term .)
    SMALLER_OR_EQUAL reduce using rule 39 (expression -> term .)
    EQUAL_COMPARE   reduce using rule 39 (expression -> term .)
    NOT_EQUAL       reduce using rule 39 (expression -> term .)
    RPAREN          reduce using rule 39 (expression -> term .)
    RLLAVE          reduce using rule 39 (expression -> term .)
    AND             reduce using rule 39 (expression -> term .)
    OR              reduce using rule 39 (expression -> term .)
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28


state 12

    (8) cicloFor -> FOR . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 29


state 13

    (9) comparison -> value . op value
    (12) op -> . GREATER
    (13) op -> . SMALLER
    (14) op -> . GREATER_OR_EQUAL
    (15) op -> . SMALLER_OR_EQUAL
    (16) op -> . EQUAL_COMPARE
    (17) op -> . NOT_EQUAL

    GREATER         shift and go to state 31
    SMALLER         shift and go to state 32
    GREATER_OR_EQUAL shift and go to state 33
    SMALLER_OR_EQUAL shift and go to state 34
    EQUAL_COMPARE   shift and go to state 35
    NOT_EQUAL       shift and go to state 36

    op                             shift and go to state 30

state 14

    (18) logic_operation -> logic_value . logic_op logic_value
    (24) logic_op -> . AND
    (25) logic_op -> . OR

    AND             shift and go to state 38
    OR              shift and go to state 39

    logic_op                       shift and go to state 37

state 15

    (19) logic_operation -> negation .
    (20) logic_value -> negation .

    $end            reduce using rule 19 (logic_operation -> negation .)
    RLLAVE          reduce using rule 19 (logic_operation -> negation .)
    AND             reduce using rule 20 (logic_value -> negation .)
    OR              reduce using rule 20 (logic_value -> negation .)


state 16

    (26) SenIF -> IF . LPAREN comparison RPAREN LLLAVE codigo RLLAVE

    LPAREN          shift and go to state 40


state 17

    (27) SenStruct -> TYPE . ID STRUCT LLLAVE declaration RLLAVE

    ID              shift and go to state 41


state 18

    (10) value -> ID .
    (44) factor -> ID .

  ! reduce/reduce conflict for $end resolved using rule 10 (value -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 10 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 10 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 10 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 10 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 10 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 10 (value -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 10 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 10 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 10 (value -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 10 (value -> ID .)
    GREATER         reduce using rule 10 (value -> ID .)
    SMALLER         reduce using rule 10 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 10 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 10 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 10 (value -> ID .)
    NOT_EQUAL       reduce using rule 10 (value -> ID .)
    $end            reduce using rule 10 (value -> ID .)
    AND             reduce using rule 10 (value -> ID .)
    OR              reduce using rule 10 (value -> ID .)
    RLLAVE          reduce using rule 10 (value -> ID .)
    RPAREN          reduce using rule 10 (value -> ID .)
    TIMES           reduce using rule 44 (factor -> ID .)
    DIVIDE          reduce using rule 44 (factor -> ID .)
    PLUS            reduce using rule 44 (factor -> ID .)
    MINUS           reduce using rule 44 (factor -> ID .)

  ! $end            [ reduce using rule 44 (factor -> ID .) ]
  ! GREATER         [ reduce using rule 44 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 44 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 44 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 44 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 44 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 44 (factor -> ID .) ]
  ! RLLAVE          [ reduce using rule 44 (factor -> ID .) ]
  ! AND             [ reduce using rule 44 (factor -> ID .) ]
  ! OR              [ reduce using rule 44 (factor -> ID .) ]
  ! RPAREN          [ reduce using rule 44 (factor -> ID .) ]


state 19

    (42) term -> factor .

    TIMES           reduce using rule 42 (term -> factor .)
    DIVIDE          reduce using rule 42 (term -> factor .)
    PLUS            reduce using rule 42 (term -> factor .)
    MINUS           reduce using rule 42 (term -> factor .)
    $end            reduce using rule 42 (term -> factor .)
    GREATER         reduce using rule 42 (term -> factor .)
    SMALLER         reduce using rule 42 (term -> factor .)
    GREATER_OR_EQUAL reduce using rule 42 (term -> factor .)
    SMALLER_OR_EQUAL reduce using rule 42 (term -> factor .)
    EQUAL_COMPARE   reduce using rule 42 (term -> factor .)
    NOT_EQUAL       reduce using rule 42 (term -> factor .)
    RPAREN          reduce using rule 42 (term -> factor .)
    RLLAVE          reduce using rule 42 (term -> factor .)
    AND             reduce using rule 42 (term -> factor .)
    OR              reduce using rule 42 (term -> factor .)


state 20

    (22) negation -> NOT . comparison
    (23) negation -> NOT . ID
    (9) comparison -> . value op value
    (10) value -> . ID
    (11) value -> . expression
    (37) expression -> . expression PLUS term
    (38) expression -> . expression MINUS term
    (39) expression -> . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . ID
    (45) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 43
    INTEGER         shift and go to state 21
    LPAREN          shift and go to state 10

    comparison                     shift and go to state 42
    value                          shift and go to state 13
    expression                     shift and go to state 44
    term                           shift and go to state 11
    factor                         shift and go to state 19

state 21

    (43) factor -> INTEGER .

    TIMES           reduce using rule 43 (factor -> INTEGER .)
    DIVIDE          reduce using rule 43 (factor -> INTEGER .)
    PLUS            reduce using rule 43 (factor -> INTEGER .)
    MINUS           reduce using rule 43 (factor -> INTEGER .)
    $end            reduce using rule 43 (factor -> INTEGER .)
    GREATER         reduce using rule 43 (factor -> INTEGER .)
    SMALLER         reduce using rule 43 (factor -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 43 (factor -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 43 (factor -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 43 (factor -> INTEGER .)
    NOT_EQUAL       reduce using rule 43 (factor -> INTEGER .)
    RPAREN          reduce using rule 43 (factor -> INTEGER .)
    RLLAVE          reduce using rule 43 (factor -> INTEGER .)
    AND             reduce using rule 43 (factor -> INTEGER .)
    OR              reduce using rule 43 (factor -> INTEGER .)


state 22

    (37) expression -> expression PLUS . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . ID
    (45) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    ID              shift and go to state 26
    LPAREN          shift and go to state 10

    term                           shift and go to state 45
    factor                         shift and go to state 19

state 23

    (38) expression -> expression MINUS . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . ID
    (45) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    ID              shift and go to state 26
    LPAREN          shift and go to state 10

    term                           shift and go to state 46
    factor                         shift and go to state 19

state 24

    (36) impresion -> PRINT LPAREN . expression RPAREN
    (37) expression -> . expression PLUS term
    (38) expression -> . expression MINUS term
    (39) expression -> . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . ID
    (45) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    ID              shift and go to state 26
    LPAREN          shift and go to state 10

    expression                     shift and go to state 47
    term                           shift and go to state 11
    factor                         shift and go to state 19

state 25

    (45) factor -> LPAREN expression . RPAREN
    (37) expression -> expression . PLUS term
    (38) expression -> expression . MINUS term

    RPAREN          shift and go to state 48
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23


state 26

    (44) factor -> ID .

    TIMES           reduce using rule 44 (factor -> ID .)
    DIVIDE          reduce using rule 44 (factor -> ID .)
    RPAREN          reduce using rule 44 (factor -> ID .)
    PLUS            reduce using rule 44 (factor -> ID .)
    MINUS           reduce using rule 44 (factor -> ID .)
    $end            reduce using rule 44 (factor -> ID .)
    GREATER         reduce using rule 44 (factor -> ID .)
    SMALLER         reduce using rule 44 (factor -> ID .)
    GREATER_OR_EQUAL reduce using rule 44 (factor -> ID .)
    SMALLER_OR_EQUAL reduce using rule 44 (factor -> ID .)
    EQUAL_COMPARE   reduce using rule 44 (factor -> ID .)
    NOT_EQUAL       reduce using rule 44 (factor -> ID .)
    RLLAVE          reduce using rule 44 (factor -> ID .)
    AND             reduce using rule 44 (factor -> ID .)
    OR              reduce using rule 44 (factor -> ID .)


state 27

    (40) term -> term TIMES . factor
    (43) factor -> . INTEGER
    (44) factor -> . ID
    (45) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    ID              shift and go to state 26
    LPAREN          shift and go to state 10

    factor                         shift and go to state 49

state 28

    (41) term -> term DIVIDE . factor
    (43) factor -> . INTEGER
    (44) factor -> . ID
    (45) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 21
    ID              shift and go to state 26
    LPAREN          shift and go to state 10

    factor                         shift and go to state 50

state 29

    (8) cicloFor -> FOR LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion
    (2) codigo -> . expression
    (3) codigo -> . cicloFor
    (4) codigo -> . comparison
    (5) codigo -> . logic_operation
    (6) codigo -> . SenIF
    (7) codigo -> . SenStruct
    (36) impresion -> . PRINT LPAREN expression RPAREN
    (37) expression -> . expression PLUS term
    (38) expression -> . expression MINUS term
    (39) expression -> . term
    (8) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (9) comparison -> . value op value
    (18) logic_operation -> . logic_value logic_op logic_value
    (19) logic_operation -> . negation
    (26) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (27) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (10) value -> . ID
    (11) value -> . expression
    (20) logic_value -> . negation
    (21) logic_value -> . comparison
    (22) negation -> . NOT comparison
    (23) negation -> . NOT ID
    (43) factor -> . INTEGER
    (44) factor -> . ID
    (45) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 9
    FOR             shift and go to state 12
    IF              shift and go to state 16
    TYPE            shift and go to state 17
    ID              shift and go to state 18
    NOT             shift and go to state 20
    INTEGER         shift and go to state 21
    LPAREN          shift and go to state 10

    codigo                         shift and go to state 51
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    SenIF                          shift and go to state 7
    SenStruct                      shift and go to state 8
    term                           shift and go to state 11
    value                          shift and go to state 13
    logic_value                    shift and go to state 14
    negation                       shift and go to state 15
    factor                         shift and go to state 19

state 30

    (9) comparison -> value op . value
    (10) value -> . ID
    (11) value -> . expression
    (37) expression -> . expression PLUS term
    (38) expression -> . expression MINUS term
    (39) expression -> . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . ID
    (45) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 18
    INTEGER         shift and go to state 21
    LPAREN          shift and go to state 10

    value                          shift and go to state 52
    expression                     shift and go to state 44
    term                           shift and go to state 11
    factor                         shift and go to state 19

state 31

    (12) op -> GREATER .

    ID              reduce using rule 12 (op -> GREATER .)
    INTEGER         reduce using rule 12 (op -> GREATER .)
    LPAREN          reduce using rule 12 (op -> GREATER .)


state 32

    (13) op -> SMALLER .

    ID              reduce using rule 13 (op -> SMALLER .)
    INTEGER         reduce using rule 13 (op -> SMALLER .)
    LPAREN          reduce using rule 13 (op -> SMALLER .)


state 33

    (14) op -> GREATER_OR_EQUAL .

    ID              reduce using rule 14 (op -> GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 14 (op -> GREATER_OR_EQUAL .)
    LPAREN          reduce using rule 14 (op -> GREATER_OR_EQUAL .)


state 34

    (15) op -> SMALLER_OR_EQUAL .

    ID              reduce using rule 15 (op -> SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 15 (op -> SMALLER_OR_EQUAL .)
    LPAREN          reduce using rule 15 (op -> SMALLER_OR_EQUAL .)


state 35

    (16) op -> EQUAL_COMPARE .

    ID              reduce using rule 16 (op -> EQUAL_COMPARE .)
    INTEGER         reduce using rule 16 (op -> EQUAL_COMPARE .)
    LPAREN          reduce using rule 16 (op -> EQUAL_COMPARE .)


state 36

    (17) op -> NOT_EQUAL .

    ID              reduce using rule 17 (op -> NOT_EQUAL .)
    INTEGER         reduce using rule 17 (op -> NOT_EQUAL .)
    LPAREN          reduce using rule 17 (op -> NOT_EQUAL .)


state 37

    (18) logic_operation -> logic_value logic_op . logic_value
    (20) logic_value -> . negation
    (21) logic_value -> . comparison
    (22) negation -> . NOT comparison
    (23) negation -> . NOT ID
    (9) comparison -> . value op value
    (10) value -> . ID
    (11) value -> . expression
    (37) expression -> . expression PLUS term
    (38) expression -> . expression MINUS term
    (39) expression -> . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . ID
    (45) factor -> . LPAREN expression RPAREN

    NOT             shift and go to state 20
    ID              shift and go to state 18
    INTEGER         shift and go to state 21
    LPAREN          shift and go to state 10

    logic_value                    shift and go to state 53
    negation                       shift and go to state 54
    comparison                     shift and go to state 55
    value                          shift and go to state 13
    expression                     shift and go to state 44
    term                           shift and go to state 11
    factor                         shift and go to state 19

state 38

    (24) logic_op -> AND .

    NOT             reduce using rule 24 (logic_op -> AND .)
    ID              reduce using rule 24 (logic_op -> AND .)
    INTEGER         reduce using rule 24 (logic_op -> AND .)
    LPAREN          reduce using rule 24 (logic_op -> AND .)


state 39

    (25) logic_op -> OR .

    NOT             reduce using rule 25 (logic_op -> OR .)
    ID              reduce using rule 25 (logic_op -> OR .)
    INTEGER         reduce using rule 25 (logic_op -> OR .)
    LPAREN          reduce using rule 25 (logic_op -> OR .)


state 40

    (26) SenIF -> IF LPAREN . comparison RPAREN LLLAVE codigo RLLAVE
    (9) comparison -> . value op value
    (10) value -> . ID
    (11) value -> . expression
    (37) expression -> . expression PLUS term
    (38) expression -> . expression MINUS term
    (39) expression -> . term
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (43) factor -> . INTEGER
    (44) factor -> . ID
    (45) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 18
    INTEGER         shift and go to state 21
    LPAREN          shift and go to state 10

    comparison                     shift and go to state 56
    value                          shift and go to state 13
    expression                     shift and go to state 44
    term                           shift and go to state 11
    factor                         shift and go to state 19

state 41

    (27) SenStruct -> TYPE ID . STRUCT LLLAVE declaration RLLAVE

    STRUCT          shift and go to state 57


state 42

    (22) negation -> NOT comparison .

    $end            reduce using rule 22 (negation -> NOT comparison .)
    AND             reduce using rule 22 (negation -> NOT comparison .)
    OR              reduce using rule 22 (negation -> NOT comparison .)
    RLLAVE          reduce using rule 22 (negation -> NOT comparison .)


state 43

    (23) negation -> NOT ID .
    (10) value -> ID .
    (44) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 10 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 10 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 10 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 10 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 10 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 10 (value -> ID .)
    $end            reduce using rule 23 (negation -> NOT ID .)
    AND             reduce using rule 23 (negation -> NOT ID .)
    OR              reduce using rule 23 (negation -> NOT ID .)
    RLLAVE          reduce using rule 23 (negation -> NOT ID .)
    GREATER         reduce using rule 10 (value -> ID .)
    SMALLER         reduce using rule 10 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 10 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 10 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 10 (value -> ID .)
    NOT_EQUAL       reduce using rule 10 (value -> ID .)
    TIMES           reduce using rule 44 (factor -> ID .)
    DIVIDE          reduce using rule 44 (factor -> ID .)
    PLUS            reduce using rule 44 (factor -> ID .)
    MINUS           reduce using rule 44 (factor -> ID .)

  ! GREATER         [ reduce using rule 44 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 44 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 44 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 44 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 44 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 44 (factor -> ID .) ]


state 44

    (11) value -> expression .
    (37) expression -> expression . PLUS term
    (38) expression -> expression . MINUS term

    GREATER         reduce using rule 11 (value -> expression .)
    SMALLER         reduce using rule 11 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 11 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 11 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 11 (value -> expression .)
    NOT_EQUAL       reduce using rule 11 (value -> expression .)
    $end            reduce using rule 11 (value -> expression .)
    AND             reduce using rule 11 (value -> expression .)
    OR              reduce using rule 11 (value -> expression .)
    RLLAVE          reduce using rule 11 (value -> expression .)
    RPAREN          reduce using rule 11 (value -> expression .)
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23


state 45

    (37) expression -> expression PLUS term .
    (40) term -> term . TIMES factor
    (41) term -> term . DIVIDE factor

    PLUS            reduce using rule 37 (expression -> expression PLUS term .)
    MINUS           reduce using rule 37 (expression -> expression PLUS term .)
    $end            reduce using rule 37 (expression -> expression PLUS term .)
    GREATER         reduce using rule 37 (expression -> expression PLUS term .)
    SMALLER         reduce using rule 37 (expression -> expression PLUS term .)
    GREATER_OR_EQUAL reduce using rule 37 (expression -> expression PLUS term .)
    SMALLER_OR_EQUAL reduce using rule 37 (expression -> expression PLUS term .)
    EQUAL_COMPARE   reduce using rule 37 (expression -> expression PLUS term .)
    NOT_EQUAL       reduce using rule 37 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 37 (expression -> expression PLUS term .)
    RLLAVE          reduce using rule 37 (expression -> expression PLUS term .)
    AND             reduce using rule 37 (expression -> expression PLUS term .)
    OR              reduce using rule 37 (expression -> expression PLUS term .)
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28


state 46

    (38) expression -> expression MINUS term .
    (40) term -> term . TIMES factor
    (41) term -> term . DIVIDE factor

    PLUS            reduce using rule 38 (expression -> expression MINUS term .)
    MINUS           reduce using rule 38 (expression -> expression MINUS term .)
    $end            reduce using rule 38 (expression -> expression MINUS term .)
    GREATER         reduce using rule 38 (expression -> expression MINUS term .)
    SMALLER         reduce using rule 38 (expression -> expression MINUS term .)
    GREATER_OR_EQUAL reduce using rule 38 (expression -> expression MINUS term .)
    SMALLER_OR_EQUAL reduce using rule 38 (expression -> expression MINUS term .)
    EQUAL_COMPARE   reduce using rule 38 (expression -> expression MINUS term .)
    NOT_EQUAL       reduce using rule 38 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 38 (expression -> expression MINUS term .)
    RLLAVE          reduce using rule 38 (expression -> expression MINUS term .)
    AND             reduce using rule 38 (expression -> expression MINUS term .)
    OR              reduce using rule 38 (expression -> expression MINUS term .)
    TIMES           shift and go to state 27
    DIVIDE          shift and go to state 28


state 47

    (36) impresion -> PRINT LPAREN expression . RPAREN
    (37) expression -> expression . PLUS term
    (38) expression -> expression . MINUS term

    RPAREN          shift and go to state 58
    PLUS            shift and go to state 22
    MINUS           shift and go to state 23


state 48

    (45) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 45 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 45 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 45 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 45 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 45 (factor -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 45 (factor -> LPAREN expression RPAREN .)
    SMALLER         reduce using rule 45 (factor -> LPAREN expression RPAREN .)
    GREATER_OR_EQUAL reduce using rule 45 (factor -> LPAREN expression RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 45 (factor -> LPAREN expression RPAREN .)
    EQUAL_COMPARE   reduce using rule 45 (factor -> LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 45 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 45 (factor -> LPAREN expression RPAREN .)
    RLLAVE          reduce using rule 45 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 45 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 45 (factor -> LPAREN expression RPAREN .)


state 49

    (40) term -> term TIMES factor .

    TIMES           reduce using rule 40 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 40 (term -> term TIMES factor .)
    PLUS            reduce using rule 40 (term -> term TIMES factor .)
    MINUS           reduce using rule 40 (term -> term TIMES factor .)
    $end            reduce using rule 40 (term -> term TIMES factor .)
    GREATER         reduce using rule 40 (term -> term TIMES factor .)
    SMALLER         reduce using rule 40 (term -> term TIMES factor .)
    GREATER_OR_EQUAL reduce using rule 40 (term -> term TIMES factor .)
    SMALLER_OR_EQUAL reduce using rule 40 (term -> term TIMES factor .)
    EQUAL_COMPARE   reduce using rule 40 (term -> term TIMES factor .)
    NOT_EQUAL       reduce using rule 40 (term -> term TIMES factor .)
    RPAREN          reduce using rule 40 (term -> term TIMES factor .)
    RLLAVE          reduce using rule 40 (term -> term TIMES factor .)
    AND             reduce using rule 40 (term -> term TIMES factor .)
    OR              reduce using rule 40 (term -> term TIMES factor .)


state 50

    (41) term -> term DIVIDE factor .

    TIMES           reduce using rule 41 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 41 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 41 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 41 (term -> term DIVIDE factor .)
    $end            reduce using rule 41 (term -> term DIVIDE factor .)
    GREATER         reduce using rule 41 (term -> term DIVIDE factor .)
    SMALLER         reduce using rule 41 (term -> term DIVIDE factor .)
    GREATER_OR_EQUAL reduce using rule 41 (term -> term DIVIDE factor .)
    SMALLER_OR_EQUAL reduce using rule 41 (term -> term DIVIDE factor .)
    EQUAL_COMPARE   reduce using rule 41 (term -> term DIVIDE factor .)
    NOT_EQUAL       reduce using rule 41 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 41 (term -> term DIVIDE factor .)
    RLLAVE          reduce using rule 41 (term -> term DIVIDE factor .)
    AND             reduce using rule 41 (term -> term DIVIDE factor .)
    OR              reduce using rule 41 (term -> term DIVIDE factor .)


state 51

    (8) cicloFor -> FOR LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 59


state 52

    (9) comparison -> value op value .

    $end            reduce using rule 9 (comparison -> value op value .)
    AND             reduce using rule 9 (comparison -> value op value .)
    OR              reduce using rule 9 (comparison -> value op value .)
    RLLAVE          reduce using rule 9 (comparison -> value op value .)
    RPAREN          reduce using rule 9 (comparison -> value op value .)


state 53

    (18) logic_operation -> logic_value logic_op logic_value .

    $end            reduce using rule 18 (logic_operation -> logic_value logic_op logic_value .)
    RLLAVE          reduce using rule 18 (logic_operation -> logic_value logic_op logic_value .)


state 54

    (20) logic_value -> negation .

    $end            reduce using rule 20 (logic_value -> negation .)
    RLLAVE          reduce using rule 20 (logic_value -> negation .)


state 55

    (21) logic_value -> comparison .

    $end            reduce using rule 21 (logic_value -> comparison .)
    RLLAVE          reduce using rule 21 (logic_value -> comparison .)


state 56

    (26) SenIF -> IF LPAREN comparison . RPAREN LLLAVE codigo RLLAVE

    RPAREN          shift and go to state 60


state 57

    (27) SenStruct -> TYPE ID STRUCT . LLLAVE declaration RLLAVE

    LLLAVE          shift and go to state 61


state 58

    (36) impresion -> PRINT LPAREN expression RPAREN .

    $end            reduce using rule 36 (impresion -> PRINT LPAREN expression RPAREN .)
    RLLAVE          reduce using rule 36 (impresion -> PRINT LPAREN expression RPAREN .)


state 59

    (8) cicloFor -> FOR LLLAVE codigo RLLAVE .

    $end            reduce using rule 8 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 8 (cicloFor -> FOR LLLAVE codigo RLLAVE .)


state 60

    (26) SenIF -> IF LPAREN comparison RPAREN . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 62


state 61

    (27) SenStruct -> TYPE ID STRUCT LLLAVE . declaration RLLAVE
    (28) declaration -> . tipo variable
    (29) tipo -> . INT32
    (30) tipo -> . INT64
    (31) tipo -> . FLOAT32
    (32) tipo -> . FLOAT64
    (33) tipo -> . STRING
    (34) tipo -> . BOOL

    INT32           shift and go to state 65
    INT64           shift and go to state 66
    FLOAT32         shift and go to state 67
    FLOAT64         shift and go to state 68
    STRING          shift and go to state 69
    BOOL            shift and go to state 70

    declaration                    shift and go to state 63
    tipo                           shift and go to state 64

state 62

    (26) SenIF -> IF LPAREN comparison RPAREN LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion
    (2) codigo -> . expression
    (3) codigo -> . cicloFor
    (4) codigo -> . comparison
    (5) codigo -> . logic_operation
    (6) codigo -> . SenIF
    (7) codigo -> . SenStruct
    (36) impresion -> . PRINT LPAREN expression RPAREN
    (37) expression -> . expression PLUS term
    (38) expression -> . expression MINUS term
    (39) expression -> . term
    (8) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (9) comparison -> . value op value
    (18) logic_operation -> . logic_value logic_op logic_value
    (19) logic_operation -> . negation
    (26) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (27) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (40) term -> . term TIMES factor
    (41) term -> . term DIVIDE factor
    (42) term -> . factor
    (10) value -> . ID
    (11) value -> . expression
    (20) logic_value -> . negation
    (21) logic_value -> . comparison
    (22) negation -> . NOT comparison
    (23) negation -> . NOT ID
    (43) factor -> . INTEGER
    (44) factor -> . ID
    (45) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 9
    FOR             shift and go to state 12
    IF              shift and go to state 16
    TYPE            shift and go to state 17
    ID              shift and go to state 18
    NOT             shift and go to state 20
    INTEGER         shift and go to state 21
    LPAREN          shift and go to state 10

    comparison                     shift and go to state 5
    codigo                         shift and go to state 71
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    logic_operation                shift and go to state 6
    SenIF                          shift and go to state 7
    SenStruct                      shift and go to state 8
    term                           shift and go to state 11
    value                          shift and go to state 13
    logic_value                    shift and go to state 14
    negation                       shift and go to state 15
    factor                         shift and go to state 19

state 63

    (27) SenStruct -> TYPE ID STRUCT LLLAVE declaration . RLLAVE

    RLLAVE          shift and go to state 72


state 64

    (28) declaration -> tipo . variable
    (35) variable -> . ID

    ID              shift and go to state 74

    variable                       shift and go to state 73

state 65

    (29) tipo -> INT32 .

    ID              reduce using rule 29 (tipo -> INT32 .)


state 66

    (30) tipo -> INT64 .

    ID              reduce using rule 30 (tipo -> INT64 .)


state 67

    (31) tipo -> FLOAT32 .

    ID              reduce using rule 31 (tipo -> FLOAT32 .)


state 68

    (32) tipo -> FLOAT64 .

    ID              reduce using rule 32 (tipo -> FLOAT64 .)


state 69

    (33) tipo -> STRING .

    ID              reduce using rule 33 (tipo -> STRING .)


state 70

    (34) tipo -> BOOL .

    ID              reduce using rule 34 (tipo -> BOOL .)


state 71

    (26) SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 75


state 72

    (27) SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .

    $end            reduce using rule 27 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RLLAVE          reduce using rule 27 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)


state 73

    (28) declaration -> tipo variable .

    RLLAVE          reduce using rule 28 (declaration -> tipo variable .)


state 74

    (35) variable -> ID .

    RLLAVE          reduce using rule 35 (variable -> ID .)


state 75

    (26) SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .

    $end            reduce using rule 26 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 26 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 18 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 18
WARNING: reduce/reduce conflict in state 43 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 43
