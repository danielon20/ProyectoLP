Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARRAY
    CAP
    COMMENT
    CONST
    ELSE
    INTERFACE
    JOIN
    MAIN
    MAP
    MOD
    MULTI_COMMENT
    PACKAGE
    POINTER
    SCAN

Grammar

Rule 0     S' -> codigo
Rule 1     codigo -> impresion COLON
Rule 2     codigo -> impresion
Rule 3     codigo -> expression COLON
Rule 4     codigo -> expression
Rule 5     codigo -> cicloFor
Rule 6     codigo -> comparison
Rule 7     codigo -> logic_operation
Rule 8     codigo -> decVar COLON
Rule 9     codigo -> decVar
Rule 10    codigo -> funciones
Rule 11    codigo -> funciones COLON
Rule 12    codigo -> SenIF
Rule 13    codigo -> SenStruct
Rule 14    codigo -> switch_statement
Rule 15    codigo -> array_declaration COLON
Rule 16    codigo -> array_declaration
Rule 17    codigo -> array_var COLON
Rule 18    codigo -> array_var
Rule 19    codigo -> array_assignment COLON
Rule 20    codigo -> array_assignment
Rule 21    codigo -> map_declaration COLON
Rule 22    codigo -> map_declaration
Rule 23    codigo -> map_assignment COLON
Rule 24    codigo -> map_assignment
Rule 25    codigo -> func_declaration
Rule 26    values -> STRING
Rule 27    values -> INTEGER
Rule 28    values -> FLOAT
Rule 29    values -> TRUE
Rule 30    values -> FALSE
Rule 31    data_types -> INT32
Rule 32    data_types -> INT64
Rule 33    data_types -> FLOAT32
Rule 34    data_types -> FLOAT64
Rule 35    data_types -> BYTE
Rule 36    data_types -> WINT
Rule 37    data_types -> WFLOAT
Rule 38    data_types -> WSTRING
Rule 39    data_types -> BOOL
Rule 40    operations -> expression
Rule 41    operations -> comparison
Rule 42    operations -> logic_operation
Rule 43    data_structure -> array_var
Rule 44    data_structure -> map_var
Rule 45    arr_content -> LLLAVE items COMA more_items RLLAVE
Rule 46    arr_content -> LLLAVE items RLLAVE
Rule 47    more_items -> items COMA more_items
Rule 48    more_items -> items
Rule 49    items -> values
Rule 50    items -> operations
Rule 51    something -> ID
Rule 52    something -> data_structure
Rule 53    something -> values
Rule 54    something -> operations
Rule 55    cicloFor -> FOR LLLAVE codigo RLLAVE
Rule 56    cicloFor -> FOR comparison LLLAVE codigo RLLAVE
Rule 57    cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE
Rule 58    cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
Rule 59    incre -> ID INCREASE
Rule 60    incre -> ID DECREASE
Rule 61    decVar -> decVarOne
Rule 62    decVar -> VAR ID EQUAL INTEGER
Rule 63    decVar -> VAR ID EQUAL ID
Rule 64    decVar -> VAR ID EQUAL FLOAT
Rule 65    decVar -> VAR ID EQUAL expression
Rule 66    decVar -> VAR ID EQUAL logic_operation
Rule 67    decVar -> VAR ID EQUAL comparison
Rule 68    decVar -> sliceC
Rule 69    decVar -> VAR ID EQUAL STRING
Rule 70    decVar -> ID DEQUAL STRING
Rule 71    decVar -> ID DEQUAL FLOAT
Rule 72    decVar -> ID DEQUAL expression
Rule 73    decVar -> ID DEQUAL logic_operation
Rule 74    decVar -> ID DEQUAL comparison
Rule 75    sliceC -> VAR ID LCORCHE RCORCHE data_types
Rule 76    sliceC -> ID DEQUAL funM
Rule 77    sliceC -> ID DEQUAL LCORCHE RCORCHE data_types arr_content
Rule 78    funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
Rule 79    funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
Rule 80    cap -> INTEGER
Rule 81    cap -> ID
Rule 82    cap -> expression
Rule 83    funciones -> APPEND LPAREN ID COMA values RPAREN
Rule 84    funciones -> APPEND LPAREN ID COMA ID RPAREN
Rule 85    funciones -> LEN LPAREN ID RPAREN
Rule 86    funciones -> COPY LPAREN ID COMA ID RPAREN
Rule 87    funciones -> DELETE LPAREN ID COMA ID RPAREN
Rule 88    decVarOne -> ID DEQUAL ID
Rule 89    decVarOne -> ID DEQUAL INTEGER
Rule 90    SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
Rule 91    SenIF -> IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
Rule 92    SenIF -> IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
Rule 93    SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE
Rule 94    declaration -> variable data_types
Rule 95    declaration -> declaration variable data_types
Rule 96    variable -> ID
Rule 97    comparison -> value op value
Rule 98    value -> ID
Rule 99    value -> expression
Rule 100   op -> GREATER
Rule 101   op -> SMALLER
Rule 102   op -> GREATER_OR_EQUAL
Rule 103   op -> SMALLER_OR_EQUAL
Rule 104   op -> EQUAL_COMPARE
Rule 105   op -> NOT_EQUAL
Rule 106   logic_operation -> logic_value logic_op logic_value
Rule 107   logic_operation -> negation
Rule 108   logic_value -> negation
Rule 109   logic_value -> comparison
Rule 110   logic_value -> ID
Rule 111   negation -> NOT comparison
Rule 112   negation -> NOT ID
Rule 113   logic_op -> AND
Rule 114   logic_op -> OR
Rule 115   switch_statement -> SWITCH ID LLLAVE cases RLLAVE
Rule 116   cases -> CASE values POINTS codigo
Rule 117   cases -> CASE values POINTS codigo more
Rule 118   more -> cases
Rule 119   more -> DEFAULT POINTS codigo
Rule 120   array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types
Rule 121   array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
Rule 122   capacity -> INTEGER
Rule 123   capacity -> ID
Rule 124   capacity -> expression
Rule 125   array_var -> ID LCORCHE index RCORCHE
Rule 126   index -> ID
Rule 127   index -> INTEGER
Rule 128   index -> expression
Rule 129   array_assignment -> array_var EQUAL something
Rule 130   map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types
Rule 131   map_var -> ID LCORCHE key RCORCHE
Rule 132   key -> ID
Rule 133   key -> values
Rule 134   key -> operations
Rule 135   map_assignment -> array_var EQUAL something
Rule 136   func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
Rule 137   func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
Rule 138   return_value -> retorno COLON
Rule 139   return_value -> retorno
Rule 140   retorno -> ID
Rule 141   retorno -> values
Rule 142   retorno -> operations
Rule 143   retorno -> data_structure
Rule 144   params -> ID data_types
Rule 145   params -> more_params
Rule 146   more_params -> ID data_types COMA params
Rule 147   impresion -> PRINT LPAREN expression RPAREN
Rule 148   expression -> expression PLUS term
Rule 149   expression -> expression MINUS term
Rule 150   expression -> term
Rule 151   term -> term TIMES factor
Rule 152   term -> term DIVIDE factor
Rule 153   term -> factor
Rule 154   factor -> INTEGER
Rule 155   factor -> ID
Rule 156   factor -> LPAREN expression RPAREN

Terminals, with rules where they appear

AND                  : 113
APPEND               : 83 84
ARRAY                : 
BOOL                 : 39
BYTE                 : 35
CAP                  : 
CASE                 : 116 117
COLON                : 1 3 8 11 15 17 19 21 23 58 58 138
COMA                 : 45 47 78 79 79 83 84 86 87 146
COMMENT              : 
CONST                : 
COPY                 : 86
DECREASE             : 60
DEFAULT              : 119
DELETE               : 87
DEQUAL               : 70 71 72 73 74 76 77 88 89
DIVIDE               : 152
ELSE                 : 
EQUAL                : 62 63 64 65 66 67 69 121 129 135
EQUAL_COMPARE        : 104
FALSE                : 30 92
FLOAT                : 28 64 71
FLOAT32              : 33
FLOAT64              : 34
FOR                  : 55 56 57 58
FUNC                 : 136 137
GREATER              : 100
GREATER_OR_EQUAL     : 102
ID                   : 51 59 60 62 63 63 64 65 66 67 69 70 71 72 73 74 75 76 77 81 83 84 84 85 86 86 87 87 88 88 89 93 96 98 110 112 115 120 121 123 125 126 130 131 132 136 137 140 144 146 155
IF                   : 90 91 92
INCREASE             : 59
INT32                : 31
INT64                : 32
INTEGER              : 27 62 80 89 122 127 154
INTERFACE            : 
JOIN                 : 
LCORCHE              : 75 77 78 79 120 121 125 130 131
LEN                  : 85
LLLAVE               : 45 46 55 56 57 58 90 91 92 93 115 136 137
LPAREN               : 78 79 83 84 85 86 87 90 91 92 136 137 147 156
MAIN                 : 
MAKE                 : 78 79
MAP                  : 
MINUS                : 149
MOD                  : 
MULTI_COMMENT        : 
NOT                  : 111 112
NOT_EQUAL            : 105
OR                   : 114
PACKAGE              : 
PLUS                 : 148
POINTER              : 
POINTS               : 116 117 119
PRINT                : 147
RCORCHE              : 75 77 78 79 120 121 125 130 131
RETURN               : 136 137
RLLAVE               : 45 46 55 56 57 58 90 91 92 93 115 136 137
RPAREN               : 78 79 83 84 85 86 87 90 91 92 136 137 147 156
SCAN                 : 
SMALLER              : 101
SMALLER_OR_EQUAL     : 103
STRING               : 26 69 70
STRUCT               : 93
SWITCH               : 115
TIMES                : 151
TRUE                 : 29 91
TYPE                 : 93
VAR                  : 62 63 64 65 66 67 69 75 120 121 130
WFLOAT               : 37
WINT                 : 36
WSTRING              : 38
error                : 

Nonterminals, with rules where they appear

SenIF                : 12
SenStruct            : 13
arr_content          : 77 121
array_assignment     : 19 20
array_declaration    : 15 16
array_var            : 17 18 43 129 135
cap                  : 78 79 79
capacity             : 120 121
cases                : 115 118
cicloFor             : 5
codigo               : 55 56 57 58 90 91 92 116 117 119 136 0
comparison           : 6 41 56 58 67 74 90 109 111
data_structure       : 52 143
data_types           : 75 77 78 79 94 95 120 121 130 130 136 137 144 146
decVar               : 8 9
decVarOne            : 58 61
declaration          : 93 95
expression           : 3 4 40 65 72 82 99 124 128 147 148 149 156
factor               : 151 152 153
funM                 : 76
func_declaration     : 25
funciones            : 10 11
impresion            : 1 2
incre                : 58
index                : 125
items                : 45 46 47 48
key                  : 131
logic_op             : 106
logic_operation      : 7 42 57 66 73
logic_value          : 106 106
map_assignment       : 23 24
map_declaration      : 21 22
map_var              : 44
more                 : 117
more_items           : 45 47
more_params          : 145
negation             : 107 108
op                   : 97
operations           : 50 54 134 142
params               : 136 137 146
retorno              : 136 138 139
return_value         : 137
sliceC               : 68
something            : 129 135
switch_statement     : 14
term                 : 148 149 150 151 152
value                : 97 97
values               : 49 53 83 116 117 133 141
variable             : 94 95

Parsing method: LALR

state 0

    (0) S' -> . codigo
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . map_declaration COLON
    (22) codigo -> . map_declaration
    (23) codigo -> . map_assignment COLON
    (24) codigo -> . map_assignment
    (25) codigo -> . func_declaration
    (147) impresion -> . PRINT LPAREN expression RPAREN
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (55) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (56) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (57) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (58) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (61) decVar -> . decVarOne
    (62) decVar -> . VAR ID EQUAL INTEGER
    (63) decVar -> . VAR ID EQUAL ID
    (64) decVar -> . VAR ID EQUAL FLOAT
    (65) decVar -> . VAR ID EQUAL expression
    (66) decVar -> . VAR ID EQUAL logic_operation
    (67) decVar -> . VAR ID EQUAL comparison
    (68) decVar -> . sliceC
    (69) decVar -> . VAR ID EQUAL STRING
    (70) decVar -> . ID DEQUAL STRING
    (71) decVar -> . ID DEQUAL FLOAT
    (72) decVar -> . ID DEQUAL expression
    (73) decVar -> . ID DEQUAL logic_operation
    (74) decVar -> . ID DEQUAL comparison
    (83) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (84) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (85) funciones -> . LEN LPAREN ID RPAREN
    (86) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (87) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (90) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (91) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (92) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (93) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (115) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (120) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (121) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (125) array_var -> . ID LCORCHE index RCORCHE
    (129) array_assignment -> . array_var EQUAL something
    (130) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (135) map_assignment -> . array_var EQUAL something
    (136) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (88) decVarOne -> . ID DEQUAL ID
    (89) decVarOne -> . ID DEQUAL INTEGER
    (75) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (76) sliceC -> . ID DEQUAL funM
    (77) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 18
    FOR             shift and go to state 21
    VAR             shift and go to state 26
    ID              shift and go to state 27
    APPEND          shift and go to state 30
    LEN             shift and go to state 31
    COPY            shift and go to state 32
    DELETE          shift and go to state 33
    IF              shift and go to state 34
    TYPE            shift and go to state 35
    SWITCH          shift and go to state 36
    FUNC            shift and go to state 37
    NOT             shift and go to state 39
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    codigo                         shift and go to state 1
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    map_declaration                shift and go to state 15
    map_assignment                 shift and go to state 16
    func_declaration               shift and go to state 17
    term                           shift and go to state 20
    decVarOne                      shift and go to state 22
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    sliceC                         shift and go to state 29
    factor                         shift and go to state 38

state 1

    (0) S' -> codigo .



state 2

    (1) codigo -> impresion . COLON
    (2) codigo -> impresion .

    COLON           shift and go to state 40
    $end            reduce using rule 2 (codigo -> impresion .)
    RLLAVE          reduce using rule 2 (codigo -> impresion .)
    DEFAULT         reduce using rule 2 (codigo -> impresion .)
    CASE            reduce using rule 2 (codigo -> impresion .)
    RETURN          reduce using rule 2 (codigo -> impresion .)


state 3

    (3) codigo -> expression . COLON
    (4) codigo -> expression .
    (148) expression -> expression . PLUS term
    (149) expression -> expression . MINUS term
    (99) value -> expression .

    COLON           shift and go to state 41
    $end            reduce using rule 4 (codigo -> expression .)
    RLLAVE          reduce using rule 4 (codigo -> expression .)
    DEFAULT         reduce using rule 4 (codigo -> expression .)
    CASE            reduce using rule 4 (codigo -> expression .)
    RETURN          reduce using rule 4 (codigo -> expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    GREATER         reduce using rule 99 (value -> expression .)
    SMALLER         reduce using rule 99 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 99 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 99 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 99 (value -> expression .)
    NOT_EQUAL       reduce using rule 99 (value -> expression .)


state 4

    (5) codigo -> cicloFor .

    $end            reduce using rule 5 (codigo -> cicloFor .)
    RLLAVE          reduce using rule 5 (codigo -> cicloFor .)
    DEFAULT         reduce using rule 5 (codigo -> cicloFor .)
    CASE            reduce using rule 5 (codigo -> cicloFor .)
    RETURN          reduce using rule 5 (codigo -> cicloFor .)


state 5

    (6) codigo -> comparison .
    (109) logic_value -> comparison .

    $end            reduce using rule 6 (codigo -> comparison .)
    RLLAVE          reduce using rule 6 (codigo -> comparison .)
    DEFAULT         reduce using rule 6 (codigo -> comparison .)
    CASE            reduce using rule 6 (codigo -> comparison .)
    RETURN          reduce using rule 6 (codigo -> comparison .)
    AND             reduce using rule 109 (logic_value -> comparison .)
    OR              reduce using rule 109 (logic_value -> comparison .)


state 6

    (7) codigo -> logic_operation .

    $end            reduce using rule 7 (codigo -> logic_operation .)
    RLLAVE          reduce using rule 7 (codigo -> logic_operation .)
    DEFAULT         reduce using rule 7 (codigo -> logic_operation .)
    CASE            reduce using rule 7 (codigo -> logic_operation .)
    RETURN          reduce using rule 7 (codigo -> logic_operation .)


state 7

    (8) codigo -> decVar . COLON
    (9) codigo -> decVar .

    COLON           shift and go to state 44
    $end            reduce using rule 9 (codigo -> decVar .)
    RLLAVE          reduce using rule 9 (codigo -> decVar .)
    DEFAULT         reduce using rule 9 (codigo -> decVar .)
    CASE            reduce using rule 9 (codigo -> decVar .)
    RETURN          reduce using rule 9 (codigo -> decVar .)


state 8

    (10) codigo -> funciones .
    (11) codigo -> funciones . COLON

    $end            reduce using rule 10 (codigo -> funciones .)
    RLLAVE          reduce using rule 10 (codigo -> funciones .)
    DEFAULT         reduce using rule 10 (codigo -> funciones .)
    CASE            reduce using rule 10 (codigo -> funciones .)
    RETURN          reduce using rule 10 (codigo -> funciones .)
    COLON           shift and go to state 45


state 9

    (12) codigo -> SenIF .

    $end            reduce using rule 12 (codigo -> SenIF .)
    RLLAVE          reduce using rule 12 (codigo -> SenIF .)
    DEFAULT         reduce using rule 12 (codigo -> SenIF .)
    CASE            reduce using rule 12 (codigo -> SenIF .)
    RETURN          reduce using rule 12 (codigo -> SenIF .)


state 10

    (13) codigo -> SenStruct .

    $end            reduce using rule 13 (codigo -> SenStruct .)
    RLLAVE          reduce using rule 13 (codigo -> SenStruct .)
    DEFAULT         reduce using rule 13 (codigo -> SenStruct .)
    CASE            reduce using rule 13 (codigo -> SenStruct .)
    RETURN          reduce using rule 13 (codigo -> SenStruct .)


state 11

    (14) codigo -> switch_statement .

    $end            reduce using rule 14 (codigo -> switch_statement .)
    RLLAVE          reduce using rule 14 (codigo -> switch_statement .)
    DEFAULT         reduce using rule 14 (codigo -> switch_statement .)
    CASE            reduce using rule 14 (codigo -> switch_statement .)
    RETURN          reduce using rule 14 (codigo -> switch_statement .)


state 12

    (15) codigo -> array_declaration . COLON
    (16) codigo -> array_declaration .

    COLON           shift and go to state 46
    $end            reduce using rule 16 (codigo -> array_declaration .)
    RLLAVE          reduce using rule 16 (codigo -> array_declaration .)
    DEFAULT         reduce using rule 16 (codigo -> array_declaration .)
    CASE            reduce using rule 16 (codigo -> array_declaration .)
    RETURN          reduce using rule 16 (codigo -> array_declaration .)


state 13

    (17) codigo -> array_var . COLON
    (18) codigo -> array_var .
    (129) array_assignment -> array_var . EQUAL something
    (135) map_assignment -> array_var . EQUAL something

    COLON           shift and go to state 47
    $end            reduce using rule 18 (codigo -> array_var .)
    RLLAVE          reduce using rule 18 (codigo -> array_var .)
    DEFAULT         reduce using rule 18 (codigo -> array_var .)
    CASE            reduce using rule 18 (codigo -> array_var .)
    RETURN          reduce using rule 18 (codigo -> array_var .)
    EQUAL           shift and go to state 48


state 14

    (19) codigo -> array_assignment . COLON
    (20) codigo -> array_assignment .

    COLON           shift and go to state 49
    $end            reduce using rule 20 (codigo -> array_assignment .)
    RLLAVE          reduce using rule 20 (codigo -> array_assignment .)
    DEFAULT         reduce using rule 20 (codigo -> array_assignment .)
    CASE            reduce using rule 20 (codigo -> array_assignment .)
    RETURN          reduce using rule 20 (codigo -> array_assignment .)


state 15

    (21) codigo -> map_declaration . COLON
    (22) codigo -> map_declaration .

    COLON           shift and go to state 50
    $end            reduce using rule 22 (codigo -> map_declaration .)
    RLLAVE          reduce using rule 22 (codigo -> map_declaration .)
    DEFAULT         reduce using rule 22 (codigo -> map_declaration .)
    CASE            reduce using rule 22 (codigo -> map_declaration .)
    RETURN          reduce using rule 22 (codigo -> map_declaration .)


state 16

    (23) codigo -> map_assignment . COLON
    (24) codigo -> map_assignment .

    COLON           shift and go to state 51
    $end            reduce using rule 24 (codigo -> map_assignment .)
    RLLAVE          reduce using rule 24 (codigo -> map_assignment .)
    DEFAULT         reduce using rule 24 (codigo -> map_assignment .)
    CASE            reduce using rule 24 (codigo -> map_assignment .)
    RETURN          reduce using rule 24 (codigo -> map_assignment .)


state 17

    (25) codigo -> func_declaration .

    $end            reduce using rule 25 (codigo -> func_declaration .)
    RLLAVE          reduce using rule 25 (codigo -> func_declaration .)
    DEFAULT         reduce using rule 25 (codigo -> func_declaration .)
    CASE            reduce using rule 25 (codigo -> func_declaration .)
    RETURN          reduce using rule 25 (codigo -> func_declaration .)


state 18

    (147) impresion -> PRINT . LPAREN expression RPAREN

    LPAREN          shift and go to state 52


state 19

    (156) factor -> LPAREN . expression RPAREN
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 28
    ID              shift and go to state 54
    LPAREN          shift and go to state 19

    expression                     shift and go to state 53
    term                           shift and go to state 20
    factor                         shift and go to state 38

state 20

    (150) expression -> term .
    (151) term -> term . TIMES factor
    (152) term -> term . DIVIDE factor

    COLON           reduce using rule 150 (expression -> term .)
    PLUS            reduce using rule 150 (expression -> term .)
    MINUS           reduce using rule 150 (expression -> term .)
    $end            reduce using rule 150 (expression -> term .)
    GREATER         reduce using rule 150 (expression -> term .)
    SMALLER         reduce using rule 150 (expression -> term .)
    GREATER_OR_EQUAL reduce using rule 150 (expression -> term .)
    SMALLER_OR_EQUAL reduce using rule 150 (expression -> term .)
    EQUAL_COMPARE   reduce using rule 150 (expression -> term .)
    NOT_EQUAL       reduce using rule 150 (expression -> term .)
    RPAREN          reduce using rule 150 (expression -> term .)
    RLLAVE          reduce using rule 150 (expression -> term .)
    DEFAULT         reduce using rule 150 (expression -> term .)
    CASE            reduce using rule 150 (expression -> term .)
    RETURN          reduce using rule 150 (expression -> term .)
    AND             reduce using rule 150 (expression -> term .)
    OR              reduce using rule 150 (expression -> term .)
    LLLAVE          reduce using rule 150 (expression -> term .)
    RCORCHE         reduce using rule 150 (expression -> term .)
    COMA            reduce using rule 150 (expression -> term .)
    TIMES           shift and go to state 55
    DIVIDE          shift and go to state 56


state 21

    (55) cicloFor -> FOR . LLLAVE codigo RLLAVE
    (56) cicloFor -> FOR . comparison LLLAVE codigo RLLAVE
    (57) cicloFor -> FOR . logic_operation LLLAVE codigo RLLAVE
    (58) cicloFor -> FOR . decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (88) decVarOne -> . ID DEQUAL ID
    (89) decVarOne -> . ID DEQUAL INTEGER
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    LLLAVE          shift and go to state 57
    ID              shift and go to state 61
    NOT             shift and go to state 39
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    comparison                     shift and go to state 58
    logic_operation                shift and go to state 59
    decVarOne                      shift and go to state 60
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    expression                     shift and go to state 62
    term                           shift and go to state 20
    factor                         shift and go to state 38

state 22

    (61) decVar -> decVarOne .

    COLON           reduce using rule 61 (decVar -> decVarOne .)
    $end            reduce using rule 61 (decVar -> decVarOne .)
    RLLAVE          reduce using rule 61 (decVar -> decVarOne .)
    DEFAULT         reduce using rule 61 (decVar -> decVarOne .)
    CASE            reduce using rule 61 (decVar -> decVarOne .)
    RETURN          reduce using rule 61 (decVar -> decVarOne .)


state 23

    (97) comparison -> value . op value
    (100) op -> . GREATER
    (101) op -> . SMALLER
    (102) op -> . GREATER_OR_EQUAL
    (103) op -> . SMALLER_OR_EQUAL
    (104) op -> . EQUAL_COMPARE
    (105) op -> . NOT_EQUAL

    GREATER         shift and go to state 64
    SMALLER         shift and go to state 65
    GREATER_OR_EQUAL shift and go to state 66
    SMALLER_OR_EQUAL shift and go to state 67
    EQUAL_COMPARE   shift and go to state 68
    NOT_EQUAL       shift and go to state 69

    op                             shift and go to state 63

state 24

    (106) logic_operation -> logic_value . logic_op logic_value
    (113) logic_op -> . AND
    (114) logic_op -> . OR

    AND             shift and go to state 71
    OR              shift and go to state 72

    logic_op                       shift and go to state 70

state 25

    (107) logic_operation -> negation .
    (108) logic_value -> negation .

    $end            reduce using rule 107 (logic_operation -> negation .)
    LLLAVE          reduce using rule 107 (logic_operation -> negation .)
    COLON           reduce using rule 107 (logic_operation -> negation .)
    RLLAVE          reduce using rule 107 (logic_operation -> negation .)
    DEFAULT         reduce using rule 107 (logic_operation -> negation .)
    CASE            reduce using rule 107 (logic_operation -> negation .)
    RETURN          reduce using rule 107 (logic_operation -> negation .)
    RCORCHE         reduce using rule 107 (logic_operation -> negation .)
    COMA            reduce using rule 107 (logic_operation -> negation .)
    AND             reduce using rule 108 (logic_value -> negation .)
    OR              reduce using rule 108 (logic_value -> negation .)


state 26

    (62) decVar -> VAR . ID EQUAL INTEGER
    (63) decVar -> VAR . ID EQUAL ID
    (64) decVar -> VAR . ID EQUAL FLOAT
    (65) decVar -> VAR . ID EQUAL expression
    (66) decVar -> VAR . ID EQUAL logic_operation
    (67) decVar -> VAR . ID EQUAL comparison
    (69) decVar -> VAR . ID EQUAL STRING
    (120) array_declaration -> VAR . ID LCORCHE capacity RCORCHE data_types
    (121) array_declaration -> VAR . ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (130) map_declaration -> VAR . ID LCORCHE data_types RCORCHE data_types
    (75) sliceC -> VAR . ID LCORCHE RCORCHE data_types

    ID              shift and go to state 73


state 27

    (70) decVar -> ID . DEQUAL STRING
    (71) decVar -> ID . DEQUAL FLOAT
    (72) decVar -> ID . DEQUAL expression
    (73) decVar -> ID . DEQUAL logic_operation
    (74) decVar -> ID . DEQUAL comparison
    (125) array_var -> ID . LCORCHE index RCORCHE
    (98) value -> ID .
    (110) logic_value -> ID .
    (88) decVarOne -> ID . DEQUAL ID
    (89) decVarOne -> ID . DEQUAL INTEGER
    (76) sliceC -> ID . DEQUAL funM
    (77) sliceC -> ID . DEQUAL LCORCHE RCORCHE data_types arr_content
    (155) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 98 (value -> ID .)
    DEQUAL          shift and go to state 74
    LCORCHE         shift and go to state 75
    GREATER         reduce using rule 98 (value -> ID .)
    SMALLER         reduce using rule 98 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 98 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 98 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 98 (value -> ID .)
    NOT_EQUAL       reduce using rule 98 (value -> ID .)
    AND             reduce using rule 110 (logic_value -> ID .)
    OR              reduce using rule 110 (logic_value -> ID .)
    TIMES           reduce using rule 155 (factor -> ID .)
    DIVIDE          reduce using rule 155 (factor -> ID .)
    COLON           reduce using rule 155 (factor -> ID .)
    PLUS            reduce using rule 155 (factor -> ID .)
    MINUS           reduce using rule 155 (factor -> ID .)
    $end            reduce using rule 155 (factor -> ID .)
    RLLAVE          reduce using rule 155 (factor -> ID .)
    DEFAULT         reduce using rule 155 (factor -> ID .)
    CASE            reduce using rule 155 (factor -> ID .)
    RETURN          reduce using rule 155 (factor -> ID .)

  ! GREATER         [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 155 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 155 (factor -> ID .) ]


state 28

    (154) factor -> INTEGER .

    TIMES           reduce using rule 154 (factor -> INTEGER .)
    DIVIDE          reduce using rule 154 (factor -> INTEGER .)
    COLON           reduce using rule 154 (factor -> INTEGER .)
    PLUS            reduce using rule 154 (factor -> INTEGER .)
    MINUS           reduce using rule 154 (factor -> INTEGER .)
    $end            reduce using rule 154 (factor -> INTEGER .)
    GREATER         reduce using rule 154 (factor -> INTEGER .)
    SMALLER         reduce using rule 154 (factor -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 154 (factor -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 154 (factor -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 154 (factor -> INTEGER .)
    NOT_EQUAL       reduce using rule 154 (factor -> INTEGER .)
    RPAREN          reduce using rule 154 (factor -> INTEGER .)
    RLLAVE          reduce using rule 154 (factor -> INTEGER .)
    DEFAULT         reduce using rule 154 (factor -> INTEGER .)
    CASE            reduce using rule 154 (factor -> INTEGER .)
    RETURN          reduce using rule 154 (factor -> INTEGER .)
    AND             reduce using rule 154 (factor -> INTEGER .)
    OR              reduce using rule 154 (factor -> INTEGER .)
    LLLAVE          reduce using rule 154 (factor -> INTEGER .)
    RCORCHE         reduce using rule 154 (factor -> INTEGER .)
    COMA            reduce using rule 154 (factor -> INTEGER .)


state 29

    (68) decVar -> sliceC .

    COLON           reduce using rule 68 (decVar -> sliceC .)
    $end            reduce using rule 68 (decVar -> sliceC .)
    RLLAVE          reduce using rule 68 (decVar -> sliceC .)
    DEFAULT         reduce using rule 68 (decVar -> sliceC .)
    CASE            reduce using rule 68 (decVar -> sliceC .)
    RETURN          reduce using rule 68 (decVar -> sliceC .)


state 30

    (83) funciones -> APPEND . LPAREN ID COMA values RPAREN
    (84) funciones -> APPEND . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 76


state 31

    (85) funciones -> LEN . LPAREN ID RPAREN

    LPAREN          shift and go to state 77


state 32

    (86) funciones -> COPY . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 78


state 33

    (87) funciones -> DELETE . LPAREN ID COMA ID RPAREN

    LPAREN          shift and go to state 79


state 34

    (90) SenIF -> IF . LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (91) SenIF -> IF . LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (92) SenIF -> IF . LPAREN FALSE RPAREN LLLAVE codigo RLLAVE

    LPAREN          shift and go to state 80


state 35

    (93) SenStruct -> TYPE . ID STRUCT LLLAVE declaration RLLAVE

    ID              shift and go to state 81


state 36

    (115) switch_statement -> SWITCH . ID LLLAVE cases RLLAVE

    ID              shift and go to state 82


state 37

    (136) func_declaration -> FUNC . ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> FUNC . ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE

    ID              shift and go to state 83


state 38

    (153) term -> factor .

    TIMES           reduce using rule 153 (term -> factor .)
    DIVIDE          reduce using rule 153 (term -> factor .)
    COLON           reduce using rule 153 (term -> factor .)
    PLUS            reduce using rule 153 (term -> factor .)
    MINUS           reduce using rule 153 (term -> factor .)
    $end            reduce using rule 153 (term -> factor .)
    GREATER         reduce using rule 153 (term -> factor .)
    SMALLER         reduce using rule 153 (term -> factor .)
    GREATER_OR_EQUAL reduce using rule 153 (term -> factor .)
    SMALLER_OR_EQUAL reduce using rule 153 (term -> factor .)
    EQUAL_COMPARE   reduce using rule 153 (term -> factor .)
    NOT_EQUAL       reduce using rule 153 (term -> factor .)
    RPAREN          reduce using rule 153 (term -> factor .)
    RLLAVE          reduce using rule 153 (term -> factor .)
    DEFAULT         reduce using rule 153 (term -> factor .)
    CASE            reduce using rule 153 (term -> factor .)
    RETURN          reduce using rule 153 (term -> factor .)
    AND             reduce using rule 153 (term -> factor .)
    OR              reduce using rule 153 (term -> factor .)
    LLLAVE          reduce using rule 153 (term -> factor .)
    RCORCHE         reduce using rule 153 (term -> factor .)
    COMA            reduce using rule 153 (term -> factor .)


state 39

    (111) negation -> NOT . comparison
    (112) negation -> NOT . ID
    (97) comparison -> . value op value
    (98) value -> . ID
    (99) value -> . expression
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 85
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    comparison                     shift and go to state 84
    value                          shift and go to state 23
    expression                     shift and go to state 62
    term                           shift and go to state 20
    factor                         shift and go to state 38

state 40

    (1) codigo -> impresion COLON .

    $end            reduce using rule 1 (codigo -> impresion COLON .)
    RLLAVE          reduce using rule 1 (codigo -> impresion COLON .)
    DEFAULT         reduce using rule 1 (codigo -> impresion COLON .)
    CASE            reduce using rule 1 (codigo -> impresion COLON .)
    RETURN          reduce using rule 1 (codigo -> impresion COLON .)


state 41

    (3) codigo -> expression COLON .

    $end            reduce using rule 3 (codigo -> expression COLON .)
    RLLAVE          reduce using rule 3 (codigo -> expression COLON .)
    DEFAULT         reduce using rule 3 (codigo -> expression COLON .)
    CASE            reduce using rule 3 (codigo -> expression COLON .)
    RETURN          reduce using rule 3 (codigo -> expression COLON .)


state 42

    (148) expression -> expression PLUS . term
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 28
    ID              shift and go to state 54
    LPAREN          shift and go to state 19

    term                           shift and go to state 86
    factor                         shift and go to state 38

state 43

    (149) expression -> expression MINUS . term
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 28
    ID              shift and go to state 54
    LPAREN          shift and go to state 19

    term                           shift and go to state 87
    factor                         shift and go to state 38

state 44

    (8) codigo -> decVar COLON .

    $end            reduce using rule 8 (codigo -> decVar COLON .)
    RLLAVE          reduce using rule 8 (codigo -> decVar COLON .)
    DEFAULT         reduce using rule 8 (codigo -> decVar COLON .)
    CASE            reduce using rule 8 (codigo -> decVar COLON .)
    RETURN          reduce using rule 8 (codigo -> decVar COLON .)


state 45

    (11) codigo -> funciones COLON .

    $end            reduce using rule 11 (codigo -> funciones COLON .)
    RLLAVE          reduce using rule 11 (codigo -> funciones COLON .)
    DEFAULT         reduce using rule 11 (codigo -> funciones COLON .)
    CASE            reduce using rule 11 (codigo -> funciones COLON .)
    RETURN          reduce using rule 11 (codigo -> funciones COLON .)


state 46

    (15) codigo -> array_declaration COLON .

    $end            reduce using rule 15 (codigo -> array_declaration COLON .)
    RLLAVE          reduce using rule 15 (codigo -> array_declaration COLON .)
    DEFAULT         reduce using rule 15 (codigo -> array_declaration COLON .)
    CASE            reduce using rule 15 (codigo -> array_declaration COLON .)
    RETURN          reduce using rule 15 (codigo -> array_declaration COLON .)


state 47

    (17) codigo -> array_var COLON .

    $end            reduce using rule 17 (codigo -> array_var COLON .)
    RLLAVE          reduce using rule 17 (codigo -> array_var COLON .)
    DEFAULT         reduce using rule 17 (codigo -> array_var COLON .)
    CASE            reduce using rule 17 (codigo -> array_var COLON .)
    RETURN          reduce using rule 17 (codigo -> array_var COLON .)


state 48

    (129) array_assignment -> array_var EQUAL . something
    (135) map_assignment -> array_var EQUAL . something
    (51) something -> . ID
    (52) something -> . data_structure
    (53) something -> . values
    (54) something -> . operations
    (43) data_structure -> . array_var
    (44) data_structure -> . map_var
    (26) values -> . STRING
    (27) values -> . INTEGER
    (28) values -> . FLOAT
    (29) values -> . TRUE
    (30) values -> . FALSE
    (40) operations -> . expression
    (41) operations -> . comparison
    (42) operations -> . logic_operation
    (125) array_var -> . ID LCORCHE index RCORCHE
    (131) map_var -> . ID LCORCHE key RCORCHE
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 90
    STRING          shift and go to state 95
    INTEGER         shift and go to state 96
    FLOAT           shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    NOT             shift and go to state 39
    LPAREN          shift and go to state 19

    array_var                      shift and go to state 88
    something                      shift and go to state 89
    data_structure                 shift and go to state 91
    values                         shift and go to state 92
    operations                     shift and go to state 93
    map_var                        shift and go to state 94
    expression                     shift and go to state 100
    comparison                     shift and go to state 101
    logic_operation                shift and go to state 102
    term                           shift and go to state 20
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    factor                         shift and go to state 38

state 49

    (19) codigo -> array_assignment COLON .

    $end            reduce using rule 19 (codigo -> array_assignment COLON .)
    RLLAVE          reduce using rule 19 (codigo -> array_assignment COLON .)
    DEFAULT         reduce using rule 19 (codigo -> array_assignment COLON .)
    CASE            reduce using rule 19 (codigo -> array_assignment COLON .)
    RETURN          reduce using rule 19 (codigo -> array_assignment COLON .)


state 50

    (21) codigo -> map_declaration COLON .

    $end            reduce using rule 21 (codigo -> map_declaration COLON .)
    RLLAVE          reduce using rule 21 (codigo -> map_declaration COLON .)
    DEFAULT         reduce using rule 21 (codigo -> map_declaration COLON .)
    CASE            reduce using rule 21 (codigo -> map_declaration COLON .)
    RETURN          reduce using rule 21 (codigo -> map_declaration COLON .)


state 51

    (23) codigo -> map_assignment COLON .

    $end            reduce using rule 23 (codigo -> map_assignment COLON .)
    RLLAVE          reduce using rule 23 (codigo -> map_assignment COLON .)
    DEFAULT         reduce using rule 23 (codigo -> map_assignment COLON .)
    CASE            reduce using rule 23 (codigo -> map_assignment COLON .)
    RETURN          reduce using rule 23 (codigo -> map_assignment COLON .)


state 52

    (147) impresion -> PRINT LPAREN . expression RPAREN
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 28
    ID              shift and go to state 54
    LPAREN          shift and go to state 19

    expression                     shift and go to state 103
    term                           shift and go to state 20
    factor                         shift and go to state 38

state 53

    (156) factor -> LPAREN expression . RPAREN
    (148) expression -> expression . PLUS term
    (149) expression -> expression . MINUS term

    RPAREN          shift and go to state 104
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43


state 54

    (155) factor -> ID .

    TIMES           reduce using rule 155 (factor -> ID .)
    DIVIDE          reduce using rule 155 (factor -> ID .)
    RPAREN          reduce using rule 155 (factor -> ID .)
    PLUS            reduce using rule 155 (factor -> ID .)
    MINUS           reduce using rule 155 (factor -> ID .)
    COLON           reduce using rule 155 (factor -> ID .)
    $end            reduce using rule 155 (factor -> ID .)
    GREATER         reduce using rule 155 (factor -> ID .)
    SMALLER         reduce using rule 155 (factor -> ID .)
    GREATER_OR_EQUAL reduce using rule 155 (factor -> ID .)
    SMALLER_OR_EQUAL reduce using rule 155 (factor -> ID .)
    EQUAL_COMPARE   reduce using rule 155 (factor -> ID .)
    NOT_EQUAL       reduce using rule 155 (factor -> ID .)
    RLLAVE          reduce using rule 155 (factor -> ID .)
    DEFAULT         reduce using rule 155 (factor -> ID .)
    CASE            reduce using rule 155 (factor -> ID .)
    RETURN          reduce using rule 155 (factor -> ID .)
    AND             reduce using rule 155 (factor -> ID .)
    OR              reduce using rule 155 (factor -> ID .)
    LLLAVE          reduce using rule 155 (factor -> ID .)
    RCORCHE         reduce using rule 155 (factor -> ID .)
    COMA            reduce using rule 155 (factor -> ID .)


state 55

    (151) term -> term TIMES . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 28
    ID              shift and go to state 54
    LPAREN          shift and go to state 19

    factor                         shift and go to state 105

state 56

    (152) term -> term DIVIDE . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 28
    ID              shift and go to state 54
    LPAREN          shift and go to state 19

    factor                         shift and go to state 106

state 57

    (55) cicloFor -> FOR LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . map_declaration COLON
    (22) codigo -> . map_declaration
    (23) codigo -> . map_assignment COLON
    (24) codigo -> . map_assignment
    (25) codigo -> . func_declaration
    (147) impresion -> . PRINT LPAREN expression RPAREN
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (55) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (56) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (57) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (58) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (61) decVar -> . decVarOne
    (62) decVar -> . VAR ID EQUAL INTEGER
    (63) decVar -> . VAR ID EQUAL ID
    (64) decVar -> . VAR ID EQUAL FLOAT
    (65) decVar -> . VAR ID EQUAL expression
    (66) decVar -> . VAR ID EQUAL logic_operation
    (67) decVar -> . VAR ID EQUAL comparison
    (68) decVar -> . sliceC
    (69) decVar -> . VAR ID EQUAL STRING
    (70) decVar -> . ID DEQUAL STRING
    (71) decVar -> . ID DEQUAL FLOAT
    (72) decVar -> . ID DEQUAL expression
    (73) decVar -> . ID DEQUAL logic_operation
    (74) decVar -> . ID DEQUAL comparison
    (83) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (84) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (85) funciones -> . LEN LPAREN ID RPAREN
    (86) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (87) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (90) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (91) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (92) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (93) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (115) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (120) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (121) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (125) array_var -> . ID LCORCHE index RCORCHE
    (129) array_assignment -> . array_var EQUAL something
    (130) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (135) map_assignment -> . array_var EQUAL something
    (136) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (88) decVarOne -> . ID DEQUAL ID
    (89) decVarOne -> . ID DEQUAL INTEGER
    (75) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (76) sliceC -> . ID DEQUAL funM
    (77) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 18
    FOR             shift and go to state 21
    VAR             shift and go to state 26
    ID              shift and go to state 27
    APPEND          shift and go to state 30
    LEN             shift and go to state 31
    COPY            shift and go to state 32
    DELETE          shift and go to state 33
    IF              shift and go to state 34
    TYPE            shift and go to state 35
    SWITCH          shift and go to state 36
    FUNC            shift and go to state 37
    NOT             shift and go to state 39
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    codigo                         shift and go to state 107
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    map_declaration                shift and go to state 15
    map_assignment                 shift and go to state 16
    func_declaration               shift and go to state 17
    term                           shift and go to state 20
    decVarOne                      shift and go to state 22
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    sliceC                         shift and go to state 29
    factor                         shift and go to state 38

state 58

    (56) cicloFor -> FOR comparison . LLLAVE codigo RLLAVE
    (109) logic_value -> comparison .

    LLLAVE          shift and go to state 108
    AND             reduce using rule 109 (logic_value -> comparison .)
    OR              reduce using rule 109 (logic_value -> comparison .)


state 59

    (57) cicloFor -> FOR logic_operation . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 109


state 60

    (58) cicloFor -> FOR decVarOne . COLON comparison COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 110


state 61

    (88) decVarOne -> ID . DEQUAL ID
    (89) decVarOne -> ID . DEQUAL INTEGER
    (98) value -> ID .
    (110) logic_value -> ID .
    (155) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 98 (value -> ID .)
    DEQUAL          shift and go to state 111
    GREATER         reduce using rule 98 (value -> ID .)
    SMALLER         reduce using rule 98 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 98 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 98 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 98 (value -> ID .)
    NOT_EQUAL       reduce using rule 98 (value -> ID .)
    AND             reduce using rule 110 (logic_value -> ID .)
    OR              reduce using rule 110 (logic_value -> ID .)
    TIMES           reduce using rule 155 (factor -> ID .)
    DIVIDE          reduce using rule 155 (factor -> ID .)
    PLUS            reduce using rule 155 (factor -> ID .)
    MINUS           reduce using rule 155 (factor -> ID .)

  ! GREATER         [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 155 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 155 (factor -> ID .) ]


state 62

    (99) value -> expression .
    (148) expression -> expression . PLUS term
    (149) expression -> expression . MINUS term

    GREATER         reduce using rule 99 (value -> expression .)
    SMALLER         reduce using rule 99 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 99 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 99 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 99 (value -> expression .)
    NOT_EQUAL       reduce using rule 99 (value -> expression .)
    $end            reduce using rule 99 (value -> expression .)
    AND             reduce using rule 99 (value -> expression .)
    OR              reduce using rule 99 (value -> expression .)
    LLLAVE          reduce using rule 99 (value -> expression .)
    COLON           reduce using rule 99 (value -> expression .)
    RLLAVE          reduce using rule 99 (value -> expression .)
    DEFAULT         reduce using rule 99 (value -> expression .)
    CASE            reduce using rule 99 (value -> expression .)
    RETURN          reduce using rule 99 (value -> expression .)
    RCORCHE         reduce using rule 99 (value -> expression .)
    COMA            reduce using rule 99 (value -> expression .)
    RPAREN          reduce using rule 99 (value -> expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43


state 63

    (97) comparison -> value op . value
    (98) value -> . ID
    (99) value -> . expression
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 113
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    value                          shift and go to state 112
    expression                     shift and go to state 62
    term                           shift and go to state 20
    factor                         shift and go to state 38

state 64

    (100) op -> GREATER .

    ID              reduce using rule 100 (op -> GREATER .)
    INTEGER         reduce using rule 100 (op -> GREATER .)
    LPAREN          reduce using rule 100 (op -> GREATER .)


state 65

    (101) op -> SMALLER .

    ID              reduce using rule 101 (op -> SMALLER .)
    INTEGER         reduce using rule 101 (op -> SMALLER .)
    LPAREN          reduce using rule 101 (op -> SMALLER .)


state 66

    (102) op -> GREATER_OR_EQUAL .

    ID              reduce using rule 102 (op -> GREATER_OR_EQUAL .)
    INTEGER         reduce using rule 102 (op -> GREATER_OR_EQUAL .)
    LPAREN          reduce using rule 102 (op -> GREATER_OR_EQUAL .)


state 67

    (103) op -> SMALLER_OR_EQUAL .

    ID              reduce using rule 103 (op -> SMALLER_OR_EQUAL .)
    INTEGER         reduce using rule 103 (op -> SMALLER_OR_EQUAL .)
    LPAREN          reduce using rule 103 (op -> SMALLER_OR_EQUAL .)


state 68

    (104) op -> EQUAL_COMPARE .

    ID              reduce using rule 104 (op -> EQUAL_COMPARE .)
    INTEGER         reduce using rule 104 (op -> EQUAL_COMPARE .)
    LPAREN          reduce using rule 104 (op -> EQUAL_COMPARE .)


state 69

    (105) op -> NOT_EQUAL .

    ID              reduce using rule 105 (op -> NOT_EQUAL .)
    INTEGER         reduce using rule 105 (op -> NOT_EQUAL .)
    LPAREN          reduce using rule 105 (op -> NOT_EQUAL .)


state 70

    (106) logic_operation -> logic_value logic_op . logic_value
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (97) comparison -> . value op value
    (98) value -> . ID
    (99) value -> . expression
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 117
    NOT             shift and go to state 39
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    logic_value                    shift and go to state 114
    negation                       shift and go to state 115
    comparison                     shift and go to state 116
    value                          shift and go to state 23
    expression                     shift and go to state 62
    term                           shift and go to state 20
    factor                         shift and go to state 38

state 71

    (113) logic_op -> AND .

    ID              reduce using rule 113 (logic_op -> AND .)
    NOT             reduce using rule 113 (logic_op -> AND .)
    INTEGER         reduce using rule 113 (logic_op -> AND .)
    LPAREN          reduce using rule 113 (logic_op -> AND .)


state 72

    (114) logic_op -> OR .

    ID              reduce using rule 114 (logic_op -> OR .)
    NOT             reduce using rule 114 (logic_op -> OR .)
    INTEGER         reduce using rule 114 (logic_op -> OR .)
    LPAREN          reduce using rule 114 (logic_op -> OR .)


state 73

    (62) decVar -> VAR ID . EQUAL INTEGER
    (63) decVar -> VAR ID . EQUAL ID
    (64) decVar -> VAR ID . EQUAL FLOAT
    (65) decVar -> VAR ID . EQUAL expression
    (66) decVar -> VAR ID . EQUAL logic_operation
    (67) decVar -> VAR ID . EQUAL comparison
    (69) decVar -> VAR ID . EQUAL STRING
    (120) array_declaration -> VAR ID . LCORCHE capacity RCORCHE data_types
    (121) array_declaration -> VAR ID . EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (130) map_declaration -> VAR ID . LCORCHE data_types RCORCHE data_types
    (75) sliceC -> VAR ID . LCORCHE RCORCHE data_types

    EQUAL           shift and go to state 118
    LCORCHE         shift and go to state 119


state 74

    (70) decVar -> ID DEQUAL . STRING
    (71) decVar -> ID DEQUAL . FLOAT
    (72) decVar -> ID DEQUAL . expression
    (73) decVar -> ID DEQUAL . logic_operation
    (74) decVar -> ID DEQUAL . comparison
    (88) decVarOne -> ID DEQUAL . ID
    (89) decVarOne -> ID DEQUAL . INTEGER
    (76) sliceC -> ID DEQUAL . funM
    (77) sliceC -> ID DEQUAL . LCORCHE RCORCHE data_types arr_content
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (97) comparison -> . value op value
    (78) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (79) funM -> . MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (98) value -> . ID
    (99) value -> . expression
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    STRING          shift and go to state 121
    FLOAT           shift and go to state 122
    ID              shift and go to state 120
    INTEGER         shift and go to state 126
    LCORCHE         shift and go to state 128
    MAKE            shift and go to state 129
    NOT             shift and go to state 39
    LPAREN          shift and go to state 19

    expression                     shift and go to state 123
    logic_operation                shift and go to state 124
    comparison                     shift and go to state 125
    funM                           shift and go to state 127
    term                           shift and go to state 20
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    value                          shift and go to state 23
    factor                         shift and go to state 38

state 75

    (125) array_var -> ID LCORCHE . index RCORCHE
    (126) index -> . ID
    (127) index -> . INTEGER
    (128) index -> . expression
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 130
    INTEGER         shift and go to state 132
    LPAREN          shift and go to state 19

    index                          shift and go to state 131
    expression                     shift and go to state 133
    term                           shift and go to state 20
    factor                         shift and go to state 38

state 76

    (83) funciones -> APPEND LPAREN . ID COMA values RPAREN
    (84) funciones -> APPEND LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 134


state 77

    (85) funciones -> LEN LPAREN . ID RPAREN

    ID              shift and go to state 135


state 78

    (86) funciones -> COPY LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 136


state 79

    (87) funciones -> DELETE LPAREN . ID COMA ID RPAREN

    ID              shift and go to state 137


state 80

    (90) SenIF -> IF LPAREN . comparison RPAREN LLLAVE codigo RLLAVE
    (91) SenIF -> IF LPAREN . TRUE RPAREN LLLAVE codigo RLLAVE
    (92) SenIF -> IF LPAREN . FALSE RPAREN LLLAVE codigo RLLAVE
    (97) comparison -> . value op value
    (98) value -> . ID
    (99) value -> . expression
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    TRUE            shift and go to state 139
    FALSE           shift and go to state 140
    ID              shift and go to state 113
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    comparison                     shift and go to state 138
    value                          shift and go to state 23
    expression                     shift and go to state 62
    term                           shift and go to state 20
    factor                         shift and go to state 38

state 81

    (93) SenStruct -> TYPE ID . STRUCT LLLAVE declaration RLLAVE

    STRUCT          shift and go to state 141


state 82

    (115) switch_statement -> SWITCH ID . LLLAVE cases RLLAVE

    LLLAVE          shift and go to state 142


state 83

    (136) func_declaration -> FUNC ID . LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> FUNC ID . LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE

    LPAREN          shift and go to state 143


state 84

    (111) negation -> NOT comparison .

    $end            reduce using rule 111 (negation -> NOT comparison .)
    AND             reduce using rule 111 (negation -> NOT comparison .)
    OR              reduce using rule 111 (negation -> NOT comparison .)
    LLLAVE          reduce using rule 111 (negation -> NOT comparison .)
    COLON           reduce using rule 111 (negation -> NOT comparison .)
    RLLAVE          reduce using rule 111 (negation -> NOT comparison .)
    DEFAULT         reduce using rule 111 (negation -> NOT comparison .)
    CASE            reduce using rule 111 (negation -> NOT comparison .)
    RETURN          reduce using rule 111 (negation -> NOT comparison .)
    RCORCHE         reduce using rule 111 (negation -> NOT comparison .)
    COMA            reduce using rule 111 (negation -> NOT comparison .)


state 85

    (112) negation -> NOT ID .
    (98) value -> ID .
    (155) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 98 (value -> ID .)
    $end            reduce using rule 112 (negation -> NOT ID .)
    AND             reduce using rule 112 (negation -> NOT ID .)
    OR              reduce using rule 112 (negation -> NOT ID .)
    LLLAVE          reduce using rule 112 (negation -> NOT ID .)
    COLON           reduce using rule 112 (negation -> NOT ID .)
    RLLAVE          reduce using rule 112 (negation -> NOT ID .)
    DEFAULT         reduce using rule 112 (negation -> NOT ID .)
    CASE            reduce using rule 112 (negation -> NOT ID .)
    RETURN          reduce using rule 112 (negation -> NOT ID .)
    RCORCHE         reduce using rule 112 (negation -> NOT ID .)
    COMA            reduce using rule 112 (negation -> NOT ID .)
    GREATER         reduce using rule 98 (value -> ID .)
    SMALLER         reduce using rule 98 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 98 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 98 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 98 (value -> ID .)
    NOT_EQUAL       reduce using rule 98 (value -> ID .)
    TIMES           reduce using rule 155 (factor -> ID .)
    DIVIDE          reduce using rule 155 (factor -> ID .)
    PLUS            reduce using rule 155 (factor -> ID .)
    MINUS           reduce using rule 155 (factor -> ID .)

  ! GREATER         [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 155 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 155 (factor -> ID .) ]


state 86

    (148) expression -> expression PLUS term .
    (151) term -> term . TIMES factor
    (152) term -> term . DIVIDE factor

    COLON           reduce using rule 148 (expression -> expression PLUS term .)
    PLUS            reduce using rule 148 (expression -> expression PLUS term .)
    MINUS           reduce using rule 148 (expression -> expression PLUS term .)
    $end            reduce using rule 148 (expression -> expression PLUS term .)
    GREATER         reduce using rule 148 (expression -> expression PLUS term .)
    SMALLER         reduce using rule 148 (expression -> expression PLUS term .)
    GREATER_OR_EQUAL reduce using rule 148 (expression -> expression PLUS term .)
    SMALLER_OR_EQUAL reduce using rule 148 (expression -> expression PLUS term .)
    EQUAL_COMPARE   reduce using rule 148 (expression -> expression PLUS term .)
    NOT_EQUAL       reduce using rule 148 (expression -> expression PLUS term .)
    RPAREN          reduce using rule 148 (expression -> expression PLUS term .)
    RLLAVE          reduce using rule 148 (expression -> expression PLUS term .)
    DEFAULT         reduce using rule 148 (expression -> expression PLUS term .)
    CASE            reduce using rule 148 (expression -> expression PLUS term .)
    RETURN          reduce using rule 148 (expression -> expression PLUS term .)
    AND             reduce using rule 148 (expression -> expression PLUS term .)
    OR              reduce using rule 148 (expression -> expression PLUS term .)
    LLLAVE          reduce using rule 148 (expression -> expression PLUS term .)
    RCORCHE         reduce using rule 148 (expression -> expression PLUS term .)
    COMA            reduce using rule 148 (expression -> expression PLUS term .)
    TIMES           shift and go to state 55
    DIVIDE          shift and go to state 56


state 87

    (149) expression -> expression MINUS term .
    (151) term -> term . TIMES factor
    (152) term -> term . DIVIDE factor

    COLON           reduce using rule 149 (expression -> expression MINUS term .)
    PLUS            reduce using rule 149 (expression -> expression MINUS term .)
    MINUS           reduce using rule 149 (expression -> expression MINUS term .)
    $end            reduce using rule 149 (expression -> expression MINUS term .)
    GREATER         reduce using rule 149 (expression -> expression MINUS term .)
    SMALLER         reduce using rule 149 (expression -> expression MINUS term .)
    GREATER_OR_EQUAL reduce using rule 149 (expression -> expression MINUS term .)
    SMALLER_OR_EQUAL reduce using rule 149 (expression -> expression MINUS term .)
    EQUAL_COMPARE   reduce using rule 149 (expression -> expression MINUS term .)
    NOT_EQUAL       reduce using rule 149 (expression -> expression MINUS term .)
    RPAREN          reduce using rule 149 (expression -> expression MINUS term .)
    RLLAVE          reduce using rule 149 (expression -> expression MINUS term .)
    DEFAULT         reduce using rule 149 (expression -> expression MINUS term .)
    CASE            reduce using rule 149 (expression -> expression MINUS term .)
    RETURN          reduce using rule 149 (expression -> expression MINUS term .)
    AND             reduce using rule 149 (expression -> expression MINUS term .)
    OR              reduce using rule 149 (expression -> expression MINUS term .)
    LLLAVE          reduce using rule 149 (expression -> expression MINUS term .)
    RCORCHE         reduce using rule 149 (expression -> expression MINUS term .)
    COMA            reduce using rule 149 (expression -> expression MINUS term .)
    TIMES           shift and go to state 55
    DIVIDE          shift and go to state 56


state 88

    (43) data_structure -> array_var .

    COLON           reduce using rule 43 (data_structure -> array_var .)
    $end            reduce using rule 43 (data_structure -> array_var .)
    RLLAVE          reduce using rule 43 (data_structure -> array_var .)
    DEFAULT         reduce using rule 43 (data_structure -> array_var .)
    CASE            reduce using rule 43 (data_structure -> array_var .)
    RETURN          reduce using rule 43 (data_structure -> array_var .)


state 89

    (129) array_assignment -> array_var EQUAL something .
    (135) map_assignment -> array_var EQUAL something .

  ! reduce/reduce conflict for COLON resolved using rule 129 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for $end resolved using rule 129 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 129 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 129 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for CASE resolved using rule 129 (array_assignment -> array_var EQUAL something .)
  ! reduce/reduce conflict for RETURN resolved using rule 129 (array_assignment -> array_var EQUAL something .)
    COLON           reduce using rule 129 (array_assignment -> array_var EQUAL something .)
    $end            reduce using rule 129 (array_assignment -> array_var EQUAL something .)
    RLLAVE          reduce using rule 129 (array_assignment -> array_var EQUAL something .)
    DEFAULT         reduce using rule 129 (array_assignment -> array_var EQUAL something .)
    CASE            reduce using rule 129 (array_assignment -> array_var EQUAL something .)
    RETURN          reduce using rule 129 (array_assignment -> array_var EQUAL something .)

  ! COLON           [ reduce using rule 135 (map_assignment -> array_var EQUAL something .) ]
  ! $end            [ reduce using rule 135 (map_assignment -> array_var EQUAL something .) ]
  ! RLLAVE          [ reduce using rule 135 (map_assignment -> array_var EQUAL something .) ]
  ! DEFAULT         [ reduce using rule 135 (map_assignment -> array_var EQUAL something .) ]
  ! CASE            [ reduce using rule 135 (map_assignment -> array_var EQUAL something .) ]
  ! RETURN          [ reduce using rule 135 (map_assignment -> array_var EQUAL something .) ]


state 90

    (51) something -> ID .
    (125) array_var -> ID . LCORCHE index RCORCHE
    (131) map_var -> ID . LCORCHE key RCORCHE
    (98) value -> ID .
    (110) logic_value -> ID .
    (155) factor -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 51 (something -> ID .)
  ! reduce/reduce conflict for $end resolved using rule 51 (something -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 51 (something -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 51 (something -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 51 (something -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 51 (something -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 98 (value -> ID .)
    COLON           reduce using rule 51 (something -> ID .)
    $end            reduce using rule 51 (something -> ID .)
    RLLAVE          reduce using rule 51 (something -> ID .)
    DEFAULT         reduce using rule 51 (something -> ID .)
    CASE            reduce using rule 51 (something -> ID .)
    RETURN          reduce using rule 51 (something -> ID .)
    LCORCHE         shift and go to state 144
    GREATER         reduce using rule 98 (value -> ID .)
    SMALLER         reduce using rule 98 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 98 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 98 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 98 (value -> ID .)
    NOT_EQUAL       reduce using rule 98 (value -> ID .)
    AND             reduce using rule 110 (logic_value -> ID .)
    OR              reduce using rule 110 (logic_value -> ID .)
    TIMES           reduce using rule 155 (factor -> ID .)
    DIVIDE          reduce using rule 155 (factor -> ID .)
    PLUS            reduce using rule 155 (factor -> ID .)
    MINUS           reduce using rule 155 (factor -> ID .)

  ! COLON           [ reduce using rule 155 (factor -> ID .) ]
  ! $end            [ reduce using rule 155 (factor -> ID .) ]
  ! RLLAVE          [ reduce using rule 155 (factor -> ID .) ]
  ! DEFAULT         [ reduce using rule 155 (factor -> ID .) ]
  ! CASE            [ reduce using rule 155 (factor -> ID .) ]
  ! RETURN          [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER         [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 155 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 155 (factor -> ID .) ]


state 91

    (52) something -> data_structure .

    COLON           reduce using rule 52 (something -> data_structure .)
    $end            reduce using rule 52 (something -> data_structure .)
    RLLAVE          reduce using rule 52 (something -> data_structure .)
    DEFAULT         reduce using rule 52 (something -> data_structure .)
    CASE            reduce using rule 52 (something -> data_structure .)
    RETURN          reduce using rule 52 (something -> data_structure .)


state 92

    (53) something -> values .

    COLON           reduce using rule 53 (something -> values .)
    $end            reduce using rule 53 (something -> values .)
    RLLAVE          reduce using rule 53 (something -> values .)
    DEFAULT         reduce using rule 53 (something -> values .)
    CASE            reduce using rule 53 (something -> values .)
    RETURN          reduce using rule 53 (something -> values .)


state 93

    (54) something -> operations .

    COLON           reduce using rule 54 (something -> operations .)
    $end            reduce using rule 54 (something -> operations .)
    RLLAVE          reduce using rule 54 (something -> operations .)
    DEFAULT         reduce using rule 54 (something -> operations .)
    CASE            reduce using rule 54 (something -> operations .)
    RETURN          reduce using rule 54 (something -> operations .)


state 94

    (44) data_structure -> map_var .

    COLON           reduce using rule 44 (data_structure -> map_var .)
    $end            reduce using rule 44 (data_structure -> map_var .)
    RLLAVE          reduce using rule 44 (data_structure -> map_var .)
    DEFAULT         reduce using rule 44 (data_structure -> map_var .)
    CASE            reduce using rule 44 (data_structure -> map_var .)
    RETURN          reduce using rule 44 (data_structure -> map_var .)


state 95

    (26) values -> STRING .

    COLON           reduce using rule 26 (values -> STRING .)
    $end            reduce using rule 26 (values -> STRING .)
    RLLAVE          reduce using rule 26 (values -> STRING .)
    DEFAULT         reduce using rule 26 (values -> STRING .)
    CASE            reduce using rule 26 (values -> STRING .)
    RETURN          reduce using rule 26 (values -> STRING .)
    RCORCHE         reduce using rule 26 (values -> STRING .)
    RPAREN          reduce using rule 26 (values -> STRING .)
    POINTS          reduce using rule 26 (values -> STRING .)
    COMA            reduce using rule 26 (values -> STRING .)


state 96

    (27) values -> INTEGER .
    (154) factor -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 27 (values -> INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 27 (values -> INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 27 (values -> INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 27 (values -> INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 27 (values -> INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 27 (values -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 27 (values -> INTEGER .)
    COLON           reduce using rule 27 (values -> INTEGER .)
    $end            reduce using rule 27 (values -> INTEGER .)
    RLLAVE          reduce using rule 27 (values -> INTEGER .)
    DEFAULT         reduce using rule 27 (values -> INTEGER .)
    CASE            reduce using rule 27 (values -> INTEGER .)
    RETURN          reduce using rule 27 (values -> INTEGER .)
    COMA            reduce using rule 27 (values -> INTEGER .)
    TIMES           reduce using rule 154 (factor -> INTEGER .)
    DIVIDE          reduce using rule 154 (factor -> INTEGER .)
    PLUS            reduce using rule 154 (factor -> INTEGER .)
    MINUS           reduce using rule 154 (factor -> INTEGER .)
    GREATER         reduce using rule 154 (factor -> INTEGER .)
    SMALLER         reduce using rule 154 (factor -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 154 (factor -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 154 (factor -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 154 (factor -> INTEGER .)
    NOT_EQUAL       reduce using rule 154 (factor -> INTEGER .)

  ! COLON           [ reduce using rule 154 (factor -> INTEGER .) ]
  ! $end            [ reduce using rule 154 (factor -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 154 (factor -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 154 (factor -> INTEGER .) ]
  ! CASE            [ reduce using rule 154 (factor -> INTEGER .) ]
  ! RETURN          [ reduce using rule 154 (factor -> INTEGER .) ]
  ! COMA            [ reduce using rule 154 (factor -> INTEGER .) ]


state 97

    (28) values -> FLOAT .

    COLON           reduce using rule 28 (values -> FLOAT .)
    $end            reduce using rule 28 (values -> FLOAT .)
    RLLAVE          reduce using rule 28 (values -> FLOAT .)
    DEFAULT         reduce using rule 28 (values -> FLOAT .)
    CASE            reduce using rule 28 (values -> FLOAT .)
    RETURN          reduce using rule 28 (values -> FLOAT .)
    RCORCHE         reduce using rule 28 (values -> FLOAT .)
    RPAREN          reduce using rule 28 (values -> FLOAT .)
    POINTS          reduce using rule 28 (values -> FLOAT .)
    COMA            reduce using rule 28 (values -> FLOAT .)


state 98

    (29) values -> TRUE .

    COLON           reduce using rule 29 (values -> TRUE .)
    $end            reduce using rule 29 (values -> TRUE .)
    RLLAVE          reduce using rule 29 (values -> TRUE .)
    DEFAULT         reduce using rule 29 (values -> TRUE .)
    CASE            reduce using rule 29 (values -> TRUE .)
    RETURN          reduce using rule 29 (values -> TRUE .)
    RCORCHE         reduce using rule 29 (values -> TRUE .)
    RPAREN          reduce using rule 29 (values -> TRUE .)
    POINTS          reduce using rule 29 (values -> TRUE .)
    COMA            reduce using rule 29 (values -> TRUE .)


state 99

    (30) values -> FALSE .

    COLON           reduce using rule 30 (values -> FALSE .)
    $end            reduce using rule 30 (values -> FALSE .)
    RLLAVE          reduce using rule 30 (values -> FALSE .)
    DEFAULT         reduce using rule 30 (values -> FALSE .)
    CASE            reduce using rule 30 (values -> FALSE .)
    RETURN          reduce using rule 30 (values -> FALSE .)
    RCORCHE         reduce using rule 30 (values -> FALSE .)
    RPAREN          reduce using rule 30 (values -> FALSE .)
    POINTS          reduce using rule 30 (values -> FALSE .)
    COMA            reduce using rule 30 (values -> FALSE .)


state 100

    (40) operations -> expression .
    (148) expression -> expression . PLUS term
    (149) expression -> expression . MINUS term
    (99) value -> expression .

    COLON           reduce using rule 40 (operations -> expression .)
    $end            reduce using rule 40 (operations -> expression .)
    RLLAVE          reduce using rule 40 (operations -> expression .)
    DEFAULT         reduce using rule 40 (operations -> expression .)
    CASE            reduce using rule 40 (operations -> expression .)
    RETURN          reduce using rule 40 (operations -> expression .)
    COMA            reduce using rule 40 (operations -> expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    GREATER         reduce using rule 99 (value -> expression .)
    SMALLER         reduce using rule 99 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 99 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 99 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 99 (value -> expression .)
    NOT_EQUAL       reduce using rule 99 (value -> expression .)


state 101

    (41) operations -> comparison .
    (109) logic_value -> comparison .

    COLON           reduce using rule 41 (operations -> comparison .)
    $end            reduce using rule 41 (operations -> comparison .)
    RLLAVE          reduce using rule 41 (operations -> comparison .)
    DEFAULT         reduce using rule 41 (operations -> comparison .)
    CASE            reduce using rule 41 (operations -> comparison .)
    RETURN          reduce using rule 41 (operations -> comparison .)
    RCORCHE         reduce using rule 41 (operations -> comparison .)
    COMA            reduce using rule 41 (operations -> comparison .)
    AND             reduce using rule 109 (logic_value -> comparison .)
    OR              reduce using rule 109 (logic_value -> comparison .)


state 102

    (42) operations -> logic_operation .

    COLON           reduce using rule 42 (operations -> logic_operation .)
    $end            reduce using rule 42 (operations -> logic_operation .)
    RLLAVE          reduce using rule 42 (operations -> logic_operation .)
    DEFAULT         reduce using rule 42 (operations -> logic_operation .)
    CASE            reduce using rule 42 (operations -> logic_operation .)
    RETURN          reduce using rule 42 (operations -> logic_operation .)
    RCORCHE         reduce using rule 42 (operations -> logic_operation .)
    COMA            reduce using rule 42 (operations -> logic_operation .)


state 103

    (147) impresion -> PRINT LPAREN expression . RPAREN
    (148) expression -> expression . PLUS term
    (149) expression -> expression . MINUS term

    RPAREN          shift and go to state 145
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43


state 104

    (156) factor -> LPAREN expression RPAREN .

    TIMES           reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    DIVIDE          reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    COLON           reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    PLUS            reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    MINUS           reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    $end            reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    GREATER         reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    SMALLER         reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    GREATER_OR_EQUAL reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    SMALLER_OR_EQUAL reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    EQUAL_COMPARE   reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    NOT_EQUAL       reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    RPAREN          reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    RLLAVE          reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    CASE            reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    RETURN          reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    AND             reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    OR              reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    LLLAVE          reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    RCORCHE         reduce using rule 156 (factor -> LPAREN expression RPAREN .)
    COMA            reduce using rule 156 (factor -> LPAREN expression RPAREN .)


state 105

    (151) term -> term TIMES factor .

    TIMES           reduce using rule 151 (term -> term TIMES factor .)
    DIVIDE          reduce using rule 151 (term -> term TIMES factor .)
    COLON           reduce using rule 151 (term -> term TIMES factor .)
    PLUS            reduce using rule 151 (term -> term TIMES factor .)
    MINUS           reduce using rule 151 (term -> term TIMES factor .)
    $end            reduce using rule 151 (term -> term TIMES factor .)
    GREATER         reduce using rule 151 (term -> term TIMES factor .)
    SMALLER         reduce using rule 151 (term -> term TIMES factor .)
    GREATER_OR_EQUAL reduce using rule 151 (term -> term TIMES factor .)
    SMALLER_OR_EQUAL reduce using rule 151 (term -> term TIMES factor .)
    EQUAL_COMPARE   reduce using rule 151 (term -> term TIMES factor .)
    NOT_EQUAL       reduce using rule 151 (term -> term TIMES factor .)
    RPAREN          reduce using rule 151 (term -> term TIMES factor .)
    RLLAVE          reduce using rule 151 (term -> term TIMES factor .)
    DEFAULT         reduce using rule 151 (term -> term TIMES factor .)
    CASE            reduce using rule 151 (term -> term TIMES factor .)
    RETURN          reduce using rule 151 (term -> term TIMES factor .)
    AND             reduce using rule 151 (term -> term TIMES factor .)
    OR              reduce using rule 151 (term -> term TIMES factor .)
    LLLAVE          reduce using rule 151 (term -> term TIMES factor .)
    RCORCHE         reduce using rule 151 (term -> term TIMES factor .)
    COMA            reduce using rule 151 (term -> term TIMES factor .)


state 106

    (152) term -> term DIVIDE factor .

    TIMES           reduce using rule 152 (term -> term DIVIDE factor .)
    DIVIDE          reduce using rule 152 (term -> term DIVIDE factor .)
    COLON           reduce using rule 152 (term -> term DIVIDE factor .)
    PLUS            reduce using rule 152 (term -> term DIVIDE factor .)
    MINUS           reduce using rule 152 (term -> term DIVIDE factor .)
    $end            reduce using rule 152 (term -> term DIVIDE factor .)
    GREATER         reduce using rule 152 (term -> term DIVIDE factor .)
    SMALLER         reduce using rule 152 (term -> term DIVIDE factor .)
    GREATER_OR_EQUAL reduce using rule 152 (term -> term DIVIDE factor .)
    SMALLER_OR_EQUAL reduce using rule 152 (term -> term DIVIDE factor .)
    EQUAL_COMPARE   reduce using rule 152 (term -> term DIVIDE factor .)
    NOT_EQUAL       reduce using rule 152 (term -> term DIVIDE factor .)
    RPAREN          reduce using rule 152 (term -> term DIVIDE factor .)
    RLLAVE          reduce using rule 152 (term -> term DIVIDE factor .)
    DEFAULT         reduce using rule 152 (term -> term DIVIDE factor .)
    CASE            reduce using rule 152 (term -> term DIVIDE factor .)
    RETURN          reduce using rule 152 (term -> term DIVIDE factor .)
    AND             reduce using rule 152 (term -> term DIVIDE factor .)
    OR              reduce using rule 152 (term -> term DIVIDE factor .)
    LLLAVE          reduce using rule 152 (term -> term DIVIDE factor .)
    RCORCHE         reduce using rule 152 (term -> term DIVIDE factor .)
    COMA            reduce using rule 152 (term -> term DIVIDE factor .)


state 107

    (55) cicloFor -> FOR LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 146


state 108

    (56) cicloFor -> FOR comparison LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . map_declaration COLON
    (22) codigo -> . map_declaration
    (23) codigo -> . map_assignment COLON
    (24) codigo -> . map_assignment
    (25) codigo -> . func_declaration
    (147) impresion -> . PRINT LPAREN expression RPAREN
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (55) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (56) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (57) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (58) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (61) decVar -> . decVarOne
    (62) decVar -> . VAR ID EQUAL INTEGER
    (63) decVar -> . VAR ID EQUAL ID
    (64) decVar -> . VAR ID EQUAL FLOAT
    (65) decVar -> . VAR ID EQUAL expression
    (66) decVar -> . VAR ID EQUAL logic_operation
    (67) decVar -> . VAR ID EQUAL comparison
    (68) decVar -> . sliceC
    (69) decVar -> . VAR ID EQUAL STRING
    (70) decVar -> . ID DEQUAL STRING
    (71) decVar -> . ID DEQUAL FLOAT
    (72) decVar -> . ID DEQUAL expression
    (73) decVar -> . ID DEQUAL logic_operation
    (74) decVar -> . ID DEQUAL comparison
    (83) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (84) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (85) funciones -> . LEN LPAREN ID RPAREN
    (86) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (87) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (90) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (91) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (92) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (93) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (115) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (120) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (121) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (125) array_var -> . ID LCORCHE index RCORCHE
    (129) array_assignment -> . array_var EQUAL something
    (130) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (135) map_assignment -> . array_var EQUAL something
    (136) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (88) decVarOne -> . ID DEQUAL ID
    (89) decVarOne -> . ID DEQUAL INTEGER
    (75) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (76) sliceC -> . ID DEQUAL funM
    (77) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 18
    FOR             shift and go to state 21
    VAR             shift and go to state 26
    ID              shift and go to state 27
    APPEND          shift and go to state 30
    LEN             shift and go to state 31
    COPY            shift and go to state 32
    DELETE          shift and go to state 33
    IF              shift and go to state 34
    TYPE            shift and go to state 35
    SWITCH          shift and go to state 36
    FUNC            shift and go to state 37
    NOT             shift and go to state 39
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    comparison                     shift and go to state 5
    codigo                         shift and go to state 147
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    map_declaration                shift and go to state 15
    map_assignment                 shift and go to state 16
    func_declaration               shift and go to state 17
    term                           shift and go to state 20
    decVarOne                      shift and go to state 22
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    sliceC                         shift and go to state 29
    factor                         shift and go to state 38

state 109

    (57) cicloFor -> FOR logic_operation LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . map_declaration COLON
    (22) codigo -> . map_declaration
    (23) codigo -> . map_assignment COLON
    (24) codigo -> . map_assignment
    (25) codigo -> . func_declaration
    (147) impresion -> . PRINT LPAREN expression RPAREN
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (55) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (56) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (57) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (58) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (61) decVar -> . decVarOne
    (62) decVar -> . VAR ID EQUAL INTEGER
    (63) decVar -> . VAR ID EQUAL ID
    (64) decVar -> . VAR ID EQUAL FLOAT
    (65) decVar -> . VAR ID EQUAL expression
    (66) decVar -> . VAR ID EQUAL logic_operation
    (67) decVar -> . VAR ID EQUAL comparison
    (68) decVar -> . sliceC
    (69) decVar -> . VAR ID EQUAL STRING
    (70) decVar -> . ID DEQUAL STRING
    (71) decVar -> . ID DEQUAL FLOAT
    (72) decVar -> . ID DEQUAL expression
    (73) decVar -> . ID DEQUAL logic_operation
    (74) decVar -> . ID DEQUAL comparison
    (83) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (84) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (85) funciones -> . LEN LPAREN ID RPAREN
    (86) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (87) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (90) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (91) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (92) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (93) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (115) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (120) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (121) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (125) array_var -> . ID LCORCHE index RCORCHE
    (129) array_assignment -> . array_var EQUAL something
    (130) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (135) map_assignment -> . array_var EQUAL something
    (136) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (88) decVarOne -> . ID DEQUAL ID
    (89) decVarOne -> . ID DEQUAL INTEGER
    (75) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (76) sliceC -> . ID DEQUAL funM
    (77) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 18
    FOR             shift and go to state 21
    VAR             shift and go to state 26
    ID              shift and go to state 27
    APPEND          shift and go to state 30
    LEN             shift and go to state 31
    COPY            shift and go to state 32
    DELETE          shift and go to state 33
    IF              shift and go to state 34
    TYPE            shift and go to state 35
    SWITCH          shift and go to state 36
    FUNC            shift and go to state 37
    NOT             shift and go to state 39
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    logic_operation                shift and go to state 6
    codigo                         shift and go to state 148
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    map_declaration                shift and go to state 15
    map_assignment                 shift and go to state 16
    func_declaration               shift and go to state 17
    term                           shift and go to state 20
    decVarOne                      shift and go to state 22
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    sliceC                         shift and go to state 29
    factor                         shift and go to state 38

state 110

    (58) cicloFor -> FOR decVarOne COLON . comparison COLON incre LLLAVE codigo RLLAVE
    (97) comparison -> . value op value
    (98) value -> . ID
    (99) value -> . expression
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 113
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    comparison                     shift and go to state 149
    value                          shift and go to state 23
    expression                     shift and go to state 62
    term                           shift and go to state 20
    factor                         shift and go to state 38

state 111

    (88) decVarOne -> ID DEQUAL . ID
    (89) decVarOne -> ID DEQUAL . INTEGER

    ID              shift and go to state 150
    INTEGER         shift and go to state 151


state 112

    (97) comparison -> value op value .

    $end            reduce using rule 97 (comparison -> value op value .)
    AND             reduce using rule 97 (comparison -> value op value .)
    OR              reduce using rule 97 (comparison -> value op value .)
    LLLAVE          reduce using rule 97 (comparison -> value op value .)
    COLON           reduce using rule 97 (comparison -> value op value .)
    RLLAVE          reduce using rule 97 (comparison -> value op value .)
    DEFAULT         reduce using rule 97 (comparison -> value op value .)
    CASE            reduce using rule 97 (comparison -> value op value .)
    RETURN          reduce using rule 97 (comparison -> value op value .)
    RCORCHE         reduce using rule 97 (comparison -> value op value .)
    COMA            reduce using rule 97 (comparison -> value op value .)
    RPAREN          reduce using rule 97 (comparison -> value op value .)


state 113

    (98) value -> ID .
    (155) factor -> ID .

  ! reduce/reduce conflict for $end resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for AND resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for OR resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for LLLAVE resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for COLON resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for CASE resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for RPAREN resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 98 (value -> ID .)
    $end            reduce using rule 98 (value -> ID .)
    AND             reduce using rule 98 (value -> ID .)
    OR              reduce using rule 98 (value -> ID .)
    LLLAVE          reduce using rule 98 (value -> ID .)
    COLON           reduce using rule 98 (value -> ID .)
    RLLAVE          reduce using rule 98 (value -> ID .)
    DEFAULT         reduce using rule 98 (value -> ID .)
    CASE            reduce using rule 98 (value -> ID .)
    RETURN          reduce using rule 98 (value -> ID .)
    RCORCHE         reduce using rule 98 (value -> ID .)
    COMA            reduce using rule 98 (value -> ID .)
    RPAREN          reduce using rule 98 (value -> ID .)
    GREATER         reduce using rule 98 (value -> ID .)
    SMALLER         reduce using rule 98 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 98 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 98 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 98 (value -> ID .)
    NOT_EQUAL       reduce using rule 98 (value -> ID .)
    TIMES           reduce using rule 155 (factor -> ID .)
    DIVIDE          reduce using rule 155 (factor -> ID .)
    PLUS            reduce using rule 155 (factor -> ID .)
    MINUS           reduce using rule 155 (factor -> ID .)

  ! $end            [ reduce using rule 155 (factor -> ID .) ]
  ! AND             [ reduce using rule 155 (factor -> ID .) ]
  ! OR              [ reduce using rule 155 (factor -> ID .) ]
  ! LLLAVE          [ reduce using rule 155 (factor -> ID .) ]
  ! COLON           [ reduce using rule 155 (factor -> ID .) ]
  ! RLLAVE          [ reduce using rule 155 (factor -> ID .) ]
  ! DEFAULT         [ reduce using rule 155 (factor -> ID .) ]
  ! CASE            [ reduce using rule 155 (factor -> ID .) ]
  ! RETURN          [ reduce using rule 155 (factor -> ID .) ]
  ! RCORCHE         [ reduce using rule 155 (factor -> ID .) ]
  ! COMA            [ reduce using rule 155 (factor -> ID .) ]
  ! RPAREN          [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER         [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 155 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 155 (factor -> ID .) ]


state 114

    (106) logic_operation -> logic_value logic_op logic_value .

    $end            reduce using rule 106 (logic_operation -> logic_value logic_op logic_value .)
    LLLAVE          reduce using rule 106 (logic_operation -> logic_value logic_op logic_value .)
    COLON           reduce using rule 106 (logic_operation -> logic_value logic_op logic_value .)
    RLLAVE          reduce using rule 106 (logic_operation -> logic_value logic_op logic_value .)
    DEFAULT         reduce using rule 106 (logic_operation -> logic_value logic_op logic_value .)
    CASE            reduce using rule 106 (logic_operation -> logic_value logic_op logic_value .)
    RETURN          reduce using rule 106 (logic_operation -> logic_value logic_op logic_value .)
    RCORCHE         reduce using rule 106 (logic_operation -> logic_value logic_op logic_value .)
    COMA            reduce using rule 106 (logic_operation -> logic_value logic_op logic_value .)


state 115

    (108) logic_value -> negation .

    $end            reduce using rule 108 (logic_value -> negation .)
    LLLAVE          reduce using rule 108 (logic_value -> negation .)
    COLON           reduce using rule 108 (logic_value -> negation .)
    RLLAVE          reduce using rule 108 (logic_value -> negation .)
    DEFAULT         reduce using rule 108 (logic_value -> negation .)
    CASE            reduce using rule 108 (logic_value -> negation .)
    RETURN          reduce using rule 108 (logic_value -> negation .)
    RCORCHE         reduce using rule 108 (logic_value -> negation .)
    COMA            reduce using rule 108 (logic_value -> negation .)


state 116

    (109) logic_value -> comparison .

    $end            reduce using rule 109 (logic_value -> comparison .)
    LLLAVE          reduce using rule 109 (logic_value -> comparison .)
    COLON           reduce using rule 109 (logic_value -> comparison .)
    RLLAVE          reduce using rule 109 (logic_value -> comparison .)
    DEFAULT         reduce using rule 109 (logic_value -> comparison .)
    CASE            reduce using rule 109 (logic_value -> comparison .)
    RETURN          reduce using rule 109 (logic_value -> comparison .)
    RCORCHE         reduce using rule 109 (logic_value -> comparison .)
    COMA            reduce using rule 109 (logic_value -> comparison .)


state 117

    (110) logic_value -> ID .
    (98) value -> ID .
    (155) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 98 (value -> ID .)
    $end            reduce using rule 110 (logic_value -> ID .)
    LLLAVE          reduce using rule 110 (logic_value -> ID .)
    COLON           reduce using rule 110 (logic_value -> ID .)
    RLLAVE          reduce using rule 110 (logic_value -> ID .)
    DEFAULT         reduce using rule 110 (logic_value -> ID .)
    CASE            reduce using rule 110 (logic_value -> ID .)
    RETURN          reduce using rule 110 (logic_value -> ID .)
    RCORCHE         reduce using rule 110 (logic_value -> ID .)
    COMA            reduce using rule 110 (logic_value -> ID .)
    GREATER         reduce using rule 98 (value -> ID .)
    SMALLER         reduce using rule 98 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 98 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 98 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 98 (value -> ID .)
    NOT_EQUAL       reduce using rule 98 (value -> ID .)
    TIMES           reduce using rule 155 (factor -> ID .)
    DIVIDE          reduce using rule 155 (factor -> ID .)
    PLUS            reduce using rule 155 (factor -> ID .)
    MINUS           reduce using rule 155 (factor -> ID .)

  ! GREATER         [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 155 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 155 (factor -> ID .) ]


state 118

    (62) decVar -> VAR ID EQUAL . INTEGER
    (63) decVar -> VAR ID EQUAL . ID
    (64) decVar -> VAR ID EQUAL . FLOAT
    (65) decVar -> VAR ID EQUAL . expression
    (66) decVar -> VAR ID EQUAL . logic_operation
    (67) decVar -> VAR ID EQUAL . comparison
    (69) decVar -> VAR ID EQUAL . STRING
    (121) array_declaration -> VAR ID EQUAL . LCORCHE capacity RCORCHE data_types arr_content
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (97) comparison -> . value op value
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (98) value -> . ID
    (99) value -> . expression
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 153
    ID              shift and go to state 152
    FLOAT           shift and go to state 154
    STRING          shift and go to state 158
    LCORCHE         shift and go to state 159
    NOT             shift and go to state 39
    LPAREN          shift and go to state 19

    expression                     shift and go to state 155
    logic_operation                shift and go to state 156
    comparison                     shift and go to state 157
    term                           shift and go to state 20
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    value                          shift and go to state 23
    factor                         shift and go to state 38

state 119

    (120) array_declaration -> VAR ID LCORCHE . capacity RCORCHE data_types
    (130) map_declaration -> VAR ID LCORCHE . data_types RCORCHE data_types
    (75) sliceC -> VAR ID LCORCHE . RCORCHE data_types
    (122) capacity -> . INTEGER
    (123) capacity -> . ID
    (124) capacity -> . expression
    (31) data_types -> . INT32
    (32) data_types -> . INT64
    (33) data_types -> . FLOAT32
    (34) data_types -> . FLOAT64
    (35) data_types -> . BYTE
    (36) data_types -> . WINT
    (37) data_types -> . WFLOAT
    (38) data_types -> . WSTRING
    (39) data_types -> . BOOL
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    RCORCHE         shift and go to state 162
    INTEGER         shift and go to state 164
    ID              shift and go to state 160
    INT32           shift and go to state 166
    INT64           shift and go to state 167
    FLOAT32         shift and go to state 168
    FLOAT64         shift and go to state 169
    BYTE            shift and go to state 170
    WINT            shift and go to state 171
    WFLOAT          shift and go to state 172
    WSTRING         shift and go to state 173
    BOOL            shift and go to state 174
    LPAREN          shift and go to state 19

    capacity                       shift and go to state 161
    data_types                     shift and go to state 163
    expression                     shift and go to state 165
    term                           shift and go to state 20
    factor                         shift and go to state 38

state 120

    (88) decVarOne -> ID DEQUAL ID .
    (110) logic_value -> ID .
    (98) value -> ID .
    (155) factor -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 88 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for $end resolved using rule 88 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 88 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 88 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for CASE resolved using rule 88 (decVarOne -> ID DEQUAL ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 88 (decVarOne -> ID DEQUAL ID .)
    COLON           reduce using rule 88 (decVarOne -> ID DEQUAL ID .)
    $end            reduce using rule 88 (decVarOne -> ID DEQUAL ID .)
    RLLAVE          reduce using rule 88 (decVarOne -> ID DEQUAL ID .)
    DEFAULT         reduce using rule 88 (decVarOne -> ID DEQUAL ID .)
    CASE            reduce using rule 88 (decVarOne -> ID DEQUAL ID .)
    RETURN          reduce using rule 88 (decVarOne -> ID DEQUAL ID .)
    AND             reduce using rule 110 (logic_value -> ID .)
    OR              reduce using rule 110 (logic_value -> ID .)
    GREATER         reduce using rule 98 (value -> ID .)
    SMALLER         reduce using rule 98 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 98 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 98 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 98 (value -> ID .)
    NOT_EQUAL       reduce using rule 98 (value -> ID .)
    TIMES           reduce using rule 155 (factor -> ID .)
    DIVIDE          reduce using rule 155 (factor -> ID .)
    PLUS            reduce using rule 155 (factor -> ID .)
    MINUS           reduce using rule 155 (factor -> ID .)

  ! COLON           [ reduce using rule 155 (factor -> ID .) ]
  ! $end            [ reduce using rule 155 (factor -> ID .) ]
  ! RLLAVE          [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER         [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 155 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 155 (factor -> ID .) ]
  ! DEFAULT         [ reduce using rule 155 (factor -> ID .) ]
  ! CASE            [ reduce using rule 155 (factor -> ID .) ]
  ! RETURN          [ reduce using rule 155 (factor -> ID .) ]


state 121

    (70) decVar -> ID DEQUAL STRING .

    COLON           reduce using rule 70 (decVar -> ID DEQUAL STRING .)
    $end            reduce using rule 70 (decVar -> ID DEQUAL STRING .)
    RLLAVE          reduce using rule 70 (decVar -> ID DEQUAL STRING .)
    DEFAULT         reduce using rule 70 (decVar -> ID DEQUAL STRING .)
    CASE            reduce using rule 70 (decVar -> ID DEQUAL STRING .)
    RETURN          reduce using rule 70 (decVar -> ID DEQUAL STRING .)


state 122

    (71) decVar -> ID DEQUAL FLOAT .

    COLON           reduce using rule 71 (decVar -> ID DEQUAL FLOAT .)
    $end            reduce using rule 71 (decVar -> ID DEQUAL FLOAT .)
    RLLAVE          reduce using rule 71 (decVar -> ID DEQUAL FLOAT .)
    DEFAULT         reduce using rule 71 (decVar -> ID DEQUAL FLOAT .)
    CASE            reduce using rule 71 (decVar -> ID DEQUAL FLOAT .)
    RETURN          reduce using rule 71 (decVar -> ID DEQUAL FLOAT .)


state 123

    (72) decVar -> ID DEQUAL expression .
    (148) expression -> expression . PLUS term
    (149) expression -> expression . MINUS term
    (99) value -> expression .

    COLON           reduce using rule 72 (decVar -> ID DEQUAL expression .)
    $end            reduce using rule 72 (decVar -> ID DEQUAL expression .)
    RLLAVE          reduce using rule 72 (decVar -> ID DEQUAL expression .)
    DEFAULT         reduce using rule 72 (decVar -> ID DEQUAL expression .)
    CASE            reduce using rule 72 (decVar -> ID DEQUAL expression .)
    RETURN          reduce using rule 72 (decVar -> ID DEQUAL expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    GREATER         reduce using rule 99 (value -> expression .)
    SMALLER         reduce using rule 99 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 99 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 99 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 99 (value -> expression .)
    NOT_EQUAL       reduce using rule 99 (value -> expression .)


state 124

    (73) decVar -> ID DEQUAL logic_operation .

    COLON           reduce using rule 73 (decVar -> ID DEQUAL logic_operation .)
    $end            reduce using rule 73 (decVar -> ID DEQUAL logic_operation .)
    RLLAVE          reduce using rule 73 (decVar -> ID DEQUAL logic_operation .)
    DEFAULT         reduce using rule 73 (decVar -> ID DEQUAL logic_operation .)
    CASE            reduce using rule 73 (decVar -> ID DEQUAL logic_operation .)
    RETURN          reduce using rule 73 (decVar -> ID DEQUAL logic_operation .)


state 125

    (74) decVar -> ID DEQUAL comparison .
    (109) logic_value -> comparison .

    COLON           reduce using rule 74 (decVar -> ID DEQUAL comparison .)
    $end            reduce using rule 74 (decVar -> ID DEQUAL comparison .)
    RLLAVE          reduce using rule 74 (decVar -> ID DEQUAL comparison .)
    DEFAULT         reduce using rule 74 (decVar -> ID DEQUAL comparison .)
    CASE            reduce using rule 74 (decVar -> ID DEQUAL comparison .)
    RETURN          reduce using rule 74 (decVar -> ID DEQUAL comparison .)
    AND             reduce using rule 109 (logic_value -> comparison .)
    OR              reduce using rule 109 (logic_value -> comparison .)


state 126

    (89) decVarOne -> ID DEQUAL INTEGER .
    (154) factor -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 89 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 89 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 89 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 89 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 89 (decVarOne -> ID DEQUAL INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 89 (decVarOne -> ID DEQUAL INTEGER .)
    COLON           reduce using rule 89 (decVarOne -> ID DEQUAL INTEGER .)
    $end            reduce using rule 89 (decVarOne -> ID DEQUAL INTEGER .)
    RLLAVE          reduce using rule 89 (decVarOne -> ID DEQUAL INTEGER .)
    DEFAULT         reduce using rule 89 (decVarOne -> ID DEQUAL INTEGER .)
    CASE            reduce using rule 89 (decVarOne -> ID DEQUAL INTEGER .)
    RETURN          reduce using rule 89 (decVarOne -> ID DEQUAL INTEGER .)
    TIMES           reduce using rule 154 (factor -> INTEGER .)
    DIVIDE          reduce using rule 154 (factor -> INTEGER .)
    PLUS            reduce using rule 154 (factor -> INTEGER .)
    MINUS           reduce using rule 154 (factor -> INTEGER .)
    GREATER         reduce using rule 154 (factor -> INTEGER .)
    SMALLER         reduce using rule 154 (factor -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 154 (factor -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 154 (factor -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 154 (factor -> INTEGER .)
    NOT_EQUAL       reduce using rule 154 (factor -> INTEGER .)

  ! COLON           [ reduce using rule 154 (factor -> INTEGER .) ]
  ! $end            [ reduce using rule 154 (factor -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 154 (factor -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 154 (factor -> INTEGER .) ]
  ! CASE            [ reduce using rule 154 (factor -> INTEGER .) ]
  ! RETURN          [ reduce using rule 154 (factor -> INTEGER .) ]


state 127

    (76) sliceC -> ID DEQUAL funM .

    COLON           reduce using rule 76 (sliceC -> ID DEQUAL funM .)
    $end            reduce using rule 76 (sliceC -> ID DEQUAL funM .)
    RLLAVE          reduce using rule 76 (sliceC -> ID DEQUAL funM .)
    DEFAULT         reduce using rule 76 (sliceC -> ID DEQUAL funM .)
    CASE            reduce using rule 76 (sliceC -> ID DEQUAL funM .)
    RETURN          reduce using rule 76 (sliceC -> ID DEQUAL funM .)


state 128

    (77) sliceC -> ID DEQUAL LCORCHE . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 175


state 129

    (78) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN
    (79) funM -> MAKE . LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LPAREN          shift and go to state 176


state 130

    (126) index -> ID .
    (155) factor -> ID .

  ! reduce/reduce conflict for RCORCHE resolved using rule 126 (index -> ID .)
    RCORCHE         reduce using rule 126 (index -> ID .)
    TIMES           reduce using rule 155 (factor -> ID .)
    DIVIDE          reduce using rule 155 (factor -> ID .)
    PLUS            reduce using rule 155 (factor -> ID .)
    MINUS           reduce using rule 155 (factor -> ID .)

  ! RCORCHE         [ reduce using rule 155 (factor -> ID .) ]


state 131

    (125) array_var -> ID LCORCHE index . RCORCHE

    RCORCHE         shift and go to state 177


state 132

    (127) index -> INTEGER .
    (154) factor -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 127 (index -> INTEGER .)
    RCORCHE         reduce using rule 127 (index -> INTEGER .)
    TIMES           reduce using rule 154 (factor -> INTEGER .)
    DIVIDE          reduce using rule 154 (factor -> INTEGER .)
    PLUS            reduce using rule 154 (factor -> INTEGER .)
    MINUS           reduce using rule 154 (factor -> INTEGER .)

  ! RCORCHE         [ reduce using rule 154 (factor -> INTEGER .) ]


state 133

    (128) index -> expression .
    (148) expression -> expression . PLUS term
    (149) expression -> expression . MINUS term

    RCORCHE         reduce using rule 128 (index -> expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43


state 134

    (83) funciones -> APPEND LPAREN ID . COMA values RPAREN
    (84) funciones -> APPEND LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 178


state 135

    (85) funciones -> LEN LPAREN ID . RPAREN

    RPAREN          shift and go to state 179


state 136

    (86) funciones -> COPY LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 180


state 137

    (87) funciones -> DELETE LPAREN ID . COMA ID RPAREN

    COMA            shift and go to state 181


state 138

    (90) SenIF -> IF LPAREN comparison . RPAREN LLLAVE codigo RLLAVE

    RPAREN          shift and go to state 182


state 139

    (91) SenIF -> IF LPAREN TRUE . RPAREN LLLAVE codigo RLLAVE

    RPAREN          shift and go to state 183


state 140

    (92) SenIF -> IF LPAREN FALSE . RPAREN LLLAVE codigo RLLAVE

    RPAREN          shift and go to state 184


state 141

    (93) SenStruct -> TYPE ID STRUCT . LLLAVE declaration RLLAVE

    LLLAVE          shift and go to state 185


state 142

    (115) switch_statement -> SWITCH ID LLLAVE . cases RLLAVE
    (116) cases -> . CASE values POINTS codigo
    (117) cases -> . CASE values POINTS codigo more

    CASE            shift and go to state 187

    cases                          shift and go to state 186

state 143

    (136) func_declaration -> FUNC ID LPAREN . params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> FUNC ID LPAREN . params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (144) params -> . ID data_types
    (145) params -> . more_params
    (146) more_params -> . ID data_types COMA params

    ID              shift and go to state 188

    params                         shift and go to state 189
    more_params                    shift and go to state 190

state 144

    (125) array_var -> ID LCORCHE . index RCORCHE
    (131) map_var -> ID LCORCHE . key RCORCHE
    (126) index -> . ID
    (127) index -> . INTEGER
    (128) index -> . expression
    (132) key -> . ID
    (133) key -> . values
    (134) key -> . operations
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (26) values -> . STRING
    (27) values -> . INTEGER
    (28) values -> . FLOAT
    (29) values -> . TRUE
    (30) values -> . FALSE
    (40) operations -> . expression
    (41) operations -> . comparison
    (42) operations -> . logic_operation
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID

    ID              shift and go to state 191
    INTEGER         shift and go to state 193
    STRING          shift and go to state 95
    FLOAT           shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    LPAREN          shift and go to state 19
    NOT             shift and go to state 39

    index                          shift and go to state 131
    key                            shift and go to state 192
    expression                     shift and go to state 194
    values                         shift and go to state 195
    operations                     shift and go to state 196
    term                           shift and go to state 20
    comparison                     shift and go to state 101
    logic_operation                shift and go to state 102
    factor                         shift and go to state 38
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25

state 145

    (147) impresion -> PRINT LPAREN expression RPAREN .

    COLON           reduce using rule 147 (impresion -> PRINT LPAREN expression RPAREN .)
    $end            reduce using rule 147 (impresion -> PRINT LPAREN expression RPAREN .)
    RLLAVE          reduce using rule 147 (impresion -> PRINT LPAREN expression RPAREN .)
    DEFAULT         reduce using rule 147 (impresion -> PRINT LPAREN expression RPAREN .)
    CASE            reduce using rule 147 (impresion -> PRINT LPAREN expression RPAREN .)
    RETURN          reduce using rule 147 (impresion -> PRINT LPAREN expression RPAREN .)


state 146

    (55) cicloFor -> FOR LLLAVE codigo RLLAVE .

    $end            reduce using rule 55 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 55 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 55 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 55 (cicloFor -> FOR LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 55 (cicloFor -> FOR LLLAVE codigo RLLAVE .)


state 147

    (56) cicloFor -> FOR comparison LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 197


state 148

    (57) cicloFor -> FOR logic_operation LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 198


state 149

    (58) cicloFor -> FOR decVarOne COLON comparison . COLON incre LLLAVE codigo RLLAVE

    COLON           shift and go to state 199


state 150

    (88) decVarOne -> ID DEQUAL ID .

    COLON           reduce using rule 88 (decVarOne -> ID DEQUAL ID .)


state 151

    (89) decVarOne -> ID DEQUAL INTEGER .

    COLON           reduce using rule 89 (decVarOne -> ID DEQUAL INTEGER .)


state 152

    (63) decVar -> VAR ID EQUAL ID .
    (110) logic_value -> ID .
    (98) value -> ID .
    (155) factor -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 63 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for $end resolved using rule 63 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 63 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 63 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for CASE resolved using rule 63 (decVar -> VAR ID EQUAL ID .)
  ! reduce/reduce conflict for RETURN resolved using rule 63 (decVar -> VAR ID EQUAL ID .)
    COLON           reduce using rule 63 (decVar -> VAR ID EQUAL ID .)
    $end            reduce using rule 63 (decVar -> VAR ID EQUAL ID .)
    RLLAVE          reduce using rule 63 (decVar -> VAR ID EQUAL ID .)
    DEFAULT         reduce using rule 63 (decVar -> VAR ID EQUAL ID .)
    CASE            reduce using rule 63 (decVar -> VAR ID EQUAL ID .)
    RETURN          reduce using rule 63 (decVar -> VAR ID EQUAL ID .)
    AND             reduce using rule 110 (logic_value -> ID .)
    OR              reduce using rule 110 (logic_value -> ID .)
    GREATER         reduce using rule 98 (value -> ID .)
    SMALLER         reduce using rule 98 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 98 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 98 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 98 (value -> ID .)
    NOT_EQUAL       reduce using rule 98 (value -> ID .)
    TIMES           reduce using rule 155 (factor -> ID .)
    DIVIDE          reduce using rule 155 (factor -> ID .)
    PLUS            reduce using rule 155 (factor -> ID .)
    MINUS           reduce using rule 155 (factor -> ID .)

  ! COLON           [ reduce using rule 155 (factor -> ID .) ]
  ! $end            [ reduce using rule 155 (factor -> ID .) ]
  ! RLLAVE          [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER         [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 155 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 155 (factor -> ID .) ]
  ! DEFAULT         [ reduce using rule 155 (factor -> ID .) ]
  ! CASE            [ reduce using rule 155 (factor -> ID .) ]
  ! RETURN          [ reduce using rule 155 (factor -> ID .) ]


state 153

    (62) decVar -> VAR ID EQUAL INTEGER .
    (154) factor -> INTEGER .

  ! reduce/reduce conflict for COLON resolved using rule 62 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for $end resolved using rule 62 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 62 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for DEFAULT resolved using rule 62 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for CASE resolved using rule 62 (decVar -> VAR ID EQUAL INTEGER .)
  ! reduce/reduce conflict for RETURN resolved using rule 62 (decVar -> VAR ID EQUAL INTEGER .)
    COLON           reduce using rule 62 (decVar -> VAR ID EQUAL INTEGER .)
    $end            reduce using rule 62 (decVar -> VAR ID EQUAL INTEGER .)
    RLLAVE          reduce using rule 62 (decVar -> VAR ID EQUAL INTEGER .)
    DEFAULT         reduce using rule 62 (decVar -> VAR ID EQUAL INTEGER .)
    CASE            reduce using rule 62 (decVar -> VAR ID EQUAL INTEGER .)
    RETURN          reduce using rule 62 (decVar -> VAR ID EQUAL INTEGER .)
    TIMES           reduce using rule 154 (factor -> INTEGER .)
    DIVIDE          reduce using rule 154 (factor -> INTEGER .)
    PLUS            reduce using rule 154 (factor -> INTEGER .)
    MINUS           reduce using rule 154 (factor -> INTEGER .)
    GREATER         reduce using rule 154 (factor -> INTEGER .)
    SMALLER         reduce using rule 154 (factor -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 154 (factor -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 154 (factor -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 154 (factor -> INTEGER .)
    NOT_EQUAL       reduce using rule 154 (factor -> INTEGER .)

  ! COLON           [ reduce using rule 154 (factor -> INTEGER .) ]
  ! $end            [ reduce using rule 154 (factor -> INTEGER .) ]
  ! RLLAVE          [ reduce using rule 154 (factor -> INTEGER .) ]
  ! DEFAULT         [ reduce using rule 154 (factor -> INTEGER .) ]
  ! CASE            [ reduce using rule 154 (factor -> INTEGER .) ]
  ! RETURN          [ reduce using rule 154 (factor -> INTEGER .) ]


state 154

    (64) decVar -> VAR ID EQUAL FLOAT .

    COLON           reduce using rule 64 (decVar -> VAR ID EQUAL FLOAT .)
    $end            reduce using rule 64 (decVar -> VAR ID EQUAL FLOAT .)
    RLLAVE          reduce using rule 64 (decVar -> VAR ID EQUAL FLOAT .)
    DEFAULT         reduce using rule 64 (decVar -> VAR ID EQUAL FLOAT .)
    CASE            reduce using rule 64 (decVar -> VAR ID EQUAL FLOAT .)
    RETURN          reduce using rule 64 (decVar -> VAR ID EQUAL FLOAT .)


state 155

    (65) decVar -> VAR ID EQUAL expression .
    (148) expression -> expression . PLUS term
    (149) expression -> expression . MINUS term
    (99) value -> expression .

    COLON           reduce using rule 65 (decVar -> VAR ID EQUAL expression .)
    $end            reduce using rule 65 (decVar -> VAR ID EQUAL expression .)
    RLLAVE          reduce using rule 65 (decVar -> VAR ID EQUAL expression .)
    DEFAULT         reduce using rule 65 (decVar -> VAR ID EQUAL expression .)
    CASE            reduce using rule 65 (decVar -> VAR ID EQUAL expression .)
    RETURN          reduce using rule 65 (decVar -> VAR ID EQUAL expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    GREATER         reduce using rule 99 (value -> expression .)
    SMALLER         reduce using rule 99 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 99 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 99 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 99 (value -> expression .)
    NOT_EQUAL       reduce using rule 99 (value -> expression .)


state 156

    (66) decVar -> VAR ID EQUAL logic_operation .

    COLON           reduce using rule 66 (decVar -> VAR ID EQUAL logic_operation .)
    $end            reduce using rule 66 (decVar -> VAR ID EQUAL logic_operation .)
    RLLAVE          reduce using rule 66 (decVar -> VAR ID EQUAL logic_operation .)
    DEFAULT         reduce using rule 66 (decVar -> VAR ID EQUAL logic_operation .)
    CASE            reduce using rule 66 (decVar -> VAR ID EQUAL logic_operation .)
    RETURN          reduce using rule 66 (decVar -> VAR ID EQUAL logic_operation .)


state 157

    (67) decVar -> VAR ID EQUAL comparison .
    (109) logic_value -> comparison .

    COLON           reduce using rule 67 (decVar -> VAR ID EQUAL comparison .)
    $end            reduce using rule 67 (decVar -> VAR ID EQUAL comparison .)
    RLLAVE          reduce using rule 67 (decVar -> VAR ID EQUAL comparison .)
    DEFAULT         reduce using rule 67 (decVar -> VAR ID EQUAL comparison .)
    CASE            reduce using rule 67 (decVar -> VAR ID EQUAL comparison .)
    RETURN          reduce using rule 67 (decVar -> VAR ID EQUAL comparison .)
    AND             reduce using rule 109 (logic_value -> comparison .)
    OR              reduce using rule 109 (logic_value -> comparison .)


state 158

    (69) decVar -> VAR ID EQUAL STRING .

    COLON           reduce using rule 69 (decVar -> VAR ID EQUAL STRING .)
    $end            reduce using rule 69 (decVar -> VAR ID EQUAL STRING .)
    RLLAVE          reduce using rule 69 (decVar -> VAR ID EQUAL STRING .)
    DEFAULT         reduce using rule 69 (decVar -> VAR ID EQUAL STRING .)
    CASE            reduce using rule 69 (decVar -> VAR ID EQUAL STRING .)
    RETURN          reduce using rule 69 (decVar -> VAR ID EQUAL STRING .)


state 159

    (121) array_declaration -> VAR ID EQUAL LCORCHE . capacity RCORCHE data_types arr_content
    (122) capacity -> . INTEGER
    (123) capacity -> . ID
    (124) capacity -> . expression
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 164
    ID              shift and go to state 160
    LPAREN          shift and go to state 19

    capacity                       shift and go to state 200
    expression                     shift and go to state 165
    term                           shift and go to state 20
    factor                         shift and go to state 38

state 160

    (123) capacity -> ID .
    (155) factor -> ID .

  ! reduce/reduce conflict for RCORCHE resolved using rule 123 (capacity -> ID .)
    RCORCHE         reduce using rule 123 (capacity -> ID .)
    TIMES           reduce using rule 155 (factor -> ID .)
    DIVIDE          reduce using rule 155 (factor -> ID .)
    PLUS            reduce using rule 155 (factor -> ID .)
    MINUS           reduce using rule 155 (factor -> ID .)

  ! RCORCHE         [ reduce using rule 155 (factor -> ID .) ]


state 161

    (120) array_declaration -> VAR ID LCORCHE capacity . RCORCHE data_types

    RCORCHE         shift and go to state 201


state 162

    (75) sliceC -> VAR ID LCORCHE RCORCHE . data_types
    (31) data_types -> . INT32
    (32) data_types -> . INT64
    (33) data_types -> . FLOAT32
    (34) data_types -> . FLOAT64
    (35) data_types -> . BYTE
    (36) data_types -> . WINT
    (37) data_types -> . WFLOAT
    (38) data_types -> . WSTRING
    (39) data_types -> . BOOL

    INT32           shift and go to state 166
    INT64           shift and go to state 167
    FLOAT32         shift and go to state 168
    FLOAT64         shift and go to state 169
    BYTE            shift and go to state 170
    WINT            shift and go to state 171
    WFLOAT          shift and go to state 172
    WSTRING         shift and go to state 173
    BOOL            shift and go to state 174

    data_types                     shift and go to state 202

state 163

    (130) map_declaration -> VAR ID LCORCHE data_types . RCORCHE data_types

    RCORCHE         shift and go to state 203


state 164

    (122) capacity -> INTEGER .
    (154) factor -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 122 (capacity -> INTEGER .)
    RCORCHE         reduce using rule 122 (capacity -> INTEGER .)
    TIMES           reduce using rule 154 (factor -> INTEGER .)
    DIVIDE          reduce using rule 154 (factor -> INTEGER .)
    PLUS            reduce using rule 154 (factor -> INTEGER .)
    MINUS           reduce using rule 154 (factor -> INTEGER .)

  ! RCORCHE         [ reduce using rule 154 (factor -> INTEGER .) ]


state 165

    (124) capacity -> expression .
    (148) expression -> expression . PLUS term
    (149) expression -> expression . MINUS term

    RCORCHE         reduce using rule 124 (capacity -> expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43


state 166

    (31) data_types -> INT32 .

    RCORCHE         reduce using rule 31 (data_types -> INT32 .)
    COLON           reduce using rule 31 (data_types -> INT32 .)
    $end            reduce using rule 31 (data_types -> INT32 .)
    RLLAVE          reduce using rule 31 (data_types -> INT32 .)
    DEFAULT         reduce using rule 31 (data_types -> INT32 .)
    CASE            reduce using rule 31 (data_types -> INT32 .)
    RETURN          reduce using rule 31 (data_types -> INT32 .)
    LLLAVE          reduce using rule 31 (data_types -> INT32 .)
    COMA            reduce using rule 31 (data_types -> INT32 .)
    RPAREN          reduce using rule 31 (data_types -> INT32 .)
    ID              reduce using rule 31 (data_types -> INT32 .)


state 167

    (32) data_types -> INT64 .

    RCORCHE         reduce using rule 32 (data_types -> INT64 .)
    COLON           reduce using rule 32 (data_types -> INT64 .)
    $end            reduce using rule 32 (data_types -> INT64 .)
    RLLAVE          reduce using rule 32 (data_types -> INT64 .)
    DEFAULT         reduce using rule 32 (data_types -> INT64 .)
    CASE            reduce using rule 32 (data_types -> INT64 .)
    RETURN          reduce using rule 32 (data_types -> INT64 .)
    LLLAVE          reduce using rule 32 (data_types -> INT64 .)
    COMA            reduce using rule 32 (data_types -> INT64 .)
    RPAREN          reduce using rule 32 (data_types -> INT64 .)
    ID              reduce using rule 32 (data_types -> INT64 .)


state 168

    (33) data_types -> FLOAT32 .

    RCORCHE         reduce using rule 33 (data_types -> FLOAT32 .)
    COLON           reduce using rule 33 (data_types -> FLOAT32 .)
    $end            reduce using rule 33 (data_types -> FLOAT32 .)
    RLLAVE          reduce using rule 33 (data_types -> FLOAT32 .)
    DEFAULT         reduce using rule 33 (data_types -> FLOAT32 .)
    CASE            reduce using rule 33 (data_types -> FLOAT32 .)
    RETURN          reduce using rule 33 (data_types -> FLOAT32 .)
    LLLAVE          reduce using rule 33 (data_types -> FLOAT32 .)
    COMA            reduce using rule 33 (data_types -> FLOAT32 .)
    RPAREN          reduce using rule 33 (data_types -> FLOAT32 .)
    ID              reduce using rule 33 (data_types -> FLOAT32 .)


state 169

    (34) data_types -> FLOAT64 .

    RCORCHE         reduce using rule 34 (data_types -> FLOAT64 .)
    COLON           reduce using rule 34 (data_types -> FLOAT64 .)
    $end            reduce using rule 34 (data_types -> FLOAT64 .)
    RLLAVE          reduce using rule 34 (data_types -> FLOAT64 .)
    DEFAULT         reduce using rule 34 (data_types -> FLOAT64 .)
    CASE            reduce using rule 34 (data_types -> FLOAT64 .)
    RETURN          reduce using rule 34 (data_types -> FLOAT64 .)
    LLLAVE          reduce using rule 34 (data_types -> FLOAT64 .)
    COMA            reduce using rule 34 (data_types -> FLOAT64 .)
    RPAREN          reduce using rule 34 (data_types -> FLOAT64 .)
    ID              reduce using rule 34 (data_types -> FLOAT64 .)


state 170

    (35) data_types -> BYTE .

    RCORCHE         reduce using rule 35 (data_types -> BYTE .)
    COLON           reduce using rule 35 (data_types -> BYTE .)
    $end            reduce using rule 35 (data_types -> BYTE .)
    RLLAVE          reduce using rule 35 (data_types -> BYTE .)
    DEFAULT         reduce using rule 35 (data_types -> BYTE .)
    CASE            reduce using rule 35 (data_types -> BYTE .)
    RETURN          reduce using rule 35 (data_types -> BYTE .)
    LLLAVE          reduce using rule 35 (data_types -> BYTE .)
    COMA            reduce using rule 35 (data_types -> BYTE .)
    RPAREN          reduce using rule 35 (data_types -> BYTE .)
    ID              reduce using rule 35 (data_types -> BYTE .)


state 171

    (36) data_types -> WINT .

    RCORCHE         reduce using rule 36 (data_types -> WINT .)
    COLON           reduce using rule 36 (data_types -> WINT .)
    $end            reduce using rule 36 (data_types -> WINT .)
    RLLAVE          reduce using rule 36 (data_types -> WINT .)
    DEFAULT         reduce using rule 36 (data_types -> WINT .)
    CASE            reduce using rule 36 (data_types -> WINT .)
    RETURN          reduce using rule 36 (data_types -> WINT .)
    LLLAVE          reduce using rule 36 (data_types -> WINT .)
    COMA            reduce using rule 36 (data_types -> WINT .)
    RPAREN          reduce using rule 36 (data_types -> WINT .)
    ID              reduce using rule 36 (data_types -> WINT .)


state 172

    (37) data_types -> WFLOAT .

    RCORCHE         reduce using rule 37 (data_types -> WFLOAT .)
    COLON           reduce using rule 37 (data_types -> WFLOAT .)
    $end            reduce using rule 37 (data_types -> WFLOAT .)
    RLLAVE          reduce using rule 37 (data_types -> WFLOAT .)
    DEFAULT         reduce using rule 37 (data_types -> WFLOAT .)
    CASE            reduce using rule 37 (data_types -> WFLOAT .)
    RETURN          reduce using rule 37 (data_types -> WFLOAT .)
    LLLAVE          reduce using rule 37 (data_types -> WFLOAT .)
    COMA            reduce using rule 37 (data_types -> WFLOAT .)
    RPAREN          reduce using rule 37 (data_types -> WFLOAT .)
    ID              reduce using rule 37 (data_types -> WFLOAT .)


state 173

    (38) data_types -> WSTRING .

    RCORCHE         reduce using rule 38 (data_types -> WSTRING .)
    COLON           reduce using rule 38 (data_types -> WSTRING .)
    $end            reduce using rule 38 (data_types -> WSTRING .)
    RLLAVE          reduce using rule 38 (data_types -> WSTRING .)
    DEFAULT         reduce using rule 38 (data_types -> WSTRING .)
    CASE            reduce using rule 38 (data_types -> WSTRING .)
    RETURN          reduce using rule 38 (data_types -> WSTRING .)
    LLLAVE          reduce using rule 38 (data_types -> WSTRING .)
    COMA            reduce using rule 38 (data_types -> WSTRING .)
    RPAREN          reduce using rule 38 (data_types -> WSTRING .)
    ID              reduce using rule 38 (data_types -> WSTRING .)


state 174

    (39) data_types -> BOOL .

    RCORCHE         reduce using rule 39 (data_types -> BOOL .)
    COLON           reduce using rule 39 (data_types -> BOOL .)
    $end            reduce using rule 39 (data_types -> BOOL .)
    RLLAVE          reduce using rule 39 (data_types -> BOOL .)
    DEFAULT         reduce using rule 39 (data_types -> BOOL .)
    CASE            reduce using rule 39 (data_types -> BOOL .)
    RETURN          reduce using rule 39 (data_types -> BOOL .)
    LLLAVE          reduce using rule 39 (data_types -> BOOL .)
    COMA            reduce using rule 39 (data_types -> BOOL .)
    RPAREN          reduce using rule 39 (data_types -> BOOL .)
    ID              reduce using rule 39 (data_types -> BOOL .)


state 175

    (77) sliceC -> ID DEQUAL LCORCHE RCORCHE . data_types arr_content
    (31) data_types -> . INT32
    (32) data_types -> . INT64
    (33) data_types -> . FLOAT32
    (34) data_types -> . FLOAT64
    (35) data_types -> . BYTE
    (36) data_types -> . WINT
    (37) data_types -> . WFLOAT
    (38) data_types -> . WSTRING
    (39) data_types -> . BOOL

    INT32           shift and go to state 166
    INT64           shift and go to state 167
    FLOAT32         shift and go to state 168
    FLOAT64         shift and go to state 169
    BYTE            shift and go to state 170
    WINT            shift and go to state 171
    WFLOAT          shift and go to state 172
    WSTRING         shift and go to state 173
    BOOL            shift and go to state 174

    data_types                     shift and go to state 204

state 176

    (78) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap RPAREN
    (79) funM -> MAKE LPAREN . LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN

    LCORCHE         shift and go to state 205


state 177

    (125) array_var -> ID LCORCHE index RCORCHE .

    COLON           reduce using rule 125 (array_var -> ID LCORCHE index RCORCHE .)
    EQUAL           reduce using rule 125 (array_var -> ID LCORCHE index RCORCHE .)
    $end            reduce using rule 125 (array_var -> ID LCORCHE index RCORCHE .)
    RLLAVE          reduce using rule 125 (array_var -> ID LCORCHE index RCORCHE .)
    DEFAULT         reduce using rule 125 (array_var -> ID LCORCHE index RCORCHE .)
    CASE            reduce using rule 125 (array_var -> ID LCORCHE index RCORCHE .)
    RETURN          reduce using rule 125 (array_var -> ID LCORCHE index RCORCHE .)


state 178

    (83) funciones -> APPEND LPAREN ID COMA . values RPAREN
    (84) funciones -> APPEND LPAREN ID COMA . ID RPAREN
    (26) values -> . STRING
    (27) values -> . INTEGER
    (28) values -> . FLOAT
    (29) values -> . TRUE
    (30) values -> . FALSE

    ID              shift and go to state 206
    STRING          shift and go to state 95
    INTEGER         shift and go to state 208
    FLOAT           shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99

    values                         shift and go to state 207

state 179

    (85) funciones -> LEN LPAREN ID RPAREN .

    COLON           reduce using rule 85 (funciones -> LEN LPAREN ID RPAREN .)
    $end            reduce using rule 85 (funciones -> LEN LPAREN ID RPAREN .)
    RLLAVE          reduce using rule 85 (funciones -> LEN LPAREN ID RPAREN .)
    DEFAULT         reduce using rule 85 (funciones -> LEN LPAREN ID RPAREN .)
    CASE            reduce using rule 85 (funciones -> LEN LPAREN ID RPAREN .)
    RETURN          reduce using rule 85 (funciones -> LEN LPAREN ID RPAREN .)


state 180

    (86) funciones -> COPY LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 209


state 181

    (87) funciones -> DELETE LPAREN ID COMA . ID RPAREN

    ID              shift and go to state 210


state 182

    (90) SenIF -> IF LPAREN comparison RPAREN . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 211


state 183

    (91) SenIF -> IF LPAREN TRUE RPAREN . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 212


state 184

    (92) SenIF -> IF LPAREN FALSE RPAREN . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 213


state 185

    (93) SenStruct -> TYPE ID STRUCT LLLAVE . declaration RLLAVE
    (94) declaration -> . variable data_types
    (95) declaration -> . declaration variable data_types
    (96) variable -> . ID

    ID              shift and go to state 214

    declaration                    shift and go to state 215
    variable                       shift and go to state 216

state 186

    (115) switch_statement -> SWITCH ID LLLAVE cases . RLLAVE

    RLLAVE          shift and go to state 217


state 187

    (116) cases -> CASE . values POINTS codigo
    (117) cases -> CASE . values POINTS codigo more
    (26) values -> . STRING
    (27) values -> . INTEGER
    (28) values -> . FLOAT
    (29) values -> . TRUE
    (30) values -> . FALSE

    STRING          shift and go to state 95
    INTEGER         shift and go to state 208
    FLOAT           shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99

    values                         shift and go to state 218

state 188

    (144) params -> ID . data_types
    (146) more_params -> ID . data_types COMA params
    (31) data_types -> . INT32
    (32) data_types -> . INT64
    (33) data_types -> . FLOAT32
    (34) data_types -> . FLOAT64
    (35) data_types -> . BYTE
    (36) data_types -> . WINT
    (37) data_types -> . WFLOAT
    (38) data_types -> . WSTRING
    (39) data_types -> . BOOL

    INT32           shift and go to state 166
    INT64           shift and go to state 167
    FLOAT32         shift and go to state 168
    FLOAT64         shift and go to state 169
    BYTE            shift and go to state 170
    WINT            shift and go to state 171
    WFLOAT          shift and go to state 172
    WSTRING         shift and go to state 173
    BOOL            shift and go to state 174

    data_types                     shift and go to state 219

state 189

    (136) func_declaration -> FUNC ID LPAREN params . RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> FUNC ID LPAREN params . RPAREN data_types LLLAVE RETURN return_value RLLAVE

    RPAREN          shift and go to state 220


state 190

    (145) params -> more_params .

    RPAREN          reduce using rule 145 (params -> more_params .)


state 191

    (126) index -> ID .
    (132) key -> ID .
    (155) factor -> ID .
    (98) value -> ID .
    (110) logic_value -> ID .

  ! reduce/reduce conflict for RCORCHE resolved using rule 126 (index -> ID .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 126 (index -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 98 (value -> ID .)
    RCORCHE         reduce using rule 126 (index -> ID .)
    TIMES           reduce using rule 155 (factor -> ID .)
    DIVIDE          reduce using rule 155 (factor -> ID .)
    PLUS            reduce using rule 155 (factor -> ID .)
    MINUS           reduce using rule 155 (factor -> ID .)
    GREATER         reduce using rule 98 (value -> ID .)
    SMALLER         reduce using rule 98 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 98 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 98 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 98 (value -> ID .)
    NOT_EQUAL       reduce using rule 98 (value -> ID .)
    AND             reduce using rule 110 (logic_value -> ID .)
    OR              reduce using rule 110 (logic_value -> ID .)

  ! RCORCHE         [ reduce using rule 132 (key -> ID .) ]
  ! RCORCHE         [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER         [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 155 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 155 (factor -> ID .) ]


state 192

    (131) map_var -> ID LCORCHE key . RCORCHE

    RCORCHE         shift and go to state 221


state 193

    (127) index -> INTEGER .
    (27) values -> INTEGER .
    (154) factor -> INTEGER .

  ! reduce/reduce conflict for RCORCHE resolved using rule 27 (values -> INTEGER .)
  ! reduce/reduce conflict for RCORCHE resolved using rule 27 (values -> INTEGER .)
    RCORCHE         reduce using rule 27 (values -> INTEGER .)
    TIMES           reduce using rule 154 (factor -> INTEGER .)
    DIVIDE          reduce using rule 154 (factor -> INTEGER .)
    PLUS            reduce using rule 154 (factor -> INTEGER .)
    MINUS           reduce using rule 154 (factor -> INTEGER .)
    GREATER         reduce using rule 154 (factor -> INTEGER .)
    SMALLER         reduce using rule 154 (factor -> INTEGER .)
    GREATER_OR_EQUAL reduce using rule 154 (factor -> INTEGER .)
    SMALLER_OR_EQUAL reduce using rule 154 (factor -> INTEGER .)
    EQUAL_COMPARE   reduce using rule 154 (factor -> INTEGER .)
    NOT_EQUAL       reduce using rule 154 (factor -> INTEGER .)

  ! RCORCHE         [ reduce using rule 127 (index -> INTEGER .) ]
  ! RCORCHE         [ reduce using rule 154 (factor -> INTEGER .) ]


state 194

    (128) index -> expression .
    (148) expression -> expression . PLUS term
    (149) expression -> expression . MINUS term
    (40) operations -> expression .
    (99) value -> expression .

  ! reduce/reduce conflict for RCORCHE resolved using rule 40 (operations -> expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43
    RCORCHE         reduce using rule 40 (operations -> expression .)
    GREATER         reduce using rule 99 (value -> expression .)
    SMALLER         reduce using rule 99 (value -> expression .)
    GREATER_OR_EQUAL reduce using rule 99 (value -> expression .)
    SMALLER_OR_EQUAL reduce using rule 99 (value -> expression .)
    EQUAL_COMPARE   reduce using rule 99 (value -> expression .)
    NOT_EQUAL       reduce using rule 99 (value -> expression .)

  ! RCORCHE         [ reduce using rule 128 (index -> expression .) ]


state 195

    (133) key -> values .

    RCORCHE         reduce using rule 133 (key -> values .)


state 196

    (134) key -> operations .

    RCORCHE         reduce using rule 134 (key -> operations .)


state 197

    (56) cicloFor -> FOR comparison LLLAVE codigo RLLAVE .

    $end            reduce using rule 56 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 56 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 56 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 56 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 56 (cicloFor -> FOR comparison LLLAVE codigo RLLAVE .)


state 198

    (57) cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .

    $end            reduce using rule 57 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 57 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 57 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 57 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 57 (cicloFor -> FOR logic_operation LLLAVE codigo RLLAVE .)


state 199

    (58) cicloFor -> FOR decVarOne COLON comparison COLON . incre LLLAVE codigo RLLAVE
    (59) incre -> . ID INCREASE
    (60) incre -> . ID DECREASE

    ID              shift and go to state 223

    incre                          shift and go to state 222

state 200

    (121) array_declaration -> VAR ID EQUAL LCORCHE capacity . RCORCHE data_types arr_content

    RCORCHE         shift and go to state 224


state 201

    (120) array_declaration -> VAR ID LCORCHE capacity RCORCHE . data_types
    (31) data_types -> . INT32
    (32) data_types -> . INT64
    (33) data_types -> . FLOAT32
    (34) data_types -> . FLOAT64
    (35) data_types -> . BYTE
    (36) data_types -> . WINT
    (37) data_types -> . WFLOAT
    (38) data_types -> . WSTRING
    (39) data_types -> . BOOL

    INT32           shift and go to state 166
    INT64           shift and go to state 167
    FLOAT32         shift and go to state 168
    FLOAT64         shift and go to state 169
    BYTE            shift and go to state 170
    WINT            shift and go to state 171
    WFLOAT          shift and go to state 172
    WSTRING         shift and go to state 173
    BOOL            shift and go to state 174

    data_types                     shift and go to state 225

state 202

    (75) sliceC -> VAR ID LCORCHE RCORCHE data_types .

    COLON           reduce using rule 75 (sliceC -> VAR ID LCORCHE RCORCHE data_types .)
    $end            reduce using rule 75 (sliceC -> VAR ID LCORCHE RCORCHE data_types .)
    RLLAVE          reduce using rule 75 (sliceC -> VAR ID LCORCHE RCORCHE data_types .)
    DEFAULT         reduce using rule 75 (sliceC -> VAR ID LCORCHE RCORCHE data_types .)
    CASE            reduce using rule 75 (sliceC -> VAR ID LCORCHE RCORCHE data_types .)
    RETURN          reduce using rule 75 (sliceC -> VAR ID LCORCHE RCORCHE data_types .)


state 203

    (130) map_declaration -> VAR ID LCORCHE data_types RCORCHE . data_types
    (31) data_types -> . INT32
    (32) data_types -> . INT64
    (33) data_types -> . FLOAT32
    (34) data_types -> . FLOAT64
    (35) data_types -> . BYTE
    (36) data_types -> . WINT
    (37) data_types -> . WFLOAT
    (38) data_types -> . WSTRING
    (39) data_types -> . BOOL

    INT32           shift and go to state 166
    INT64           shift and go to state 167
    FLOAT32         shift and go to state 168
    FLOAT64         shift and go to state 169
    BYTE            shift and go to state 170
    WINT            shift and go to state 171
    WFLOAT          shift and go to state 172
    WSTRING         shift and go to state 173
    BOOL            shift and go to state 174

    data_types                     shift and go to state 226

state 204

    (77) sliceC -> ID DEQUAL LCORCHE RCORCHE data_types . arr_content
    (45) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (46) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 228

    arr_content                    shift and go to state 227

state 205

    (78) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap RPAREN
    (79) funM -> MAKE LPAREN LCORCHE . RCORCHE data_types COMA cap COMA cap RPAREN

    RCORCHE         shift and go to state 229


state 206

    (84) funciones -> APPEND LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 230


state 207

    (83) funciones -> APPEND LPAREN ID COMA values . RPAREN

    RPAREN          shift and go to state 231


state 208

    (27) values -> INTEGER .

    RPAREN          reduce using rule 27 (values -> INTEGER .)
    POINTS          reduce using rule 27 (values -> INTEGER .)


state 209

    (86) funciones -> COPY LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 232


state 210

    (87) funciones -> DELETE LPAREN ID COMA ID . RPAREN

    RPAREN          shift and go to state 233


state 211

    (90) SenIF -> IF LPAREN comparison RPAREN LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . map_declaration COLON
    (22) codigo -> . map_declaration
    (23) codigo -> . map_assignment COLON
    (24) codigo -> . map_assignment
    (25) codigo -> . func_declaration
    (147) impresion -> . PRINT LPAREN expression RPAREN
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (55) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (56) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (57) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (58) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (61) decVar -> . decVarOne
    (62) decVar -> . VAR ID EQUAL INTEGER
    (63) decVar -> . VAR ID EQUAL ID
    (64) decVar -> . VAR ID EQUAL FLOAT
    (65) decVar -> . VAR ID EQUAL expression
    (66) decVar -> . VAR ID EQUAL logic_operation
    (67) decVar -> . VAR ID EQUAL comparison
    (68) decVar -> . sliceC
    (69) decVar -> . VAR ID EQUAL STRING
    (70) decVar -> . ID DEQUAL STRING
    (71) decVar -> . ID DEQUAL FLOAT
    (72) decVar -> . ID DEQUAL expression
    (73) decVar -> . ID DEQUAL logic_operation
    (74) decVar -> . ID DEQUAL comparison
    (83) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (84) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (85) funciones -> . LEN LPAREN ID RPAREN
    (86) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (87) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (90) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (91) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (92) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (93) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (115) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (120) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (121) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (125) array_var -> . ID LCORCHE index RCORCHE
    (129) array_assignment -> . array_var EQUAL something
    (130) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (135) map_assignment -> . array_var EQUAL something
    (136) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (88) decVarOne -> . ID DEQUAL ID
    (89) decVarOne -> . ID DEQUAL INTEGER
    (75) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (76) sliceC -> . ID DEQUAL funM
    (77) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 18
    FOR             shift and go to state 21
    VAR             shift and go to state 26
    ID              shift and go to state 27
    APPEND          shift and go to state 30
    LEN             shift and go to state 31
    COPY            shift and go to state 32
    DELETE          shift and go to state 33
    IF              shift and go to state 34
    TYPE            shift and go to state 35
    SWITCH          shift and go to state 36
    FUNC            shift and go to state 37
    NOT             shift and go to state 39
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    comparison                     shift and go to state 5
    codigo                         shift and go to state 234
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    map_declaration                shift and go to state 15
    map_assignment                 shift and go to state 16
    func_declaration               shift and go to state 17
    term                           shift and go to state 20
    decVarOne                      shift and go to state 22
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    sliceC                         shift and go to state 29
    factor                         shift and go to state 38

state 212

    (91) SenIF -> IF LPAREN TRUE RPAREN LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . map_declaration COLON
    (22) codigo -> . map_declaration
    (23) codigo -> . map_assignment COLON
    (24) codigo -> . map_assignment
    (25) codigo -> . func_declaration
    (147) impresion -> . PRINT LPAREN expression RPAREN
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (55) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (56) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (57) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (58) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (61) decVar -> . decVarOne
    (62) decVar -> . VAR ID EQUAL INTEGER
    (63) decVar -> . VAR ID EQUAL ID
    (64) decVar -> . VAR ID EQUAL FLOAT
    (65) decVar -> . VAR ID EQUAL expression
    (66) decVar -> . VAR ID EQUAL logic_operation
    (67) decVar -> . VAR ID EQUAL comparison
    (68) decVar -> . sliceC
    (69) decVar -> . VAR ID EQUAL STRING
    (70) decVar -> . ID DEQUAL STRING
    (71) decVar -> . ID DEQUAL FLOAT
    (72) decVar -> . ID DEQUAL expression
    (73) decVar -> . ID DEQUAL logic_operation
    (74) decVar -> . ID DEQUAL comparison
    (83) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (84) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (85) funciones -> . LEN LPAREN ID RPAREN
    (86) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (87) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (90) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (91) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (92) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (93) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (115) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (120) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (121) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (125) array_var -> . ID LCORCHE index RCORCHE
    (129) array_assignment -> . array_var EQUAL something
    (130) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (135) map_assignment -> . array_var EQUAL something
    (136) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (88) decVarOne -> . ID DEQUAL ID
    (89) decVarOne -> . ID DEQUAL INTEGER
    (75) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (76) sliceC -> . ID DEQUAL funM
    (77) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 18
    FOR             shift and go to state 21
    VAR             shift and go to state 26
    ID              shift and go to state 27
    APPEND          shift and go to state 30
    LEN             shift and go to state 31
    COPY            shift and go to state 32
    DELETE          shift and go to state 33
    IF              shift and go to state 34
    TYPE            shift and go to state 35
    SWITCH          shift and go to state 36
    FUNC            shift and go to state 37
    NOT             shift and go to state 39
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    codigo                         shift and go to state 235
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    map_declaration                shift and go to state 15
    map_assignment                 shift and go to state 16
    func_declaration               shift and go to state 17
    term                           shift and go to state 20
    decVarOne                      shift and go to state 22
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    sliceC                         shift and go to state 29
    factor                         shift and go to state 38

state 213

    (92) SenIF -> IF LPAREN FALSE RPAREN LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . map_declaration COLON
    (22) codigo -> . map_declaration
    (23) codigo -> . map_assignment COLON
    (24) codigo -> . map_assignment
    (25) codigo -> . func_declaration
    (147) impresion -> . PRINT LPAREN expression RPAREN
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (55) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (56) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (57) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (58) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (61) decVar -> . decVarOne
    (62) decVar -> . VAR ID EQUAL INTEGER
    (63) decVar -> . VAR ID EQUAL ID
    (64) decVar -> . VAR ID EQUAL FLOAT
    (65) decVar -> . VAR ID EQUAL expression
    (66) decVar -> . VAR ID EQUAL logic_operation
    (67) decVar -> . VAR ID EQUAL comparison
    (68) decVar -> . sliceC
    (69) decVar -> . VAR ID EQUAL STRING
    (70) decVar -> . ID DEQUAL STRING
    (71) decVar -> . ID DEQUAL FLOAT
    (72) decVar -> . ID DEQUAL expression
    (73) decVar -> . ID DEQUAL logic_operation
    (74) decVar -> . ID DEQUAL comparison
    (83) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (84) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (85) funciones -> . LEN LPAREN ID RPAREN
    (86) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (87) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (90) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (91) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (92) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (93) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (115) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (120) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (121) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (125) array_var -> . ID LCORCHE index RCORCHE
    (129) array_assignment -> . array_var EQUAL something
    (130) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (135) map_assignment -> . array_var EQUAL something
    (136) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (88) decVarOne -> . ID DEQUAL ID
    (89) decVarOne -> . ID DEQUAL INTEGER
    (75) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (76) sliceC -> . ID DEQUAL funM
    (77) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 18
    FOR             shift and go to state 21
    VAR             shift and go to state 26
    ID              shift and go to state 27
    APPEND          shift and go to state 30
    LEN             shift and go to state 31
    COPY            shift and go to state 32
    DELETE          shift and go to state 33
    IF              shift and go to state 34
    TYPE            shift and go to state 35
    SWITCH          shift and go to state 36
    FUNC            shift and go to state 37
    NOT             shift and go to state 39
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    codigo                         shift and go to state 236
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    map_declaration                shift and go to state 15
    map_assignment                 shift and go to state 16
    func_declaration               shift and go to state 17
    term                           shift and go to state 20
    decVarOne                      shift and go to state 22
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    sliceC                         shift and go to state 29
    factor                         shift and go to state 38

state 214

    (96) variable -> ID .

    INT32           reduce using rule 96 (variable -> ID .)
    INT64           reduce using rule 96 (variable -> ID .)
    FLOAT32         reduce using rule 96 (variable -> ID .)
    FLOAT64         reduce using rule 96 (variable -> ID .)
    BYTE            reduce using rule 96 (variable -> ID .)
    WINT            reduce using rule 96 (variable -> ID .)
    WFLOAT          reduce using rule 96 (variable -> ID .)
    WSTRING         reduce using rule 96 (variable -> ID .)
    BOOL            reduce using rule 96 (variable -> ID .)


state 215

    (93) SenStruct -> TYPE ID STRUCT LLLAVE declaration . RLLAVE
    (95) declaration -> declaration . variable data_types
    (96) variable -> . ID

    RLLAVE          shift and go to state 237
    ID              shift and go to state 214

    variable                       shift and go to state 238

state 216

    (94) declaration -> variable . data_types
    (31) data_types -> . INT32
    (32) data_types -> . INT64
    (33) data_types -> . FLOAT32
    (34) data_types -> . FLOAT64
    (35) data_types -> . BYTE
    (36) data_types -> . WINT
    (37) data_types -> . WFLOAT
    (38) data_types -> . WSTRING
    (39) data_types -> . BOOL

    INT32           shift and go to state 166
    INT64           shift and go to state 167
    FLOAT32         shift and go to state 168
    FLOAT64         shift and go to state 169
    BYTE            shift and go to state 170
    WINT            shift and go to state 171
    WFLOAT          shift and go to state 172
    WSTRING         shift and go to state 173
    BOOL            shift and go to state 174

    data_types                     shift and go to state 239

state 217

    (115) switch_statement -> SWITCH ID LLLAVE cases RLLAVE .

    $end            reduce using rule 115 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RLLAVE          reduce using rule 115 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    DEFAULT         reduce using rule 115 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    CASE            reduce using rule 115 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)
    RETURN          reduce using rule 115 (switch_statement -> SWITCH ID LLLAVE cases RLLAVE .)


state 218

    (116) cases -> CASE values . POINTS codigo
    (117) cases -> CASE values . POINTS codigo more

    POINTS          shift and go to state 240


state 219

    (144) params -> ID data_types .
    (146) more_params -> ID data_types . COMA params

    RPAREN          reduce using rule 144 (params -> ID data_types .)
    COMA            shift and go to state 241


state 220

    (136) func_declaration -> FUNC ID LPAREN params RPAREN . data_types LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> FUNC ID LPAREN params RPAREN . data_types LLLAVE RETURN return_value RLLAVE
    (31) data_types -> . INT32
    (32) data_types -> . INT64
    (33) data_types -> . FLOAT32
    (34) data_types -> . FLOAT64
    (35) data_types -> . BYTE
    (36) data_types -> . WINT
    (37) data_types -> . WFLOAT
    (38) data_types -> . WSTRING
    (39) data_types -> . BOOL

    INT32           shift and go to state 166
    INT64           shift and go to state 167
    FLOAT32         shift and go to state 168
    FLOAT64         shift and go to state 169
    BYTE            shift and go to state 170
    WINT            shift and go to state 171
    WFLOAT          shift and go to state 172
    WSTRING         shift and go to state 173
    BOOL            shift and go to state 174

    data_types                     shift and go to state 242

state 221

    (131) map_var -> ID LCORCHE key RCORCHE .

    COLON           reduce using rule 131 (map_var -> ID LCORCHE key RCORCHE .)
    $end            reduce using rule 131 (map_var -> ID LCORCHE key RCORCHE .)
    RLLAVE          reduce using rule 131 (map_var -> ID LCORCHE key RCORCHE .)
    DEFAULT         reduce using rule 131 (map_var -> ID LCORCHE key RCORCHE .)
    CASE            reduce using rule 131 (map_var -> ID LCORCHE key RCORCHE .)
    RETURN          reduce using rule 131 (map_var -> ID LCORCHE key RCORCHE .)


state 222

    (58) cicloFor -> FOR decVarOne COLON comparison COLON incre . LLLAVE codigo RLLAVE

    LLLAVE          shift and go to state 243


state 223

    (59) incre -> ID . INCREASE
    (60) incre -> ID . DECREASE

    INCREASE        shift and go to state 244
    DECREASE        shift and go to state 245


state 224

    (121) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE . data_types arr_content
    (31) data_types -> . INT32
    (32) data_types -> . INT64
    (33) data_types -> . FLOAT32
    (34) data_types -> . FLOAT64
    (35) data_types -> . BYTE
    (36) data_types -> . WINT
    (37) data_types -> . WFLOAT
    (38) data_types -> . WSTRING
    (39) data_types -> . BOOL

    INT32           shift and go to state 166
    INT64           shift and go to state 167
    FLOAT32         shift and go to state 168
    FLOAT64         shift and go to state 169
    BYTE            shift and go to state 170
    WINT            shift and go to state 171
    WFLOAT          shift and go to state 172
    WSTRING         shift and go to state 173
    BOOL            shift and go to state 174

    data_types                     shift and go to state 246

state 225

    (120) array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .

    COLON           reduce using rule 120 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    $end            reduce using rule 120 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RLLAVE          reduce using rule 120 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    DEFAULT         reduce using rule 120 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    CASE            reduce using rule 120 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)
    RETURN          reduce using rule 120 (array_declaration -> VAR ID LCORCHE capacity RCORCHE data_types .)


state 226

    (130) map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .

    COLON           reduce using rule 130 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    $end            reduce using rule 130 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    RLLAVE          reduce using rule 130 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    DEFAULT         reduce using rule 130 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    CASE            reduce using rule 130 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)
    RETURN          reduce using rule 130 (map_declaration -> VAR ID LCORCHE data_types RCORCHE data_types .)


state 227

    (77) sliceC -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .

    COLON           reduce using rule 77 (sliceC -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    $end            reduce using rule 77 (sliceC -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 77 (sliceC -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 77 (sliceC -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    CASE            reduce using rule 77 (sliceC -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)
    RETURN          reduce using rule 77 (sliceC -> ID DEQUAL LCORCHE RCORCHE data_types arr_content .)


state 228

    (45) arr_content -> LLLAVE . items COMA more_items RLLAVE
    (46) arr_content -> LLLAVE . items RLLAVE
    (49) items -> . values
    (50) items -> . operations
    (26) values -> . STRING
    (27) values -> . INTEGER
    (28) values -> . FLOAT
    (29) values -> . TRUE
    (30) values -> . FALSE
    (40) operations -> . expression
    (41) operations -> . comparison
    (42) operations -> . logic_operation
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    STRING          shift and go to state 95
    INTEGER         shift and go to state 96
    FLOAT           shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    ID              shift and go to state 250
    NOT             shift and go to state 39
    LPAREN          shift and go to state 19

    items                          shift and go to state 247
    values                         shift and go to state 248
    operations                     shift and go to state 249
    expression                     shift and go to state 100
    comparison                     shift and go to state 101
    logic_operation                shift and go to state 102
    term                           shift and go to state 20
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    factor                         shift and go to state 38

state 229

    (78) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap RPAREN
    (79) funM -> MAKE LPAREN LCORCHE RCORCHE . data_types COMA cap COMA cap RPAREN
    (31) data_types -> . INT32
    (32) data_types -> . INT64
    (33) data_types -> . FLOAT32
    (34) data_types -> . FLOAT64
    (35) data_types -> . BYTE
    (36) data_types -> . WINT
    (37) data_types -> . WFLOAT
    (38) data_types -> . WSTRING
    (39) data_types -> . BOOL

    INT32           shift and go to state 166
    INT64           shift and go to state 167
    FLOAT32         shift and go to state 168
    FLOAT64         shift and go to state 169
    BYTE            shift and go to state 170
    WINT            shift and go to state 171
    WFLOAT          shift and go to state 172
    WSTRING         shift and go to state 173
    BOOL            shift and go to state 174

    data_types                     shift and go to state 251

state 230

    (84) funciones -> APPEND LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 84 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 84 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 84 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 84 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 84 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 84 (funciones -> APPEND LPAREN ID COMA ID RPAREN .)


state 231

    (83) funciones -> APPEND LPAREN ID COMA values RPAREN .

    COLON           reduce using rule 83 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    $end            reduce using rule 83 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RLLAVE          reduce using rule 83 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    DEFAULT         reduce using rule 83 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    CASE            reduce using rule 83 (funciones -> APPEND LPAREN ID COMA values RPAREN .)
    RETURN          reduce using rule 83 (funciones -> APPEND LPAREN ID COMA values RPAREN .)


state 232

    (86) funciones -> COPY LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 86 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 86 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 86 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 86 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 86 (funciones -> COPY LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 86 (funciones -> COPY LPAREN ID COMA ID RPAREN .)


state 233

    (87) funciones -> DELETE LPAREN ID COMA ID RPAREN .

    COLON           reduce using rule 87 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    $end            reduce using rule 87 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RLLAVE          reduce using rule 87 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    DEFAULT         reduce using rule 87 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    CASE            reduce using rule 87 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)
    RETURN          reduce using rule 87 (funciones -> DELETE LPAREN ID COMA ID RPAREN .)


state 234

    (90) SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 252


state 235

    (91) SenIF -> IF LPAREN TRUE RPAREN LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 253


state 236

    (92) SenIF -> IF LPAREN FALSE RPAREN LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 254


state 237

    (93) SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .

    $end            reduce using rule 93 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RLLAVE          reduce using rule 93 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    DEFAULT         reduce using rule 93 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    CASE            reduce using rule 93 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)
    RETURN          reduce using rule 93 (SenStruct -> TYPE ID STRUCT LLLAVE declaration RLLAVE .)


state 238

    (95) declaration -> declaration variable . data_types
    (31) data_types -> . INT32
    (32) data_types -> . INT64
    (33) data_types -> . FLOAT32
    (34) data_types -> . FLOAT64
    (35) data_types -> . BYTE
    (36) data_types -> . WINT
    (37) data_types -> . WFLOAT
    (38) data_types -> . WSTRING
    (39) data_types -> . BOOL

    INT32           shift and go to state 166
    INT64           shift and go to state 167
    FLOAT32         shift and go to state 168
    FLOAT64         shift and go to state 169
    BYTE            shift and go to state 170
    WINT            shift and go to state 171
    WFLOAT          shift and go to state 172
    WSTRING         shift and go to state 173
    BOOL            shift and go to state 174

    data_types                     shift and go to state 255

state 239

    (94) declaration -> variable data_types .

    RLLAVE          reduce using rule 94 (declaration -> variable data_types .)
    ID              reduce using rule 94 (declaration -> variable data_types .)


state 240

    (116) cases -> CASE values POINTS . codigo
    (117) cases -> CASE values POINTS . codigo more
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . map_declaration COLON
    (22) codigo -> . map_declaration
    (23) codigo -> . map_assignment COLON
    (24) codigo -> . map_assignment
    (25) codigo -> . func_declaration
    (147) impresion -> . PRINT LPAREN expression RPAREN
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (55) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (56) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (57) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (58) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (61) decVar -> . decVarOne
    (62) decVar -> . VAR ID EQUAL INTEGER
    (63) decVar -> . VAR ID EQUAL ID
    (64) decVar -> . VAR ID EQUAL FLOAT
    (65) decVar -> . VAR ID EQUAL expression
    (66) decVar -> . VAR ID EQUAL logic_operation
    (67) decVar -> . VAR ID EQUAL comparison
    (68) decVar -> . sliceC
    (69) decVar -> . VAR ID EQUAL STRING
    (70) decVar -> . ID DEQUAL STRING
    (71) decVar -> . ID DEQUAL FLOAT
    (72) decVar -> . ID DEQUAL expression
    (73) decVar -> . ID DEQUAL logic_operation
    (74) decVar -> . ID DEQUAL comparison
    (83) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (84) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (85) funciones -> . LEN LPAREN ID RPAREN
    (86) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (87) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (90) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (91) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (92) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (93) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (115) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (120) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (121) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (125) array_var -> . ID LCORCHE index RCORCHE
    (129) array_assignment -> . array_var EQUAL something
    (130) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (135) map_assignment -> . array_var EQUAL something
    (136) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (88) decVarOne -> . ID DEQUAL ID
    (89) decVarOne -> . ID DEQUAL INTEGER
    (75) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (76) sliceC -> . ID DEQUAL funM
    (77) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 18
    FOR             shift and go to state 21
    VAR             shift and go to state 26
    ID              shift and go to state 27
    APPEND          shift and go to state 30
    LEN             shift and go to state 31
    COPY            shift and go to state 32
    DELETE          shift and go to state 33
    IF              shift and go to state 34
    TYPE            shift and go to state 35
    SWITCH          shift and go to state 36
    FUNC            shift and go to state 37
    NOT             shift and go to state 39
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    codigo                         shift and go to state 256
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    map_declaration                shift and go to state 15
    map_assignment                 shift and go to state 16
    func_declaration               shift and go to state 17
    term                           shift and go to state 20
    decVarOne                      shift and go to state 22
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    sliceC                         shift and go to state 29
    factor                         shift and go to state 38

state 241

    (146) more_params -> ID data_types COMA . params
    (144) params -> . ID data_types
    (145) params -> . more_params
    (146) more_params -> . ID data_types COMA params

    ID              shift and go to state 188

    params                         shift and go to state 257
    more_params                    shift and go to state 190

state 242

    (136) func_declaration -> FUNC ID LPAREN params RPAREN data_types . LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> FUNC ID LPAREN params RPAREN data_types . LLLAVE RETURN return_value RLLAVE

    LLLAVE          shift and go to state 258


state 243

    (58) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE . codigo RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . map_declaration COLON
    (22) codigo -> . map_declaration
    (23) codigo -> . map_assignment COLON
    (24) codigo -> . map_assignment
    (25) codigo -> . func_declaration
    (147) impresion -> . PRINT LPAREN expression RPAREN
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (55) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (56) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (57) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (58) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (61) decVar -> . decVarOne
    (62) decVar -> . VAR ID EQUAL INTEGER
    (63) decVar -> . VAR ID EQUAL ID
    (64) decVar -> . VAR ID EQUAL FLOAT
    (65) decVar -> . VAR ID EQUAL expression
    (66) decVar -> . VAR ID EQUAL logic_operation
    (67) decVar -> . VAR ID EQUAL comparison
    (68) decVar -> . sliceC
    (69) decVar -> . VAR ID EQUAL STRING
    (70) decVar -> . ID DEQUAL STRING
    (71) decVar -> . ID DEQUAL FLOAT
    (72) decVar -> . ID DEQUAL expression
    (73) decVar -> . ID DEQUAL logic_operation
    (74) decVar -> . ID DEQUAL comparison
    (83) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (84) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (85) funciones -> . LEN LPAREN ID RPAREN
    (86) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (87) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (90) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (91) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (92) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (93) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (115) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (120) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (121) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (125) array_var -> . ID LCORCHE index RCORCHE
    (129) array_assignment -> . array_var EQUAL something
    (130) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (135) map_assignment -> . array_var EQUAL something
    (136) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (88) decVarOne -> . ID DEQUAL ID
    (89) decVarOne -> . ID DEQUAL INTEGER
    (75) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (76) sliceC -> . ID DEQUAL funM
    (77) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 18
    FOR             shift and go to state 21
    VAR             shift and go to state 26
    ID              shift and go to state 27
    APPEND          shift and go to state 30
    LEN             shift and go to state 31
    COPY            shift and go to state 32
    DELETE          shift and go to state 33
    IF              shift and go to state 34
    TYPE            shift and go to state 35
    SWITCH          shift and go to state 36
    FUNC            shift and go to state 37
    NOT             shift and go to state 39
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    decVarOne                      shift and go to state 22
    comparison                     shift and go to state 5
    codigo                         shift and go to state 259
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    map_declaration                shift and go to state 15
    map_assignment                 shift and go to state 16
    func_declaration               shift and go to state 17
    term                           shift and go to state 20
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    sliceC                         shift and go to state 29
    factor                         shift and go to state 38

state 244

    (59) incre -> ID INCREASE .

    LLLAVE          reduce using rule 59 (incre -> ID INCREASE .)


state 245

    (60) incre -> ID DECREASE .

    LLLAVE          reduce using rule 60 (incre -> ID DECREASE .)


state 246

    (121) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types . arr_content
    (45) arr_content -> . LLLAVE items COMA more_items RLLAVE
    (46) arr_content -> . LLLAVE items RLLAVE

    LLLAVE          shift and go to state 228

    arr_content                    shift and go to state 260

state 247

    (45) arr_content -> LLLAVE items . COMA more_items RLLAVE
    (46) arr_content -> LLLAVE items . RLLAVE

    COMA            shift and go to state 261
    RLLAVE          shift and go to state 262


state 248

    (49) items -> values .

    COMA            reduce using rule 49 (items -> values .)
    RLLAVE          reduce using rule 49 (items -> values .)


state 249

    (50) items -> operations .

    COMA            reduce using rule 50 (items -> operations .)
    RLLAVE          reduce using rule 50 (items -> operations .)


state 250

    (98) value -> ID .
    (110) logic_value -> ID .
    (155) factor -> ID .

  ! reduce/reduce conflict for GREATER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 98 (value -> ID .)
    GREATER         reduce using rule 98 (value -> ID .)
    SMALLER         reduce using rule 98 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 98 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 98 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 98 (value -> ID .)
    NOT_EQUAL       reduce using rule 98 (value -> ID .)
    AND             reduce using rule 110 (logic_value -> ID .)
    OR              reduce using rule 110 (logic_value -> ID .)
    TIMES           reduce using rule 155 (factor -> ID .)
    DIVIDE          reduce using rule 155 (factor -> ID .)
    PLUS            reduce using rule 155 (factor -> ID .)
    MINUS           reduce using rule 155 (factor -> ID .)
    COMA            reduce using rule 155 (factor -> ID .)
    RLLAVE          reduce using rule 155 (factor -> ID .)

  ! GREATER         [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 155 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 155 (factor -> ID .) ]


state 251

    (78) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap RPAREN
    (79) funM -> MAKE LPAREN LCORCHE RCORCHE data_types . COMA cap COMA cap RPAREN

    COMA            shift and go to state 263


state 252

    (90) SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .

    $end            reduce using rule 90 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 90 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 90 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 90 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 90 (SenIF -> IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE .)


state 253

    (91) SenIF -> IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE .

    $end            reduce using rule 91 (SenIF -> IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 91 (SenIF -> IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 91 (SenIF -> IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 91 (SenIF -> IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 91 (SenIF -> IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE .)


state 254

    (92) SenIF -> IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE .

    $end            reduce using rule 92 (SenIF -> IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 92 (SenIF -> IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 92 (SenIF -> IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 92 (SenIF -> IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 92 (SenIF -> IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE .)


state 255

    (95) declaration -> declaration variable data_types .

    RLLAVE          reduce using rule 95 (declaration -> declaration variable data_types .)
    ID              reduce using rule 95 (declaration -> declaration variable data_types .)


state 256

    (116) cases -> CASE values POINTS codigo .
    (117) cases -> CASE values POINTS codigo . more
    (118) more -> . cases
    (119) more -> . DEFAULT POINTS codigo
    (116) cases -> . CASE values POINTS codigo
    (117) cases -> . CASE values POINTS codigo more

    RLLAVE          reduce using rule 116 (cases -> CASE values POINTS codigo .)
    DEFAULT         shift and go to state 266
    CASE            shift and go to state 187

    more                           shift and go to state 264
    cases                          shift and go to state 265

state 257

    (146) more_params -> ID data_types COMA params .

    RPAREN          reduce using rule 146 (more_params -> ID data_types COMA params .)


state 258

    (136) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE . codigo RETURN retorno RLLAVE
    (137) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE . RETURN return_value RLLAVE
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . map_declaration COLON
    (22) codigo -> . map_declaration
    (23) codigo -> . map_assignment COLON
    (24) codigo -> . map_assignment
    (25) codigo -> . func_declaration
    (147) impresion -> . PRINT LPAREN expression RPAREN
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (55) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (56) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (57) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (58) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (61) decVar -> . decVarOne
    (62) decVar -> . VAR ID EQUAL INTEGER
    (63) decVar -> . VAR ID EQUAL ID
    (64) decVar -> . VAR ID EQUAL FLOAT
    (65) decVar -> . VAR ID EQUAL expression
    (66) decVar -> . VAR ID EQUAL logic_operation
    (67) decVar -> . VAR ID EQUAL comparison
    (68) decVar -> . sliceC
    (69) decVar -> . VAR ID EQUAL STRING
    (70) decVar -> . ID DEQUAL STRING
    (71) decVar -> . ID DEQUAL FLOAT
    (72) decVar -> . ID DEQUAL expression
    (73) decVar -> . ID DEQUAL logic_operation
    (74) decVar -> . ID DEQUAL comparison
    (83) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (84) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (85) funciones -> . LEN LPAREN ID RPAREN
    (86) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (87) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (90) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (91) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (92) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (93) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (115) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (120) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (121) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (125) array_var -> . ID LCORCHE index RCORCHE
    (129) array_assignment -> . array_var EQUAL something
    (130) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (135) map_assignment -> . array_var EQUAL something
    (136) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (88) decVarOne -> . ID DEQUAL ID
    (89) decVarOne -> . ID DEQUAL INTEGER
    (75) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (76) sliceC -> . ID DEQUAL funM
    (77) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    RETURN          shift and go to state 268
    PRINT           shift and go to state 18
    FOR             shift and go to state 21
    VAR             shift and go to state 26
    ID              shift and go to state 27
    APPEND          shift and go to state 30
    LEN             shift and go to state 31
    COPY            shift and go to state 32
    DELETE          shift and go to state 33
    IF              shift and go to state 34
    TYPE            shift and go to state 35
    SWITCH          shift and go to state 36
    FUNC            shift and go to state 37
    NOT             shift and go to state 39
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    codigo                         shift and go to state 267
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    map_declaration                shift and go to state 15
    map_assignment                 shift and go to state 16
    func_declaration               shift and go to state 17
    term                           shift and go to state 20
    decVarOne                      shift and go to state 22
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    sliceC                         shift and go to state 29
    factor                         shift and go to state 38

state 259

    (58) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo . RLLAVE

    RLLAVE          shift and go to state 269


state 260

    (121) array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .

    COLON           reduce using rule 121 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    $end            reduce using rule 121 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RLLAVE          reduce using rule 121 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    DEFAULT         reduce using rule 121 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    CASE            reduce using rule 121 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)
    RETURN          reduce using rule 121 (array_declaration -> VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content .)


state 261

    (45) arr_content -> LLLAVE items COMA . more_items RLLAVE
    (47) more_items -> . items COMA more_items
    (48) more_items -> . items
    (49) items -> . values
    (50) items -> . operations
    (26) values -> . STRING
    (27) values -> . INTEGER
    (28) values -> . FLOAT
    (29) values -> . TRUE
    (30) values -> . FALSE
    (40) operations -> . expression
    (41) operations -> . comparison
    (42) operations -> . logic_operation
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    STRING          shift and go to state 95
    INTEGER         shift and go to state 96
    FLOAT           shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    ID              shift and go to state 250
    NOT             shift and go to state 39
    LPAREN          shift and go to state 19

    items                          shift and go to state 270
    more_items                     shift and go to state 271
    values                         shift and go to state 248
    operations                     shift and go to state 249
    expression                     shift and go to state 100
    comparison                     shift and go to state 101
    logic_operation                shift and go to state 102
    term                           shift and go to state 20
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    factor                         shift and go to state 38

state 262

    (46) arr_content -> LLLAVE items RLLAVE .

    COLON           reduce using rule 46 (arr_content -> LLLAVE items RLLAVE .)
    $end            reduce using rule 46 (arr_content -> LLLAVE items RLLAVE .)
    RLLAVE          reduce using rule 46 (arr_content -> LLLAVE items RLLAVE .)
    DEFAULT         reduce using rule 46 (arr_content -> LLLAVE items RLLAVE .)
    CASE            reduce using rule 46 (arr_content -> LLLAVE items RLLAVE .)
    RETURN          reduce using rule 46 (arr_content -> LLLAVE items RLLAVE .)


state 263

    (78) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap RPAREN
    (79) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA . cap COMA cap RPAREN
    (80) cap -> . INTEGER
    (81) cap -> . ID
    (82) cap -> . expression
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 273
    ID              shift and go to state 274
    LPAREN          shift and go to state 19

    cap                            shift and go to state 272
    expression                     shift and go to state 275
    term                           shift and go to state 20
    factor                         shift and go to state 38

state 264

    (117) cases -> CASE values POINTS codigo more .

    RLLAVE          reduce using rule 117 (cases -> CASE values POINTS codigo more .)


state 265

    (118) more -> cases .

    RLLAVE          reduce using rule 118 (more -> cases .)


state 266

    (119) more -> DEFAULT . POINTS codigo

    POINTS          shift and go to state 276


state 267

    (136) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo . RETURN retorno RLLAVE

    RETURN          shift and go to state 277


state 268

    (137) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN . return_value RLLAVE
    (138) return_value -> . retorno COLON
    (139) return_value -> . retorno
    (140) retorno -> . ID
    (141) retorno -> . values
    (142) retorno -> . operations
    (143) retorno -> . data_structure
    (26) values -> . STRING
    (27) values -> . INTEGER
    (28) values -> . FLOAT
    (29) values -> . TRUE
    (30) values -> . FALSE
    (40) operations -> . expression
    (41) operations -> . comparison
    (42) operations -> . logic_operation
    (43) data_structure -> . array_var
    (44) data_structure -> . map_var
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (125) array_var -> . ID LCORCHE index RCORCHE
    (131) map_var -> . ID LCORCHE key RCORCHE
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 278
    STRING          shift and go to state 95
    INTEGER         shift and go to state 96
    FLOAT           shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    NOT             shift and go to state 39
    LPAREN          shift and go to state 19

    return_value                   shift and go to state 279
    retorno                        shift and go to state 280
    values                         shift and go to state 281
    operations                     shift and go to state 282
    data_structure                 shift and go to state 283
    expression                     shift and go to state 100
    comparison                     shift and go to state 101
    logic_operation                shift and go to state 102
    array_var                      shift and go to state 88
    map_var                        shift and go to state 94
    term                           shift and go to state 20
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    factor                         shift and go to state 38

state 269

    (58) cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .

    $end            reduce using rule 58 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RLLAVE          reduce using rule 58 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    DEFAULT         reduce using rule 58 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    CASE            reduce using rule 58 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)
    RETURN          reduce using rule 58 (cicloFor -> FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE .)


state 270

    (47) more_items -> items . COMA more_items
    (48) more_items -> items .

    COMA            shift and go to state 284
    RLLAVE          reduce using rule 48 (more_items -> items .)


state 271

    (45) arr_content -> LLLAVE items COMA more_items . RLLAVE

    RLLAVE          shift and go to state 285


state 272

    (78) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . RPAREN
    (79) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap . COMA cap RPAREN

    RPAREN          shift and go to state 287
    COMA            shift and go to state 286


state 273

    (80) cap -> INTEGER .
    (154) factor -> INTEGER .

  ! reduce/reduce conflict for RPAREN resolved using rule 80 (cap -> INTEGER .)
  ! reduce/reduce conflict for COMA resolved using rule 80 (cap -> INTEGER .)
    RPAREN          reduce using rule 80 (cap -> INTEGER .)
    COMA            reduce using rule 80 (cap -> INTEGER .)
    TIMES           reduce using rule 154 (factor -> INTEGER .)
    DIVIDE          reduce using rule 154 (factor -> INTEGER .)
    PLUS            reduce using rule 154 (factor -> INTEGER .)
    MINUS           reduce using rule 154 (factor -> INTEGER .)

  ! RPAREN          [ reduce using rule 154 (factor -> INTEGER .) ]
  ! COMA            [ reduce using rule 154 (factor -> INTEGER .) ]


state 274

    (81) cap -> ID .
    (155) factor -> ID .

  ! reduce/reduce conflict for RPAREN resolved using rule 81 (cap -> ID .)
  ! reduce/reduce conflict for COMA resolved using rule 81 (cap -> ID .)
    RPAREN          reduce using rule 81 (cap -> ID .)
    COMA            reduce using rule 81 (cap -> ID .)
    TIMES           reduce using rule 155 (factor -> ID .)
    DIVIDE          reduce using rule 155 (factor -> ID .)
    PLUS            reduce using rule 155 (factor -> ID .)
    MINUS           reduce using rule 155 (factor -> ID .)

  ! RPAREN          [ reduce using rule 155 (factor -> ID .) ]
  ! COMA            [ reduce using rule 155 (factor -> ID .) ]


state 275

    (82) cap -> expression .
    (148) expression -> expression . PLUS term
    (149) expression -> expression . MINUS term

    RPAREN          reduce using rule 82 (cap -> expression .)
    COMA            reduce using rule 82 (cap -> expression .)
    PLUS            shift and go to state 42
    MINUS           shift and go to state 43


state 276

    (119) more -> DEFAULT POINTS . codigo
    (1) codigo -> . impresion COLON
    (2) codigo -> . impresion
    (3) codigo -> . expression COLON
    (4) codigo -> . expression
    (5) codigo -> . cicloFor
    (6) codigo -> . comparison
    (7) codigo -> . logic_operation
    (8) codigo -> . decVar COLON
    (9) codigo -> . decVar
    (10) codigo -> . funciones
    (11) codigo -> . funciones COLON
    (12) codigo -> . SenIF
    (13) codigo -> . SenStruct
    (14) codigo -> . switch_statement
    (15) codigo -> . array_declaration COLON
    (16) codigo -> . array_declaration
    (17) codigo -> . array_var COLON
    (18) codigo -> . array_var
    (19) codigo -> . array_assignment COLON
    (20) codigo -> . array_assignment
    (21) codigo -> . map_declaration COLON
    (22) codigo -> . map_declaration
    (23) codigo -> . map_assignment COLON
    (24) codigo -> . map_assignment
    (25) codigo -> . func_declaration
    (147) impresion -> . PRINT LPAREN expression RPAREN
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (55) cicloFor -> . FOR LLLAVE codigo RLLAVE
    (56) cicloFor -> . FOR comparison LLLAVE codigo RLLAVE
    (57) cicloFor -> . FOR logic_operation LLLAVE codigo RLLAVE
    (58) cicloFor -> . FOR decVarOne COLON comparison COLON incre LLLAVE codigo RLLAVE
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (61) decVar -> . decVarOne
    (62) decVar -> . VAR ID EQUAL INTEGER
    (63) decVar -> . VAR ID EQUAL ID
    (64) decVar -> . VAR ID EQUAL FLOAT
    (65) decVar -> . VAR ID EQUAL expression
    (66) decVar -> . VAR ID EQUAL logic_operation
    (67) decVar -> . VAR ID EQUAL comparison
    (68) decVar -> . sliceC
    (69) decVar -> . VAR ID EQUAL STRING
    (70) decVar -> . ID DEQUAL STRING
    (71) decVar -> . ID DEQUAL FLOAT
    (72) decVar -> . ID DEQUAL expression
    (73) decVar -> . ID DEQUAL logic_operation
    (74) decVar -> . ID DEQUAL comparison
    (83) funciones -> . APPEND LPAREN ID COMA values RPAREN
    (84) funciones -> . APPEND LPAREN ID COMA ID RPAREN
    (85) funciones -> . LEN LPAREN ID RPAREN
    (86) funciones -> . COPY LPAREN ID COMA ID RPAREN
    (87) funciones -> . DELETE LPAREN ID COMA ID RPAREN
    (90) SenIF -> . IF LPAREN comparison RPAREN LLLAVE codigo RLLAVE
    (91) SenIF -> . IF LPAREN TRUE RPAREN LLLAVE codigo RLLAVE
    (92) SenIF -> . IF LPAREN FALSE RPAREN LLLAVE codigo RLLAVE
    (93) SenStruct -> . TYPE ID STRUCT LLLAVE declaration RLLAVE
    (115) switch_statement -> . SWITCH ID LLLAVE cases RLLAVE
    (120) array_declaration -> . VAR ID LCORCHE capacity RCORCHE data_types
    (121) array_declaration -> . VAR ID EQUAL LCORCHE capacity RCORCHE data_types arr_content
    (125) array_var -> . ID LCORCHE index RCORCHE
    (129) array_assignment -> . array_var EQUAL something
    (130) map_declaration -> . VAR ID LCORCHE data_types RCORCHE data_types
    (135) map_assignment -> . array_var EQUAL something
    (136) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE
    (137) func_declaration -> . FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (88) decVarOne -> . ID DEQUAL ID
    (89) decVarOne -> . ID DEQUAL INTEGER
    (75) sliceC -> . VAR ID LCORCHE RCORCHE data_types
    (76) sliceC -> . ID DEQUAL funM
    (77) sliceC -> . ID DEQUAL LCORCHE RCORCHE data_types arr_content
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    PRINT           shift and go to state 18
    FOR             shift and go to state 21
    VAR             shift and go to state 26
    ID              shift and go to state 27
    APPEND          shift and go to state 30
    LEN             shift and go to state 31
    COPY            shift and go to state 32
    DELETE          shift and go to state 33
    IF              shift and go to state 34
    TYPE            shift and go to state 35
    SWITCH          shift and go to state 36
    FUNC            shift and go to state 37
    NOT             shift and go to state 39
    INTEGER         shift and go to state 28
    LPAREN          shift and go to state 19

    codigo                         shift and go to state 288
    impresion                      shift and go to state 2
    expression                     shift and go to state 3
    cicloFor                       shift and go to state 4
    comparison                     shift and go to state 5
    logic_operation                shift and go to state 6
    decVar                         shift and go to state 7
    funciones                      shift and go to state 8
    SenIF                          shift and go to state 9
    SenStruct                      shift and go to state 10
    switch_statement               shift and go to state 11
    array_declaration              shift and go to state 12
    array_var                      shift and go to state 13
    array_assignment               shift and go to state 14
    map_declaration                shift and go to state 15
    map_assignment                 shift and go to state 16
    func_declaration               shift and go to state 17
    term                           shift and go to state 20
    decVarOne                      shift and go to state 22
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    sliceC                         shift and go to state 29
    factor                         shift and go to state 38

state 277

    (136) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN . retorno RLLAVE
    (140) retorno -> . ID
    (141) retorno -> . values
    (142) retorno -> . operations
    (143) retorno -> . data_structure
    (26) values -> . STRING
    (27) values -> . INTEGER
    (28) values -> . FLOAT
    (29) values -> . TRUE
    (30) values -> . FALSE
    (40) operations -> . expression
    (41) operations -> . comparison
    (42) operations -> . logic_operation
    (43) data_structure -> . array_var
    (44) data_structure -> . map_var
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (125) array_var -> . ID LCORCHE index RCORCHE
    (131) map_var -> . ID LCORCHE key RCORCHE
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    ID              shift and go to state 278
    STRING          shift and go to state 95
    INTEGER         shift and go to state 96
    FLOAT           shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    NOT             shift and go to state 39
    LPAREN          shift and go to state 19

    retorno                        shift and go to state 289
    values                         shift and go to state 281
    operations                     shift and go to state 282
    data_structure                 shift and go to state 283
    expression                     shift and go to state 100
    comparison                     shift and go to state 101
    logic_operation                shift and go to state 102
    array_var                      shift and go to state 88
    map_var                        shift and go to state 94
    term                           shift and go to state 20
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    factor                         shift and go to state 38

state 278

    (140) retorno -> ID .
    (125) array_var -> ID . LCORCHE index RCORCHE
    (131) map_var -> ID . LCORCHE key RCORCHE
    (98) value -> ID .
    (110) logic_value -> ID .
    (155) factor -> ID .

  ! reduce/reduce conflict for COLON resolved using rule 140 (retorno -> ID .)
  ! reduce/reduce conflict for RLLAVE resolved using rule 140 (retorno -> ID .)
  ! reduce/reduce conflict for GREATER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for GREATER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for SMALLER_OR_EQUAL resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for EQUAL_COMPARE resolved using rule 98 (value -> ID .)
  ! reduce/reduce conflict for NOT_EQUAL resolved using rule 98 (value -> ID .)
    COLON           reduce using rule 140 (retorno -> ID .)
    RLLAVE          reduce using rule 140 (retorno -> ID .)
    LCORCHE         shift and go to state 144
    GREATER         reduce using rule 98 (value -> ID .)
    SMALLER         reduce using rule 98 (value -> ID .)
    GREATER_OR_EQUAL reduce using rule 98 (value -> ID .)
    SMALLER_OR_EQUAL reduce using rule 98 (value -> ID .)
    EQUAL_COMPARE   reduce using rule 98 (value -> ID .)
    NOT_EQUAL       reduce using rule 98 (value -> ID .)
    AND             reduce using rule 110 (logic_value -> ID .)
    OR              reduce using rule 110 (logic_value -> ID .)
    TIMES           reduce using rule 155 (factor -> ID .)
    DIVIDE          reduce using rule 155 (factor -> ID .)
    PLUS            reduce using rule 155 (factor -> ID .)
    MINUS           reduce using rule 155 (factor -> ID .)

  ! COLON           [ reduce using rule 155 (factor -> ID .) ]
  ! RLLAVE          [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER         [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER         [ reduce using rule 155 (factor -> ID .) ]
  ! GREATER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! SMALLER_OR_EQUAL [ reduce using rule 155 (factor -> ID .) ]
  ! EQUAL_COMPARE   [ reduce using rule 155 (factor -> ID .) ]
  ! NOT_EQUAL       [ reduce using rule 155 (factor -> ID .) ]


state 279

    (137) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value . RLLAVE

    RLLAVE          shift and go to state 290


state 280

    (138) return_value -> retorno . COLON
    (139) return_value -> retorno .

    COLON           shift and go to state 291
    RLLAVE          reduce using rule 139 (return_value -> retorno .)


state 281

    (141) retorno -> values .

    COLON           reduce using rule 141 (retorno -> values .)
    RLLAVE          reduce using rule 141 (retorno -> values .)


state 282

    (142) retorno -> operations .

    COLON           reduce using rule 142 (retorno -> operations .)
    RLLAVE          reduce using rule 142 (retorno -> operations .)


state 283

    (143) retorno -> data_structure .

    COLON           reduce using rule 143 (retorno -> data_structure .)
    RLLAVE          reduce using rule 143 (retorno -> data_structure .)


state 284

    (47) more_items -> items COMA . more_items
    (47) more_items -> . items COMA more_items
    (48) more_items -> . items
    (49) items -> . values
    (50) items -> . operations
    (26) values -> . STRING
    (27) values -> . INTEGER
    (28) values -> . FLOAT
    (29) values -> . TRUE
    (30) values -> . FALSE
    (40) operations -> . expression
    (41) operations -> . comparison
    (42) operations -> . logic_operation
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (97) comparison -> . value op value
    (106) logic_operation -> . logic_value logic_op logic_value
    (107) logic_operation -> . negation
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (98) value -> . ID
    (99) value -> . expression
    (108) logic_value -> . negation
    (109) logic_value -> . comparison
    (110) logic_value -> . ID
    (111) negation -> . NOT comparison
    (112) negation -> . NOT ID
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    STRING          shift and go to state 95
    INTEGER         shift and go to state 96
    FLOAT           shift and go to state 97
    TRUE            shift and go to state 98
    FALSE           shift and go to state 99
    ID              shift and go to state 250
    NOT             shift and go to state 39
    LPAREN          shift and go to state 19

    items                          shift and go to state 270
    more_items                     shift and go to state 292
    values                         shift and go to state 248
    operations                     shift and go to state 249
    expression                     shift and go to state 100
    comparison                     shift and go to state 101
    logic_operation                shift and go to state 102
    term                           shift and go to state 20
    value                          shift and go to state 23
    logic_value                    shift and go to state 24
    negation                       shift and go to state 25
    factor                         shift and go to state 38

state 285

    (45) arr_content -> LLLAVE items COMA more_items RLLAVE .

    COLON           reduce using rule 45 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    $end            reduce using rule 45 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RLLAVE          reduce using rule 45 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    DEFAULT         reduce using rule 45 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    CASE            reduce using rule 45 (arr_content -> LLLAVE items COMA more_items RLLAVE .)
    RETURN          reduce using rule 45 (arr_content -> LLLAVE items COMA more_items RLLAVE .)


state 286

    (79) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA . cap RPAREN
    (80) cap -> . INTEGER
    (81) cap -> . ID
    (82) cap -> . expression
    (148) expression -> . expression PLUS term
    (149) expression -> . expression MINUS term
    (150) expression -> . term
    (151) term -> . term TIMES factor
    (152) term -> . term DIVIDE factor
    (153) term -> . factor
    (154) factor -> . INTEGER
    (155) factor -> . ID
    (156) factor -> . LPAREN expression RPAREN

    INTEGER         shift and go to state 273
    ID              shift and go to state 274
    LPAREN          shift and go to state 19

    cap                            shift and go to state 293
    expression                     shift and go to state 275
    term                           shift and go to state 20
    factor                         shift and go to state 38

state 287

    (78) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .

    COLON           reduce using rule 78 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    $end            reduce using rule 78 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RLLAVE          reduce using rule 78 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    DEFAULT         reduce using rule 78 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    CASE            reduce using rule 78 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)
    RETURN          reduce using rule 78 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap RPAREN .)


state 288

    (119) more -> DEFAULT POINTS codigo .

    RLLAVE          reduce using rule 119 (more -> DEFAULT POINTS codigo .)


state 289

    (136) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno . RLLAVE

    RLLAVE          shift and go to state 294


state 290

    (137) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .

    $end            reduce using rule 137 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    RLLAVE          reduce using rule 137 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    DEFAULT         reduce using rule 137 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    CASE            reduce using rule 137 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)
    RETURN          reduce using rule 137 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE RETURN return_value RLLAVE .)


state 291

    (138) return_value -> retorno COLON .

    RLLAVE          reduce using rule 138 (return_value -> retorno COLON .)


state 292

    (47) more_items -> items COMA more_items .

    RLLAVE          reduce using rule 47 (more_items -> items COMA more_items .)


state 293

    (79) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap . RPAREN

    RPAREN          shift and go to state 295


state 294

    (136) func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .

    $end            reduce using rule 136 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    RLLAVE          reduce using rule 136 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    DEFAULT         reduce using rule 136 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    CASE            reduce using rule 136 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)
    RETURN          reduce using rule 136 (func_declaration -> FUNC ID LPAREN params RPAREN data_types LLLAVE codigo RETURN retorno RLLAVE .)


state 295

    (79) funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .

    COLON           reduce using rule 79 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    $end            reduce using rule 79 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RLLAVE          reduce using rule 79 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    DEFAULT         reduce using rule 79 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    CASE            reduce using rule 79 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)
    RETURN          reduce using rule 79 (funM -> MAKE LPAREN LCORCHE RCORCHE data_types COMA cap COMA cap RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: reduce/reduce conflict in state 27 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 27
WARNING: reduce/reduce conflict in state 61 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 61
WARNING: reduce/reduce conflict in state 85 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 85
WARNING: reduce/reduce conflict in state 89 resolved using rule (array_assignment -> array_var EQUAL something)
WARNING: rejected rule (map_assignment -> array_var EQUAL something) in state 89
WARNING: reduce/reduce conflict in state 90 resolved using rule (something -> ID)
WARNING: rejected rule (factor -> ID) in state 90
WARNING: reduce/reduce conflict in state 90 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 90
WARNING: reduce/reduce conflict in state 96 resolved using rule (values -> INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 96
WARNING: reduce/reduce conflict in state 113 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 113
WARNING: reduce/reduce conflict in state 117 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 117
WARNING: reduce/reduce conflict in state 120 resolved using rule (decVarOne -> ID DEQUAL ID)
WARNING: rejected rule (factor -> ID) in state 120
WARNING: reduce/reduce conflict in state 120 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 120
WARNING: reduce/reduce conflict in state 126 resolved using rule (decVarOne -> ID DEQUAL INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 126
WARNING: reduce/reduce conflict in state 130 resolved using rule (index -> ID)
WARNING: rejected rule (factor -> ID) in state 130
WARNING: reduce/reduce conflict in state 132 resolved using rule (index -> INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 132
WARNING: reduce/reduce conflict in state 152 resolved using rule (decVar -> VAR ID EQUAL ID)
WARNING: rejected rule (factor -> ID) in state 152
WARNING: reduce/reduce conflict in state 152 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 152
WARNING: reduce/reduce conflict in state 153 resolved using rule (decVar -> VAR ID EQUAL INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 153
WARNING: reduce/reduce conflict in state 160 resolved using rule (capacity -> ID)
WARNING: rejected rule (factor -> ID) in state 160
WARNING: reduce/reduce conflict in state 164 resolved using rule (capacity -> INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 164
WARNING: reduce/reduce conflict in state 191 resolved using rule (index -> ID)
WARNING: rejected rule (key -> ID) in state 191
WARNING: reduce/reduce conflict in state 191 resolved using rule (index -> ID)
WARNING: rejected rule (factor -> ID) in state 191
WARNING: reduce/reduce conflict in state 191 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 191
WARNING: reduce/reduce conflict in state 193 resolved using rule (values -> INTEGER)
WARNING: rejected rule (index -> INTEGER) in state 193
WARNING: reduce/reduce conflict in state 193 resolved using rule (values -> INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 193
WARNING: reduce/reduce conflict in state 194 resolved using rule (operations -> expression)
WARNING: rejected rule (index -> expression) in state 194
WARNING: reduce/reduce conflict in state 250 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 250
WARNING: reduce/reduce conflict in state 273 resolved using rule (cap -> INTEGER)
WARNING: rejected rule (factor -> INTEGER) in state 273
WARNING: reduce/reduce conflict in state 274 resolved using rule (cap -> ID)
WARNING: rejected rule (factor -> ID) in state 274
WARNING: reduce/reduce conflict in state 278 resolved using rule (retorno -> ID)
WARNING: rejected rule (factor -> ID) in state 278
WARNING: reduce/reduce conflict in state 278 resolved using rule (value -> ID)
WARNING: rejected rule (factor -> ID) in state 278
WARNING: Rule (map_assignment -> array_var EQUAL something) is never reduced
WARNING: Rule (key -> ID) is never reduced
